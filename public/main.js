/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./app/classes/Component.js":
/*!**********************************!*\
  !*** ./app/classes/Component.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js");
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_each__WEBPACK_IMPORTED_MODULE_1__);


class Component extends (events__WEBPACK_IMPORTED_MODULE_0___default()) {
  constructor({
    element,
    elements
  }) {
    super();
    this.selector = element;
    this.selectorChildren = { ...elements
    };
    this.create();
    this.addEventListeners();
  }

  create() {
    this.element = document.querySelector(this.selector);
    this.elements = {};
    lodash_each__WEBPACK_IMPORTED_MODULE_1___default()(this.selectorChildren, (entry, key) => {
      if (entry instanceof window.HTMLElement || entry instanceof window.NodeList || Array.isArray(entry)) {
        this.elements[key] = entry;
      } else {
        this.elements[key] = document.querySelectorAll(entry);

        if (this.elements[key].lenght === 0) {
          this.elements[key] = null;
        } else if (this.elements[key] === 1) {
          this.elements[key] = document.querySelector(entry);
        }
      }
    });
  }

  addEventListeners() {}

  removeEventListeners() {}

}

/***/ }),

/***/ "./app/classes/Page.js":
/*!*****************************!*\
  !*** ./app/classes/Page.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Page)
/* harmony export */ });
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js");
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_each__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prefix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prefix */ "./node_modules/prefix/index.js");
/* harmony import */ var prefix__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prefix__WEBPACK_IMPORTED_MODULE_1__);



class Page {
  constructor({
    id,
    element,
    elements
  }) {
    this.id = id;
    this.selector = element;
    this.selectorChildren = { ...elements
    };
    this.scroll = {
      current: 0,
      target: 0,
      last: 0
    };
    this.transformPrefix = prefix__WEBPACK_IMPORTED_MODULE_1___default()('transform');
    this.addEventListeners();
    this.onMouseWheel();
    this.update();
  }

  create() {
    this.element = document.querySelector(this.selector);
    this.elements = {};
    lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(this.selectorChildren, (entry, key) => {
      if (entry instanceof window.HTMLElement || entry instanceof window.NodeList || Array.isArray(entry)) {
        this.elements[key] = entry;
      } else {
        this.elements[key] = document.querySelectorAll(entry);

        if (this.elements[key].lenght === 0) {
          this.elements[key] = null;
        } else if (this.elements[key] === 1) {
          this.elements[key] = document.querySelector(entry);
        }
      }
    });
  }

  show() {
    this.animateIn = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].timeline();
    return new Promise(resolve => {
      gsap__WEBPACK_IMPORTED_MODULE_2__["default"].from(this.element, {
        autoAlpha: 0,
        onComplete: resolve
      });
    });
  }

  hide() {
    this.animateOut = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].timeline();
    return new Promise(resolve => {
      gsap__WEBPACK_IMPORTED_MODULE_2__["default"].to(this.element, {
        autoAlpha: 0,
        onComplete: resolve
      });
    });
  }

  update() {
    this.scroll.current = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].utils.interpolate(this.scroll.current, this.scroll.target, 0.1);
    /* 
        if (this.elements.wrapper) {
          this.elements.wrapper.style[this.transformPrefix] = `translateX(${this.scroll.current}px)`
        } */
  }

  onMouseWheel(event) {
    console.log(event);
  }

  addEventListeners() {
    window.addEventListener('wheel', this.onMouseWheel);
  }

}

/***/ }),

/***/ "./app/components/Preloader.js":
/*!*************************************!*\
  !*** ./app/components/Preloader.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Preloader)
/* harmony export */ });
/* harmony import */ var classes_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classes/Component */ "./app/classes/Component.js");
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var utils_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/text */ "./app/utils/text.js");




class Preloader extends classes_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super({
      element: '.preloader',
      elements: {
        title: document.querySelector('.preloader__text'),
        number: document.querySelector('.preloader__number'),
        images: document.querySelectorAll('img')
      }
    });
    this.length = 0;
    this.createLoader();
    (0,utils_text__WEBPACK_IMPORTED_MODULE_2__.split)({
      element: this.elements.title,
      expression: '<br>'
    });
    (0,utils_text__WEBPACK_IMPORTED_MODULE_2__.split)({
      element: this.elements.title,
      expression: '<br>'
    });
    this.elements.titleSpans = this.elements.title.querySelectorAll('span span');
  }

  onAssetLoaded(image) {
    this.length += 1;
    const percent = Math.round(this.length / this.elements.images.length * 100);
    this.elements.number.innerHTML = `${percent}%`;

    if (percent === 100) {
      this.onLoaded();
    }
  }

  createLoader() {
    (0,lodash__WEBPACK_IMPORTED_MODULE_1__.each)(this.elements.images, element => {
      element.src = element.getAttribute('data-src');

      element.onload = _ => this.onAssetLoaded(element);
    });
  }

  onLoaded() {
    return new Promise(resolve => {
      /*  this.animateOut.to(this.element, {
        autoAlpha: 0,
        delay: 2
      }) */
      this.animateOut = gsap__WEBPACK_IMPORTED_MODULE_3__["default"].timeline();
      this.animateOut.to(this.elements.titleSpans, {
        stagger: 0.1,
        duration: 1.5,
        ease: 'expo.out',
        y: '100%'
      });
      this.animateOut.to(this.element, {
        scaleY: 0,
        transformOrigin: '0 0',
        ease: 'expo.out'
      });
    });
  }

  destroy() {
    this.element.parentNode.removeChild(this.element);
  }

}

/***/ }),

/***/ "./app/index.js":
/*!**********************!*\
  !*** ./app/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pages_About__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pages/About */ "./app/pages/About/index.js");
/* harmony import */ var _pages_Detail__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pages/Detail */ "./app/pages/Detail/index.js");
/* harmony import */ var _pages_Collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pages/Collections */ "./app/pages/Collections/index.js");
/* harmony import */ var _pages_Home__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/Home */ "./app/pages/Home/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var components_Preloader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! components/Preloader */ "./app/components/Preloader.js");







class App {
  constructor() {
    this.createContent();
    this.createPages();
    this.addLinkListeners();
    this.update();
  }

  createContent() {
    this.content = document.querySelector('.content');
    this.template = this.content.getAttribute('data-template');
  }

  createPages() {
    this.pages = {
      home: new _pages_Home__WEBPACK_IMPORTED_MODULE_3__["default"](),
      collections: new _pages_Collections__WEBPACK_IMPORTED_MODULE_2__["default"](),
      about: new _pages_About__WEBPACK_IMPORTED_MODULE_0__["default"](),
      detail: new _pages_Detail__WEBPACK_IMPORTED_MODULE_1__["default"]()
    };
    this.page = this.pages[this.template];
    this.page.create();
    this.page.show();
  }

  async onChange(url) {
    this.page.hide();
    const request = await window.fetch(url);

    if (request.status === 200) {
      const nextPage = await request.text();
      const div = document.createElement('div');
      div.innerHTML = nextPage;
      const divContent = div.querySelector('.content');
      this.content.setAttribute('data-template', divContent.getAttribute('data-template'));
      this.content.innerHTML = divContent.innerHTML;
      this.page.create();
      this.page.show();
      this.addLinkListeners();
    } else {
      console.log('Deu pau, bixo!!');
    }
  }

  addLinkListeners() {
    const links = document.querySelectorAll('a');
    (0,lodash__WEBPACK_IMPORTED_MODULE_4__.each)(links, link => {
      link.onclick = event => {
        event.preventDefault();
        const {
          href
        } = link;
        this.onChange(href);
      };
    });
  }

  update() {
    if (this.page && this.page.update) {
      this.page.update();
    }

    this.frame = window.requestAnimationFrame(this.update.bind(this));
  }

}
/* eslint no-new: "off" */


new App();

/***/ }),

/***/ "./app/pages/About/index.js":
/*!**********************************!*\
  !*** ./app/pages/About/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ About)
/* harmony export */ });
/* harmony import */ var classes_Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classes/Page */ "./app/classes/Page.js");

class About extends classes_Page__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super({
      id: 'about',
      element: '.about',
      elements: {
        wrapper: '.about__wrapper',
        navigation: '.navigation',
        title: '.about__title'
      }
    });
  }

}

/***/ }),

/***/ "./app/pages/Collections/index.js":
/*!****************************************!*\
  !*** ./app/pages/Collections/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Collections)
/* harmony export */ });
/* harmony import */ var classes_Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classes/Page */ "./app/classes/Page.js");

class Collections extends classes_Page__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super({
      id: 'collections',
      element: '.collections',
      elements: {
        wrapper: '.collections__wrapper'
      }
    });
  }

}

/***/ }),

/***/ "./app/pages/Detail/index.js":
/*!***********************************!*\
  !*** ./app/pages/Detail/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Detail)
/* harmony export */ });
/* harmony import */ var classes_Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classes/Page */ "./app/classes/Page.js");

class Detail extends classes_Page__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super({
      id: 'detail',
      element: '.detail'
    });
  }

}

/***/ }),

/***/ "./app/pages/Home/index.js":
/*!*********************************!*\
  !*** ./app/pages/Home/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Home)
/* harmony export */ });
/* harmony import */ var classes_Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classes/Page */ "./app/classes/Page.js");

class Home extends classes_Page__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super({
      id: 'home',
      element: '.home',
      elements: {
        navigation: document.querySelector('.navigation'),
        link: document.querySelector('.home__link')
      }
    });
  }

  create() {
    super.create();
  }

}

/***/ }),

/***/ "./app/utils/text.js":
/*!***************************!*\
  !*** ./app/utils/text.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "split": () => (/* binding */ split),
/* harmony export */   "calculate": () => (/* binding */ calculate)
/* harmony export */ });
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js");
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_each__WEBPACK_IMPORTED_MODULE_0__);

function split({
  element,
  expression = ' ',
  append = true
}) {
  const words = splitText(element.innerHTML.toString().trim(), expression);
  let innerHTML = '';
  lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(words, line => {
    if (line.indexOf('<br>') > -1) {
      const lines = line.split('<br>');
      lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(lines, (line, index) => {
        innerHTML += index > 0 ? '<br>' + parseLine(line) : parseLine(line);
      });
    } else {
      innerHTML += parseLine(line);
    }
  });
  element.innerHTML = innerHTML;
  const spans = element.querySelectorAll('span');

  if (append) {
    lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(spans, span => {
      const isSingleLetter = span.textContent.length === 1;
      const isNotEmpty = span.innerHTML.trim() !== '';
      const isNotAndCharacter = span.textContent !== '&';
      const isNotDashCharacter = span.textContent !== '-';

      if (isSingleLetter && isNotEmpty && isNotAndCharacter && isNotDashCharacter) {
        span.innerHTML = `${span.textContent}&nbsp;`;
      }
    });
  }

  return spans;
}
function calculate(spans) {
  const lines = [];
  let words = [];
  let position = spans[0].offsetTop;
  lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(spans, (span, index) => {
    if (span.offsetTop === position) {
      words.push(span);
    }

    if (span.offsetTop !== position) {
      lines.push(words);
      words = [];
      words.push(span);
      position = span.offsetTop;
    }

    if (index + 1 === spans.length) {
      lines.push(words);
    }
  });
  return lines;
}

function splitText(text, expression) {
  const splits = text.split('<br>');
  let words = [];
  lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(splits, (item, index) => {
    if (index > 0) {
      words.push('<br>');
    }

    words = words.concat(item.split(expression));
    let isLink = false;
    let link = '';
    const innerHTML = [];
    lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(words, word => {
      if (!isLink && (word.includes('<a') || word.includes('<strong'))) {
        link = '';
        isLink = true;
      }

      if (isLink) {
        link += ` ${word}`;
      }

      if (isLink && (word.includes('/a>') || word.includes('/strong>'))) {
        innerHTML.push(link);
        link = '';
      }

      if (!isLink && link === '') {
        innerHTML.push(word);
      }

      if (isLink && (word.includes('/a>') || word.includes('/strong>'))) {
        isLink = false;
      }
    });
    words = innerHTML;
  });
  return words;
}

function parseLine(line) {
  if (line === '') {
    return line;
  } else if (line === ' ') {
    return '&nbsp;';
  } else {
    line = line.trim();
    return line === '<br>' ? '<br>' : `<span>${line}</span>` + (line.length > 1 ? ' ' : '');
  }
}

/***/ }),

/***/ "./node_modules/ansi-html-community/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ansi-html-community/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = ansiHTML; // Reference to https://github.com/sindresorhus/ansi-regex

var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/;
var _defColors = {
  reset: ['fff', '000'],
  // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
};
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
};
var _openTags = {
  '1': 'font-weight:bold',
  // bold
  '2': 'opacity:0.5',
  // dim
  '3': '<i>',
  // italic
  '4': '<u>',
  // underscore
  '8': 'display:none',
  // hidden
  '9': '<del>' // delete

};
var _closeTags = {
  '23': '</i>',
  // reset italic
  '24': '</u>',
  // reset underscore
  '29': '</del>' // reset delete

};
[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>';
});
/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */

function ansiHTML(text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text;
  } // Cache opened sequence.


  var ansiCodes = []; // Replace with markup.

  var ret = text.replace(/\033\[(\d+)m/g, function (match, seq) {
    var ot = _openTags[seq];

    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) {
        // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop();
        return '</span>';
      } // Open tag.


      ansiCodes.push(seq);
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">';
    }

    var ct = _closeTags[seq];

    if (ct) {
      // Pop sequence
      ansiCodes.pop();
      return ct;
    }

    return '';
  }); // Make sure tags are closed.

  var l = ansiCodes.length;
  l > 0 && (ret += Array(l + 1).join('</span>'));
  return ret;
}
/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */


ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.');
  }

  var _finalColors = {};

  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null;

    if (!hex) {
      _finalColors[key] = _defColors[key];
      continue;
    }

    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex];
      }

      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string';
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');
      }

      var defHexColor = _defColors[key];

      if (!hex[0]) {
        hex[0] = defHexColor[0];
      }

      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]];
        hex.push(defHexColor[1]);
      }

      hex = hex.slice(0, 2);
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');
    }

    _finalColors[key] = hex;
  }

  _setTags(_finalColors);
};
/**
 * Reset colors.
 */


ansiHTML.reset = function () {
  _setTags(_defColors);
};
/**
 * Expose tags, including open and close.
 * @type {Object}
 */


ansiHTML.tags = {};

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () {
      return _openTags;
    }
  });
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () {
      return _closeTags;
    }
  });
} else {
  ansiHTML.tags.open = _openTags;
  ansiHTML.tags.close = _closeTags;
}

function _setTags(colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]; // inverse

  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]; // dark grey

  _openTags['90'] = 'color:#' + colors.darkgrey;

  for (var code in _styles) {
    var color = _styles[code];
    var oriColor = colors[color] || '000';
    _openTags[code] = 'color:#' + oriColor;
    code = parseInt(code);
    _openTags[(code + 10).toString()] = 'background:#' + oriColor;
  }
}

ansiHTML.reset();

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

/***/ }),

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSPlugin": () => (/* binding */ CSSPlugin),
/* harmony export */   "default": () => (/* binding */ CSSPlugin),
/* harmony export */   "_getBBox": () => (/* binding */ _getBBox),
/* harmony export */   "_createElement": () => (/* binding */ _createElement),
/* harmony export */   "checkPrefix": () => (/* binding */ _checkPropPrefix)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/*!
 * CSSPlugin 3.8.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time) {
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      relative,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: relative ? relative * endNum : endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
      scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
  cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
  cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
  cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
  cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
    a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
    a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
    a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
  var cap = 360,
      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
      endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;

        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue) && (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p]); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));
          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], endValue, index, targets);
          } else {
            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, endValue);
        }

        props.push(p);
      }
    }

    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);


/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GSCache": () => (/* binding */ GSCache),
/* harmony export */   "Animation": () => (/* binding */ Animation),
/* harmony export */   "Timeline": () => (/* binding */ Timeline),
/* harmony export */   "Tween": () => (/* binding */ Tween),
/* harmony export */   "PropTween": () => (/* binding */ PropTween),
/* harmony export */   "gsap": () => (/* binding */ gsap),
/* harmony export */   "Power0": () => (/* binding */ Power0),
/* harmony export */   "Power1": () => (/* binding */ Power1),
/* harmony export */   "Power2": () => (/* binding */ Power2),
/* harmony export */   "Power3": () => (/* binding */ Power3),
/* harmony export */   "Power4": () => (/* binding */ Power4),
/* harmony export */   "Linear": () => (/* binding */ Linear),
/* harmony export */   "Quad": () => (/* binding */ Quad),
/* harmony export */   "Cubic": () => (/* binding */ Cubic),
/* harmony export */   "Quart": () => (/* binding */ Quart),
/* harmony export */   "Quint": () => (/* binding */ Quint),
/* harmony export */   "Strong": () => (/* binding */ Strong),
/* harmony export */   "Elastic": () => (/* binding */ Elastic),
/* harmony export */   "Back": () => (/* binding */ Back),
/* harmony export */   "SteppedEase": () => (/* binding */ SteppedEase),
/* harmony export */   "Bounce": () => (/* binding */ Bounce),
/* harmony export */   "Sine": () => (/* binding */ Sine),
/* harmony export */   "Expo": () => (/* binding */ Expo),
/* harmony export */   "Circ": () => (/* binding */ Circ),
/* harmony export */   "TweenMax": () => (/* binding */ Tween),
/* harmony export */   "TweenLite": () => (/* binding */ Tween),
/* harmony export */   "TimelineMax": () => (/* binding */ Timeline),
/* harmony export */   "TimelineLite": () => (/* binding */ Timeline),
/* harmony export */   "default": () => (/* binding */ gsap),
/* harmony export */   "wrap": () => (/* binding */ wrap),
/* harmony export */   "wrapYoyo": () => (/* binding */ wrapYoyo),
/* harmony export */   "distribute": () => (/* binding */ distribute),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "snap": () => (/* binding */ snap),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "getUnit": () => (/* binding */ getUnit),
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "splitColor": () => (/* binding */ splitColor),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "selector": () => (/* binding */ selector),
/* harmony export */   "mapRange": () => (/* binding */ mapRange),
/* harmony export */   "pipe": () => (/* binding */ pipe),
/* harmony export */   "unitize": () => (/* binding */ unitize),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "shuffle": () => (/* binding */ shuffle),
/* harmony export */   "_getProperty": () => (/* binding */ _getProperty),
/* harmony export */   "_numExp": () => (/* binding */ _numExp),
/* harmony export */   "_numWithUnitExp": () => (/* binding */ _numWithUnitExp),
/* harmony export */   "_isString": () => (/* binding */ _isString),
/* harmony export */   "_isUndefined": () => (/* binding */ _isUndefined),
/* harmony export */   "_renderComplexString": () => (/* binding */ _renderComplexString),
/* harmony export */   "_relExp": () => (/* binding */ _relExp),
/* harmony export */   "_setDefaults": () => (/* binding */ _setDefaults),
/* harmony export */   "_removeLinkedListItem": () => (/* binding */ _removeLinkedListItem),
/* harmony export */   "_forEachName": () => (/* binding */ _forEachName),
/* harmony export */   "_sortPropTweensByPriority": () => (/* binding */ _sortPropTweensByPriority),
/* harmony export */   "_colorStringFilter": () => (/* binding */ _colorStringFilter),
/* harmony export */   "_replaceRandom": () => (/* binding */ _replaceRandom),
/* harmony export */   "_checkPlugin": () => (/* binding */ _checkPlugin),
/* harmony export */   "_plugins": () => (/* binding */ _plugins),
/* harmony export */   "_ticker": () => (/* binding */ _ticker),
/* harmony export */   "_config": () => (/* binding */ _config),
/* harmony export */   "_roundModifier": () => (/* binding */ _roundModifier),
/* harmony export */   "_round": () => (/* binding */ _round),
/* harmony export */   "_missingPlugin": () => (/* binding */ _missingPlugin),
/* harmony export */   "_getSetter": () => (/* binding */ _getSetter),
/* harmony export */   "_getCache": () => (/* binding */ _getCache),
/* harmony export */   "_colorExp": () => (/* binding */ _colorExp)
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * GSAP 3.8.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);
  }
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    prevIteration = _animationCycle(tween._tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== prevIteration) {
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (!child._dur && child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (!child._dur && child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value) {
  if (typeof value !== "string") {
    return "";
  }

  var v = _unitExp.exec(value);

  return v ? value.substr(v.index + v[0].length) : "";
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    _hue = function _hue(h, m1, m2) {
  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback) {
      _listeners.indexOf(callback) < 0 && _listeners.push(callback);

      _wake();
    },
    remove: function remove(callback) {
      var i;
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return this;
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (parsedStart !== end) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);
    prevStartAt && prevStartAt.render(-1, true).kill();

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        } // if (time > 0) {
        // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        // } else if (dur && !(time < 0 && prevStartAt)) {
        // 	time && (tween._zTime = time);
        // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        // }

      } else if (autoRevert === false) {
        tween._startAt = 0;
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        stagger ? parsedTargets.forEach(function (t, i) {
          return keyframes.forEach(function (frame, j) {
            return tl.to(t, frame, j ? ">" : i * stagger);
          });
        }) : keyframes.forEach(function (frame) {
          return tl.to(parsedTargets, frame, ">");
        });
      } else {
        l = parsedTargets.length;
        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = {};

          for (p in vars) {
            if (_staggerPropsToSkip.indexOf(p) < 0) {
              copy[p] = vars[p];
            }
          }

          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.8.0";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gsap": () => (/* binding */ gsapWithCSS),
/* harmony export */   "default": () => (/* binding */ gsapWithCSS),
/* harmony export */   "CSSPlugin": () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin),
/* harmony export */   "TweenMax": () => (/* binding */ TweenMaxWithCSS),
/* harmony export */   "TweenLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),
/* harmony export */   "TimelineMax": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),
/* harmony export */   "TimelineLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),
/* harmony export */   "Power0": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),
/* harmony export */   "Power1": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),
/* harmony export */   "Power2": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),
/* harmony export */   "Power3": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),
/* harmony export */   "Power4": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),
/* harmony export */   "Linear": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),
/* harmony export */   "Quad": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),
/* harmony export */   "Cubic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),
/* harmony export */   "Quart": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),
/* harmony export */   "Quint": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),
/* harmony export */   "Strong": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),
/* harmony export */   "Elastic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),
/* harmony export */   "Back": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),
/* harmony export */   "SteppedEase": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),
/* harmony export */   "Bounce": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),
/* harmony export */   "Sine": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),
/* harmony export */   "Expo": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),
/* harmony export */   "Circ": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");


var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ "./node_modules/html-entities/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/html-entities/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var named_references_1 = __webpack_require__(/*! ./named-references */ "./node_modules/html-entities/lib/named-references.js");

var numeric_unicode_map_1 = __webpack_require__(/*! ./numeric-unicode-map */ "./node_modules/html-entities/lib/numeric-unicode-map.js");

var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/html-entities/lib/surrogate-pairs.js");

var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), {
  all: named_references_1.namedReferences.html5
});

var encodeRegExps = {
  specialChars: /[<>'"&]/g,
  nonAscii: /(?:[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
  nonAsciiPrintable: /(?:[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
  extensive: /(?:[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g
};
var defaultEncodeOptions = {
  mode: 'specialChars',
  level: 'all',
  numeric: 'decimal'
};
/** Encodes all the necessary (specified by `level`) characters in the text */

function encode(text, _a) {
  var _b = _a === void 0 ? defaultEncodeOptions : _a,
      _c = _b.mode,
      mode = _c === void 0 ? 'specialChars' : _c,
      _d = _b.numeric,
      numeric = _d === void 0 ? 'decimal' : _d,
      _e = _b.level,
      level = _e === void 0 ? 'all' : _e;

  if (!text) {
    return '';
  }

  var encodeRegExp = encodeRegExps[mode];
  var references = allNamedReferences[level].characters;
  var isHex = numeric === 'hexadecimal';
  encodeRegExp.lastIndex = 0;

  var _b = encodeRegExp.exec(text);

  var _c;

  if (_b) {
    _c = '';
    var _d = 0;

    do {
      if (_d !== _b.index) {
        _c += text.substring(_d, _b.index);
      }

      var _e = _b[0];
      var result_1 = references[_e];

      if (!result_1) {
        var code_1 = _e.length > 1 ? surrogate_pairs_1.getCodePoint(_e, 0) : _e.charCodeAt(0);
        result_1 = (isHex ? '&#x' + code_1.toString(16) : '&#' + code_1) + ';';
      }

      _c += result_1;
      _d = _b.index + _e.length;
    } while (_b = encodeRegExp.exec(text));

    if (_d !== text.length) {
      _c += text.substring(_d);
    }
  } else {
    _c = text;
  }

  return _c;
}

exports.encode = encode;
var defaultDecodeOptions = {
  scope: 'body',
  level: 'all'
};
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = {
  xml: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.xml
  },
  html4: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.html4
  },
  html5: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.html5
  }
};

var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), {
  all: baseDecodeRegExps.html5
});

var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
var defaultDecodeEntityOptions = {
  level: 'all'
};
/** Decodes a single entity */

function decodeEntity(entity, _a) {
  var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level,
      level = _b === void 0 ? 'all' : _b;

  if (!entity) {
    return '';
  }

  var _b = entity;
  var decodeEntityLastChar_1 = entity[entity.length - 1];

  if (false) {} else if (false) {} else {
    var decodeResultByReference_1 = allNamedReferences[level].entities[entity];

    if (decodeResultByReference_1) {
      _b = decodeResultByReference_1;
    } else if (entity[0] === '&' && entity[1] === '#') {
      var decodeSecondChar_1 = entity[2];
      var decodeCode_1 = decodeSecondChar_1 == 'x' || decodeSecondChar_1 == 'X' ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
      _b = decodeCode_1 >= 0x10ffff ? outOfBoundsChar : decodeCode_1 > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode_1) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_1] || decodeCode_1);
    }
  }

  return _b;
}

exports.decodeEntity = decodeEntity;
/** Decodes all entities in the text */

function decode(text, _a) {
  var decodeSecondChar_1 = _a === void 0 ? defaultDecodeOptions : _a,
      decodeCode_1 = decodeSecondChar_1.level,
      level = decodeCode_1 === void 0 ? 'all' : decodeCode_1,
      _b = decodeSecondChar_1.scope,
      scope = _b === void 0 ? level === 'xml' ? 'strict' : 'body' : _b;

  if (!text) {
    return '';
  }

  var decodeRegExp = decodeRegExps[level][scope];
  var references = allNamedReferences[level].entities;
  var isAttribute = scope === 'attribute';
  var isStrict = scope === 'strict';
  decodeRegExp.lastIndex = 0;
  var replaceMatch_1 = decodeRegExp.exec(text);
  var replaceResult_1;

  if (replaceMatch_1) {
    replaceResult_1 = '';
    var replaceLastIndex_1 = 0;

    do {
      if (replaceLastIndex_1 !== replaceMatch_1.index) {
        replaceResult_1 += text.substring(replaceLastIndex_1, replaceMatch_1.index);
      }

      var replaceInput_1 = replaceMatch_1[0];
      var decodeResult_1 = replaceInput_1;
      var decodeEntityLastChar_2 = replaceInput_1[replaceInput_1.length - 1];

      if (isAttribute && decodeEntityLastChar_2 === '=') {
        decodeResult_1 = replaceInput_1;
      } else if (isStrict && decodeEntityLastChar_2 !== ';') {
        decodeResult_1 = replaceInput_1;
      } else {
        var decodeResultByReference_2 = references[replaceInput_1];

        if (decodeResultByReference_2) {
          decodeResult_1 = decodeResultByReference_2;
        } else if (replaceInput_1[0] === '&' && replaceInput_1[1] === '#') {
          var decodeSecondChar_2 = replaceInput_1[2];
          var decodeCode_2 = decodeSecondChar_2 == 'x' || decodeSecondChar_2 == 'X' ? parseInt(replaceInput_1.substr(3), 16) : parseInt(replaceInput_1.substr(2));
          decodeResult_1 = decodeCode_2 >= 0x10ffff ? outOfBoundsChar : decodeCode_2 > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode_2) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_2] || decodeCode_2);
        }
      }

      replaceResult_1 += decodeResult_1;
      replaceLastIndex_1 = replaceMatch_1.index + replaceInput_1.length;
    } while (replaceMatch_1 = decodeRegExp.exec(text));

    if (replaceLastIndex_1 !== text.length) {
      replaceResult_1 += text.substring(replaceLastIndex_1);
    }
  } else {
    replaceResult_1 = text;
  }

  return replaceResult_1;
}

exports.decode = decode;

/***/ }),

/***/ "./node_modules/html-entities/lib/named-references.js":
/*!************************************************************!*\
  !*** ./node_modules/html-entities/lib/named-references.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bodyRegExps = {
  xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html4: /&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html5: /&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g
};
exports.namedReferences = {
  xml: {
    entities: {
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&apos;": "'",
      "&amp;": "&"
    },
    characters: {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&apos;",
      "&": "&amp;"
    }
  },
  html4: {
    entities: {
      "&apos;": "'",
      "&nbsp": "",
      "&nbsp;": "",
      "&iexcl": "",
      "&iexcl;": "",
      "&cent": "",
      "&cent;": "",
      "&pound": "",
      "&pound;": "",
      "&curren": "",
      "&curren;": "",
      "&yen": "",
      "&yen;": "",
      "&brvbar": "",
      "&brvbar;": "",
      "&sect": "",
      "&sect;": "",
      "&uml": "",
      "&uml;": "",
      "&copy": "",
      "&copy;": "",
      "&ordf": "",
      "&ordf;": "",
      "&laquo": "",
      "&laquo;": "",
      "&not": "",
      "&not;": "",
      "&shy": "",
      "&shy;": "",
      "&reg": "",
      "&reg;": "",
      "&macr": "",
      "&macr;": "",
      "&deg": "",
      "&deg;": "",
      "&plusmn": "",
      "&plusmn;": "",
      "&sup2": "",
      "&sup2;": "",
      "&sup3": "",
      "&sup3;": "",
      "&acute": "",
      "&acute;": "",
      "&micro": "",
      "&micro;": "",
      "&para": "",
      "&para;": "",
      "&middot": "",
      "&middot;": "",
      "&cedil": "",
      "&cedil;": "",
      "&sup1": "",
      "&sup1;": "",
      "&ordm": "",
      "&ordm;": "",
      "&raquo": "",
      "&raquo;": "",
      "&frac14": "",
      "&frac14;": "",
      "&frac12": "",
      "&frac12;": "",
      "&frac34": "",
      "&frac34;": "",
      "&iquest": "",
      "&iquest;": "",
      "&Agrave": "",
      "&Agrave;": "",
      "&Aacute": "",
      "&Aacute;": "",
      "&Acirc": "",
      "&Acirc;": "",
      "&Atilde": "",
      "&Atilde;": "",
      "&Auml": "",
      "&Auml;": "",
      "&Aring": "",
      "&Aring;": "",
      "&AElig": "",
      "&AElig;": "",
      "&Ccedil": "",
      "&Ccedil;": "",
      "&Egrave": "",
      "&Egrave;": "",
      "&Eacute": "",
      "&Eacute;": "",
      "&Ecirc": "",
      "&Ecirc;": "",
      "&Euml": "",
      "&Euml;": "",
      "&Igrave": "",
      "&Igrave;": "",
      "&Iacute": "",
      "&Iacute;": "",
      "&Icirc": "",
      "&Icirc;": "",
      "&Iuml": "",
      "&Iuml;": "",
      "&ETH": "",
      "&ETH;": "",
      "&Ntilde": "",
      "&Ntilde;": "",
      "&Ograve": "",
      "&Ograve;": "",
      "&Oacute": "",
      "&Oacute;": "",
      "&Ocirc": "",
      "&Ocirc;": "",
      "&Otilde": "",
      "&Otilde;": "",
      "&Ouml": "",
      "&Ouml;": "",
      "&times": "",
      "&times;": "",
      "&Oslash": "",
      "&Oslash;": "",
      "&Ugrave": "",
      "&Ugrave;": "",
      "&Uacute": "",
      "&Uacute;": "",
      "&Ucirc": "",
      "&Ucirc;": "",
      "&Uuml": "",
      "&Uuml;": "",
      "&Yacute": "",
      "&Yacute;": "",
      "&THORN": "",
      "&THORN;": "",
      "&szlig": "",
      "&szlig;": "",
      "&agrave": "",
      "&agrave;": "",
      "&aacute": "",
      "&aacute;": "",
      "&acirc": "",
      "&acirc;": "",
      "&atilde": "",
      "&atilde;": "",
      "&auml": "",
      "&auml;": "",
      "&aring": "",
      "&aring;": "",
      "&aelig": "",
      "&aelig;": "",
      "&ccedil": "",
      "&ccedil;": "",
      "&egrave": "",
      "&egrave;": "",
      "&eacute": "",
      "&eacute;": "",
      "&ecirc": "",
      "&ecirc;": "",
      "&euml": "",
      "&euml;": "",
      "&igrave": "",
      "&igrave;": "",
      "&iacute": "",
      "&iacute;": "",
      "&icirc": "",
      "&icirc;": "",
      "&iuml": "",
      "&iuml;": "",
      "&eth": "",
      "&eth;": "",
      "&ntilde": "",
      "&ntilde;": "",
      "&ograve": "",
      "&ograve;": "",
      "&oacute": "",
      "&oacute;": "",
      "&ocirc": "",
      "&ocirc;": "",
      "&otilde": "",
      "&otilde;": "",
      "&ouml": "",
      "&ouml;": "",
      "&divide": "",
      "&divide;": "",
      "&oslash": "",
      "&oslash;": "",
      "&ugrave": "",
      "&ugrave;": "",
      "&uacute": "",
      "&uacute;": "",
      "&ucirc": "",
      "&ucirc;": "",
      "&uuml": "",
      "&uuml;": "",
      "&yacute": "",
      "&yacute;": "",
      "&thorn": "",
      "&thorn;": "",
      "&yuml": "",
      "&yuml;": "",
      "&quot": '"',
      "&quot;": '"',
      "&amp": "&",
      "&amp;": "&",
      "&lt": "<",
      "&lt;": "<",
      "&gt": ">",
      "&gt;": ">",
      "&OElig;": "",
      "&oelig;": "",
      "&Scaron;": "",
      "&scaron;": "",
      "&Yuml;": "",
      "&circ;": "",
      "&tilde;": "",
      "&ensp;": "",
      "&emsp;": "",
      "&thinsp;": "",
      "&zwnj;": "",
      "&zwj;": "",
      "&lrm;": "",
      "&rlm;": "",
      "&ndash;": "",
      "&mdash;": "",
      "&lsquo;": "",
      "&rsquo;": "",
      "&sbquo;": "",
      "&ldquo;": "",
      "&rdquo;": "",
      "&bdquo;": "",
      "&dagger;": "",
      "&Dagger;": "",
      "&permil;": "",
      "&lsaquo;": "",
      "&rsaquo;": "",
      "&euro;": "",
      "&fnof;": "",
      "&Alpha;": "",
      "&Beta;": "",
      "&Gamma;": "",
      "&Delta;": "",
      "&Epsilon;": "",
      "&Zeta;": "",
      "&Eta;": "",
      "&Theta;": "",
      "&Iota;": "",
      "&Kappa;": "",
      "&Lambda;": "",
      "&Mu;": "",
      "&Nu;": "",
      "&Xi;": "",
      "&Omicron;": "",
      "&Pi;": "",
      "&Rho;": "",
      "&Sigma;": "",
      "&Tau;": "",
      "&Upsilon;": "",
      "&Phi;": "",
      "&Chi;": "",
      "&Psi;": "",
      "&Omega;": "",
      "&alpha;": "",
      "&beta;": "",
      "&gamma;": "",
      "&delta;": "",
      "&epsilon;": "",
      "&zeta;": "",
      "&eta;": "",
      "&theta;": "",
      "&iota;": "",
      "&kappa;": "",
      "&lambda;": "",
      "&mu;": "",
      "&nu;": "",
      "&xi;": "",
      "&omicron;": "",
      "&pi;": "",
      "&rho;": "",
      "&sigmaf;": "",
      "&sigma;": "",
      "&tau;": "",
      "&upsilon;": "",
      "&phi;": "",
      "&chi;": "",
      "&psi;": "",
      "&omega;": "",
      "&thetasym;": "",
      "&upsih;": "",
      "&piv;": "",
      "&bull;": "",
      "&hellip;": "",
      "&prime;": "",
      "&Prime;": "",
      "&oline;": "",
      "&frasl;": "",
      "&weierp;": "",
      "&image;": "",
      "&real;": "",
      "&trade;": "",
      "&alefsym;": "",
      "&larr;": "",
      "&uarr;": "",
      "&rarr;": "",
      "&darr;": "",
      "&harr;": "",
      "&crarr;": "",
      "&lArr;": "",
      "&uArr;": "",
      "&rArr;": "",
      "&dArr;": "",
      "&hArr;": "",
      "&forall;": "",
      "&part;": "",
      "&exist;": "",
      "&empty;": "",
      "&nabla;": "",
      "&isin;": "",
      "&notin;": "",
      "&ni;": "",
      "&prod;": "",
      "&sum;": "",
      "&minus;": "",
      "&lowast;": "",
      "&radic;": "",
      "&prop;": "",
      "&infin;": "",
      "&ang;": "",
      "&and;": "",
      "&or;": "",
      "&cap;": "",
      "&cup;": "",
      "&int;": "",
      "&there4;": "",
      "&sim;": "",
      "&cong;": "",
      "&asymp;": "",
      "&ne;": "",
      "&equiv;": "",
      "&le;": "",
      "&ge;": "",
      "&sub;": "",
      "&sup;": "",
      "&nsub;": "",
      "&sube;": "",
      "&supe;": "",
      "&oplus;": "",
      "&otimes;": "",
      "&perp;": "",
      "&sdot;": "",
      "&lceil;": "",
      "&rceil;": "",
      "&lfloor;": "",
      "&rfloor;": "",
      "&lang;": "",
      "&rang;": "",
      "&loz;": "",
      "&spades;": "",
      "&clubs;": "",
      "&hearts;": "",
      "&diams;": ""
    },
    characters: {
      "'": "&apos;",
      "": "&nbsp;",
      "": "&iexcl;",
      "": "&cent;",
      "": "&pound;",
      "": "&curren;",
      "": "&yen;",
      "": "&brvbar;",
      "": "&sect;",
      "": "&uml;",
      "": "&copy;",
      "": "&ordf;",
      "": "&laquo;",
      "": "&not;",
      "": "&shy;",
      "": "&reg;",
      "": "&macr;",
      "": "&deg;",
      "": "&plusmn;",
      "": "&sup2;",
      "": "&sup3;",
      "": "&acute;",
      "": "&micro;",
      "": "&para;",
      "": "&middot;",
      "": "&cedil;",
      "": "&sup1;",
      "": "&ordm;",
      "": "&raquo;",
      "": "&frac14;",
      "": "&frac12;",
      "": "&frac34;",
      "": "&iquest;",
      "": "&Agrave;",
      "": "&Aacute;",
      "": "&Acirc;",
      "": "&Atilde;",
      "": "&Auml;",
      "": "&Aring;",
      "": "&AElig;",
      "": "&Ccedil;",
      "": "&Egrave;",
      "": "&Eacute;",
      "": "&Ecirc;",
      "": "&Euml;",
      "": "&Igrave;",
      "": "&Iacute;",
      "": "&Icirc;",
      "": "&Iuml;",
      "": "&ETH;",
      "": "&Ntilde;",
      "": "&Ograve;",
      "": "&Oacute;",
      "": "&Ocirc;",
      "": "&Otilde;",
      "": "&Ouml;",
      "": "&times;",
      "": "&Oslash;",
      "": "&Ugrave;",
      "": "&Uacute;",
      "": "&Ucirc;",
      "": "&Uuml;",
      "": "&Yacute;",
      "": "&THORN;",
      "": "&szlig;",
      "": "&agrave;",
      "": "&aacute;",
      "": "&acirc;",
      "": "&atilde;",
      "": "&auml;",
      "": "&aring;",
      "": "&aelig;",
      "": "&ccedil;",
      "": "&egrave;",
      "": "&eacute;",
      "": "&ecirc;",
      "": "&euml;",
      "": "&igrave;",
      "": "&iacute;",
      "": "&icirc;",
      "": "&iuml;",
      "": "&eth;",
      "": "&ntilde;",
      "": "&ograve;",
      "": "&oacute;",
      "": "&ocirc;",
      "": "&otilde;",
      "": "&ouml;",
      "": "&divide;",
      "": "&oslash;",
      "": "&ugrave;",
      "": "&uacute;",
      "": "&ucirc;",
      "": "&uuml;",
      "": "&yacute;",
      "": "&thorn;",
      "": "&yuml;",
      '"': "&quot;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "": "&OElig;",
      "": "&oelig;",
      "": "&Scaron;",
      "": "&scaron;",
      "": "&Yuml;",
      "": "&circ;",
      "": "&tilde;",
      "": "&ensp;",
      "": "&emsp;",
      "": "&thinsp;",
      "": "&zwnj;",
      "": "&zwj;",
      "": "&lrm;",
      "": "&rlm;",
      "": "&ndash;",
      "": "&mdash;",
      "": "&lsquo;",
      "": "&rsquo;",
      "": "&sbquo;",
      "": "&ldquo;",
      "": "&rdquo;",
      "": "&bdquo;",
      "": "&dagger;",
      "": "&Dagger;",
      "": "&permil;",
      "": "&lsaquo;",
      "": "&rsaquo;",
      "": "&euro;",
      "": "&fnof;",
      "": "&Alpha;",
      "": "&Beta;",
      "": "&Gamma;",
      "": "&Delta;",
      "": "&Epsilon;",
      "": "&Zeta;",
      "": "&Eta;",
      "": "&Theta;",
      "": "&Iota;",
      "": "&Kappa;",
      "": "&Lambda;",
      "": "&Mu;",
      "": "&Nu;",
      "": "&Xi;",
      "": "&Omicron;",
      "": "&Pi;",
      "": "&Rho;",
      "": "&Sigma;",
      "": "&Tau;",
      "": "&Upsilon;",
      "": "&Phi;",
      "": "&Chi;",
      "": "&Psi;",
      "": "&Omega;",
      "": "&alpha;",
      "": "&beta;",
      "": "&gamma;",
      "": "&delta;",
      "": "&epsilon;",
      "": "&zeta;",
      "": "&eta;",
      "": "&theta;",
      "": "&iota;",
      "": "&kappa;",
      "": "&lambda;",
      "": "&mu;",
      "": "&nu;",
      "": "&xi;",
      "": "&omicron;",
      "": "&pi;",
      "": "&rho;",
      "": "&sigmaf;",
      "": "&sigma;",
      "": "&tau;",
      "": "&upsilon;",
      "": "&phi;",
      "": "&chi;",
      "": "&psi;",
      "": "&omega;",
      "": "&thetasym;",
      "": "&upsih;",
      "": "&piv;",
      "": "&bull;",
      "": "&hellip;",
      "": "&prime;",
      "": "&Prime;",
      "": "&oline;",
      "": "&frasl;",
      "": "&weierp;",
      "": "&image;",
      "": "&real;",
      "": "&trade;",
      "": "&alefsym;",
      "": "&larr;",
      "": "&uarr;",
      "": "&rarr;",
      "": "&darr;",
      "": "&harr;",
      "": "&crarr;",
      "": "&lArr;",
      "": "&uArr;",
      "": "&rArr;",
      "": "&dArr;",
      "": "&hArr;",
      "": "&forall;",
      "": "&part;",
      "": "&exist;",
      "": "&empty;",
      "": "&nabla;",
      "": "&isin;",
      "": "&notin;",
      "": "&ni;",
      "": "&prod;",
      "": "&sum;",
      "": "&minus;",
      "": "&lowast;",
      "": "&radic;",
      "": "&prop;",
      "": "&infin;",
      "": "&ang;",
      "": "&and;",
      "": "&or;",
      "": "&cap;",
      "": "&cup;",
      "": "&int;",
      "": "&there4;",
      "": "&sim;",
      "": "&cong;",
      "": "&asymp;",
      "": "&ne;",
      "": "&equiv;",
      "": "&le;",
      "": "&ge;",
      "": "&sub;",
      "": "&sup;",
      "": "&nsub;",
      "": "&sube;",
      "": "&supe;",
      "": "&oplus;",
      "": "&otimes;",
      "": "&perp;",
      "": "&sdot;",
      "": "&lceil;",
      "": "&rceil;",
      "": "&lfloor;",
      "": "&rfloor;",
      "": "&lang;",
      "": "&rang;",
      "": "&loz;",
      "": "&spades;",
      "": "&clubs;",
      "": "&hearts;",
      "": "&diams;"
    }
  },
  html5: {
    entities: {
      "&AElig": "",
      "&AElig;": "",
      "&AMP": "&",
      "&AMP;": "&",
      "&Aacute": "",
      "&Aacute;": "",
      "&Abreve;": "",
      "&Acirc": "",
      "&Acirc;": "",
      "&Acy;": "",
      "&Afr;": "",
      "&Agrave": "",
      "&Agrave;": "",
      "&Alpha;": "",
      "&Amacr;": "",
      "&And;": "",
      "&Aogon;": "",
      "&Aopf;": "",
      "&ApplyFunction;": "",
      "&Aring": "",
      "&Aring;": "",
      "&Ascr;": "",
      "&Assign;": "",
      "&Atilde": "",
      "&Atilde;": "",
      "&Auml": "",
      "&Auml;": "",
      "&Backslash;": "",
      "&Barv;": "",
      "&Barwed;": "",
      "&Bcy;": "",
      "&Because;": "",
      "&Bernoullis;": "",
      "&Beta;": "",
      "&Bfr;": "",
      "&Bopf;": "",
      "&Breve;": "",
      "&Bscr;": "",
      "&Bumpeq;": "",
      "&CHcy;": "",
      "&COPY": "",
      "&COPY;": "",
      "&Cacute;": "",
      "&Cap;": "",
      "&CapitalDifferentialD;": "",
      "&Cayleys;": "",
      "&Ccaron;": "",
      "&Ccedil": "",
      "&Ccedil;": "",
      "&Ccirc;": "",
      "&Cconint;": "",
      "&Cdot;": "",
      "&Cedilla;": "",
      "&CenterDot;": "",
      "&Cfr;": "",
      "&Chi;": "",
      "&CircleDot;": "",
      "&CircleMinus;": "",
      "&CirclePlus;": "",
      "&CircleTimes;": "",
      "&ClockwiseContourIntegral;": "",
      "&CloseCurlyDoubleQuote;": "",
      "&CloseCurlyQuote;": "",
      "&Colon;": "",
      "&Colone;": "",
      "&Congruent;": "",
      "&Conint;": "",
      "&ContourIntegral;": "",
      "&Copf;": "",
      "&Coproduct;": "",
      "&CounterClockwiseContourIntegral;": "",
      "&Cross;": "",
      "&Cscr;": "",
      "&Cup;": "",
      "&CupCap;": "",
      "&DD;": "",
      "&DDotrahd;": "",
      "&DJcy;": "",
      "&DScy;": "",
      "&DZcy;": "",
      "&Dagger;": "",
      "&Darr;": "",
      "&Dashv;": "",
      "&Dcaron;": "",
      "&Dcy;": "",
      "&Del;": "",
      "&Delta;": "",
      "&Dfr;": "",
      "&DiacriticalAcute;": "",
      "&DiacriticalDot;": "",
      "&DiacriticalDoubleAcute;": "",
      "&DiacriticalGrave;": "`",
      "&DiacriticalTilde;": "",
      "&Diamond;": "",
      "&DifferentialD;": "",
      "&Dopf;": "",
      "&Dot;": "",
      "&DotDot;": "",
      "&DotEqual;": "",
      "&DoubleContourIntegral;": "",
      "&DoubleDot;": "",
      "&DoubleDownArrow;": "",
      "&DoubleLeftArrow;": "",
      "&DoubleLeftRightArrow;": "",
      "&DoubleLeftTee;": "",
      "&DoubleLongLeftArrow;": "",
      "&DoubleLongLeftRightArrow;": "",
      "&DoubleLongRightArrow;": "",
      "&DoubleRightArrow;": "",
      "&DoubleRightTee;": "",
      "&DoubleUpArrow;": "",
      "&DoubleUpDownArrow;": "",
      "&DoubleVerticalBar;": "",
      "&DownArrow;": "",
      "&DownArrowBar;": "",
      "&DownArrowUpArrow;": "",
      "&DownBreve;": "",
      "&DownLeftRightVector;": "",
      "&DownLeftTeeVector;": "",
      "&DownLeftVector;": "",
      "&DownLeftVectorBar;": "",
      "&DownRightTeeVector;": "",
      "&DownRightVector;": "",
      "&DownRightVectorBar;": "",
      "&DownTee;": "",
      "&DownTeeArrow;": "",
      "&Downarrow;": "",
      "&Dscr;": "",
      "&Dstrok;": "",
      "&ENG;": "",
      "&ETH": "",
      "&ETH;": "",
      "&Eacute": "",
      "&Eacute;": "",
      "&Ecaron;": "",
      "&Ecirc": "",
      "&Ecirc;": "",
      "&Ecy;": "",
      "&Edot;": "",
      "&Efr;": "",
      "&Egrave": "",
      "&Egrave;": "",
      "&Element;": "",
      "&Emacr;": "",
      "&EmptySmallSquare;": "",
      "&EmptyVerySmallSquare;": "",
      "&Eogon;": "",
      "&Eopf;": "",
      "&Epsilon;": "",
      "&Equal;": "",
      "&EqualTilde;": "",
      "&Equilibrium;": "",
      "&Escr;": "",
      "&Esim;": "",
      "&Eta;": "",
      "&Euml": "",
      "&Euml;": "",
      "&Exists;": "",
      "&ExponentialE;": "",
      "&Fcy;": "",
      "&Ffr;": "",
      "&FilledSmallSquare;": "",
      "&FilledVerySmallSquare;": "",
      "&Fopf;": "",
      "&ForAll;": "",
      "&Fouriertrf;": "",
      "&Fscr;": "",
      "&GJcy;": "",
      "&GT": ">",
      "&GT;": ">",
      "&Gamma;": "",
      "&Gammad;": "",
      "&Gbreve;": "",
      "&Gcedil;": "",
      "&Gcirc;": "",
      "&Gcy;": "",
      "&Gdot;": "",
      "&Gfr;": "",
      "&Gg;": "",
      "&Gopf;": "",
      "&GreaterEqual;": "",
      "&GreaterEqualLess;": "",
      "&GreaterFullEqual;": "",
      "&GreaterGreater;": "",
      "&GreaterLess;": "",
      "&GreaterSlantEqual;": "",
      "&GreaterTilde;": "",
      "&Gscr;": "",
      "&Gt;": "",
      "&HARDcy;": "",
      "&Hacek;": "",
      "&Hat;": "^",
      "&Hcirc;": "",
      "&Hfr;": "",
      "&HilbertSpace;": "",
      "&Hopf;": "",
      "&HorizontalLine;": "",
      "&Hscr;": "",
      "&Hstrok;": "",
      "&HumpDownHump;": "",
      "&HumpEqual;": "",
      "&IEcy;": "",
      "&IJlig;": "",
      "&IOcy;": "",
      "&Iacute": "",
      "&Iacute;": "",
      "&Icirc": "",
      "&Icirc;": "",
      "&Icy;": "",
      "&Idot;": "",
      "&Ifr;": "",
      "&Igrave": "",
      "&Igrave;": "",
      "&Im;": "",
      "&Imacr;": "",
      "&ImaginaryI;": "",
      "&Implies;": "",
      "&Int;": "",
      "&Integral;": "",
      "&Intersection;": "",
      "&InvisibleComma;": "",
      "&InvisibleTimes;": "",
      "&Iogon;": "",
      "&Iopf;": "",
      "&Iota;": "",
      "&Iscr;": "",
      "&Itilde;": "",
      "&Iukcy;": "",
      "&Iuml": "",
      "&Iuml;": "",
      "&Jcirc;": "",
      "&Jcy;": "",
      "&Jfr;": "",
      "&Jopf;": "",
      "&Jscr;": "",
      "&Jsercy;": "",
      "&Jukcy;": "",
      "&KHcy;": "",
      "&KJcy;": "",
      "&Kappa;": "",
      "&Kcedil;": "",
      "&Kcy;": "",
      "&Kfr;": "",
      "&Kopf;": "",
      "&Kscr;": "",
      "&LJcy;": "",
      "&LT": "<",
      "&LT;": "<",
      "&Lacute;": "",
      "&Lambda;": "",
      "&Lang;": "",
      "&Laplacetrf;": "",
      "&Larr;": "",
      "&Lcaron;": "",
      "&Lcedil;": "",
      "&Lcy;": "",
      "&LeftAngleBracket;": "",
      "&LeftArrow;": "",
      "&LeftArrowBar;": "",
      "&LeftArrowRightArrow;": "",
      "&LeftCeiling;": "",
      "&LeftDoubleBracket;": "",
      "&LeftDownTeeVector;": "",
      "&LeftDownVector;": "",
      "&LeftDownVectorBar;": "",
      "&LeftFloor;": "",
      "&LeftRightArrow;": "",
      "&LeftRightVector;": "",
      "&LeftTee;": "",
      "&LeftTeeArrow;": "",
      "&LeftTeeVector;": "",
      "&LeftTriangle;": "",
      "&LeftTriangleBar;": "",
      "&LeftTriangleEqual;": "",
      "&LeftUpDownVector;": "",
      "&LeftUpTeeVector;": "",
      "&LeftUpVector;": "",
      "&LeftUpVectorBar;": "",
      "&LeftVector;": "",
      "&LeftVectorBar;": "",
      "&Leftarrow;": "",
      "&Leftrightarrow;": "",
      "&LessEqualGreater;": "",
      "&LessFullEqual;": "",
      "&LessGreater;": "",
      "&LessLess;": "",
      "&LessSlantEqual;": "",
      "&LessTilde;": "",
      "&Lfr;": "",
      "&Ll;": "",
      "&Lleftarrow;": "",
      "&Lmidot;": "",
      "&LongLeftArrow;": "",
      "&LongLeftRightArrow;": "",
      "&LongRightArrow;": "",
      "&Longleftarrow;": "",
      "&Longleftrightarrow;": "",
      "&Longrightarrow;": "",
      "&Lopf;": "",
      "&LowerLeftArrow;": "",
      "&LowerRightArrow;": "",
      "&Lscr;": "",
      "&Lsh;": "",
      "&Lstrok;": "",
      "&Lt;": "",
      "&Map;": "",
      "&Mcy;": "",
      "&MediumSpace;": "",
      "&Mellintrf;": "",
      "&Mfr;": "",
      "&MinusPlus;": "",
      "&Mopf;": "",
      "&Mscr;": "",
      "&Mu;": "",
      "&NJcy;": "",
      "&Nacute;": "",
      "&Ncaron;": "",
      "&Ncedil;": "",
      "&Ncy;": "",
      "&NegativeMediumSpace;": "",
      "&NegativeThickSpace;": "",
      "&NegativeThinSpace;": "",
      "&NegativeVeryThinSpace;": "",
      "&NestedGreaterGreater;": "",
      "&NestedLessLess;": "",
      "&NewLine;": "\n",
      "&Nfr;": "",
      "&NoBreak;": "",
      "&NonBreakingSpace;": "",
      "&Nopf;": "",
      "&Not;": "",
      "&NotCongruent;": "",
      "&NotCupCap;": "",
      "&NotDoubleVerticalBar;": "",
      "&NotElement;": "",
      "&NotEqual;": "",
      "&NotEqualTilde;": "",
      "&NotExists;": "",
      "&NotGreater;": "",
      "&NotGreaterEqual;": "",
      "&NotGreaterFullEqual;": "",
      "&NotGreaterGreater;": "",
      "&NotGreaterLess;": "",
      "&NotGreaterSlantEqual;": "",
      "&NotGreaterTilde;": "",
      "&NotHumpDownHump;": "",
      "&NotHumpEqual;": "",
      "&NotLeftTriangle;": "",
      "&NotLeftTriangleBar;": "",
      "&NotLeftTriangleEqual;": "",
      "&NotLess;": "",
      "&NotLessEqual;": "",
      "&NotLessGreater;": "",
      "&NotLessLess;": "",
      "&NotLessSlantEqual;": "",
      "&NotLessTilde;": "",
      "&NotNestedGreaterGreater;": "",
      "&NotNestedLessLess;": "",
      "&NotPrecedes;": "",
      "&NotPrecedesEqual;": "",
      "&NotPrecedesSlantEqual;": "",
      "&NotReverseElement;": "",
      "&NotRightTriangle;": "",
      "&NotRightTriangleBar;": "",
      "&NotRightTriangleEqual;": "",
      "&NotSquareSubset;": "",
      "&NotSquareSubsetEqual;": "",
      "&NotSquareSuperset;": "",
      "&NotSquareSupersetEqual;": "",
      "&NotSubset;": "",
      "&NotSubsetEqual;": "",
      "&NotSucceeds;": "",
      "&NotSucceedsEqual;": "",
      "&NotSucceedsSlantEqual;": "",
      "&NotSucceedsTilde;": "",
      "&NotSuperset;": "",
      "&NotSupersetEqual;": "",
      "&NotTilde;": "",
      "&NotTildeEqual;": "",
      "&NotTildeFullEqual;": "",
      "&NotTildeTilde;": "",
      "&NotVerticalBar;": "",
      "&Nscr;": "",
      "&Ntilde": "",
      "&Ntilde;": "",
      "&Nu;": "",
      "&OElig;": "",
      "&Oacute": "",
      "&Oacute;": "",
      "&Ocirc": "",
      "&Ocirc;": "",
      "&Ocy;": "",
      "&Odblac;": "",
      "&Ofr;": "",
      "&Ograve": "",
      "&Ograve;": "",
      "&Omacr;": "",
      "&Omega;": "",
      "&Omicron;": "",
      "&Oopf;": "",
      "&OpenCurlyDoubleQuote;": "",
      "&OpenCurlyQuote;": "",
      "&Or;": "",
      "&Oscr;": "",
      "&Oslash": "",
      "&Oslash;": "",
      "&Otilde": "",
      "&Otilde;": "",
      "&Otimes;": "",
      "&Ouml": "",
      "&Ouml;": "",
      "&OverBar;": "",
      "&OverBrace;": "",
      "&OverBracket;": "",
      "&OverParenthesis;": "",
      "&PartialD;": "",
      "&Pcy;": "",
      "&Pfr;": "",
      "&Phi;": "",
      "&Pi;": "",
      "&PlusMinus;": "",
      "&Poincareplane;": "",
      "&Popf;": "",
      "&Pr;": "",
      "&Precedes;": "",
      "&PrecedesEqual;": "",
      "&PrecedesSlantEqual;": "",
      "&PrecedesTilde;": "",
      "&Prime;": "",
      "&Product;": "",
      "&Proportion;": "",
      "&Proportional;": "",
      "&Pscr;": "",
      "&Psi;": "",
      "&QUOT": '"',
      "&QUOT;": '"',
      "&Qfr;": "",
      "&Qopf;": "",
      "&Qscr;": "",
      "&RBarr;": "",
      "&REG": "",
      "&REG;": "",
      "&Racute;": "",
      "&Rang;": "",
      "&Rarr;": "",
      "&Rarrtl;": "",
      "&Rcaron;": "",
      "&Rcedil;": "",
      "&Rcy;": "",
      "&Re;": "",
      "&ReverseElement;": "",
      "&ReverseEquilibrium;": "",
      "&ReverseUpEquilibrium;": "",
      "&Rfr;": "",
      "&Rho;": "",
      "&RightAngleBracket;": "",
      "&RightArrow;": "",
      "&RightArrowBar;": "",
      "&RightArrowLeftArrow;": "",
      "&RightCeiling;": "",
      "&RightDoubleBracket;": "",
      "&RightDownTeeVector;": "",
      "&RightDownVector;": "",
      "&RightDownVectorBar;": "",
      "&RightFloor;": "",
      "&RightTee;": "",
      "&RightTeeArrow;": "",
      "&RightTeeVector;": "",
      "&RightTriangle;": "",
      "&RightTriangleBar;": "",
      "&RightTriangleEqual;": "",
      "&RightUpDownVector;": "",
      "&RightUpTeeVector;": "",
      "&RightUpVector;": "",
      "&RightUpVectorBar;": "",
      "&RightVector;": "",
      "&RightVectorBar;": "",
      "&Rightarrow;": "",
      "&Ropf;": "",
      "&RoundImplies;": "",
      "&Rrightarrow;": "",
      "&Rscr;": "",
      "&Rsh;": "",
      "&RuleDelayed;": "",
      "&SHCHcy;": "",
      "&SHcy;": "",
      "&SOFTcy;": "",
      "&Sacute;": "",
      "&Sc;": "",
      "&Scaron;": "",
      "&Scedil;": "",
      "&Scirc;": "",
      "&Scy;": "",
      "&Sfr;": "",
      "&ShortDownArrow;": "",
      "&ShortLeftArrow;": "",
      "&ShortRightArrow;": "",
      "&ShortUpArrow;": "",
      "&Sigma;": "",
      "&SmallCircle;": "",
      "&Sopf;": "",
      "&Sqrt;": "",
      "&Square;": "",
      "&SquareIntersection;": "",
      "&SquareSubset;": "",
      "&SquareSubsetEqual;": "",
      "&SquareSuperset;": "",
      "&SquareSupersetEqual;": "",
      "&SquareUnion;": "",
      "&Sscr;": "",
      "&Star;": "",
      "&Sub;": "",
      "&Subset;": "",
      "&SubsetEqual;": "",
      "&Succeeds;": "",
      "&SucceedsEqual;": "",
      "&SucceedsSlantEqual;": "",
      "&SucceedsTilde;": "",
      "&SuchThat;": "",
      "&Sum;": "",
      "&Sup;": "",
      "&Superset;": "",
      "&SupersetEqual;": "",
      "&Supset;": "",
      "&THORN": "",
      "&THORN;": "",
      "&TRADE;": "",
      "&TSHcy;": "",
      "&TScy;": "",
      "&Tab;": "\t",
      "&Tau;": "",
      "&Tcaron;": "",
      "&Tcedil;": "",
      "&Tcy;": "",
      "&Tfr;": "",
      "&Therefore;": "",
      "&Theta;": "",
      "&ThickSpace;": "",
      "&ThinSpace;": "",
      "&Tilde;": "",
      "&TildeEqual;": "",
      "&TildeFullEqual;": "",
      "&TildeTilde;": "",
      "&Topf;": "",
      "&TripleDot;": "",
      "&Tscr;": "",
      "&Tstrok;": "",
      "&Uacute": "",
      "&Uacute;": "",
      "&Uarr;": "",
      "&Uarrocir;": "",
      "&Ubrcy;": "",
      "&Ubreve;": "",
      "&Ucirc": "",
      "&Ucirc;": "",
      "&Ucy;": "",
      "&Udblac;": "",
      "&Ufr;": "",
      "&Ugrave": "",
      "&Ugrave;": "",
      "&Umacr;": "",
      "&UnderBar;": "_",
      "&UnderBrace;": "",
      "&UnderBracket;": "",
      "&UnderParenthesis;": "",
      "&Union;": "",
      "&UnionPlus;": "",
      "&Uogon;": "",
      "&Uopf;": "",
      "&UpArrow;": "",
      "&UpArrowBar;": "",
      "&UpArrowDownArrow;": "",
      "&UpDownArrow;": "",
      "&UpEquilibrium;": "",
      "&UpTee;": "",
      "&UpTeeArrow;": "",
      "&Uparrow;": "",
      "&Updownarrow;": "",
      "&UpperLeftArrow;": "",
      "&UpperRightArrow;": "",
      "&Upsi;": "",
      "&Upsilon;": "",
      "&Uring;": "",
      "&Uscr;": "",
      "&Utilde;": "",
      "&Uuml": "",
      "&Uuml;": "",
      "&VDash;": "",
      "&Vbar;": "",
      "&Vcy;": "",
      "&Vdash;": "",
      "&Vdashl;": "",
      "&Vee;": "",
      "&Verbar;": "",
      "&Vert;": "",
      "&VerticalBar;": "",
      "&VerticalLine;": "|",
      "&VerticalSeparator;": "",
      "&VerticalTilde;": "",
      "&VeryThinSpace;": "",
      "&Vfr;": "",
      "&Vopf;": "",
      "&Vscr;": "",
      "&Vvdash;": "",
      "&Wcirc;": "",
      "&Wedge;": "",
      "&Wfr;": "",
      "&Wopf;": "",
      "&Wscr;": "",
      "&Xfr;": "",
      "&Xi;": "",
      "&Xopf;": "",
      "&Xscr;": "",
      "&YAcy;": "",
      "&YIcy;": "",
      "&YUcy;": "",
      "&Yacute": "",
      "&Yacute;": "",
      "&Ycirc;": "",
      "&Ycy;": "",
      "&Yfr;": "",
      "&Yopf;": "",
      "&Yscr;": "",
      "&Yuml;": "",
      "&ZHcy;": "",
      "&Zacute;": "",
      "&Zcaron;": "",
      "&Zcy;": "",
      "&Zdot;": "",
      "&ZeroWidthSpace;": "",
      "&Zeta;": "",
      "&Zfr;": "",
      "&Zopf;": "",
      "&Zscr;": "",
      "&aacute": "",
      "&aacute;": "",
      "&abreve;": "",
      "&ac;": "",
      "&acE;": "",
      "&acd;": "",
      "&acirc": "",
      "&acirc;": "",
      "&acute": "",
      "&acute;": "",
      "&acy;": "",
      "&aelig": "",
      "&aelig;": "",
      "&af;": "",
      "&afr;": "",
      "&agrave": "",
      "&agrave;": "",
      "&alefsym;": "",
      "&aleph;": "",
      "&alpha;": "",
      "&amacr;": "",
      "&amalg;": "",
      "&amp": "&",
      "&amp;": "&",
      "&and;": "",
      "&andand;": "",
      "&andd;": "",
      "&andslope;": "",
      "&andv;": "",
      "&ang;": "",
      "&ange;": "",
      "&angle;": "",
      "&angmsd;": "",
      "&angmsdaa;": "",
      "&angmsdab;": "",
      "&angmsdac;": "",
      "&angmsdad;": "",
      "&angmsdae;": "",
      "&angmsdaf;": "",
      "&angmsdag;": "",
      "&angmsdah;": "",
      "&angrt;": "",
      "&angrtvb;": "",
      "&angrtvbd;": "",
      "&angsph;": "",
      "&angst;": "",
      "&angzarr;": "",
      "&aogon;": "",
      "&aopf;": "",
      "&ap;": "",
      "&apE;": "",
      "&apacir;": "",
      "&ape;": "",
      "&apid;": "",
      "&apos;": "'",
      "&approx;": "",
      "&approxeq;": "",
      "&aring": "",
      "&aring;": "",
      "&ascr;": "",
      "&ast;": "*",
      "&asymp;": "",
      "&asympeq;": "",
      "&atilde": "",
      "&atilde;": "",
      "&auml": "",
      "&auml;": "",
      "&awconint;": "",
      "&awint;": "",
      "&bNot;": "",
      "&backcong;": "",
      "&backepsilon;": "",
      "&backprime;": "",
      "&backsim;": "",
      "&backsimeq;": "",
      "&barvee;": "",
      "&barwed;": "",
      "&barwedge;": "",
      "&bbrk;": "",
      "&bbrktbrk;": "",
      "&bcong;": "",
      "&bcy;": "",
      "&bdquo;": "",
      "&becaus;": "",
      "&because;": "",
      "&bemptyv;": "",
      "&bepsi;": "",
      "&bernou;": "",
      "&beta;": "",
      "&beth;": "",
      "&between;": "",
      "&bfr;": "",
      "&bigcap;": "",
      "&bigcirc;": "",
      "&bigcup;": "",
      "&bigodot;": "",
      "&bigoplus;": "",
      "&bigotimes;": "",
      "&bigsqcup;": "",
      "&bigstar;": "",
      "&bigtriangledown;": "",
      "&bigtriangleup;": "",
      "&biguplus;": "",
      "&bigvee;": "",
      "&bigwedge;": "",
      "&bkarow;": "",
      "&blacklozenge;": "",
      "&blacksquare;": "",
      "&blacktriangle;": "",
      "&blacktriangledown;": "",
      "&blacktriangleleft;": "",
      "&blacktriangleright;": "",
      "&blank;": "",
      "&blk12;": "",
      "&blk14;": "",
      "&blk34;": "",
      "&block;": "",
      "&bne;": "=",
      "&bnequiv;": "",
      "&bnot;": "",
      "&bopf;": "",
      "&bot;": "",
      "&bottom;": "",
      "&bowtie;": "",
      "&boxDL;": "",
      "&boxDR;": "",
      "&boxDl;": "",
      "&boxDr;": "",
      "&boxH;": "",
      "&boxHD;": "",
      "&boxHU;": "",
      "&boxHd;": "",
      "&boxHu;": "",
      "&boxUL;": "",
      "&boxUR;": "",
      "&boxUl;": "",
      "&boxUr;": "",
      "&boxV;": "",
      "&boxVH;": "",
      "&boxVL;": "",
      "&boxVR;": "",
      "&boxVh;": "",
      "&boxVl;": "",
      "&boxVr;": "",
      "&boxbox;": "",
      "&boxdL;": "",
      "&boxdR;": "",
      "&boxdl;": "",
      "&boxdr;": "",
      "&boxh;": "",
      "&boxhD;": "",
      "&boxhU;": "",
      "&boxhd;": "",
      "&boxhu;": "",
      "&boxminus;": "",
      "&boxplus;": "",
      "&boxtimes;": "",
      "&boxuL;": "",
      "&boxuR;": "",
      "&boxul;": "",
      "&boxur;": "",
      "&boxv;": "",
      "&boxvH;": "",
      "&boxvL;": "",
      "&boxvR;": "",
      "&boxvh;": "",
      "&boxvl;": "",
      "&boxvr;": "",
      "&bprime;": "",
      "&breve;": "",
      "&brvbar": "",
      "&brvbar;": "",
      "&bscr;": "",
      "&bsemi;": "",
      "&bsim;": "",
      "&bsime;": "",
      "&bsol;": "\\",
      "&bsolb;": "",
      "&bsolhsub;": "",
      "&bull;": "",
      "&bullet;": "",
      "&bump;": "",
      "&bumpE;": "",
      "&bumpe;": "",
      "&bumpeq;": "",
      "&cacute;": "",
      "&cap;": "",
      "&capand;": "",
      "&capbrcup;": "",
      "&capcap;": "",
      "&capcup;": "",
      "&capdot;": "",
      "&caps;": "",
      "&caret;": "",
      "&caron;": "",
      "&ccaps;": "",
      "&ccaron;": "",
      "&ccedil": "",
      "&ccedil;": "",
      "&ccirc;": "",
      "&ccups;": "",
      "&ccupssm;": "",
      "&cdot;": "",
      "&cedil": "",
      "&cedil;": "",
      "&cemptyv;": "",
      "&cent": "",
      "&cent;": "",
      "&centerdot;": "",
      "&cfr;": "",
      "&chcy;": "",
      "&check;": "",
      "&checkmark;": "",
      "&chi;": "",
      "&cir;": "",
      "&cirE;": "",
      "&circ;": "",
      "&circeq;": "",
      "&circlearrowleft;": "",
      "&circlearrowright;": "",
      "&circledR;": "",
      "&circledS;": "",
      "&circledast;": "",
      "&circledcirc;": "",
      "&circleddash;": "",
      "&cire;": "",
      "&cirfnint;": "",
      "&cirmid;": "",
      "&cirscir;": "",
      "&clubs;": "",
      "&clubsuit;": "",
      "&colon;": ":",
      "&colone;": "",
      "&coloneq;": "",
      "&comma;": ",",
      "&commat;": "@",
      "&comp;": "",
      "&compfn;": "",
      "&complement;": "",
      "&complexes;": "",
      "&cong;": "",
      "&congdot;": "",
      "&conint;": "",
      "&copf;": "",
      "&coprod;": "",
      "&copy": "",
      "&copy;": "",
      "&copysr;": "",
      "&crarr;": "",
      "&cross;": "",
      "&cscr;": "",
      "&csub;": "",
      "&csube;": "",
      "&csup;": "",
      "&csupe;": "",
      "&ctdot;": "",
      "&cudarrl;": "",
      "&cudarrr;": "",
      "&cuepr;": "",
      "&cuesc;": "",
      "&cularr;": "",
      "&cularrp;": "",
      "&cup;": "",
      "&cupbrcap;": "",
      "&cupcap;": "",
      "&cupcup;": "",
      "&cupdot;": "",
      "&cupor;": "",
      "&cups;": "",
      "&curarr;": "",
      "&curarrm;": "",
      "&curlyeqprec;": "",
      "&curlyeqsucc;": "",
      "&curlyvee;": "",
      "&curlywedge;": "",
      "&curren": "",
      "&curren;": "",
      "&curvearrowleft;": "",
      "&curvearrowright;": "",
      "&cuvee;": "",
      "&cuwed;": "",
      "&cwconint;": "",
      "&cwint;": "",
      "&cylcty;": "",
      "&dArr;": "",
      "&dHar;": "",
      "&dagger;": "",
      "&daleth;": "",
      "&darr;": "",
      "&dash;": "",
      "&dashv;": "",
      "&dbkarow;": "",
      "&dblac;": "",
      "&dcaron;": "",
      "&dcy;": "",
      "&dd;": "",
      "&ddagger;": "",
      "&ddarr;": "",
      "&ddotseq;": "",
      "&deg": "",
      "&deg;": "",
      "&delta;": "",
      "&demptyv;": "",
      "&dfisht;": "",
      "&dfr;": "",
      "&dharl;": "",
      "&dharr;": "",
      "&diam;": "",
      "&diamond;": "",
      "&diamondsuit;": "",
      "&diams;": "",
      "&die;": "",
      "&digamma;": "",
      "&disin;": "",
      "&div;": "",
      "&divide": "",
      "&divide;": "",
      "&divideontimes;": "",
      "&divonx;": "",
      "&djcy;": "",
      "&dlcorn;": "",
      "&dlcrop;": "",
      "&dollar;": "$",
      "&dopf;": "",
      "&dot;": "",
      "&doteq;": "",
      "&doteqdot;": "",
      "&dotminus;": "",
      "&dotplus;": "",
      "&dotsquare;": "",
      "&doublebarwedge;": "",
      "&downarrow;": "",
      "&downdownarrows;": "",
      "&downharpoonleft;": "",
      "&downharpoonright;": "",
      "&drbkarow;": "",
      "&drcorn;": "",
      "&drcrop;": "",
      "&dscr;": "",
      "&dscy;": "",
      "&dsol;": "",
      "&dstrok;": "",
      "&dtdot;": "",
      "&dtri;": "",
      "&dtrif;": "",
      "&duarr;": "",
      "&duhar;": "",
      "&dwangle;": "",
      "&dzcy;": "",
      "&dzigrarr;": "",
      "&eDDot;": "",
      "&eDot;": "",
      "&eacute": "",
      "&eacute;": "",
      "&easter;": "",
      "&ecaron;": "",
      "&ecir;": "",
      "&ecirc": "",
      "&ecirc;": "",
      "&ecolon;": "",
      "&ecy;": "",
      "&edot;": "",
      "&ee;": "",
      "&efDot;": "",
      "&efr;": "",
      "&eg;": "",
      "&egrave": "",
      "&egrave;": "",
      "&egs;": "",
      "&egsdot;": "",
      "&el;": "",
      "&elinters;": "",
      "&ell;": "",
      "&els;": "",
      "&elsdot;": "",
      "&emacr;": "",
      "&empty;": "",
      "&emptyset;": "",
      "&emptyv;": "",
      "&emsp13;": "",
      "&emsp14;": "",
      "&emsp;": "",
      "&eng;": "",
      "&ensp;": "",
      "&eogon;": "",
      "&eopf;": "",
      "&epar;": "",
      "&eparsl;": "",
      "&eplus;": "",
      "&epsi;": "",
      "&epsilon;": "",
      "&epsiv;": "",
      "&eqcirc;": "",
      "&eqcolon;": "",
      "&eqsim;": "",
      "&eqslantgtr;": "",
      "&eqslantless;": "",
      "&equals;": "=",
      "&equest;": "",
      "&equiv;": "",
      "&equivDD;": "",
      "&eqvparsl;": "",
      "&erDot;": "",
      "&erarr;": "",
      "&escr;": "",
      "&esdot;": "",
      "&esim;": "",
      "&eta;": "",
      "&eth": "",
      "&eth;": "",
      "&euml": "",
      "&euml;": "",
      "&euro;": "",
      "&excl;": "!",
      "&exist;": "",
      "&expectation;": "",
      "&exponentiale;": "",
      "&fallingdotseq;": "",
      "&fcy;": "",
      "&female;": "",
      "&ffilig;": "",
      "&fflig;": "",
      "&ffllig;": "",
      "&ffr;": "",
      "&filig;": "",
      "&fjlig;": "fj",
      "&flat;": "",
      "&fllig;": "",
      "&fltns;": "",
      "&fnof;": "",
      "&fopf;": "",
      "&forall;": "",
      "&fork;": "",
      "&forkv;": "",
      "&fpartint;": "",
      "&frac12": "",
      "&frac12;": "",
      "&frac13;": "",
      "&frac14": "",
      "&frac14;": "",
      "&frac15;": "",
      "&frac16;": "",
      "&frac18;": "",
      "&frac23;": "",
      "&frac25;": "",
      "&frac34": "",
      "&frac34;": "",
      "&frac35;": "",
      "&frac38;": "",
      "&frac45;": "",
      "&frac56;": "",
      "&frac58;": "",
      "&frac78;": "",
      "&frasl;": "",
      "&frown;": "",
      "&fscr;": "",
      "&gE;": "",
      "&gEl;": "",
      "&gacute;": "",
      "&gamma;": "",
      "&gammad;": "",
      "&gap;": "",
      "&gbreve;": "",
      "&gcirc;": "",
      "&gcy;": "",
      "&gdot;": "",
      "&ge;": "",
      "&gel;": "",
      "&geq;": "",
      "&geqq;": "",
      "&geqslant;": "",
      "&ges;": "",
      "&gescc;": "",
      "&gesdot;": "",
      "&gesdoto;": "",
      "&gesdotol;": "",
      "&gesl;": "",
      "&gesles;": "",
      "&gfr;": "",
      "&gg;": "",
      "&ggg;": "",
      "&gimel;": "",
      "&gjcy;": "",
      "&gl;": "",
      "&glE;": "",
      "&gla;": "",
      "&glj;": "",
      "&gnE;": "",
      "&gnap;": "",
      "&gnapprox;": "",
      "&gne;": "",
      "&gneq;": "",
      "&gneqq;": "",
      "&gnsim;": "",
      "&gopf;": "",
      "&grave;": "`",
      "&gscr;": "",
      "&gsim;": "",
      "&gsime;": "",
      "&gsiml;": "",
      "&gt": ">",
      "&gt;": ">",
      "&gtcc;": "",
      "&gtcir;": "",
      "&gtdot;": "",
      "&gtlPar;": "",
      "&gtquest;": "",
      "&gtrapprox;": "",
      "&gtrarr;": "",
      "&gtrdot;": "",
      "&gtreqless;": "",
      "&gtreqqless;": "",
      "&gtrless;": "",
      "&gtrsim;": "",
      "&gvertneqq;": "",
      "&gvnE;": "",
      "&hArr;": "",
      "&hairsp;": "",
      "&half;": "",
      "&hamilt;": "",
      "&hardcy;": "",
      "&harr;": "",
      "&harrcir;": "",
      "&harrw;": "",
      "&hbar;": "",
      "&hcirc;": "",
      "&hearts;": "",
      "&heartsuit;": "",
      "&hellip;": "",
      "&hercon;": "",
      "&hfr;": "",
      "&hksearow;": "",
      "&hkswarow;": "",
      "&hoarr;": "",
      "&homtht;": "",
      "&hookleftarrow;": "",
      "&hookrightarrow;": "",
      "&hopf;": "",
      "&horbar;": "",
      "&hscr;": "",
      "&hslash;": "",
      "&hstrok;": "",
      "&hybull;": "",
      "&hyphen;": "",
      "&iacute": "",
      "&iacute;": "",
      "&ic;": "",
      "&icirc": "",
      "&icirc;": "",
      "&icy;": "",
      "&iecy;": "",
      "&iexcl": "",
      "&iexcl;": "",
      "&iff;": "",
      "&ifr;": "",
      "&igrave": "",
      "&igrave;": "",
      "&ii;": "",
      "&iiiint;": "",
      "&iiint;": "",
      "&iinfin;": "",
      "&iiota;": "",
      "&ijlig;": "",
      "&imacr;": "",
      "&image;": "",
      "&imagline;": "",
      "&imagpart;": "",
      "&imath;": "",
      "&imof;": "",
      "&imped;": "",
      "&in;": "",
      "&incare;": "",
      "&infin;": "",
      "&infintie;": "",
      "&inodot;": "",
      "&int;": "",
      "&intcal;": "",
      "&integers;": "",
      "&intercal;": "",
      "&intlarhk;": "",
      "&intprod;": "",
      "&iocy;": "",
      "&iogon;": "",
      "&iopf;": "",
      "&iota;": "",
      "&iprod;": "",
      "&iquest": "",
      "&iquest;": "",
      "&iscr;": "",
      "&isin;": "",
      "&isinE;": "",
      "&isindot;": "",
      "&isins;": "",
      "&isinsv;": "",
      "&isinv;": "",
      "&it;": "",
      "&itilde;": "",
      "&iukcy;": "",
      "&iuml": "",
      "&iuml;": "",
      "&jcirc;": "",
      "&jcy;": "",
      "&jfr;": "",
      "&jmath;": "",
      "&jopf;": "",
      "&jscr;": "",
      "&jsercy;": "",
      "&jukcy;": "",
      "&kappa;": "",
      "&kappav;": "",
      "&kcedil;": "",
      "&kcy;": "",
      "&kfr;": "",
      "&kgreen;": "",
      "&khcy;": "",
      "&kjcy;": "",
      "&kopf;": "",
      "&kscr;": "",
      "&lAarr;": "",
      "&lArr;": "",
      "&lAtail;": "",
      "&lBarr;": "",
      "&lE;": "",
      "&lEg;": "",
      "&lHar;": "",
      "&lacute;": "",
      "&laemptyv;": "",
      "&lagran;": "",
      "&lambda;": "",
      "&lang;": "",
      "&langd;": "",
      "&langle;": "",
      "&lap;": "",
      "&laquo": "",
      "&laquo;": "",
      "&larr;": "",
      "&larrb;": "",
      "&larrbfs;": "",
      "&larrfs;": "",
      "&larrhk;": "",
      "&larrlp;": "",
      "&larrpl;": "",
      "&larrsim;": "",
      "&larrtl;": "",
      "&lat;": "",
      "&latail;": "",
      "&late;": "",
      "&lates;": "",
      "&lbarr;": "",
      "&lbbrk;": "",
      "&lbrace;": "{",
      "&lbrack;": "[",
      "&lbrke;": "",
      "&lbrksld;": "",
      "&lbrkslu;": "",
      "&lcaron;": "",
      "&lcedil;": "",
      "&lceil;": "",
      "&lcub;": "{",
      "&lcy;": "",
      "&ldca;": "",
      "&ldquo;": "",
      "&ldquor;": "",
      "&ldrdhar;": "",
      "&ldrushar;": "",
      "&ldsh;": "",
      "&le;": "",
      "&leftarrow;": "",
      "&leftarrowtail;": "",
      "&leftharpoondown;": "",
      "&leftharpoonup;": "",
      "&leftleftarrows;": "",
      "&leftrightarrow;": "",
      "&leftrightarrows;": "",
      "&leftrightharpoons;": "",
      "&leftrightsquigarrow;": "",
      "&leftthreetimes;": "",
      "&leg;": "",
      "&leq;": "",
      "&leqq;": "",
      "&leqslant;": "",
      "&les;": "",
      "&lescc;": "",
      "&lesdot;": "",
      "&lesdoto;": "",
      "&lesdotor;": "",
      "&lesg;": "",
      "&lesges;": "",
      "&lessapprox;": "",
      "&lessdot;": "",
      "&lesseqgtr;": "",
      "&lesseqqgtr;": "",
      "&lessgtr;": "",
      "&lesssim;": "",
      "&lfisht;": "",
      "&lfloor;": "",
      "&lfr;": "",
      "&lg;": "",
      "&lgE;": "",
      "&lhard;": "",
      "&lharu;": "",
      "&lharul;": "",
      "&lhblk;": "",
      "&ljcy;": "",
      "&ll;": "",
      "&llarr;": "",
      "&llcorner;": "",
      "&llhard;": "",
      "&lltri;": "",
      "&lmidot;": "",
      "&lmoust;": "",
      "&lmoustache;": "",
      "&lnE;": "",
      "&lnap;": "",
      "&lnapprox;": "",
      "&lne;": "",
      "&lneq;": "",
      "&lneqq;": "",
      "&lnsim;": "",
      "&loang;": "",
      "&loarr;": "",
      "&lobrk;": "",
      "&longleftarrow;": "",
      "&longleftrightarrow;": "",
      "&longmapsto;": "",
      "&longrightarrow;": "",
      "&looparrowleft;": "",
      "&looparrowright;": "",
      "&lopar;": "",
      "&lopf;": "",
      "&loplus;": "",
      "&lotimes;": "",
      "&lowast;": "",
      "&lowbar;": "_",
      "&loz;": "",
      "&lozenge;": "",
      "&lozf;": "",
      "&lpar;": "(",
      "&lparlt;": "",
      "&lrarr;": "",
      "&lrcorner;": "",
      "&lrhar;": "",
      "&lrhard;": "",
      "&lrm;": "",
      "&lrtri;": "",
      "&lsaquo;": "",
      "&lscr;": "",
      "&lsh;": "",
      "&lsim;": "",
      "&lsime;": "",
      "&lsimg;": "",
      "&lsqb;": "[",
      "&lsquo;": "",
      "&lsquor;": "",
      "&lstrok;": "",
      "&lt": "<",
      "&lt;": "<",
      "&ltcc;": "",
      "&ltcir;": "",
      "&ltdot;": "",
      "&lthree;": "",
      "&ltimes;": "",
      "&ltlarr;": "",
      "&ltquest;": "",
      "&ltrPar;": "",
      "&ltri;": "",
      "&ltrie;": "",
      "&ltrif;": "",
      "&lurdshar;": "",
      "&luruhar;": "",
      "&lvertneqq;": "",
      "&lvnE;": "",
      "&mDDot;": "",
      "&macr": "",
      "&macr;": "",
      "&male;": "",
      "&malt;": "",
      "&maltese;": "",
      "&map;": "",
      "&mapsto;": "",
      "&mapstodown;": "",
      "&mapstoleft;": "",
      "&mapstoup;": "",
      "&marker;": "",
      "&mcomma;": "",
      "&mcy;": "",
      "&mdash;": "",
      "&measuredangle;": "",
      "&mfr;": "",
      "&mho;": "",
      "&micro": "",
      "&micro;": "",
      "&mid;": "",
      "&midast;": "*",
      "&midcir;": "",
      "&middot": "",
      "&middot;": "",
      "&minus;": "",
      "&minusb;": "",
      "&minusd;": "",
      "&minusdu;": "",
      "&mlcp;": "",
      "&mldr;": "",
      "&mnplus;": "",
      "&models;": "",
      "&mopf;": "",
      "&mp;": "",
      "&mscr;": "",
      "&mstpos;": "",
      "&mu;": "",
      "&multimap;": "",
      "&mumap;": "",
      "&nGg;": "",
      "&nGt;": "",
      "&nGtv;": "",
      "&nLeftarrow;": "",
      "&nLeftrightarrow;": "",
      "&nLl;": "",
      "&nLt;": "",
      "&nLtv;": "",
      "&nRightarrow;": "",
      "&nVDash;": "",
      "&nVdash;": "",
      "&nabla;": "",
      "&nacute;": "",
      "&nang;": "",
      "&nap;": "",
      "&napE;": "",
      "&napid;": "",
      "&napos;": "",
      "&napprox;": "",
      "&natur;": "",
      "&natural;": "",
      "&naturals;": "",
      "&nbsp": "",
      "&nbsp;": "",
      "&nbump;": "",
      "&nbumpe;": "",
      "&ncap;": "",
      "&ncaron;": "",
      "&ncedil;": "",
      "&ncong;": "",
      "&ncongdot;": "",
      "&ncup;": "",
      "&ncy;": "",
      "&ndash;": "",
      "&ne;": "",
      "&neArr;": "",
      "&nearhk;": "",
      "&nearr;": "",
      "&nearrow;": "",
      "&nedot;": "",
      "&nequiv;": "",
      "&nesear;": "",
      "&nesim;": "",
      "&nexist;": "",
      "&nexists;": "",
      "&nfr;": "",
      "&ngE;": "",
      "&nge;": "",
      "&ngeq;": "",
      "&ngeqq;": "",
      "&ngeqslant;": "",
      "&nges;": "",
      "&ngsim;": "",
      "&ngt;": "",
      "&ngtr;": "",
      "&nhArr;": "",
      "&nharr;": "",
      "&nhpar;": "",
      "&ni;": "",
      "&nis;": "",
      "&nisd;": "",
      "&niv;": "",
      "&njcy;": "",
      "&nlArr;": "",
      "&nlE;": "",
      "&nlarr;": "",
      "&nldr;": "",
      "&nle;": "",
      "&nleftarrow;": "",
      "&nleftrightarrow;": "",
      "&nleq;": "",
      "&nleqq;": "",
      "&nleqslant;": "",
      "&nles;": "",
      "&nless;": "",
      "&nlsim;": "",
      "&nlt;": "",
      "&nltri;": "",
      "&nltrie;": "",
      "&nmid;": "",
      "&nopf;": "",
      "&not": "",
      "&not;": "",
      "&notin;": "",
      "&notinE;": "",
      "&notindot;": "",
      "&notinva;": "",
      "&notinvb;": "",
      "&notinvc;": "",
      "&notni;": "",
      "&notniva;": "",
      "&notnivb;": "",
      "&notnivc;": "",
      "&npar;": "",
      "&nparallel;": "",
      "&nparsl;": "",
      "&npart;": "",
      "&npolint;": "",
      "&npr;": "",
      "&nprcue;": "",
      "&npre;": "",
      "&nprec;": "",
      "&npreceq;": "",
      "&nrArr;": "",
      "&nrarr;": "",
      "&nrarrc;": "",
      "&nrarrw;": "",
      "&nrightarrow;": "",
      "&nrtri;": "",
      "&nrtrie;": "",
      "&nsc;": "",
      "&nsccue;": "",
      "&nsce;": "",
      "&nscr;": "",
      "&nshortmid;": "",
      "&nshortparallel;": "",
      "&nsim;": "",
      "&nsime;": "",
      "&nsimeq;": "",
      "&nsmid;": "",
      "&nspar;": "",
      "&nsqsube;": "",
      "&nsqsupe;": "",
      "&nsub;": "",
      "&nsubE;": "",
      "&nsube;": "",
      "&nsubset;": "",
      "&nsubseteq;": "",
      "&nsubseteqq;": "",
      "&nsucc;": "",
      "&nsucceq;": "",
      "&nsup;": "",
      "&nsupE;": "",
      "&nsupe;": "",
      "&nsupset;": "",
      "&nsupseteq;": "",
      "&nsupseteqq;": "",
      "&ntgl;": "",
      "&ntilde": "",
      "&ntilde;": "",
      "&ntlg;": "",
      "&ntriangleleft;": "",
      "&ntrianglelefteq;": "",
      "&ntriangleright;": "",
      "&ntrianglerighteq;": "",
      "&nu;": "",
      "&num;": "#",
      "&numero;": "",
      "&numsp;": "",
      "&nvDash;": "",
      "&nvHarr;": "",
      "&nvap;": "",
      "&nvdash;": "",
      "&nvge;": "",
      "&nvgt;": ">",
      "&nvinfin;": "",
      "&nvlArr;": "",
      "&nvle;": "",
      "&nvlt;": "<",
      "&nvltrie;": "",
      "&nvrArr;": "",
      "&nvrtrie;": "",
      "&nvsim;": "",
      "&nwArr;": "",
      "&nwarhk;": "",
      "&nwarr;": "",
      "&nwarrow;": "",
      "&nwnear;": "",
      "&oS;": "",
      "&oacute": "",
      "&oacute;": "",
      "&oast;": "",
      "&ocir;": "",
      "&ocirc": "",
      "&ocirc;": "",
      "&ocy;": "",
      "&odash;": "",
      "&odblac;": "",
      "&odiv;": "",
      "&odot;": "",
      "&odsold;": "",
      "&oelig;": "",
      "&ofcir;": "",
      "&ofr;": "",
      "&ogon;": "",
      "&ograve": "",
      "&ograve;": "",
      "&ogt;": "",
      "&ohbar;": "",
      "&ohm;": "",
      "&oint;": "",
      "&olarr;": "",
      "&olcir;": "",
      "&olcross;": "",
      "&oline;": "",
      "&olt;": "",
      "&omacr;": "",
      "&omega;": "",
      "&omicron;": "",
      "&omid;": "",
      "&ominus;": "",
      "&oopf;": "",
      "&opar;": "",
      "&operp;": "",
      "&oplus;": "",
      "&or;": "",
      "&orarr;": "",
      "&ord;": "",
      "&order;": "",
      "&orderof;": "",
      "&ordf": "",
      "&ordf;": "",
      "&ordm": "",
      "&ordm;": "",
      "&origof;": "",
      "&oror;": "",
      "&orslope;": "",
      "&orv;": "",
      "&oscr;": "",
      "&oslash": "",
      "&oslash;": "",
      "&osol;": "",
      "&otilde": "",
      "&otilde;": "",
      "&otimes;": "",
      "&otimesas;": "",
      "&ouml": "",
      "&ouml;": "",
      "&ovbar;": "",
      "&par;": "",
      "&para": "",
      "&para;": "",
      "&parallel;": "",
      "&parsim;": "",
      "&parsl;": "",
      "&part;": "",
      "&pcy;": "",
      "&percnt;": "%",
      "&period;": ".",
      "&permil;": "",
      "&perp;": "",
      "&pertenk;": "",
      "&pfr;": "",
      "&phi;": "",
      "&phiv;": "",
      "&phmmat;": "",
      "&phone;": "",
      "&pi;": "",
      "&pitchfork;": "",
      "&piv;": "",
      "&planck;": "",
      "&planckh;": "",
      "&plankv;": "",
      "&plus;": "+",
      "&plusacir;": "",
      "&plusb;": "",
      "&pluscir;": "",
      "&plusdo;": "",
      "&plusdu;": "",
      "&pluse;": "",
      "&plusmn": "",
      "&plusmn;": "",
      "&plussim;": "",
      "&plustwo;": "",
      "&pm;": "",
      "&pointint;": "",
      "&popf;": "",
      "&pound": "",
      "&pound;": "",
      "&pr;": "",
      "&prE;": "",
      "&prap;": "",
      "&prcue;": "",
      "&pre;": "",
      "&prec;": "",
      "&precapprox;": "",
      "&preccurlyeq;": "",
      "&preceq;": "",
      "&precnapprox;": "",
      "&precneqq;": "",
      "&precnsim;": "",
      "&precsim;": "",
      "&prime;": "",
      "&primes;": "",
      "&prnE;": "",
      "&prnap;": "",
      "&prnsim;": "",
      "&prod;": "",
      "&profalar;": "",
      "&profline;": "",
      "&profsurf;": "",
      "&prop;": "",
      "&propto;": "",
      "&prsim;": "",
      "&prurel;": "",
      "&pscr;": "",
      "&psi;": "",
      "&puncsp;": "",
      "&qfr;": "",
      "&qint;": "",
      "&qopf;": "",
      "&qprime;": "",
      "&qscr;": "",
      "&quaternions;": "",
      "&quatint;": "",
      "&quest;": "?",
      "&questeq;": "",
      "&quot": '"',
      "&quot;": '"',
      "&rAarr;": "",
      "&rArr;": "",
      "&rAtail;": "",
      "&rBarr;": "",
      "&rHar;": "",
      "&race;": "",
      "&racute;": "",
      "&radic;": "",
      "&raemptyv;": "",
      "&rang;": "",
      "&rangd;": "",
      "&range;": "",
      "&rangle;": "",
      "&raquo": "",
      "&raquo;": "",
      "&rarr;": "",
      "&rarrap;": "",
      "&rarrb;": "",
      "&rarrbfs;": "",
      "&rarrc;": "",
      "&rarrfs;": "",
      "&rarrhk;": "",
      "&rarrlp;": "",
      "&rarrpl;": "",
      "&rarrsim;": "",
      "&rarrtl;": "",
      "&rarrw;": "",
      "&ratail;": "",
      "&ratio;": "",
      "&rationals;": "",
      "&rbarr;": "",
      "&rbbrk;": "",
      "&rbrace;": "}",
      "&rbrack;": "]",
      "&rbrke;": "",
      "&rbrksld;": "",
      "&rbrkslu;": "",
      "&rcaron;": "",
      "&rcedil;": "",
      "&rceil;": "",
      "&rcub;": "}",
      "&rcy;": "",
      "&rdca;": "",
      "&rdldhar;": "",
      "&rdquo;": "",
      "&rdquor;": "",
      "&rdsh;": "",
      "&real;": "",
      "&realine;": "",
      "&realpart;": "",
      "&reals;": "",
      "&rect;": "",
      "&reg": "",
      "&reg;": "",
      "&rfisht;": "",
      "&rfloor;": "",
      "&rfr;": "",
      "&rhard;": "",
      "&rharu;": "",
      "&rharul;": "",
      "&rho;": "",
      "&rhov;": "",
      "&rightarrow;": "",
      "&rightarrowtail;": "",
      "&rightharpoondown;": "",
      "&rightharpoonup;": "",
      "&rightleftarrows;": "",
      "&rightleftharpoons;": "",
      "&rightrightarrows;": "",
      "&rightsquigarrow;": "",
      "&rightthreetimes;": "",
      "&ring;": "",
      "&risingdotseq;": "",
      "&rlarr;": "",
      "&rlhar;": "",
      "&rlm;": "",
      "&rmoust;": "",
      "&rmoustache;": "",
      "&rnmid;": "",
      "&roang;": "",
      "&roarr;": "",
      "&robrk;": "",
      "&ropar;": "",
      "&ropf;": "",
      "&roplus;": "",
      "&rotimes;": "",
      "&rpar;": ")",
      "&rpargt;": "",
      "&rppolint;": "",
      "&rrarr;": "",
      "&rsaquo;": "",
      "&rscr;": "",
      "&rsh;": "",
      "&rsqb;": "]",
      "&rsquo;": "",
      "&rsquor;": "",
      "&rthree;": "",
      "&rtimes;": "",
      "&rtri;": "",
      "&rtrie;": "",
      "&rtrif;": "",
      "&rtriltri;": "",
      "&ruluhar;": "",
      "&rx;": "",
      "&sacute;": "",
      "&sbquo;": "",
      "&sc;": "",
      "&scE;": "",
      "&scap;": "",
      "&scaron;": "",
      "&sccue;": "",
      "&sce;": "",
      "&scedil;": "",
      "&scirc;": "",
      "&scnE;": "",
      "&scnap;": "",
      "&scnsim;": "",
      "&scpolint;": "",
      "&scsim;": "",
      "&scy;": "",
      "&sdot;": "",
      "&sdotb;": "",
      "&sdote;": "",
      "&seArr;": "",
      "&searhk;": "",
      "&searr;": "",
      "&searrow;": "",
      "&sect": "",
      "&sect;": "",
      "&semi;": ";",
      "&seswar;": "",
      "&setminus;": "",
      "&setmn;": "",
      "&sext;": "",
      "&sfr;": "",
      "&sfrown;": "",
      "&sharp;": "",
      "&shchcy;": "",
      "&shcy;": "",
      "&shortmid;": "",
      "&shortparallel;": "",
      "&shy": "",
      "&shy;": "",
      "&sigma;": "",
      "&sigmaf;": "",
      "&sigmav;": "",
      "&sim;": "",
      "&simdot;": "",
      "&sime;": "",
      "&simeq;": "",
      "&simg;": "",
      "&simgE;": "",
      "&siml;": "",
      "&simlE;": "",
      "&simne;": "",
      "&simplus;": "",
      "&simrarr;": "",
      "&slarr;": "",
      "&smallsetminus;": "",
      "&smashp;": "",
      "&smeparsl;": "",
      "&smid;": "",
      "&smile;": "",
      "&smt;": "",
      "&smte;": "",
      "&smtes;": "",
      "&softcy;": "",
      "&sol;": "/",
      "&solb;": "",
      "&solbar;": "",
      "&sopf;": "",
      "&spades;": "",
      "&spadesuit;": "",
      "&spar;": "",
      "&sqcap;": "",
      "&sqcaps;": "",
      "&sqcup;": "",
      "&sqcups;": "",
      "&sqsub;": "",
      "&sqsube;": "",
      "&sqsubset;": "",
      "&sqsubseteq;": "",
      "&sqsup;": "",
      "&sqsupe;": "",
      "&sqsupset;": "",
      "&sqsupseteq;": "",
      "&squ;": "",
      "&square;": "",
      "&squarf;": "",
      "&squf;": "",
      "&srarr;": "",
      "&sscr;": "",
      "&ssetmn;": "",
      "&ssmile;": "",
      "&sstarf;": "",
      "&star;": "",
      "&starf;": "",
      "&straightepsilon;": "",
      "&straightphi;": "",
      "&strns;": "",
      "&sub;": "",
      "&subE;": "",
      "&subdot;": "",
      "&sube;": "",
      "&subedot;": "",
      "&submult;": "",
      "&subnE;": "",
      "&subne;": "",
      "&subplus;": "",
      "&subrarr;": "",
      "&subset;": "",
      "&subseteq;": "",
      "&subseteqq;": "",
      "&subsetneq;": "",
      "&subsetneqq;": "",
      "&subsim;": "",
      "&subsub;": "",
      "&subsup;": "",
      "&succ;": "",
      "&succapprox;": "",
      "&succcurlyeq;": "",
      "&succeq;": "",
      "&succnapprox;": "",
      "&succneqq;": "",
      "&succnsim;": "",
      "&succsim;": "",
      "&sum;": "",
      "&sung;": "",
      "&sup1": "",
      "&sup1;": "",
      "&sup2": "",
      "&sup2;": "",
      "&sup3": "",
      "&sup3;": "",
      "&sup;": "",
      "&supE;": "",
      "&supdot;": "",
      "&supdsub;": "",
      "&supe;": "",
      "&supedot;": "",
      "&suphsol;": "",
      "&suphsub;": "",
      "&suplarr;": "",
      "&supmult;": "",
      "&supnE;": "",
      "&supne;": "",
      "&supplus;": "",
      "&supset;": "",
      "&supseteq;": "",
      "&supseteqq;": "",
      "&supsetneq;": "",
      "&supsetneqq;": "",
      "&supsim;": "",
      "&supsub;": "",
      "&supsup;": "",
      "&swArr;": "",
      "&swarhk;": "",
      "&swarr;": "",
      "&swarrow;": "",
      "&swnwar;": "",
      "&szlig": "",
      "&szlig;": "",
      "&target;": "",
      "&tau;": "",
      "&tbrk;": "",
      "&tcaron;": "",
      "&tcedil;": "",
      "&tcy;": "",
      "&tdot;": "",
      "&telrec;": "",
      "&tfr;": "",
      "&there4;": "",
      "&therefore;": "",
      "&theta;": "",
      "&thetasym;": "",
      "&thetav;": "",
      "&thickapprox;": "",
      "&thicksim;": "",
      "&thinsp;": "",
      "&thkap;": "",
      "&thksim;": "",
      "&thorn": "",
      "&thorn;": "",
      "&tilde;": "",
      "&times": "",
      "&times;": "",
      "&timesb;": "",
      "&timesbar;": "",
      "&timesd;": "",
      "&tint;": "",
      "&toea;": "",
      "&top;": "",
      "&topbot;": "",
      "&topcir;": "",
      "&topf;": "",
      "&topfork;": "",
      "&tosa;": "",
      "&tprime;": "",
      "&trade;": "",
      "&triangle;": "",
      "&triangledown;": "",
      "&triangleleft;": "",
      "&trianglelefteq;": "",
      "&triangleq;": "",
      "&triangleright;": "",
      "&trianglerighteq;": "",
      "&tridot;": "",
      "&trie;": "",
      "&triminus;": "",
      "&triplus;": "",
      "&trisb;": "",
      "&tritime;": "",
      "&trpezium;": "",
      "&tscr;": "",
      "&tscy;": "",
      "&tshcy;": "",
      "&tstrok;": "",
      "&twixt;": "",
      "&twoheadleftarrow;": "",
      "&twoheadrightarrow;": "",
      "&uArr;": "",
      "&uHar;": "",
      "&uacute": "",
      "&uacute;": "",
      "&uarr;": "",
      "&ubrcy;": "",
      "&ubreve;": "",
      "&ucirc": "",
      "&ucirc;": "",
      "&ucy;": "",
      "&udarr;": "",
      "&udblac;": "",
      "&udhar;": "",
      "&ufisht;": "",
      "&ufr;": "",
      "&ugrave": "",
      "&ugrave;": "",
      "&uharl;": "",
      "&uharr;": "",
      "&uhblk;": "",
      "&ulcorn;": "",
      "&ulcorner;": "",
      "&ulcrop;": "",
      "&ultri;": "",
      "&umacr;": "",
      "&uml": "",
      "&uml;": "",
      "&uogon;": "",
      "&uopf;": "",
      "&uparrow;": "",
      "&updownarrow;": "",
      "&upharpoonleft;": "",
      "&upharpoonright;": "",
      "&uplus;": "",
      "&upsi;": "",
      "&upsih;": "",
      "&upsilon;": "",
      "&upuparrows;": "",
      "&urcorn;": "",
      "&urcorner;": "",
      "&urcrop;": "",
      "&uring;": "",
      "&urtri;": "",
      "&uscr;": "",
      "&utdot;": "",
      "&utilde;": "",
      "&utri;": "",
      "&utrif;": "",
      "&uuarr;": "",
      "&uuml": "",
      "&uuml;": "",
      "&uwangle;": "",
      "&vArr;": "",
      "&vBar;": "",
      "&vBarv;": "",
      "&vDash;": "",
      "&vangrt;": "",
      "&varepsilon;": "",
      "&varkappa;": "",
      "&varnothing;": "",
      "&varphi;": "",
      "&varpi;": "",
      "&varpropto;": "",
      "&varr;": "",
      "&varrho;": "",
      "&varsigma;": "",
      "&varsubsetneq;": "",
      "&varsubsetneqq;": "",
      "&varsupsetneq;": "",
      "&varsupsetneqq;": "",
      "&vartheta;": "",
      "&vartriangleleft;": "",
      "&vartriangleright;": "",
      "&vcy;": "",
      "&vdash;": "",
      "&vee;": "",
      "&veebar;": "",
      "&veeeq;": "",
      "&vellip;": "",
      "&verbar;": "|",
      "&vert;": "|",
      "&vfr;": "",
      "&vltri;": "",
      "&vnsub;": "",
      "&vnsup;": "",
      "&vopf;": "",
      "&vprop;": "",
      "&vrtri;": "",
      "&vscr;": "",
      "&vsubnE;": "",
      "&vsubne;": "",
      "&vsupnE;": "",
      "&vsupne;": "",
      "&vzigzag;": "",
      "&wcirc;": "",
      "&wedbar;": "",
      "&wedge;": "",
      "&wedgeq;": "",
      "&weierp;": "",
      "&wfr;": "",
      "&wopf;": "",
      "&wp;": "",
      "&wr;": "",
      "&wreath;": "",
      "&wscr;": "",
      "&xcap;": "",
      "&xcirc;": "",
      "&xcup;": "",
      "&xdtri;": "",
      "&xfr;": "",
      "&xhArr;": "",
      "&xharr;": "",
      "&xi;": "",
      "&xlArr;": "",
      "&xlarr;": "",
      "&xmap;": "",
      "&xnis;": "",
      "&xodot;": "",
      "&xopf;": "",
      "&xoplus;": "",
      "&xotime;": "",
      "&xrArr;": "",
      "&xrarr;": "",
      "&xscr;": "",
      "&xsqcup;": "",
      "&xuplus;": "",
      "&xutri;": "",
      "&xvee;": "",
      "&xwedge;": "",
      "&yacute": "",
      "&yacute;": "",
      "&yacy;": "",
      "&ycirc;": "",
      "&ycy;": "",
      "&yen": "",
      "&yen;": "",
      "&yfr;": "",
      "&yicy;": "",
      "&yopf;": "",
      "&yscr;": "",
      "&yucy;": "",
      "&yuml": "",
      "&yuml;": "",
      "&zacute;": "",
      "&zcaron;": "",
      "&zcy;": "",
      "&zdot;": "",
      "&zeetrf;": "",
      "&zeta;": "",
      "&zfr;": "",
      "&zhcy;": "",
      "&zigrarr;": "",
      "&zopf;": "",
      "&zscr;": "",
      "&zwj;": "",
      "&zwnj;": ""
    },
    characters: {
      "": "&AElig;",
      "&": "&amp;",
      "": "&Aacute;",
      "": "&Abreve;",
      "": "&Acirc;",
      "": "&Acy;",
      "": "&Afr;",
      "": "&Agrave;",
      "": "&Alpha;",
      "": "&Amacr;",
      "": "&And;",
      "": "&Aogon;",
      "": "&Aopf;",
      "": "&af;",
      "": "&angst;",
      "": "&Ascr;",
      "": "&coloneq;",
      "": "&Atilde;",
      "": "&Auml;",
      "": "&ssetmn;",
      "": "&Barv;",
      "": "&doublebarwedge;",
      "": "&Bcy;",
      "": "&because;",
      "": "&bernou;",
      "": "&Beta;",
      "": "&Bfr;",
      "": "&Bopf;",
      "": "&breve;",
      "": "&bump;",
      "": "&CHcy;",
      "": "&copy;",
      "": "&Cacute;",
      "": "&Cap;",
      "": "&DD;",
      "": "&Cfr;",
      "": "&Ccaron;",
      "": "&Ccedil;",
      "": "&Ccirc;",
      "": "&Cconint;",
      "": "&Cdot;",
      "": "&cedil;",
      "": "&middot;",
      "": "&Chi;",
      "": "&odot;",
      "": "&ominus;",
      "": "&oplus;",
      "": "&otimes;",
      "": "&cwconint;",
      "": "&rdquor;",
      "": "&rsquor;",
      "": "&Proportion;",
      "": "&Colone;",
      "": "&equiv;",
      "": "&DoubleContourIntegral;",
      "": "&oint;",
      "": "&complexes;",
      "": "&coprod;",
      "": "&awconint;",
      "": "&Cross;",
      "": "&Cscr;",
      "": "&Cup;",
      "": "&asympeq;",
      "": "&DDotrahd;",
      "": "&DJcy;",
      "": "&DScy;",
      "": "&DZcy;",
      "": "&ddagger;",
      "": "&Darr;",
      "": "&DoubleLeftTee;",
      "": "&Dcaron;",
      "": "&Dcy;",
      "": "&nabla;",
      "": "&Delta;",
      "": "&Dfr;",
      "": "&acute;",
      "": "&dot;",
      "": "&dblac;",
      "`": "&grave;",
      "": "&tilde;",
      "": "&diamond;",
      "": "&dd;",
      "": "&Dopf;",
      "": "&uml;",
      "": "&DotDot;",
      "": "&esdot;",
      "": "&dArr;",
      "": "&lArr;",
      "": "&iff;",
      "": "&xlArr;",
      "": "&xhArr;",
      "": "&xrArr;",
      "": "&rArr;",
      "": "&vDash;",
      "": "&uArr;",
      "": "&vArr;",
      "": "&spar;",
      "": "&downarrow;",
      "": "&DownArrowBar;",
      "": "&duarr;",
      "": "&DownBreve;",
      "": "&DownLeftRightVector;",
      "": "&DownLeftTeeVector;",
      "": "&lhard;",
      "": "&DownLeftVectorBar;",
      "": "&DownRightTeeVector;",
      "": "&rightharpoondown;",
      "": "&DownRightVectorBar;",
      "": "&top;",
      "": "&mapstodown;",
      "": "&Dscr;",
      "": "&Dstrok;",
      "": "&ENG;",
      "": "&ETH;",
      "": "&Eacute;",
      "": "&Ecaron;",
      "": "&Ecirc;",
      "": "&Ecy;",
      "": "&Edot;",
      "": "&Efr;",
      "": "&Egrave;",
      "": "&isinv;",
      "": "&Emacr;",
      "": "&EmptySmallSquare;",
      "": "&EmptyVerySmallSquare;",
      "": "&Eogon;",
      "": "&Eopf;",
      "": "&Epsilon;",
      "": "&Equal;",
      "": "&esim;",
      "": "&rlhar;",
      "": "&expectation;",
      "": "&Esim;",
      "": "&Eta;",
      "": "&Euml;",
      "": "&exist;",
      "": "&exponentiale;",
      "": "&Fcy;",
      "": "&Ffr;",
      "": "&FilledSmallSquare;",
      "": "&squf;",
      "": "&Fopf;",
      "": "&forall;",
      "": "&Fscr;",
      "": "&GJcy;",
      ">": "&gt;",
      "": "&Gamma;",
      "": "&Gammad;",
      "": "&Gbreve;",
      "": "&Gcedil;",
      "": "&Gcirc;",
      "": "&Gcy;",
      "": "&Gdot;",
      "": "&Gfr;",
      "": "&ggg;",
      "": "&Gopf;",
      "": "&geq;",
      "": "&gtreqless;",
      "": "&geqq;",
      "": "&GreaterGreater;",
      "": "&gtrless;",
      "": "&ges;",
      "": "&gtrsim;",
      "": "&Gscr;",
      "": "&gg;",
      "": "&HARDcy;",
      "": "&caron;",
      "^": "&Hat;",
      "": "&Hcirc;",
      "": "&Poincareplane;",
      "": "&hamilt;",
      "": "&quaternions;",
      "": "&boxh;",
      "": "&Hstrok;",
      "": "&bumpeq;",
      "": "&IEcy;",
      "": "&IJlig;",
      "": "&IOcy;",
      "": "&Iacute;",
      "": "&Icirc;",
      "": "&Icy;",
      "": "&Idot;",
      "": "&imagpart;",
      "": "&Igrave;",
      "": "&Imacr;",
      "": "&ii;",
      "": "&Int;",
      "": "&int;",
      "": "&xcap;",
      "": "&ic;",
      "": "&it;",
      "": "&Iogon;",
      "": "&Iopf;",
      "": "&Iota;",
      "": "&imagline;",
      "": "&Itilde;",
      "": "&Iukcy;",
      "": "&Iuml;",
      "": "&Jcirc;",
      "": "&Jcy;",
      "": "&Jfr;",
      "": "&Jopf;",
      "": "&Jscr;",
      "": "&Jsercy;",
      "": "&Jukcy;",
      "": "&KHcy;",
      "": "&KJcy;",
      "": "&Kappa;",
      "": "&Kcedil;",
      "": "&Kcy;",
      "": "&Kfr;",
      "": "&Kopf;",
      "": "&Kscr;",
      "": "&LJcy;",
      "<": "&lt;",
      "": "&Lacute;",
      "": "&Lambda;",
      "": "&Lang;",
      "": "&lagran;",
      "": "&twoheadleftarrow;",
      "": "&Lcaron;",
      "": "&Lcedil;",
      "": "&Lcy;",
      "": "&langle;",
      "": "&slarr;",
      "": "&larrb;",
      "": "&lrarr;",
      "": "&lceil;",
      "": "&lobrk;",
      "": "&LeftDownTeeVector;",
      "": "&downharpoonleft;",
      "": "&LeftDownVectorBar;",
      "": "&lfloor;",
      "": "&leftrightarrow;",
      "": "&LeftRightVector;",
      "": "&dashv;",
      "": "&mapstoleft;",
      "": "&LeftTeeVector;",
      "": "&vltri;",
      "": "&LeftTriangleBar;",
      "": "&trianglelefteq;",
      "": "&LeftUpDownVector;",
      "": "&LeftUpTeeVector;",
      "": "&upharpoonleft;",
      "": "&LeftUpVectorBar;",
      "": "&lharu;",
      "": "&LeftVectorBar;",
      "": "&lesseqgtr;",
      "": "&leqq;",
      "": "&lg;",
      "": "&LessLess;",
      "": "&les;",
      "": "&lsim;",
      "": "&Lfr;",
      "": "&Ll;",
      "": "&lAarr;",
      "": "&Lmidot;",
      "": "&xlarr;",
      "": "&xharr;",
      "": "&xrarr;",
      "": "&Lopf;",
      "": "&swarrow;",
      "": "&searrow;",
      "": "&lsh;",
      "": "&Lstrok;",
      "": "&ll;",
      "": "&Map;",
      "": "&Mcy;",
      "": "&MediumSpace;",
      "": "&phmmat;",
      "": "&Mfr;",
      "": "&mp;",
      "": "&Mopf;",
      "": "&Mu;",
      "": "&NJcy;",
      "": "&Nacute;",
      "": "&Ncaron;",
      "": "&Ncedil;",
      "": "&Ncy;",
      "": "&ZeroWidthSpace;",
      "\n": "&NewLine;",
      "": "&Nfr;",
      "": "&NoBreak;",
      "": "&nbsp;",
      "": "&naturals;",
      "": "&Not;",
      "": "&nequiv;",
      "": "&NotCupCap;",
      "": "&nspar;",
      "": "&notinva;",
      "": "&ne;",
      "": "&nesim;",
      "": "&nexists;",
      "": "&ngtr;",
      "": "&ngeq;",
      "": "&ngeqq;",
      "": "&nGtv;",
      "": "&ntgl;",
      "": "&nges;",
      "": "&ngsim;",
      "": "&nbump;",
      "": "&nbumpe;",
      "": "&ntriangleleft;",
      "": "&NotLeftTriangleBar;",
      "": "&ntrianglelefteq;",
      "": "&nlt;",
      "": "&nleq;",
      "": "&ntlg;",
      "": "&nLtv;",
      "": "&nles;",
      "": "&nlsim;",
      "": "&NotNestedGreaterGreater;",
      "": "&NotNestedLessLess;",
      "": "&nprec;",
      "": "&npreceq;",
      "": "&nprcue;",
      "": "&notniva;",
      "": "&ntriangleright;",
      "": "&NotRightTriangleBar;",
      "": "&ntrianglerighteq;",
      "": "&NotSquareSubset;",
      "": "&nsqsube;",
      "": "&NotSquareSuperset;",
      "": "&nsqsupe;",
      "": "&vnsub;",
      "": "&nsubseteq;",
      "": "&nsucc;",
      "": "&nsucceq;",
      "": "&nsccue;",
      "": "&NotSucceedsTilde;",
      "": "&vnsup;",
      "": "&nsupseteq;",
      "": "&nsim;",
      "": "&nsimeq;",
      "": "&ncong;",
      "": "&napprox;",
      "": "&nsmid;",
      "": "&Nscr;",
      "": "&Ntilde;",
      "": "&Nu;",
      "": "&OElig;",
      "": "&Oacute;",
      "": "&Ocirc;",
      "": "&Ocy;",
      "": "&Odblac;",
      "": "&Ofr;",
      "": "&Ograve;",
      "": "&Omacr;",
      "": "&ohm;",
      "": "&Omicron;",
      "": "&Oopf;",
      "": "&ldquo;",
      "": "&lsquo;",
      "": "&Or;",
      "": "&Oscr;",
      "": "&Oslash;",
      "": "&Otilde;",
      "": "&Otimes;",
      "": "&Ouml;",
      "": "&oline;",
      "": "&OverBrace;",
      "": "&tbrk;",
      "": "&OverParenthesis;",
      "": "&part;",
      "": "&Pcy;",
      "": "&Pfr;",
      "": "&Phi;",
      "": "&Pi;",
      "": "&pm;",
      "": "&primes;",
      "": "&Pr;",
      "": "&prec;",
      "": "&preceq;",
      "": "&preccurlyeq;",
      "": "&prsim;",
      "": "&Prime;",
      "": "&prod;",
      "": "&vprop;",
      "": "&Pscr;",
      "": "&Psi;",
      '"': "&quot;",
      "": "&Qfr;",
      "": "&rationals;",
      "": "&Qscr;",
      "": "&drbkarow;",
      "": "&reg;",
      "": "&Racute;",
      "": "&Rang;",
      "": "&twoheadrightarrow;",
      "": "&Rarrtl;",
      "": "&Rcaron;",
      "": "&Rcedil;",
      "": "&Rcy;",
      "": "&realpart;",
      "": "&niv;",
      "": "&lrhar;",
      "": "&duhar;",
      "": "&Rho;",
      "": "&rangle;",
      "": "&srarr;",
      "": "&rarrb;",
      "": "&rlarr;",
      "": "&rceil;",
      "": "&robrk;",
      "": "&RightDownTeeVector;",
      "": "&downharpoonright;",
      "": "&RightDownVectorBar;",
      "": "&rfloor;",
      "": "&vdash;",
      "": "&mapsto;",
      "": "&RightTeeVector;",
      "": "&vrtri;",
      "": "&RightTriangleBar;",
      "": "&trianglerighteq;",
      "": "&RightUpDownVector;",
      "": "&RightUpTeeVector;",
      "": "&upharpoonright;",
      "": "&RightUpVectorBar;",
      "": "&rightharpoonup;",
      "": "&RightVectorBar;",
      "": "&reals;",
      "": "&RoundImplies;",
      "": "&rAarr;",
      "": "&realine;",
      "": "&rsh;",
      "": "&RuleDelayed;",
      "": "&SHCHcy;",
      "": "&SHcy;",
      "": "&SOFTcy;",
      "": "&Sacute;",
      "": "&Sc;",
      "": "&Scaron;",
      "": "&Scedil;",
      "": "&Scirc;",
      "": "&Scy;",
      "": "&Sfr;",
      "": "&uparrow;",
      "": "&Sigma;",
      "": "&compfn;",
      "": "&Sopf;",
      "": "&radic;",
      "": "&square;",
      "": "&sqcap;",
      "": "&sqsubset;",
      "": "&sqsubseteq;",
      "": "&sqsupset;",
      "": "&sqsupseteq;",
      "": "&sqcup;",
      "": "&Sscr;",
      "": "&sstarf;",
      "": "&Subset;",
      "": "&subseteq;",
      "": "&succ;",
      "": "&succeq;",
      "": "&succcurlyeq;",
      "": "&succsim;",
      "": "&sum;",
      "": "&Supset;",
      "": "&supset;",
      "": "&supseteq;",
      "": "&THORN;",
      "": "&trade;",
      "": "&TSHcy;",
      "": "&TScy;",
      "\t": "&Tab;",
      "": "&Tau;",
      "": "&Tcaron;",
      "": "&Tcedil;",
      "": "&Tcy;",
      "": "&Tfr;",
      "": "&therefore;",
      "": "&Theta;",
      "": "&ThickSpace;",
      "": "&thinsp;",
      "": "&thksim;",
      "": "&simeq;",
      "": "&cong;",
      "": "&thkap;",
      "": "&Topf;",
      "": "&tdot;",
      "": "&Tscr;",
      "": "&Tstrok;",
      "": "&Uacute;",
      "": "&Uarr;",
      "": "&Uarrocir;",
      "": "&Ubrcy;",
      "": "&Ubreve;",
      "": "&Ucirc;",
      "": "&Ucy;",
      "": "&Udblac;",
      "": "&Ufr;",
      "": "&Ugrave;",
      "": "&Umacr;",
      _: "&lowbar;",
      "": "&UnderBrace;",
      "": "&bbrk;",
      "": "&UnderParenthesis;",
      "": "&xcup;",
      "": "&uplus;",
      "": "&Uogon;",
      "": "&Uopf;",
      "": "&UpArrowBar;",
      "": "&udarr;",
      "": "&varr;",
      "": "&udhar;",
      "": "&perp;",
      "": "&mapstoup;",
      "": "&nwarrow;",
      "": "&nearrow;",
      "": "&upsih;",
      "": "&Upsilon;",
      "": "&Uring;",
      "": "&Uscr;",
      "": "&Utilde;",
      "": "&Uuml;",
      "": "&VDash;",
      "": "&Vbar;",
      "": "&Vcy;",
      "": "&Vdash;",
      "": "&Vdashl;",
      "": "&xvee;",
      "": "&Vert;",
      "": "&smid;",
      "|": "&vert;",
      "": "&VerticalSeparator;",
      "": "&wreath;",
      "": "&hairsp;",
      "": "&Vfr;",
      "": "&Vopf;",
      "": "&Vscr;",
      "": "&Vvdash;",
      "": "&Wcirc;",
      "": "&xwedge;",
      "": "&Wfr;",
      "": "&Wopf;",
      "": "&Wscr;",
      "": "&Xfr;",
      "": "&Xi;",
      "": "&Xopf;",
      "": "&Xscr;",
      "": "&YAcy;",
      "": "&YIcy;",
      "": "&YUcy;",
      "": "&Yacute;",
      "": "&Ycirc;",
      "": "&Ycy;",
      "": "&Yfr;",
      "": "&Yopf;",
      "": "&Yscr;",
      "": "&Yuml;",
      "": "&ZHcy;",
      "": "&Zacute;",
      "": "&Zcaron;",
      "": "&Zcy;",
      "": "&Zdot;",
      "": "&Zeta;",
      "": "&zeetrf;",
      "": "&integers;",
      "": "&Zscr;",
      "": "&aacute;",
      "": "&abreve;",
      "": "&mstpos;",
      "": "&acE;",
      "": "&acd;",
      "": "&acirc;",
      "": "&acy;",
      "": "&aelig;",
      "": "&afr;",
      "": "&agrave;",
      "": "&aleph;",
      "": "&alpha;",
      "": "&amacr;",
      "": "&amalg;",
      "": "&wedge;",
      "": "&andand;",
      "": "&andd;",
      "": "&andslope;",
      "": "&andv;",
      "": "&angle;",
      "": "&ange;",
      "": "&measuredangle;",
      "": "&angmsdaa;",
      "": "&angmsdab;",
      "": "&angmsdac;",
      "": "&angmsdad;",
      "": "&angmsdae;",
      "": "&angmsdaf;",
      "": "&angmsdag;",
      "": "&angmsdah;",
      "": "&angrt;",
      "": "&angrtvb;",
      "": "&angrtvbd;",
      "": "&angsph;",
      "": "&angzarr;",
      "": "&aogon;",
      "": "&aopf;",
      "": "&apE;",
      "": "&apacir;",
      "": "&approxeq;",
      "": "&apid;",
      "'": "&apos;",
      "": "&aring;",
      "": "&ascr;",
      "*": "&midast;",
      "": "&atilde;",
      "": "&auml;",
      "": "&awint;",
      "": "&bNot;",
      "": "&bcong;",
      "": "&bepsi;",
      "": "&bprime;",
      "": "&bsim;",
      "": "&bsime;",
      "": "&barvee;",
      "": "&barwedge;",
      "": "&bbrktbrk;",
      "": "&bcy;",
      "": "&ldquor;",
      "": "&bemptyv;",
      "": "&beta;",
      "": "&beth;",
      "": "&twixt;",
      "": "&bfr;",
      "": "&xcirc;",
      "": "&xodot;",
      "": "&xoplus;",
      "": "&xotime;",
      "": "&xsqcup;",
      "": "&starf;",
      "": "&xdtri;",
      "": "&xutri;",
      "": "&xuplus;",
      "": "&rbarr;",
      "": "&lozf;",
      "": "&utrif;",
      "": "&dtrif;",
      "": "&ltrif;",
      "": "&rtrif;",
      "": "&blank;",
      "": "&blk12;",
      "": "&blk14;",
      "": "&blk34;",
      "": "&block;",
      "=": "&bne;",
      "": "&bnequiv;",
      "": "&bnot;",
      "": "&bopf;",
      "": "&bowtie;",
      "": "&boxDL;",
      "": "&boxDR;",
      "": "&boxDl;",
      "": "&boxDr;",
      "": "&boxH;",
      "": "&boxHD;",
      "": "&boxHU;",
      "": "&boxHd;",
      "": "&boxHu;",
      "": "&boxUL;",
      "": "&boxUR;",
      "": "&boxUl;",
      "": "&boxUr;",
      "": "&boxV;",
      "": "&boxVH;",
      "": "&boxVL;",
      "": "&boxVR;",
      "": "&boxVh;",
      "": "&boxVl;",
      "": "&boxVr;",
      "": "&boxbox;",
      "": "&boxdL;",
      "": "&boxdR;",
      "": "&boxdl;",
      "": "&boxdr;",
      "": "&boxhD;",
      "": "&boxhU;",
      "": "&boxhd;",
      "": "&boxhu;",
      "": "&minusb;",
      "": "&plusb;",
      "": "&timesb;",
      "": "&boxuL;",
      "": "&boxuR;",
      "": "&boxul;",
      "": "&boxur;",
      "": "&boxv;",
      "": "&boxvH;",
      "": "&boxvL;",
      "": "&boxvR;",
      "": "&boxvh;",
      "": "&boxvl;",
      "": "&boxvr;",
      "": "&brvbar;",
      "": "&bscr;",
      "": "&bsemi;",
      "\\": "&bsol;",
      "": "&bsolb;",
      "": "&bsolhsub;",
      "": "&bullet;",
      "": "&bumpE;",
      "": "&cacute;",
      "": "&cap;",
      "": "&capand;",
      "": "&capbrcup;",
      "": "&capcap;",
      "": "&capcup;",
      "": "&capdot;",
      "": "&caps;",
      "": "&caret;",
      "": "&ccaps;",
      "": "&ccaron;",
      "": "&ccedil;",
      "": "&ccirc;",
      "": "&ccups;",
      "": "&ccupssm;",
      "": "&cdot;",
      "": "&cemptyv;",
      "": "&cent;",
      "": "&cfr;",
      "": "&chcy;",
      "": "&checkmark;",
      "": "&chi;",
      "": "&cir;",
      "": "&cirE;",
      "": "&circ;",
      "": "&cire;",
      "": "&olarr;",
      "": "&orarr;",
      "": "&oS;",
      "": "&oast;",
      "": "&ocir;",
      "": "&odash;",
      "": "&cirfnint;",
      "": "&cirmid;",
      "": "&cirscir;",
      "": "&clubsuit;",
      ":": "&colon;",
      ",": "&comma;",
      "@": "&commat;",
      "": "&complement;",
      "": "&congdot;",
      "": "&copf;",
      "": "&copysr;",
      "": "&crarr;",
      "": "&cross;",
      "": "&cscr;",
      "": "&csub;",
      "": "&csube;",
      "": "&csup;",
      "": "&csupe;",
      "": "&ctdot;",
      "": "&cudarrl;",
      "": "&cudarrr;",
      "": "&curlyeqprec;",
      "": "&curlyeqsucc;",
      "": "&curvearrowleft;",
      "": "&cularrp;",
      "": "&cup;",
      "": "&cupbrcap;",
      "": "&cupcap;",
      "": "&cupcup;",
      "": "&cupdot;",
      "": "&cupor;",
      "": "&cups;",
      "": "&curvearrowright;",
      "": "&curarrm;",
      "": "&cuvee;",
      "": "&cuwed;",
      "": "&curren;",
      "": "&cwint;",
      "": "&cylcty;",
      "": "&dHar;",
      "": "&dagger;",
      "": "&daleth;",
      "": "&hyphen;",
      "": "&rBarr;",
      "": "&dcaron;",
      "": "&dcy;",
      "": "&downdownarrows;",
      "": "&eDDot;",
      "": "&deg;",
      "": "&delta;",
      "": "&demptyv;",
      "": "&dfisht;",
      "": "&dfr;",
      "": "&diams;",
      "": "&gammad;",
      "": "&disin;",
      "": "&divide;",
      "": "&divonx;",
      "": "&djcy;",
      "": "&llcorner;",
      "": "&dlcrop;",
      $: "&dollar;",
      "": "&dopf;",
      "": "&eDot;",
      "": "&minusd;",
      "": "&plusdo;",
      "": "&sdotb;",
      "": "&lrcorner;",
      "": "&drcrop;",
      "": "&dscr;",
      "": "&dscy;",
      "": "&dsol;",
      "": "&dstrok;",
      "": "&dtdot;",
      "": "&triangledown;",
      "": "&dwangle;",
      "": "&dzcy;",
      "": "&dzigrarr;",
      "": "&eacute;",
      "": "&easter;",
      "": "&ecaron;",
      "": "&eqcirc;",
      "": "&ecirc;",
      "": "&eqcolon;",
      "": "&ecy;",
      "": "&edot;",
      "": "&fallingdotseq;",
      "": "&efr;",
      "": "&eg;",
      "": "&egrave;",
      "": "&eqslantgtr;",
      "": "&egsdot;",
      "": "&el;",
      "": "&elinters;",
      "": "&ell;",
      "": "&eqslantless;",
      "": "&elsdot;",
      "": "&emacr;",
      "": "&varnothing;",
      "": "&emsp13;",
      "": "&emsp14;",
      "": "&emsp;",
      "": "&eng;",
      "": "&ensp;",
      "": "&eogon;",
      "": "&eopf;",
      "": "&epar;",
      "": "&eparsl;",
      "": "&eplus;",
      "": "&epsilon;",
      "": "&varepsilon;",
      "=": "&equals;",
      "": "&questeq;",
      "": "&equivDD;",
      "": "&eqvparsl;",
      "": "&risingdotseq;",
      "": "&erarr;",
      "": "&escr;",
      "": "&eta;",
      "": "&eth;",
      "": "&euml;",
      "": "&euro;",
      "!": "&excl;",
      "": "&fcy;",
      "": "&female;",
      "": "&ffilig;",
      "": "&fflig;",
      "": "&ffllig;",
      "": "&ffr;",
      "": "&filig;",
      fj: "&fjlig;",
      "": "&flat;",
      "": "&fllig;",
      "": "&fltns;",
      "": "&fnof;",
      "": "&fopf;",
      "": "&pitchfork;",
      "": "&forkv;",
      "": "&fpartint;",
      "": "&half;",
      "": "&frac13;",
      "": "&frac14;",
      "": "&frac15;",
      "": "&frac16;",
      "": "&frac18;",
      "": "&frac23;",
      "": "&frac25;",
      "": "&frac34;",
      "": "&frac35;",
      "": "&frac38;",
      "": "&frac45;",
      "": "&frac56;",
      "": "&frac58;",
      "": "&frac78;",
      "": "&frasl;",
      "": "&sfrown;",
      "": "&fscr;",
      "": "&gtreqqless;",
      "": "&gacute;",
      "": "&gamma;",
      "": "&gtrapprox;",
      "": "&gbreve;",
      "": "&gcirc;",
      "": "&gcy;",
      "": "&gdot;",
      "": "&gescc;",
      "": "&gesdot;",
      "": "&gesdoto;",
      "": "&gesdotol;",
      "": "&gesl;",
      "": "&gesles;",
      "": "&gfr;",
      "": "&gimel;",
      "": "&gjcy;",
      "": "&glE;",
      "": "&gla;",
      "": "&glj;",
      "": "&gneqq;",
      "": "&gnapprox;",
      "": "&gneq;",
      "": "&gnsim;",
      "": "&gopf;",
      "": "&gscr;",
      "": "&gsime;",
      "": "&gsiml;",
      "": "&gtcc;",
      "": "&gtcir;",
      "": "&gtrdot;",
      "": "&gtlPar;",
      "": "&gtquest;",
      "": "&gtrarr;",
      "": "&gvnE;",
      "": "&hardcy;",
      "": "&harrcir;",
      "": "&leftrightsquigarrow;",
      "": "&plankv;",
      "": "&hcirc;",
      "": "&heartsuit;",
      "": "&mldr;",
      "": "&hercon;",
      "": "&hfr;",
      "": "&searhk;",
      "": "&swarhk;",
      "": "&hoarr;",
      "": "&homtht;",
      "": "&larrhk;",
      "": "&rarrhk;",
      "": "&hopf;",
      "": "&horbar;",
      "": "&hscr;",
      "": "&hstrok;",
      "": "&hybull;",
      "": "&iacute;",
      "": "&icirc;",
      "": "&icy;",
      "": "&iecy;",
      "": "&iexcl;",
      "": "&ifr;",
      "": "&igrave;",
      "": "&qint;",
      "": "&tint;",
      "": "&iinfin;",
      "": "&iiota;",
      "": "&ijlig;",
      "": "&imacr;",
      "": "&inodot;",
      "": "&imof;",
      "": "&imped;",
      "": "&incare;",
      "": "&infin;",
      "": "&infintie;",
      "": "&intercal;",
      "": "&intlarhk;",
      "": "&iprod;",
      "": "&iocy;",
      "": "&iogon;",
      "": "&iopf;",
      "": "&iota;",
      "": "&iquest;",
      "": "&iscr;",
      "": "&isinE;",
      "": "&isindot;",
      "": "&isins;",
      "": "&isinsv;",
      "": "&itilde;",
      "": "&iukcy;",
      "": "&iuml;",
      "": "&jcirc;",
      "": "&jcy;",
      "": "&jfr;",
      "": "&jmath;",
      "": "&jopf;",
      "": "&jscr;",
      "": "&jsercy;",
      "": "&jukcy;",
      "": "&kappa;",
      "": "&varkappa;",
      "": "&kcedil;",
      "": "&kcy;",
      "": "&kfr;",
      "": "&kgreen;",
      "": "&khcy;",
      "": "&kjcy;",
      "": "&kopf;",
      "": "&kscr;",
      "": "&lAtail;",
      "": "&lBarr;",
      "": "&lesseqqgtr;",
      "": "&lHar;",
      "": "&lacute;",
      "": "&laemptyv;",
      "": "&lambda;",
      "": "&langd;",
      "": "&lessapprox;",
      "": "&laquo;",
      "": "&larrbfs;",
      "": "&larrfs;",
      "": "&looparrowleft;",
      "": "&larrpl;",
      "": "&larrsim;",
      "": "&leftarrowtail;",
      "": "&lat;",
      "": "&latail;",
      "": "&late;",
      "": "&lates;",
      "": "&lbarr;",
      "": "&lbbrk;",
      "{": "&lcub;",
      "[": "&lsqb;",
      "": "&lbrke;",
      "": "&lbrksld;",
      "": "&lbrkslu;",
      "": "&lcaron;",
      "": "&lcedil;",
      "": "&lcy;",
      "": "&ldca;",
      "": "&ldrdhar;",
      "": "&ldrushar;",
      "": "&ldsh;",
      "": "&leq;",
      "": "&llarr;",
      "": "&lthree;",
      "": "&lescc;",
      "": "&lesdot;",
      "": "&lesdoto;",
      "": "&lesdotor;",
      "": "&lesg;",
      "": "&lesges;",
      "": "&ltdot;",
      "": "&lfisht;",
      "": "&lfr;",
      "": "&lgE;",
      "": "&lharul;",
      "": "&lhblk;",
      "": "&ljcy;",
      "": "&llhard;",
      "": "&lltri;",
      "": "&lmidot;",
      "": "&lmoustache;",
      "": "&lneqq;",
      "": "&lnapprox;",
      "": "&lneq;",
      "": "&lnsim;",
      "": "&loang;",
      "": "&loarr;",
      "": "&xmap;",
      "": "&rarrlp;",
      "": "&lopar;",
      "": "&lopf;",
      "": "&loplus;",
      "": "&lotimes;",
      "": "&lowast;",
      "": "&lozenge;",
      "(": "&lpar;",
      "": "&lparlt;",
      "": "&lrhard;",
      "": "&lrm;",
      "": "&lrtri;",
      "": "&lsaquo;",
      "": "&lscr;",
      "": "&lsime;",
      "": "&lsimg;",
      "": "&sbquo;",
      "": "&lstrok;",
      "": "&ltcc;",
      "": "&ltcir;",
      "": "&ltimes;",
      "": "&ltlarr;",
      "": "&ltquest;",
      "": "&ltrPar;",
      "": "&triangleleft;",
      "": "&lurdshar;",
      "": "&luruhar;",
      "": "&lvnE;",
      "": "&mDDot;",
      "": "&strns;",
      "": "&male;",
      "": "&maltese;",
      "": "&marker;",
      "": "&mcomma;",
      "": "&mcy;",
      "": "&mdash;",
      "": "&mfr;",
      "": "&mho;",
      "": "&micro;",
      "": "&midcir;",
      "": "&minus;",
      "": "&minusdu;",
      "": "&mlcp;",
      "": "&models;",
      "": "&mopf;",
      "": "&mscr;",
      "": "&mu;",
      "": "&mumap;",
      "": "&nGg;",
      "": "&nGt;",
      "": "&nlArr;",
      "": "&nhArr;",
      "": "&nLl;",
      "": "&nLt;",
      "": "&nrArr;",
      "": "&nVDash;",
      "": "&nVdash;",
      "": "&nacute;",
      "": "&nang;",
      "": "&napE;",
      "": "&napid;",
      "": "&napos;",
      "": "&natural;",
      "": "&ncap;",
      "": "&ncaron;",
      "": "&ncedil;",
      "": "&ncongdot;",
      "": "&ncup;",
      "": "&ncy;",
      "": "&ndash;",
      "": "&neArr;",
      "": "&nearhk;",
      "": "&nedot;",
      "": "&toea;",
      "": "&nfr;",
      "": "&nleftrightarrow;",
      "": "&nhpar;",
      "": "&nis;",
      "": "&nisd;",
      "": "&njcy;",
      "": "&nleqq;",
      "": "&nleftarrow;",
      "": "&nldr;",
      "": "&nopf;",
      "": "&not;",
      "": "&notinE;",
      "": "&notindot;",
      "": "&notinvb;",
      "": "&notinvc;",
      "": "&notnivb;",
      "": "&notnivc;",
      "": "&nparsl;",
      "": "&npart;",
      "": "&npolint;",
      "": "&nrightarrow;",
      "": "&nrarrc;",
      "": "&nrarrw;",
      "": "&nscr;",
      "": "&nsub;",
      "": "&nsubseteqq;",
      "": "&nsup;",
      "": "&nsupseteqq;",
      "": "&ntilde;",
      "": "&nu;",
      "#": "&num;",
      "": "&numero;",
      "": "&numsp;",
      "": "&nvDash;",
      "": "&nvHarr;",
      "": "&nvap;",
      "": "&nvdash;",
      "": "&nvge;",
      ">": "&nvgt;",
      "": "&nvinfin;",
      "": "&nvlArr;",
      "": "&nvle;",
      "<": "&nvlt;",
      "": "&nvltrie;",
      "": "&nvrArr;",
      "": "&nvrtrie;",
      "": "&nvsim;",
      "": "&nwArr;",
      "": "&nwarhk;",
      "": "&nwnear;",
      "": "&oacute;",
      "": "&ocirc;",
      "": "&ocy;",
      "": "&odblac;",
      "": "&odiv;",
      "": "&odsold;",
      "": "&oelig;",
      "": "&ofcir;",
      "": "&ofr;",
      "": "&ogon;",
      "": "&ograve;",
      "": "&ogt;",
      "": "&ohbar;",
      "": "&olcir;",
      "": "&olcross;",
      "": "&olt;",
      "": "&omacr;",
      "": "&omega;",
      "": "&omicron;",
      "": "&omid;",
      "": "&oopf;",
      "": "&opar;",
      "": "&operp;",
      "": "&vee;",
      "": "&ord;",
      "": "&oscr;",
      "": "&ordf;",
      "": "&ordm;",
      "": "&origof;",
      "": "&oror;",
      "": "&orslope;",
      "": "&orv;",
      "": "&oslash;",
      "": "&osol;",
      "": "&otilde;",
      "": "&otimesas;",
      "": "&ouml;",
      "": "&ovbar;",
      "": "&para;",
      "": "&parsim;",
      "": "&parsl;",
      "": "&pcy;",
      "%": "&percnt;",
      ".": "&period;",
      "": "&permil;",
      "": "&pertenk;",
      "": "&pfr;",
      "": "&phi;",
      "": "&varphi;",
      "": "&phone;",
      "": "&pi;",
      "": "&varpi;",
      "": "&planckh;",
      "+": "&plus;",
      "": "&plusacir;",
      "": "&pluscir;",
      "": "&plusdu;",
      "": "&pluse;",
      "": "&plussim;",
      "": "&plustwo;",
      "": "&pointint;",
      "": "&popf;",
      "": "&pound;",
      "": "&prE;",
      "": "&precapprox;",
      "": "&prnap;",
      "": "&prnE;",
      "": "&prnsim;",
      "": "&prime;",
      "": "&profalar;",
      "": "&profline;",
      "": "&profsurf;",
      "": "&prurel;",
      "": "&pscr;",
      "": "&psi;",
      "": "&puncsp;",
      "": "&qfr;",
      "": "&qopf;",
      "": "&qprime;",
      "": "&qscr;",
      "": "&quatint;",
      "?": "&quest;",
      "": "&rAtail;",
      "": "&rHar;",
      "": "&race;",
      "": "&racute;",
      "": "&raemptyv;",
      "": "&rangd;",
      "": "&range;",
      "": "&raquo;",
      "": "&rarrap;",
      "": "&rarrbfs;",
      "": "&rarrc;",
      "": "&rarrfs;",
      "": "&rarrpl;",
      "": "&rarrsim;",
      "": "&rightarrowtail;",
      "": "&rightsquigarrow;",
      "": "&ratail;",
      "": "&ratio;",
      "": "&rbbrk;",
      "}": "&rcub;",
      "]": "&rsqb;",
      "": "&rbrke;",
      "": "&rbrksld;",
      "": "&rbrkslu;",
      "": "&rcaron;",
      "": "&rcedil;",
      "": "&rcy;",
      "": "&rdca;",
      "": "&rdldhar;",
      "": "&rdsh;",
      "": "&rect;",
      "": "&rfisht;",
      "": "&rfr;",
      "": "&rharul;",
      "": "&rho;",
      "": "&varrho;",
      "": "&rrarr;",
      "": "&rthree;",
      "": "&ring;",
      "": "&rlm;",
      "": "&rmoustache;",
      "": "&rnmid;",
      "": "&roang;",
      "": "&roarr;",
      "": "&ropar;",
      "": "&ropf;",
      "": "&roplus;",
      "": "&rotimes;",
      ")": "&rpar;",
      "": "&rpargt;",
      "": "&rppolint;",
      "": "&rsaquo;",
      "": "&rscr;",
      "": "&rtimes;",
      "": "&triangleright;",
      "": "&rtriltri;",
      "": "&ruluhar;",
      "": "&rx;",
      "": "&sacute;",
      "": "&scE;",
      "": "&succapprox;",
      "": "&scaron;",
      "": "&scedil;",
      "": "&scirc;",
      "": "&succneqq;",
      "": "&succnapprox;",
      "": "&succnsim;",
      "": "&scpolint;",
      "": "&scy;",
      "": "&sdot;",
      "": "&sdote;",
      "": "&seArr;",
      "": "&sect;",
      ";": "&semi;",
      "": "&tosa;",
      "": "&sext;",
      "": "&sfr;",
      "": "&sharp;",
      "": "&shchcy;",
      "": "&shcy;",
      "": "&shy;",
      "": "&sigma;",
      "": "&varsigma;",
      "": "&simdot;",
      "": "&simg;",
      "": "&simgE;",
      "": "&siml;",
      "": "&simlE;",
      "": "&simne;",
      "": "&simplus;",
      "": "&simrarr;",
      "": "&smashp;",
      "": "&smeparsl;",
      "": "&ssmile;",
      "": "&smt;",
      "": "&smte;",
      "": "&smtes;",
      "": "&softcy;",
      "/": "&sol;",
      "": "&solb;",
      "": "&solbar;",
      "": "&sopf;",
      "": "&spadesuit;",
      "": "&sqcaps;",
      "": "&sqcups;",
      "": "&sscr;",
      "": "&star;",
      "": "&subset;",
      "": "&subseteqq;",
      "": "&subdot;",
      "": "&subedot;",
      "": "&submult;",
      "": "&subsetneqq;",
      "": "&subsetneq;",
      "": "&subplus;",
      "": "&subrarr;",
      "": "&subsim;",
      "": "&subsub;",
      "": "&subsup;",
      "": "&sung;",
      "": "&sup1;",
      "": "&sup2;",
      "": "&sup3;",
      "": "&supseteqq;",
      "": "&supdot;",
      "": "&supdsub;",
      "": "&supedot;",
      "": "&suphsol;",
      "": "&suphsub;",
      "": "&suplarr;",
      "": "&supmult;",
      "": "&supsetneqq;",
      "": "&supsetneq;",
      "": "&supplus;",
      "": "&supsim;",
      "": "&supsub;",
      "": "&supsup;",
      "": "&swArr;",
      "": "&swnwar;",
      "": "&szlig;",
      "": "&target;",
      "": "&tau;",
      "": "&tcaron;",
      "": "&tcedil;",
      "": "&tcy;",
      "": "&telrec;",
      "": "&tfr;",
      "": "&theta;",
      "": "&vartheta;",
      "": "&thorn;",
      "": "&times;",
      "": "&timesbar;",
      "": "&timesd;",
      "": "&topbot;",
      "": "&topcir;",
      "": "&topf;",
      "": "&topfork;",
      "": "&tprime;",
      "": "&utri;",
      "": "&trie;",
      "": "&tridot;",
      "": "&triminus;",
      "": "&triplus;",
      "": "&trisb;",
      "": "&tritime;",
      "": "&trpezium;",
      "": "&tscr;",
      "": "&tscy;",
      "": "&tshcy;",
      "": "&tstrok;",
      "": "&uHar;",
      "": "&uacute;",
      "": "&ubrcy;",
      "": "&ubreve;",
      "": "&ucirc;",
      "": "&ucy;",
      "": "&udblac;",
      "": "&ufisht;",
      "": "&ufr;",
      "": "&ugrave;",
      "": "&uhblk;",
      "": "&ulcorner;",
      "": "&ulcrop;",
      "": "&ultri;",
      "": "&umacr;",
      "": "&uogon;",
      "": "&uopf;",
      "": "&upsilon;",
      "": "&uuarr;",
      "": "&urcorner;",
      "": "&urcrop;",
      "": "&uring;",
      "": "&urtri;",
      "": "&uscr;",
      "": "&utdot;",
      "": "&utilde;",
      "": "&uuml;",
      "": "&uwangle;",
      "": "&vBar;",
      "": "&vBarv;",
      "": "&vangrt;",
      "": "&vsubne;",
      "": "&vsubnE;",
      "": "&vsupne;",
      "": "&vsupnE;",
      "": "&vcy;",
      "": "&veebar;",
      "": "&veeeq;",
      "": "&vellip;",
      "": "&vfr;",
      "": "&vopf;",
      "": "&vscr;",
      "": "&vzigzag;",
      "": "&wcirc;",
      "": "&wedbar;",
      "": "&wedgeq;",
      "": "&wp;",
      "": "&wfr;",
      "": "&wopf;",
      "": "&wscr;",
      "": "&xfr;",
      "": "&xi;",
      "": "&xnis;",
      "": "&xopf;",
      "": "&xscr;",
      "": "&yacute;",
      "": "&yacy;",
      "": "&ycirc;",
      "": "&ycy;",
      "": "&yen;",
      "": "&yfr;",
      "": "&yicy;",
      "": "&yopf;",
      "": "&yscr;",
      "": "&yucy;",
      "": "&yuml;",
      "": "&zacute;",
      "": "&zcaron;",
      "": "&zcy;",
      "": "&zdot;",
      "": "&zeta;",
      "": "&zfr;",
      "": "&zhcy;",
      "": "&zigrarr;",
      "": "&zopf;",
      "": "&zscr;",
      "": "&zwj;",
      "": "&zwnj;"
    }
  }
};

/***/ }),

/***/ "./node_modules/html-entities/lib/numeric-unicode-map.js":
/*!***************************************************************!*\
  !*** ./node_modules/html-entities/lib/numeric-unicode-map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.numericUnicodeMap = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
};

/***/ }),

/***/ "./node_modules/html-entities/lib/surrogate-pairs.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/lib/surrogate-pairs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

exports.fromCodePoint = String.fromCodePoint || function (astralCodePoint) {
  return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
};

exports.getCodePoint = String.prototype.codePointAt ? function (input, position) {
  return input.codePointAt(position);
} : function (input, position) {
  return (input.charCodeAt(position) - 55296) * 1024 + input.charCodeAt(position + 1) - 56320 + 65536;
};
exports.highSurrogateFrom = 55296;
exports.highSurrogateTo = 56319;

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */


var baseEach = createBaseEach(baseForOwn);
module.exports = baseEach;

/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */


function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");
/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */


function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
module.exports = freeGlobal;

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "./node_modules/lodash/each.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/each.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./forEach */ "./node_modules/lodash/forEach.js");

/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */


function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof __webpack_require__.g=='object'&&__webpack_require__.g&&__webpack_require__.g.Object===Object&&__webpack_require__.g;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports= true&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&"object"=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||isBuff&&(key=='offset'||key=='parent')||isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else{iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
// potential command injection attacks.
else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else {}}).call(this);

/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-env browser */

/*
  eslint-disable
  no-console,
  func-names
*/

var normalizeUrl = __webpack_require__(/*! ./normalize-url */ "./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js");

var srcByModuleId = Object.create(null);
var noDocument = typeof document === "undefined";
var forEach = Array.prototype.forEach;

function debounce(fn, time) {
  var timeout = 0;
  return function () {
    var self = this; // eslint-disable-next-line prefer-rest-params

    var args = arguments;

    var functionCall = function functionCall() {
      return fn.apply(self, args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(functionCall, time);
  };
}

function noop() {}

function getCurrentScriptUrl(moduleId) {
  var src = srcByModuleId[moduleId];

  if (!src) {
    if (document.currentScript) {
      src = document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      var lastScriptTag = scripts[scripts.length - 1];

      if (lastScriptTag) {
        src = lastScriptTag.src;
      }
    }

    srcByModuleId[moduleId] = src;
  }

  return function (fileMap) {
    if (!src) {
      return null;
    }

    var splitResult = src.split(/([^\\/]+)\.js$/);
    var filename = splitResult && splitResult[1];

    if (!filename) {
      return [src.replace(".js", ".css")];
    }

    if (!fileMap) {
      return [src.replace(".js", ".css")];
    }

    return fileMap.split(",").map(function (mapRule) {
      var reg = new RegExp("".concat(filename, "\\.js$"), "g");
      return normalizeUrl(src.replace(reg, "".concat(mapRule.replace(/{fileName}/g, filename), ".css")));
    });
  };
}

function updateCss(el, url) {
  if (!url) {
    if (!el.href) {
      return;
    } // eslint-disable-next-line


    url = el.href.split("?")[0];
  }

  if (!isUrlRequest(url)) {
    return;
  }

  if (el.isLoaded === false) {
    // We seem to be about to replace a css link that hasn't loaded yet.
    // We're probably changing the same file more than once.
    return;
  }

  if (!url || !(url.indexOf(".css") > -1)) {
    return;
  } // eslint-disable-next-line no-param-reassign


  el.visited = true;
  var newEl = el.cloneNode();
  newEl.isLoaded = false;
  newEl.addEventListener("load", function () {
    if (newEl.isLoaded) {
      return;
    }

    newEl.isLoaded = true;
    el.parentNode.removeChild(el);
  });
  newEl.addEventListener("error", function () {
    if (newEl.isLoaded) {
      return;
    }

    newEl.isLoaded = true;
    el.parentNode.removeChild(el);
  });
  newEl.href = "".concat(url, "?").concat(Date.now());

  if (el.nextSibling) {
    el.parentNode.insertBefore(newEl, el.nextSibling);
  } else {
    el.parentNode.appendChild(newEl);
  }
}

function getReloadUrl(href, src) {
  var ret; // eslint-disable-next-line no-param-reassign

  href = normalizeUrl(href, {
    stripWWW: false
  }); // eslint-disable-next-line array-callback-return

  src.some(function (url) {
    if (href.indexOf(src) > -1) {
      ret = url;
    }
  });
  return ret;
}

function reloadStyle(src) {
  if (!src) {
    return false;
  }

  var elements = document.querySelectorAll("link");
  var loaded = false;
  forEach.call(elements, function (el) {
    if (!el.href) {
      return;
    }

    var url = getReloadUrl(el.href, src);

    if (!isUrlRequest(url)) {
      return;
    }

    if (el.visited === true) {
      return;
    }

    if (url) {
      updateCss(el, url);
      loaded = true;
    }
  });
  return loaded;
}

function reloadAll() {
  var elements = document.querySelectorAll("link");
  forEach.call(elements, function (el) {
    if (el.visited === true) {
      return;
    }

    updateCss(el);
  });
}

function isUrlRequest(url) {
  // An URL is not an request if
  // It is not http or https
  if (!/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url)) {
    return false;
  }

  return true;
}

module.exports = function (moduleId, options) {
  if (noDocument) {
    console.log("no window.document found, will not HMR CSS");
    return noop;
  }

  var getScriptSrc = getCurrentScriptUrl(moduleId);

  function update() {
    var src = getScriptSrc(options.filename);
    var reloaded = reloadStyle(src);

    if (options.locals) {
      console.log("[HMR] Detected local css modules. Reload all css");
      reloadAll();
      return;
    }

    if (reloaded) {
      console.log("[HMR] css reload %s", src.join(" "));
    } else {
      console.log("[HMR] Reload all css");
      reloadAll();
    }
  }

  return debounce(update, 50);
};

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";

/* eslint-disable */

function normalizeUrl(pathComponents) {
  return pathComponents.reduce(function (accumulator, item) {
    switch (item) {
      case "..":
        accumulator.pop();
        break;

      case ".":
        break;

      default:
        accumulator.push(item);
    }

    return accumulator;
  }, []).join("/");
}

module.exports = function (urlString) {
  urlString = urlString.trim();

  if (/^data:/i.test(urlString)) {
    return urlString;
  }

  var protocol = urlString.indexOf("//") !== -1 ? urlString.split("//")[0] + "//" : "";
  var components = urlString.replace(new RegExp(protocol, "i"), "").split("/");
  var host = components[0].toLowerCase().replace(/\.$/, "");
  components[0] = "";
  var path = normalizeUrl(components);
  return protocol + host + path;
};

/***/ }),

/***/ "./node_modules/prefix/index.js":
/*!**************************************!*\
  !*** ./node_modules/prefix/index.js ***!
  \**************************************/
/***/ ((module) => {

// check document first so it doesn't error in node.js
var style = typeof document != 'undefined' ? document.createElement('p').style : {};
var prefixes = ['O', 'ms', 'Moz', 'Webkit'];
var upper = /([A-Z])/g;
var memo = {};
/**
 * prefix `key`
 *
 *   prefix('transform') // => WebkitTransform
 *
 * @param {String} key
 * @return {String}
 * @api public
 */

function prefix(key) {
  // Camel case
  key = key.replace(/-([a-z])/g, function (_, char) {
    return char.toUpperCase();
  }); // Without prefix

  if (style[key] !== undefined) return key; // With prefix

  var Key = key.charAt(0).toUpperCase() + key.slice(1);
  var i = prefixes.length;

  while (i--) {
    var name = prefixes[i] + Key;
    if (style[name] !== undefined) return name;
  }

  return key;
}
/**
 * Memoized version of `prefix`
 *
 * @param {String} key
 * @return {String}
 * @api public
 */


function prefixMemozied(key) {
  return key in memo ? memo[key] : memo[key] = prefix(key);
}
/**
 * Create a dashed prefix
 *
 * @param {String} key
 * @return {String}
 * @api public
 */


function prefixDashed(key) {
  key = prefix(key);

  if (upper.test(key)) {
    key = '-' + key.replace(upper, '-$1');
    upper.lastIndex = 0;
  }

  return key.toLowerCase();
}

module.exports = prefixMemozied;
module.exports.dash = prefixDashed;

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports =  true && exports && !exports.nodeType && exports;
  var freeModule =  true && module && !module.nodeType && module;
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * http://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.3.2',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");

var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift()));

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function (arg) {
    return typeof arg === 'string';
  },
  isObject: function (arg) {
    return typeof arg === 'object' && arg !== null;
  },
  isNull: function (arg) {
    return arg === null;
  },
  isNullOrUndefined: function (arg) {
    return arg == null;
  }
};

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebSocketClient)
/* harmony export */ });
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}



var WebSocketClient = /*#__PURE__*/function () {
  function WebSocketClient(url) {
    _classCallCheck(this, WebSocketClient);

    this.client = new WebSocket(url);

    this.client.onerror = function (error) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_0__.log.error(error);
    };
  }

  _createClass(WebSocketClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.client.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.client.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.client.onmessage = function (e) {
        f(e.data);
      };
    }
  }]);

  return WebSocketClient;
}();



/***/ }),

/***/ "./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __resourceQuery = "?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/log.js */ "./node_modules/webpack/hot/log.js");
/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/strip-ansi/index.js */ "./node_modules/webpack-dev-server/client/modules/strip-ansi/index.js");
/* harmony import */ var _modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/parseURL.js */ "./node_modules/webpack-dev-server/client/utils/parseURL.js");
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./socket.js */ "./node_modules/webpack-dev-server/client/socket.js");
/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./overlay.js */ "./node_modules/webpack-dev-server/client/overlay.js");
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
/* harmony import */ var _utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/sendMessage.js */ "./node_modules/webpack-dev-server/client/utils/sendMessage.js");
/* harmony import */ var _utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/reloadApp.js */ "./node_modules/webpack-dev-server/client/utils/reloadApp.js");
/* harmony import */ var _utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/createSocketURL.js */ "./node_modules/webpack-dev-server/client/utils/createSocketURL.js");
/* global __resourceQuery, __webpack_hash__ */









var status = {
  isUnloading: false,
  // TODO Workaround for webpack v4, `__webpack_hash__` is not replaced without HotModuleReplacement
  // eslint-disable-next-line camelcase
  currentHash:  true ? __webpack_require__.h() : 0
}; // console.log(__webpack_hash__);

var options = {
  hot: false,
  liveReload: false,
  progress: false,
  overlay: false
};
var parsedResourceQuery = (0,_utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__["default"])(__resourceQuery);

if (parsedResourceQuery.hot === "true") {
  options.hot = true;
  _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Hot Module Replacement enabled.");
}

if (parsedResourceQuery["live-reload"] === "true") {
  options.liveReload = true;
  _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Live Reloading enabled.");
}

if (parsedResourceQuery.logging) {
  options.logging = parsedResourceQuery.logging;
}

function setAllLogLevel(level) {
  // This is needed because the HMR logger operate separately from dev server logger
  webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default().setLogLevel(level === "verbose" || level === "log" ? "info" : level);
  (0,_utils_log_js__WEBPACK_IMPORTED_MODULE_5__.setLogLevel)(level);
}

if (options.logging) {
  setAllLogLevel(options.logging);
}

self.addEventListener("beforeunload", function () {
  status.isUnloading = true;
});
var onSocketMessage = {
  hot: function hot() {
    if (parsedResourceQuery.hot === "false") {
      return;
    }

    options.hot = true;
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Hot Module Replacement enabled.");
  },
  liveReload: function liveReload() {
    if (parsedResourceQuery["live-reload"] === "false") {
      return;
    }

    options.liveReload = true;
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Live Reloading enabled.");
  },
  invalid: function invalid() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("App updated. Recompiling..."); // Fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.overlay) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.hide)();
    }

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Invalid");
  },
  hash: function hash(_hash) {
    status.previousHash = status.currentHash;
    status.currentHash = _hash;
  },
  logging: setAllLogLevel,
  overlay: function overlay(value) {
    if (typeof document === "undefined") {
      return;
    }

    options.overlay = value;
  },
  progress: function progress(_progress) {
    options.progress = _progress;
  },
  "progress-update": function progressUpdate(data) {
    if (options.progress) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(data.pluginName ? "[".concat(data.pluginName, "] ") : "").concat(data.percent, "% - ").concat(data.msg, "."));
    }

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Progress", data);
  },
  "still-ok": function stillOk() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Nothing changed.");

    if (options.overlay) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.hide)();
    }

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("StillOk");
  },
  ok: function ok() {
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Ok");

    if (options.overlay) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.hide)();
    }

    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__["default"])(options, status);
  },
  // TODO: remove in v5 in favor of 'static-changed'
  "content-changed": function contentChanged(file) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(file ? "\"".concat(file, "\"") : "Content", " from static directory was changed. Reloading..."));
    self.location.reload();
  },
  "static-changed": function staticChanged(file) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(file ? "\"".concat(file, "\"") : "Content", " from static directory was changed. Reloading..."));
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn("Warnings while compiling.");

    var strippedWarnings = _warnings.map(function (warning) {
      return _modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1___default()(warning.message ? warning.message : warning);
    });

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Warnings", strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn(strippedWarnings[i]);
    }

    var needShowOverlayForWarnings = typeof options.overlay === "boolean" ? options.overlay : options.overlay && options.overlay.warnings;

    if (needShowOverlayForWarnings) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.show)(_warnings, "warnings");
    }

    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__["default"])(options, status);
  },
  errors: function errors(_errors) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error("Errors while compiling. Reload prevented.");

    var strippedErrors = _errors.map(function (error) {
      return _modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1___default()(error.message ? error.message : error);
    });

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Errors", strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(strippedErrors[i]);
    }

    var needShowOverlayForErrors = typeof options.overlay === "boolean" ? options.overlay : options.overlay && options.overlay.errors;

    if (needShowOverlayForErrors) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.show)(_errors, "errors");
    }
  },
  error: function error(_error) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(_error);
  },
  close: function close() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Disconnected!");

    if (options.overlay) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.hide)();
    }

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Close");
  }
};
var socketURL = (0,_utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__["default"])(parsedResourceQuery);
(0,_socket_js__WEBPACK_IMPORTED_MODULE_3__["default"])(socketURL, onSocketMessage);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/modules/logger/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/modules/logger/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/******/
(function () {
  // webpackBootstrap

  /******/
  "use strict";
  /******/

  var __webpack_modules__ = {
    /***/
    "./client-src/modules/logger/SyncBailHookFake.js": function (module) {
      /**
       * Client stub for tapable SyncBailHook
       */
      module.exports = function clientTapableSyncBailHook() {
        return {
          call: function call() {}
        };
      };
      /***/

    },

    /***/
    "./node_modules/webpack/lib/logging/Logger.js": function (__unused_webpack_module, exports) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      var LogType = Object.freeze({
        error: "error",
        // message, c style arguments
        warn: "warn",
        // message, c style arguments
        info: "info",
        // message, c style arguments
        log: "log",
        // message, c style arguments
        debug: "debug",
        // message, c style arguments
        trace: "trace",
        // no arguments
        group: "group",
        // [label]
        groupCollapsed: "groupCollapsed",
        // [label]
        groupEnd: "groupEnd",
        // [label]
        profile: "profile",
        // [profileName]
        profileEnd: "profileEnd",
        // [profileName]
        time: "time",
        // name, time as [seconds, nanoseconds]
        clear: "clear",
        // no arguments
        status: "status" // message, arguments

      });
      exports.LogType = LogType;
      /** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */

      var LOG_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger raw log method");
      var TIMERS_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger times");
      var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger aggregated times");

      var WebpackLogger = /*#__PURE__*/function () {
        /**
         * @param {function(LogTypeEnum, any[]=): void} log log function
         * @param {function(string | function(): string): WebpackLogger} getChildLogger function to create child logger
         */
        function WebpackLogger(log, getChildLogger) {
          _classCallCheck(this, WebpackLogger);

          this[LOG_SYMBOL] = log;
          this.getChildLogger = getChildLogger;
        }

        _createClass(WebpackLogger, [{
          key: "error",
          value: function error() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            this[LOG_SYMBOL](LogType.error, args);
          }
        }, {
          key: "warn",
          value: function warn() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            this[LOG_SYMBOL](LogType.warn, args);
          }
        }, {
          key: "info",
          value: function info() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            this[LOG_SYMBOL](LogType.info, args);
          }
        }, {
          key: "log",
          value: function log() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }

            this[LOG_SYMBOL](LogType.log, args);
          }
        }, {
          key: "debug",
          value: function debug() {
            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }

            this[LOG_SYMBOL](LogType.debug, args);
          }
        }, {
          key: "assert",
          value: function assert(assertion) {
            if (!assertion) {
              for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
                args[_key6 - 1] = arguments[_key6];
              }

              this[LOG_SYMBOL](LogType.error, args);
            }
          }
        }, {
          key: "trace",
          value: function trace() {
            this[LOG_SYMBOL](LogType.trace, ["Trace"]);
          }
        }, {
          key: "clear",
          value: function clear() {
            this[LOG_SYMBOL](LogType.clear);
          }
        }, {
          key: "status",
          value: function status() {
            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
              args[_key7] = arguments[_key7];
            }

            this[LOG_SYMBOL](LogType.status, args);
          }
        }, {
          key: "group",
          value: function group() {
            for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
              args[_key8] = arguments[_key8];
            }

            this[LOG_SYMBOL](LogType.group, args);
          }
        }, {
          key: "groupCollapsed",
          value: function groupCollapsed() {
            for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
              args[_key9] = arguments[_key9];
            }

            this[LOG_SYMBOL](LogType.groupCollapsed, args);
          }
        }, {
          key: "groupEnd",
          value: function groupEnd() {
            for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
              args[_key10] = arguments[_key10];
            }

            this[LOG_SYMBOL](LogType.groupEnd, args);
          }
        }, {
          key: "profile",
          value: function profile(label) {
            this[LOG_SYMBOL](LogType.profile, [label]);
          }
        }, {
          key: "profileEnd",
          value: function profileEnd(label) {
            this[LOG_SYMBOL](LogType.profileEnd, [label]);
          }
        }, {
          key: "time",
          value: function time(label) {
            this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();
            this[TIMERS_SYMBOL].set(label, process.hrtime());
          }
        }, {
          key: "timeLog",
          value: function timeLog(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);

            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeLog()"));
            }

            var time = process.hrtime(prev);
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }, {
          key: "timeEnd",
          value: function timeEnd(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);

            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeEnd()"));
            }

            var time = process.hrtime(prev);
            this[TIMERS_SYMBOL].delete(label);
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }, {
          key: "timeAggregate",
          value: function timeAggregate(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);

            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeAggregate()"));
            }

            var time = process.hrtime(prev);
            this[TIMERS_SYMBOL].delete(label);
            this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();
            var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);

            if (current !== undefined) {
              if (time[1] + current[1] > 1e9) {
                time[0] += current[0] + 1;
                time[1] = time[1] - 1e9 + current[1];
              } else {
                time[0] += current[0];
                time[1] += current[1];
              }
            }

            this[TIMERS_AGGREGATES_SYMBOL].set(label, time);
          }
        }, {
          key: "timeAggregateEnd",
          value: function timeAggregateEnd(label) {
            if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;
            var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);
            if (time === undefined) return;
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }]);

        return WebpackLogger;
      }();

      exports.Logger = WebpackLogger;
      /***/
    },

    /***/
    "./node_modules/webpack/lib/logging/createConsoleLogger.js": function (module, __unused_webpack_exports, __nested_webpack_require_11389__) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      var _require = __nested_webpack_require_11389__(
      /*! ./Logger */
      "./node_modules/webpack/lib/logging/Logger.js"),
          LogType = _require.LogType;
      /** @typedef {import("../../declarations/WebpackOptions").FilterItemTypes} FilterItemTypes */

      /** @typedef {import("../../declarations/WebpackOptions").FilterTypes} FilterTypes */

      /** @typedef {import("./Logger").LogTypeEnum} LogTypeEnum */

      /** @typedef {function(string): boolean} FilterFunction */

      /**
       * @typedef {Object} LoggerConsole
       * @property {function(): void} clear
       * @property {function(): void} trace
       * @property {(...args: any[]) => void} info
       * @property {(...args: any[]) => void} log
       * @property {(...args: any[]) => void} warn
       * @property {(...args: any[]) => void} error
       * @property {(...args: any[]) => void=} debug
       * @property {(...args: any[]) => void=} group
       * @property {(...args: any[]) => void=} groupCollapsed
       * @property {(...args: any[]) => void=} groupEnd
       * @property {(...args: any[]) => void=} status
       * @property {(...args: any[]) => void=} profile
       * @property {(...args: any[]) => void=} profileEnd
       * @property {(...args: any[]) => void=} logTime
       */

      /**
       * @typedef {Object} LoggerOptions
       * @property {false|true|"none"|"error"|"warn"|"info"|"log"|"verbose"} level loglevel
       * @property {FilterTypes|boolean} debug filter for debug logging
       * @property {LoggerConsole} console the console to log to
       */

      /**
       * @param {FilterItemTypes} item an input item
       * @returns {FilterFunction} filter function
       */


      var filterToFunction = function filterToFunction(item) {
        if (typeof item === "string") {
          var regExp = new RegExp("[\\\\/]".concat(item.replace( // eslint-disable-next-line no-useless-escape
          /[-[\]{}()*+?.\\^$|]/g, "\\$&"), "([\\\\/]|$|!|\\?)"));
          return function (ident) {
            return regExp.test(ident);
          };
        }

        if (item && typeof item === "object" && typeof item.test === "function") {
          return function (ident) {
            return item.test(ident);
          };
        }

        if (typeof item === "function") {
          return item;
        }

        if (typeof item === "boolean") {
          return function () {
            return item;
          };
        }
      };
      /**
       * @enum {number}
       */


      var LogLevel = {
        none: 6,
        false: 6,
        error: 5,
        warn: 4,
        info: 3,
        log: 2,
        true: 2,
        verbose: 1
      };
      /**
       * @param {LoggerOptions} options options object
       * @returns {function(string, LogTypeEnum, any[]): void} logging function
       */

      module.exports = function (_ref) {
        var _ref$level = _ref.level,
            level = _ref$level === void 0 ? "info" : _ref$level,
            _ref$debug = _ref.debug,
            debug = _ref$debug === void 0 ? false : _ref$debug,
            console = _ref.console;
        var debugFilters = typeof debug === "boolean" ? [function () {
          return debug;
        }] :
        /** @type {FilterItemTypes[]} */
        [].concat(debug).map(filterToFunction);
        /** @type {number} */

        var loglevel = LogLevel["".concat(level)] || 0;
        /**
         * @param {string} name name of the logger
         * @param {LogTypeEnum} type type of the log entry
         * @param {any[]} args arguments of the log entry
         * @returns {void}
         */

        var logger = function logger(name, type, args) {
          var labeledArgs = function labeledArgs() {
            if (Array.isArray(args)) {
              if (args.length > 0 && typeof args[0] === "string") {
                return ["[".concat(name, "] ").concat(args[0])].concat(_toConsumableArray(args.slice(1)));
              } else {
                return ["[".concat(name, "]")].concat(_toConsumableArray(args));
              }
            } else {
              return [];
            }
          };

          var debug = debugFilters.some(function (f) {
            return f(name);
          });

          switch (type) {
            case LogType.debug:
              if (!debug) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              if (typeof console.debug === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.debug.apply(console, _toConsumableArray(labeledArgs()));
              } else {
                console.log.apply(console, _toConsumableArray(labeledArgs()));
              }

              break;

            case LogType.log:
              if (!debug && loglevel > LogLevel.log) return;
              console.log.apply(console, _toConsumableArray(labeledArgs()));
              break;

            case LogType.info:
              if (!debug && loglevel > LogLevel.info) return;
              console.info.apply(console, _toConsumableArray(labeledArgs()));
              break;

            case LogType.warn:
              if (!debug && loglevel > LogLevel.warn) return;
              console.warn.apply(console, _toConsumableArray(labeledArgs()));
              break;

            case LogType.error:
              if (!debug && loglevel > LogLevel.error) return;
              console.error.apply(console, _toConsumableArray(labeledArgs()));
              break;

            case LogType.trace:
              if (!debug) return;
              console.trace();
              break;

            case LogType.groupCollapsed:
              if (!debug && loglevel > LogLevel.log) return;

              if (!debug && loglevel > LogLevel.verbose) {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                if (typeof console.groupCollapsed === "function") {
                  // eslint-disable-next-line node/no-unsupported-features/node-builtins
                  console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));
                } else {
                  console.log.apply(console, _toConsumableArray(labeledArgs()));
                }

                break;
              }

            // falls through

            case LogType.group:
              if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              if (typeof console.group === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.group.apply(console, _toConsumableArray(labeledArgs()));
              } else {
                console.log.apply(console, _toConsumableArray(labeledArgs()));
              }

              break;

            case LogType.groupEnd:
              if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              if (typeof console.groupEnd === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.groupEnd();
              }

              break;

            case LogType.time:
              {
                if (!debug && loglevel > LogLevel.log) return;
                var ms = args[1] * 1000 + args[2] / 1000000;
                var msg = "[".concat(name, "] ").concat(args[0], ": ").concat(ms, " ms");

                if (typeof console.logTime === "function") {
                  console.logTime(msg);
                } else {
                  console.log(msg);
                }

                break;
              }

            case LogType.profile:
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.profile === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.profile.apply(console, _toConsumableArray(labeledArgs()));
              }

              break;

            case LogType.profileEnd:
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.profileEnd === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));
              }

              break;

            case LogType.clear:
              if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              if (typeof console.clear === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.clear();
              }

              break;

            case LogType.status:
              if (!debug && loglevel > LogLevel.info) return;

              if (typeof console.status === "function") {
                if (args.length === 0) {
                  console.status();
                } else {
                  console.status.apply(console, _toConsumableArray(labeledArgs()));
                }
              } else {
                if (args.length !== 0) {
                  console.info.apply(console, _toConsumableArray(labeledArgs()));
                }
              }

              break;

            default:
              throw new Error("Unexpected LogType ".concat(type));
          }
        };

        return logger;
      };
      /***/

    },

    /***/
    "./node_modules/webpack/lib/logging/runtime.js": function (__unused_webpack_module, exports, __nested_webpack_require_22851__) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      var SyncBailHook = __nested_webpack_require_22851__(
      /*! tapable/lib/SyncBailHook */
      "./client-src/modules/logger/SyncBailHookFake.js");

      var _require = __nested_webpack_require_22851__(
      /*! ./Logger */
      "./node_modules/webpack/lib/logging/Logger.js"),
          Logger = _require.Logger;

      var createConsoleLogger = __nested_webpack_require_22851__(
      /*! ./createConsoleLogger */
      "./node_modules/webpack/lib/logging/createConsoleLogger.js");
      /** @type {createConsoleLogger.LoggerOptions} */


      var currentDefaultLoggerOptions = {
        level: "info",
        debug: false,
        console: console
      };
      var currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);
      /**
       * @param {string} name name of the logger
       * @returns {Logger} a logger
       */

      exports.getLogger = function (name) {
        return new Logger(function (type, args) {
          if (exports.hooks.log.call(name, type, args) === undefined) {
            currentDefaultLogger(name, type, args);
          }
        }, function (childName) {
          return exports.getLogger("".concat(name, "/").concat(childName));
        });
      };
      /**
       * @param {createConsoleLogger.LoggerOptions} options new options, merge with old options
       * @returns {void}
       */


      exports.configureDefaultLogger = function (options) {
        _extends(currentDefaultLoggerOptions, options);

        currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);
      };

      exports.hooks = {
        log: new SyncBailHook(["origin", "type", "args"])
      };
      /***/
    }
    /******/

  };
  /************************************************************************/

  /******/
  // The module cache

  /******/

  var __webpack_module_cache__ = {};
  /******/

  /******/
  // The require function

  /******/

  function __nested_webpack_require_25353__(moduleId) {
    /******/
    // Check if module is in cache

    /******/
    var cachedModule = __webpack_module_cache__[moduleId];
    /******/

    if (cachedModule !== undefined) {
      /******/
      return cachedModule.exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = __webpack_module_cache__[moduleId] = {
      /******/
      // no module.id needed

      /******/
      // no module.loaded needed

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_25353__);
    /******/

    /******/
    // Return the exports of the module

    /******/


    return module.exports;
    /******/
  }
  /******/

  /************************************************************************/

  /******/

  /* webpack/runtime/define property getters */

  /******/


  !function () {
    /******/
    // define getter functions for harmony exports

    /******/
    __nested_webpack_require_25353__.d = function (exports, definition) {
      /******/
      for (var key in definition) {
        /******/
        if (__nested_webpack_require_25353__.o(definition, key) && !__nested_webpack_require_25353__.o(exports, key)) {
          /******/
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
          /******/
        }
        /******/

      }
      /******/

    };
    /******/

  }();
  /******/

  /******/

  /* webpack/runtime/hasOwnProperty shorthand */

  /******/

  !function () {
    /******/
    __nested_webpack_require_25353__.o = function (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    /******/

  }();
  /******/

  /******/

  /* webpack/runtime/make namespace object */

  /******/

  !function () {
    /******/
    // define __esModule on exports

    /******/
    __nested_webpack_require_25353__.r = function (exports) {
      /******/
      if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/
        Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/


      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/

  }();
  /******/

  /************************************************************************/

  var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.

  !function () {
    /*!********************************************!*\
      !*** ./client-src/modules/logger/index.js ***!
      \********************************************/
    __nested_webpack_require_25353__.r(__webpack_exports__);
    /* harmony export */


    __nested_webpack_require_25353__.d(__webpack_exports__, {
      /* harmony export */
      "default": function () {
        return (
          /* reexport default export from named module */
          webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__
        );
      }
      /* harmony export */

    });
    /* harmony import */


    var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_25353__(
    /*! webpack/lib/logging/runtime.js */
    "./node_modules/webpack/lib/logging/runtime.js");
  }();
  var __webpack_export_target__ = exports;

  for (var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];

  if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", {
    value: true
  });
  /******/
})();

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/modules/strip-ansi/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/modules/strip-ansi/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/******/
(function () {
  // webpackBootstrap

  /******/
  "use strict";
  /******/

  var __webpack_modules__ = {
    /***/
    "./node_modules/strip-ansi/index.js": function (__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_236__) {
      __nested_webpack_require_236__.r(__webpack_exports__);
      /* harmony export */


      __nested_webpack_require_236__.d(__webpack_exports__, {
        /* harmony export */
        "default": function () {
          return (
            /* binding */
            stripAnsi
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var ansi_regex__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_236__(
      /*! ansi-regex */
      "./node_modules/strip-ansi/node_modules/ansi-regex/index.js");

      function stripAnsi(string) {
        if (typeof string !== 'string') {
          throw new TypeError("Expected a `string`, got `".concat(typeof string, "`"));
        }

        return string.replace((0, ansi_regex__WEBPACK_IMPORTED_MODULE_0__["default"])(), '');
      }
      /***/

    },

    /***/
    "./node_modules/strip-ansi/node_modules/ansi-regex/index.js": function (__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_1220__) {
      __nested_webpack_require_1220__.r(__webpack_exports__);
      /* harmony export */


      __nested_webpack_require_1220__.d(__webpack_exports__, {
        /* harmony export */
        "default": function () {
          return (
            /* binding */
            ansiRegex
          );
        }
        /* harmony export */

      });

      function ansiRegex() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$onlyFirst = _ref.onlyFirst,
            onlyFirst = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

        var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
        return new RegExp(pattern, onlyFirst ? undefined : 'g');
      }
      /***/

    }
    /******/

  };
  /************************************************************************/

  /******/
  // The module cache

  /******/

  var __webpack_module_cache__ = {};
  /******/

  /******/
  // The require function

  /******/

  function __nested_webpack_require_2366__(moduleId) {
    /******/
    // Check if module is in cache

    /******/
    var cachedModule = __webpack_module_cache__[moduleId];
    /******/

    if (cachedModule !== undefined) {
      /******/
      return cachedModule.exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = __webpack_module_cache__[moduleId] = {
      /******/
      // no module.id needed

      /******/
      // no module.loaded needed

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_2366__);
    /******/

    /******/
    // Return the exports of the module

    /******/


    return module.exports;
    /******/
  }
  /******/

  /************************************************************************/

  /******/

  /* webpack/runtime/define property getters */

  /******/


  !function () {
    /******/
    // define getter functions for harmony exports

    /******/
    __nested_webpack_require_2366__.d = function (exports, definition) {
      /******/
      for (var key in definition) {
        /******/
        if (__nested_webpack_require_2366__.o(definition, key) && !__nested_webpack_require_2366__.o(exports, key)) {
          /******/
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
          /******/
        }
        /******/

      }
      /******/

    };
    /******/

  }();
  /******/

  /******/

  /* webpack/runtime/hasOwnProperty shorthand */

  /******/

  !function () {
    /******/
    __nested_webpack_require_2366__.o = function (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    /******/

  }();
  /******/

  /******/

  /* webpack/runtime/make namespace object */

  /******/

  !function () {
    /******/
    // define __esModule on exports

    /******/
    __nested_webpack_require_2366__.r = function (exports) {
      /******/
      if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/
        Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/


      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/

  }();
  /******/

  /************************************************************************/

  var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.

  !function () {
    /*!************************************************!*\
      !*** ./client-src/modules/strip-ansi/index.js ***!
      \************************************************/
    __nested_webpack_require_2366__.r(__webpack_exports__);
    /* harmony import */


    var strip_ansi__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_2366__(
    /*! strip-ansi */
    "./node_modules/strip-ansi/index.js");
    /* harmony default export */


    __webpack_exports__["default"] = strip_ansi__WEBPACK_IMPORTED_MODULE_0__["default"];
  }();
  var __webpack_export_target__ = exports;

  for (var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];

  if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", {
    value: true
  });
  /******/
})();

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!***********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "show": () => (/* binding */ show),
/* harmony export */   "hide": () => (/* binding */ hide)
/* harmony export */ });
/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-html-community */ "./node_modules/ansi-html-community/index.js");
/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ansi_html_community__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/lib/index.js");
/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(html_entities__WEBPACK_IMPORTED_MODULE_1__);
// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).


var colors = {
  reset: ["transparent", "transparent"],
  black: "181818",
  red: "E36049",
  green: "B3CB74",
  yellow: "FFD080",
  blue: "7CAFC2",
  magenta: "7FACCA",
  cyan: "C3C2EF",
  lightgrey: "EBE7E3",
  darkgrey: "6D7891"
};
var iframeContainerElement;
var containerElement;
var onLoadQueue = [];
ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default().setColors(colors);

function createContainer() {
  iframeContainerElement = document.createElement("iframe");
  iframeContainerElement.id = "webpack-dev-server-client-overlay";
  iframeContainerElement.src = "about:blank";
  iframeContainerElement.style.position = "fixed";
  iframeContainerElement.style.left = 0;
  iframeContainerElement.style.top = 0;
  iframeContainerElement.style.right = 0;
  iframeContainerElement.style.bottom = 0;
  iframeContainerElement.style.width = "100vw";
  iframeContainerElement.style.height = "100vh";
  iframeContainerElement.style.border = "none";
  iframeContainerElement.style.zIndex = 9999999999;

  iframeContainerElement.onload = function () {
    containerElement = iframeContainerElement.contentDocument.createElement("div");
    containerElement.id = "webpack-dev-server-client-overlay-div";
    containerElement.style.position = "fixed";
    containerElement.style.boxSizing = "border-box";
    containerElement.style.left = 0;
    containerElement.style.top = 0;
    containerElement.style.right = 0;
    containerElement.style.bottom = 0;
    containerElement.style.width = "100vw";
    containerElement.style.height = "100vh";
    containerElement.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
    containerElement.style.color = "#E8E8E8";
    containerElement.style.fontFamily = "Menlo, Consolas, monospace";
    containerElement.style.fontSize = "large";
    containerElement.style.padding = "2rem";
    containerElement.style.lineHeight = "1.2";
    containerElement.style.whiteSpace = "pre-wrap";
    containerElement.style.overflow = "auto";
    var headerElement = document.createElement("span");
    headerElement.innerText = "Compiled with problems:";
    var closeButtonElement = document.createElement("button");
    closeButtonElement.innerText = "X";
    closeButtonElement.style.background = "transparent";
    closeButtonElement.style.border = "none";
    closeButtonElement.style.fontSize = "20px";
    closeButtonElement.style.fontWeight = "bold";
    closeButtonElement.style.color = "white";
    closeButtonElement.style.cursor = "pointer";
    closeButtonElement.style.cssFloat = "right";
    closeButtonElement.style.styleFloat = "right";
    closeButtonElement.addEventListener("click", function () {
      hide();
    });
    containerElement.appendChild(headerElement);
    containerElement.appendChild(closeButtonElement);
    containerElement.appendChild(document.createElement("br"));
    containerElement.appendChild(document.createElement("br"));
    iframeContainerElement.contentDocument.body.appendChild(containerElement);
    onLoadQueue.forEach(function (onLoad) {
      onLoad(containerElement);
    });
    onLoadQueue = [];
    iframeContainerElement.onload = null;
  };

  document.body.appendChild(iframeContainerElement);
}

function ensureOverlayExists(callback) {
  if (containerElement) {
    // Everything is ready, call the callback right away.
    callback(containerElement);
    return;
  }

  onLoadQueue.push(callback);

  if (iframeContainerElement) {
    return;
  }

  createContainer();
} // Successful compilation.


function hide() {
  if (!iframeContainerElement) {
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(iframeContainerElement);
  iframeContainerElement = null;
  containerElement = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function show(messages, type) {
  ensureOverlayExists(function () {
    messages.forEach(function (message) {
      var entryElement = document.createElement("div");
      var typeElement = document.createElement("span");
      typeElement.innerText = type === "warnings" ? "Warning:" : "Error:";
      typeElement.style.color = "#".concat(colors.red); // Make it look similar to our terminal.

      var errorMessage = message.message || messages[0];
      var text = ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default()((0,html_entities__WEBPACK_IMPORTED_MODULE_1__.encode)(errorMessage));
      var messageTextNode = document.createElement("div");
      messageTextNode.innerHTML = text;
      entryElement.appendChild(typeElement);
      entryElement.appendChild(document.createElement("br"));
      entryElement.appendChild(document.createElement("br"));
      entryElement.appendChild(messageTextNode);
      entryElement.appendChild(document.createElement("br"));
      entryElement.appendChild(document.createElement("br"));
      containerElement.appendChild(entryElement);
    });
  });
}



/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/socket.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clients/WebSocketClient.js */ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js");
/* provided dependency */ var __webpack_dev_server_client__ = __webpack_require__(/*! ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js */ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js");
/* global __webpack_dev_server_client__ */
 // this WebsocketClient is here as a default fallback, in case the client is not injected

/* eslint-disable camelcase */

var Client = // eslint-disable-next-line camelcase, no-nested-ternary
typeof __webpack_dev_server_client__ !== "undefined" ? // eslint-disable-next-line camelcase
typeof __webpack_dev_server_client__.default !== "undefined" ? __webpack_dev_server_client__.default : __webpack_dev_server_client__ : _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__["default"];
/* eslint-enable camelcase */

var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var message = JSON.parse(data);

    if (handlers[message.type]) {
      handlers[message.type](message.data);
    }
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (socket);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketURL.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/createSocketURL.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
 // We handle legacy API that is Node.js specific, and a newer API that implements the same WHATWG URL Standard used by web browsers
// Please look at https://nodejs.org/api/url.html#url_url_strings_and_url_objects

function createSocketURL(parsedURL) {
  var hostname = parsedURL.hostname; // Node.js module parses it as `::`
  // `new URL(urlString, [baseURLstring])` parses it as '[::]'

  var isInAddrAny = hostname === "0.0.0.0" || hostname === "::" || hostname === "[::]"; // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384

  if (isInAddrAny && self.location.hostname && self.location.protocol.indexOf("http") === 0) {
    hostname = self.location.hostname;
  }

  var socketURLProtocol = parsedURL.protocol || self.location.protocol; // When https is used in the app, secure web sockets are always necessary because the browser doesn't accept non-secure web sockets.

  if (socketURLProtocol === "auto:" || hostname && isInAddrAny && self.location.protocol === "https:") {
    socketURLProtocol = self.location.protocol;
  }

  socketURLProtocol = socketURLProtocol.replace(/^(?:http|.+-extension|file)/i, "ws");
  var socketURLAuth = ""; // `new URL(urlString, [baseURLstring])` doesn't have `auth` property
  // Parse authentication credentials in case we need them

  if (parsedURL.username) {
    socketURLAuth = parsedURL.username; // Since HTTP basic authentication does not allow empty username,
    // we only include password if the username is not empty.

    if (parsedURL.password) {
      // Result: <username>:<password>
      socketURLAuth = socketURLAuth.concat(":", parsedURL.password);
    }
  } // In case the host is a raw IPv6 address, it can be enclosed in
  // the brackets as the brackets are needed in the final URL string.
  // Need to remove those as url.format blindly adds its own set of brackets
  // if the host string contains colons. That would lead to non-working
  // double brackets (e.g. [[::]]) host
  //
  // All of these web socket url params are optionally passed in through resourceQuery,
  // so we need to fall back to the default if they are not provided


  var socketURLHostname = (hostname || self.location.hostname || "localhost").replace(/^\[(.*)\]$/, "$1");
  var socketURLPort = parsedURL.port;

  if (!socketURLPort || socketURLPort === "0") {
    socketURLPort = self.location.port;
  } // If path is provided it'll be passed in via the resourceQuery as a
  // query param so it has to be parsed out of the querystring in order for the
  // client to open the socket to the correct location.


  var socketURLPathname = "/ws";

  if (parsedURL.pathname && !parsedURL.fromCurrentScript) {
    socketURLPathname = parsedURL.pathname;
  }

  return url__WEBPACK_IMPORTED_MODULE_0__.format({
    protocol: socketURLProtocol,
    auth: socketURLAuth,
    hostname: socketURLHostname,
    port: socketURLPort,
    pathname: socketURLPathname,
    slashes: true
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSocketURL);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!********************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute("src");
  } // Fallback to getting all scripts running in the document.


  var scriptElements = document.scripts || [];
  var scriptElementsWithSrc = Array.prototype.filter.call(scriptElements, function (element) {
    return element.getAttribute("src");
  });

  if (scriptElementsWithSrc.length > 0) {
    var currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];
    return currentScript.getAttribute("src");
  } // Fail as there was no script to use.


  throw new Error("[webpack-dev-server] Failed to get current script source.");
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getCurrentScriptSource);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/log.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "setLogLevel": () => (/* binding */ setLogLevel)
/* harmony export */ });
/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/logger/index.js */ "./node_modules/webpack-dev-server/client/modules/logger/index.js");
/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__);

var name = "webpack-dev-server"; // default level is set on the client side, so it does not need
// to be set by the CLI or API

var defaultLevel = "info";

function setLogLevel(level) {
  _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().configureDefaultLogger({
    level: level
  });
}

setLogLevel(defaultLevel);
var log = _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().getLogger(name);


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/parseURL.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/parseURL.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
/* harmony import */ var _getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCurrentScriptSource.js */ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js");



function parseURL(resourceQuery) {
  var options = {};

  if (typeof resourceQuery === "string" && resourceQuery !== "") {
    var searchParams = resourceQuery.substr(1).split("&");

    for (var i = 0; i < searchParams.length; i++) {
      var pair = searchParams[i].split("=");
      options[pair[0]] = decodeURIComponent(pair[1]);
    }
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptSource = (0,_getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_1__["default"])();

    if (scriptSource) {
      var scriptSourceURL;

      try {
        // The placeholder `baseURL` with `window.location.href`,
        // is to allow parsing of path-relative or protocol-relative URLs,
        // and will have no effect if `scriptSource` is a fully valid URL.
        scriptSourceURL = new URL(scriptSource, self.location.href);
      } catch (error) {// URL parsing failed, do nothing.
        // We will still proceed to see if we can recover using `resourceQuery`
      }

      if (scriptSourceURL) {
        options = scriptSourceURL;
        options.fromCurrentScript = true;
      }
    } else {
      options = url__WEBPACK_IMPORTED_MODULE_0__.parse(self.location.href, true, true);
      options.fromCurrentScript = true;
    }
  }

  return options;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseURL);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/reloadApp.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/emitter.js */ "./node_modules/webpack/hot/emitter.js");
/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
/* global __webpack_hash__ */



function reloadApp(_ref, status) {
  var hot = _ref.hot,
      liveReload = _ref.liveReload;

  if (status.isUnloading) {
    return;
  }

  var currentHash = status.currentHash,
      previousHash = status.previousHash;
  var isInitial = currentHash.indexOf(previousHash) >= 0;

  if (isInitial) {
    return;
  }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info("App updated. Reloading...");
    rootWindow.location.reload();
  }

  var search = self.location.search.toLowerCase();
  var allowToHot = search.indexOf("webpack-dev-server-hot=false") === -1;
  var allowToLiveReload = search.indexOf("webpack-dev-server-live-reload=false") === -1;

  if (hot && allowToHot) {
    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info("App hot update...");
    webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default().emit("webpackHotUpdate", status.currentHash);

    if (typeof self !== "undefined" && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(status.currentHash), "*");
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload && allowToLiveReload) {
    var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

    var intervalId = self.setInterval(function () {
      if (rootWindow.location.protocol !== "about:") {
        // reload immediately if protocol is valid
        applyReload(rootWindow, intervalId);
      } else {
        rootWindow = rootWindow.parent;

        if (rootWindow.parent === rootWindow) {
          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
          applyReload(rootWindow, intervalId);
        }
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reloadApp);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/sendMessage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* global __resourceQuery WorkerGlobalScope */
// Send messages to the outside, so plugins can consume it.
function sendMsg(type, data) {
  if (typeof self !== "undefined" && (typeof WorkerGlobalScope === "undefined" || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, "*");
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sendMsg);

/***/ }),

/***/ "./node_modules/webpack/hot/dev-server.js":
/*!************************************************!*\
  !*** ./node_modules/webpack/hot/dev-server.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

/* globals __webpack_hash__ */
if (true) {
  var lastHash;

  var upToDate = function upToDate() {
    return lastHash.indexOf(__webpack_require__.h()) >= 0;
  };

  var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

  var check = function check() {
    module.hot.check(true).then(function (updatedModules) {
      if (!updatedModules) {
        log("warning", "[HMR] Cannot find update. Need to do a full reload!");
        log("warning", "[HMR] (Probably because of restarting the webpack-dev-server)");
        window.location.reload();
        return;
      }

      if (!upToDate()) {
        check();
      }

      __webpack_require__(/*! ./log-apply-result */ "./node_modules/webpack/hot/log-apply-result.js")(updatedModules, updatedModules);

      if (upToDate()) {
        log("info", "[HMR] App is up to date.");
      }
    }).catch(function (err) {
      var status = module.hot.status();

      if (["abort", "fail"].indexOf(status) >= 0) {
        log("warning", "[HMR] Cannot apply update. Need to do a full reload!");
        log("warning", "[HMR] " + log.formatError(err));
        window.location.reload();
      } else {
        log("warning", "[HMR] Update failed: " + log.formatError(err));
      }
    });
  };

  var hotEmitter = __webpack_require__(/*! ./emitter */ "./node_modules/webpack/hot/emitter.js");

  hotEmitter.on("webpackHotUpdate", function (currentHash) {
    lastHash = currentHash;

    if (!upToDate() && module.hot.status() === "idle") {
      log("info", "[HMR] Checking for updates on the server...");
      check();
    }
  });
  log("info", "[HMR] Waiting for update signal from WDS...");
} else {}

/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!*********************************************!*\
  !*** ./node_modules/webpack/hot/emitter.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

module.exports = new EventEmitter();

/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!******************************************************!*\
  !*** ./node_modules/webpack/hot/log-apply-result.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function (updatedModules, renewedModules) {
  var unacceptedModules = updatedModules.filter(function (moduleId) {
    return renewedModules && renewedModules.indexOf(moduleId) < 0;
  });

  var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

  if (unacceptedModules.length > 0) {
    log("warning", "[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
    unacceptedModules.forEach(function (moduleId) {
      log("warning", "[HMR]  - " + moduleId);
    });
  }

  if (!renewedModules || renewedModules.length === 0) {
    log("info", "[HMR] Nothing hot updated.");
  } else {
    log("info", "[HMR] Updated modules:");
    renewedModules.forEach(function (moduleId) {
      if (typeof moduleId === "string" && moduleId.indexOf("!") !== -1) {
        var parts = moduleId.split("!");
        log.groupCollapsed("info", "[HMR]  - " + parts.pop());
        log("info", "[HMR]  - " + moduleId);
        log.groupEnd("info");
      } else {
        log("info", "[HMR]  - " + moduleId);
      }
    });
    var numberIds = renewedModules.every(function (moduleId) {
      return typeof moduleId === "number";
    });
    if (numberIds) log("info", '[HMR] Consider using the optimization.moduleIds: "named" for module names.');
  }
};

/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
  var shouldLog = logLevel === "info" && level === "info" || ["info", "warning"].indexOf(logLevel) >= 0 && level === "warning" || ["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error";
  return shouldLog;
}

function logGroup(logFn) {
  return function (level, msg) {
    if (shouldLog(level)) {
      logFn(msg);
    }
  };
}

module.exports = function (level, msg) {
  if (shouldLog(level)) {
    if (level === "info") {
      console.log(msg);
    } else if (level === "warning") {
      console.warn(msg);
    } else if (level === "error") {
      console.error(msg);
    }
  }
};
/* eslint-disable node/no-unsupported-features/node-builtins */


var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);
module.exports.groupCollapsed = logGroup(groupCollapsed);
module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function (level) {
  logLevel = level;
};

module.exports.formatError = function (err) {
  var message = err.message;
  var stack = err.stack;

  if (!stack) {
    return message;
  } else if (stack.indexOf(message) < 0) {
    return message + "\n" + stack;
  } else {
    return stack;
  }
};

/***/ }),

/***/ "./styles/index.scss":
/*!***************************!*\
  !*** ./styles/index.scss ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin

    if(true) {
      // 1634602689547
      var cssReload = __webpack_require__(/*! ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js */ "./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js")(module.id, {"publicPath":"","locals":false});
      module.hot.dispose(cssReload);
      module.hot.accept(undefined, cssReload);
    }
  

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("aa2acd541a63d604d034")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "floema:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises;
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 					blockingPromises.push(promise);
/******/ 					waitForBlockingPromises(function () {
/******/ 						return setStatus("ready");
/******/ 					});
/******/ 					return promise;
/******/ 				case "prepare":
/******/ 					blockingPromises.push(promise);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises.length === 0) return fn();
/******/ 			var blocker = blockingPromises;
/******/ 			blockingPromises = [];
/******/ 			return Promise.all(blocker).then(function () {
/******/ 				return waitForBlockingPromises(fn);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						blockingPromises = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error("apply() is only allowed in ready status");
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		var createStylesheet = (chunkId, fullhref, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			document.head.appendChild(linkTag);
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// no chunk loading
/******/ 		
/******/ 		var oldTags = [];
/******/ 		var newTags = [];
/******/ 		var applyHandler = (options) => {
/******/ 			return { dispose: () => {
/******/ 				for(var i = 0; i < oldTags.length; i++) {
/******/ 					var oldTag = oldTags[i];
/******/ 					if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);
/******/ 				}
/******/ 				oldTags.length = 0;
/******/ 			}, apply: () => {
/******/ 				for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";
/******/ 				newTags.length = 0;
/******/ 			} };
/******/ 		}
/******/ 		__webpack_require__.hmrC.miniCss = (chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) => {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			chunkIds.forEach((chunkId) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var oldTag = findStylesheet(href, fullhref);
/******/ 				if(!oldTag) return;
/******/ 				promises.push(new Promise((resolve, reject) => {
/******/ 					var tag = createStylesheet(chunkId, fullhref, () => {
/******/ 						tag.as = "style";
/******/ 						tag.rel = "preload";
/******/ 						resolve();
/******/ 					}, reject);
/******/ 					oldTags.push(oldTag);
/******/ 					newTags.push(tag);
/******/ 				}));
/******/ 			});
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId) {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdatefloema"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						!__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						__webpack_require__.o(installedChunks, chunkId) &&
/******/ 						installedChunks[chunkId] !== undefined
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info");
/******/ 	__webpack_require__("./node_modules/webpack/hot/dev-server.js");
/******/ 	__webpack_require__("./app/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./styles/index.scss");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLG1CQUFtQiwyQkFBMkI7V0FDOUM7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTDtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0Esa0JBQWtCLGNBQWM7V0FDaEM7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBLGNBQWMsTUFBTTtXQUNwQjtXQUNBO1dBQ0E7V0FDQSxLQUFLO1dBQ0w7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGNBQWMsYUFBYTtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dB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L2FwcC9jbGFzc2VzL0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9hcHAvY2xhc3Nlcy9QYWdlLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL2FwcC9jb21wb25lbnRzL1ByZWxvYWRlci5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9hcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vYXBwL3BhZ2VzL0Fib3V0L2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL2FwcC9wYWdlcy9Db2xsZWN0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9hcHAvcGFnZXMvRGV0YWlsL2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL2FwcC9wYWdlcy9Ib21lL2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL2FwcC91dGlscy90ZXh0LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwtY29tbXVuaXR5L2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9nc2FwL0NTU1BsdWdpbi5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvZ3NhcC9nc2FwLWNvcmUuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2dzYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9uYW1lZC1yZWZlcmVuY2VzLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9udW1lcmljLXVuaWNvZGUtbWFwLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9zdXJyb2dhdGUtcGFpcnMuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdEZ1bmN0aW9uLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VhY2guanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mb3JFYWNoLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvbm9ybWFsaXplLXVybC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvcHJlZml4L2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3VybC9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L2NsaWVudHMvV2ViU29ja2V0Q2xpZW50LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L21vZHVsZXMvbG9nZ2VyL2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9jcmVhdGVTb2NrZXRVUkwuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvZ2V0Q3VycmVudFNjcmlwdFNvdXJjZS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9sb2cuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvcGFyc2VVUkwuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvcmVsb2FkQXBwLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3NlbmRNZXNzYWdlLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9kZXYtc2VydmVyLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9lbWl0dGVyLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9sb2cuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vc3R5bGVzL2luZGV4LnNjc3MiLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvZ2V0IGphdmFzY3JpcHQgdXBkYXRlIGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvZ2V0IG1pbmktY3NzIGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvZ2V0IHVwZGF0ZSBtYW5pZmVzdCBmaWxlbmFtZSIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2dldEZ1bGxIYXNoIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvbG9hZCBzY3JpcHQiLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svcnVudGltZS9ob3QgbW9kdWxlIHJlcGxhY2VtZW50Iiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2NzcyBsb2FkaW5nIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnXG5cbmltcG9ydCBlYWNoIGZyb20gJ2xvZGFzaC9lYWNoJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBlbGVtZW50LCBlbGVtZW50cyB9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5zZWxlY3RvciA9IGVsZW1lbnRcbiAgICB0aGlzLnNlbGVjdG9yQ2hpbGRyZW4gPSB7XG4gICAgICAuLi5lbGVtZW50c1xuICAgIH1cblxuICAgIHRoaXMuY3JlYXRlKClcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgY3JlYXRlICgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3IpXG4gICAgdGhpcy5lbGVtZW50cyA9IHt9XG5cbiAgICBlYWNoKHRoaXMuc2VsZWN0b3JDaGlsZHJlbiwgKGVudHJ5LCBrZXkpID0+IHtcbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCB8fCBlbnRyeSBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdCB8fCBBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2tleV0gPSBlbnRyeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1trZXldID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbnRyeSlcblxuICAgICAgICBpZiAodGhpcy5lbGVtZW50c1trZXldLmxlbmdodCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNba2V5XSA9IG51bGxcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnRzW2tleV0gPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzW2tleV0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVudHJ5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzICgpIHtcblxuICB9XG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgKCkge1xuXG4gIH1cbn1cbiIsImltcG9ydCBHU0FQIGZyb20gJ2dzYXAnXG5cbmltcG9ydCBlYWNoIGZyb20gJ2xvZGFzaC9lYWNoJ1xuXG5pbXBvcnQgUHJlZml4IGZyb20gJ3ByZWZpeCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZSB7XG4gIGNvbnN0cnVjdG9yICh7IGlkLCBlbGVtZW50LCBlbGVtZW50cyB9KSB7XG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5zZWxlY3RvciA9IGVsZW1lbnRcbiAgICB0aGlzLnNlbGVjdG9yQ2hpbGRyZW4gPSB7XG4gICAgICAuLi5lbGVtZW50c1xuICAgIH1cblxuICAgIHRoaXMuc2Nyb2xsID0ge1xuICAgICAgY3VycmVudDogMCxcbiAgICAgIHRhcmdldDogMCxcbiAgICAgIGxhc3Q6IDBcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zZm9ybVByZWZpeCA9IFByZWZpeCgndHJhbnNmb3JtJylcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICAgIHRoaXMub25Nb3VzZVdoZWVsKClcbiAgICB0aGlzLnVwZGF0ZSgpXG4gIH1cblxuICBjcmVhdGUgKCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5zZWxlY3RvcilcbiAgICB0aGlzLmVsZW1lbnRzID0ge31cblxuICAgIGVhY2godGhpcy5zZWxlY3RvckNoaWxkcmVuLCAoZW50cnksIGtleSkgPT4ge1xuICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50IHx8IGVudHJ5IGluc3RhbmNlb2Ygd2luZG93Lk5vZGVMaXN0IHx8IEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNba2V5XSA9IGVudHJ5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2tleV0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVudHJ5KVxuXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2tleV0ubGVuZ2h0ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50c1trZXldID0gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWxlbWVudHNba2V5XSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNba2V5XSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZW50cnkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2hvdyAoKSB7XG4gICAgdGhpcy5hbmltYXRlSW4gPSBHU0FQLnRpbWVsaW5lKClcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIEdTQVAuZnJvbSh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgYXV0b0FscGhhOiAwLFxuICAgICAgICBvbkNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoaWRlICgpIHtcbiAgICB0aGlzLmFuaW1hdGVPdXQgPSBHU0FQLnRpbWVsaW5lKClcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIEdTQVAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIGF1dG9BbHBoYTogMCxcbiAgICAgICAgb25Db21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlICgpIHtcbiAgICB0aGlzLnNjcm9sbC5jdXJyZW50ID0gR1NBUC51dGlscy5pbnRlcnBvbGF0ZSh0aGlzLnNjcm9sbC5jdXJyZW50LCB0aGlzLnNjcm9sbC50YXJnZXQsIDAuMSlcbi8qIFxuICAgIGlmICh0aGlzLmVsZW1lbnRzLndyYXBwZXIpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMud3JhcHBlci5zdHlsZVt0aGlzLnRyYW5zZm9ybVByZWZpeF0gPSBgdHJhbnNsYXRlWCgke3RoaXMuc2Nyb2xsLmN1cnJlbnR9cHgpYFxuICAgIH0gKi9cbiAgfVxuXG4gIG9uTW91c2VXaGVlbCAoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZyhldmVudClcbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzICgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uTW91c2VXaGVlbClcbiAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICdjbGFzc2VzL0NvbXBvbmVudCdcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IHsgc3BsaXQgfSBmcm9tICd1dGlscy90ZXh0J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVsb2FkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgZWxlbWVudDogJy5wcmVsb2FkZXInLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgdGl0bGU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcmVsb2FkZXJfX3RleHQnKSxcbiAgICAgICAgbnVtYmVyOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJlbG9hZGVyX19udW1iZXInKSxcbiAgICAgICAgaW1hZ2VzOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmxlbmd0aCA9IDBcblxuICAgIHRoaXMuY3JlYXRlTG9hZGVyKClcblxuICAgIHNwbGl0KHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudHMudGl0bGUsXG4gICAgICBleHByZXNzaW9uOiAnPGJyPidcbiAgICB9KVxuXG4gICAgc3BsaXQoe1xuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50cy50aXRsZSxcbiAgICAgIGV4cHJlc3Npb246ICc8YnI+J1xuICAgIH0pXG5cbiAgICB0aGlzLmVsZW1lbnRzLnRpdGxlU3BhbnMgPSB0aGlzLmVsZW1lbnRzLnRpdGxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NwYW4gc3BhbicpXG4gIH1cblxuICBvbkFzc2V0TG9hZGVkIChpbWFnZSkge1xuICAgIHRoaXMubGVuZ3RoICs9IDFcbiAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5yb3VuZCh0aGlzLmxlbmd0aCAvIHRoaXMuZWxlbWVudHMuaW1hZ2VzLmxlbmd0aCAqIDEwMClcblxuICAgIHRoaXMuZWxlbWVudHMubnVtYmVyLmlubmVySFRNTCA9IGAke3BlcmNlbnR9JWBcblxuICAgIGlmIChwZXJjZW50ID09PSAxMDApIHtcbiAgICAgIHRoaXMub25Mb2FkZWQoKVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUxvYWRlciAoKSB7XG4gICAgZWFjaCh0aGlzLmVsZW1lbnRzLmltYWdlcywgZWxlbWVudCA9PiB7XG4gICAgICBlbGVtZW50LnNyYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpXG4gICAgICBlbGVtZW50Lm9ubG9hZCA9IF8gPT4gdGhpcy5vbkFzc2V0TG9hZGVkKGVsZW1lbnQpXG4gICAgfSlcbiAgfVxuXG4gIG9uTG9hZGVkICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAvKiAgdGhpcy5hbmltYXRlT3V0LnRvKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBhdXRvQWxwaGE6IDAsXG4gICAgICAgIGRlbGF5OiAyXG4gICAgICB9KSAqL1xuXG4gICAgICB0aGlzLmFuaW1hdGVPdXQgPSBnc2FwLnRpbWVsaW5lKClcblxuICAgICAgdGhpcy5hbmltYXRlT3V0LnRvKHRoaXMuZWxlbWVudHMudGl0bGVTcGFucywge1xuICAgICAgICBzdGFnZ2VyOiAwLjEsXG4gICAgICAgIGR1cmF0aW9uOiAxLjUsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCcsXG4gICAgICAgIHk6ICcxMDAlJ1xuICAgICAgfSlcblxuICAgICAgdGhpcy5hbmltYXRlT3V0LnRvKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBzY2FsZVk6IDAsXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJzAgMCcsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudClcbiAgfVxufVxuIiwiaW1wb3J0IEFib3V0IGZyb20gJy4vcGFnZXMvQWJvdXQnXG5pbXBvcnQgRGV0YWlsIGZyb20gJy4vcGFnZXMvRGV0YWlsJ1xuaW1wb3J0IENvbGxlY3Rpb25zIGZyb20gJy4vcGFnZXMvQ29sbGVjdGlvbnMnXG5pbXBvcnQgSG9tZSBmcm9tICcuL3BhZ2VzL0hvbWUnXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IFByZWxvYWRlciBmcm9tICdjb21wb25lbnRzL1ByZWxvYWRlcidcblxuY2xhc3MgQXBwIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY3JlYXRlQ29udGVudCgpXG4gICAgdGhpcy5jcmVhdGVQYWdlcygpXG4gICAgdGhpcy5hZGRMaW5rTGlzdGVuZXJzKClcbiAgICB0aGlzLnVwZGF0ZSgpXG4gIH1cblxuICBjcmVhdGVDb250ZW50ICgpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGVudCcpXG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMuY29udGVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGVtcGxhdGUnKVxuICB9XG5cbiAgY3JlYXRlUGFnZXMgKCkge1xuICAgIHRoaXMucGFnZXMgPSB7XG4gICAgICBob21lOiBuZXcgSG9tZSgpLFxuICAgICAgY29sbGVjdGlvbnM6IG5ldyBDb2xsZWN0aW9ucygpLFxuICAgICAgYWJvdXQ6IG5ldyBBYm91dCgpLFxuICAgICAgZGV0YWlsOiBuZXcgRGV0YWlsKClcbiAgICB9XG5cbiAgICB0aGlzLnBhZ2UgPSB0aGlzLnBhZ2VzW3RoaXMudGVtcGxhdGVdXG4gICAgdGhpcy5wYWdlLmNyZWF0ZSgpXG4gICAgdGhpcy5wYWdlLnNob3coKVxuICB9XG5cbiAgYXN5bmMgb25DaGFuZ2UgKHVybCkge1xuICAgIHRoaXMucGFnZS5oaWRlKClcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgd2luZG93LmZldGNoKHVybClcblxuICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBjb25zdCBuZXh0UGFnZSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpXG5cbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBkaXYuaW5uZXJIVE1MID0gbmV4dFBhZ2VcblxuICAgICAgY29uc3QgZGl2Q29udGVudCA9IGRpdi5xdWVyeVNlbGVjdG9yKCcuY29udGVudCcpXG4gICAgICB0aGlzLmNvbnRlbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRlbXBsYXRlJywgZGl2Q29udGVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGVtcGxhdGUnKSlcbiAgICAgIHRoaXMuY29udGVudC5pbm5lckhUTUwgPSBkaXZDb250ZW50LmlubmVySFRNTFxuXG4gICAgICB0aGlzLnBhZ2UuY3JlYXRlKClcbiAgICAgIHRoaXMucGFnZS5zaG93KClcbiAgICAgIHRoaXMuYWRkTGlua0xpc3RlbmVycygpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEZXUgcGF1LCBiaXhvISEnKVxuICAgIH1cbiAgfVxuXG4gIGFkZExpbmtMaXN0ZW5lcnMgKCkge1xuICAgIGNvbnN0IGxpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYScpXG5cbiAgICBlYWNoKGxpbmtzLCBsaW5rID0+IHtcbiAgICAgIGxpbmsub25jbGljayA9IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gbGlua1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKGhyZWYpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHVwZGF0ZSAoKSB7XG4gICAgaWYgKHRoaXMucGFnZSAmJiB0aGlzLnBhZ2UudXBkYXRlKSB7XG4gICAgICB0aGlzLnBhZ2UudXBkYXRlKClcbiAgICB9XG4gICAgdGhpcy5mcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUuYmluZCh0aGlzKSlcbiAgfVxufVxuXG4vKiBlc2xpbnQgbm8tbmV3OiBcIm9mZlwiICovXG5uZXcgQXBwKClcbiIsImltcG9ydCBQYWdlIGZyb20gJ2NsYXNzZXMvUGFnZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWJvdXQgZXh0ZW5kcyBQYWdlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIGlkOiAnYWJvdXQnLFxuICAgICAgZWxlbWVudDogJy5hYm91dCcsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICB3cmFwcGVyOiAnLmFib3V0X193cmFwcGVyJyxcbiAgICAgICAgbmF2aWdhdGlvbjogJy5uYXZpZ2F0aW9uJyxcbiAgICAgICAgdGl0bGU6ICcuYWJvdXRfX3RpdGxlJ1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCBQYWdlIGZyb20gJ2NsYXNzZXMvUGFnZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sbGVjdGlvbnMgZXh0ZW5kcyBQYWdlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIGlkOiAnY29sbGVjdGlvbnMnLFxuICAgICAgZWxlbWVudDogJy5jb2xsZWN0aW9ucycsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICB3cmFwcGVyOiAnLmNvbGxlY3Rpb25zX193cmFwcGVyJ1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCBQYWdlIGZyb20gJ2NsYXNzZXMvUGFnZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGV0YWlsIGV4dGVuZHMgUGFnZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcih7XG4gICAgICBpZDogJ2RldGFpbCcsXG4gICAgICBlbGVtZW50OiAnLmRldGFpbCdcbiAgICB9KVxuICB9XG59XG4iLCJpbXBvcnQgUGFnZSBmcm9tICdjbGFzc2VzL1BhZ2UnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhvbWUgZXh0ZW5kcyBQYWdlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIGlkOiAnaG9tZScsXG4gICAgICBlbGVtZW50OiAnLmhvbWUnLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbmF2aWdhdGlvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5hdmlnYXRpb24nKSxcbiAgICAgICAgbGluazogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhvbWVfX2xpbmsnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjcmVhdGUgKCkge1xuICAgIHN1cGVyLmNyZWF0ZSgpXG4gIH1cbn1cbiIsImltcG9ydCBlYWNoIGZyb20gJ2xvZGFzaC9lYWNoJ1xuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXQgKHsgZWxlbWVudCwgZXhwcmVzc2lvbiA9ICcgJywgYXBwZW5kID0gdHJ1ZSB9KSB7XG4gIGNvbnN0IHdvcmRzID0gc3BsaXRUZXh0KGVsZW1lbnQuaW5uZXJIVE1MLnRvU3RyaW5nKCkudHJpbSgpLCBleHByZXNzaW9uKVxuXG4gIGxldCBpbm5lckhUTUwgPSAnJ1xuXG4gIGVhY2god29yZHMsIGxpbmUgPT4ge1xuICAgIGlmIChsaW5lLmluZGV4T2YoJzxicj4nKSA+IC0xKSB7XG4gICAgICBjb25zdCBsaW5lcyA9IGxpbmUuc3BsaXQoJzxicj4nKVxuXG4gICAgICBlYWNoKGxpbmVzLCAobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgaW5uZXJIVE1MICs9IChpbmRleCA+IDApID8gJzxicj4nICsgcGFyc2VMaW5lKGxpbmUpIDogcGFyc2VMaW5lKGxpbmUpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lckhUTUwgKz0gcGFyc2VMaW5lKGxpbmUpXG4gICAgfVxuICB9KVxuXG4gIGVsZW1lbnQuaW5uZXJIVE1MID0gaW5uZXJIVE1MXG5cbiAgY29uc3Qgc3BhbnMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NwYW4nKVxuXG4gIGlmIChhcHBlbmQpIHtcbiAgICBlYWNoKHNwYW5zLCBzcGFuID0+IHtcbiAgICAgIGNvbnN0IGlzU2luZ2xlTGV0dGVyID0gc3Bhbi50ZXh0Q29udGVudC5sZW5ndGggPT09IDFcbiAgICAgIGNvbnN0IGlzTm90RW1wdHkgPSBzcGFuLmlubmVySFRNTC50cmltKCkgIT09ICcnXG4gICAgICBjb25zdCBpc05vdEFuZENoYXJhY3RlciA9IHNwYW4udGV4dENvbnRlbnQgIT09ICcmJ1xuICAgICAgY29uc3QgaXNOb3REYXNoQ2hhcmFjdGVyID0gc3Bhbi50ZXh0Q29udGVudCAhPT0gJy0nXG5cbiAgICAgIGlmIChpc1NpbmdsZUxldHRlciAmJiBpc05vdEVtcHR5ICYmIGlzTm90QW5kQ2hhcmFjdGVyICYmIGlzTm90RGFzaENoYXJhY3Rlcikge1xuICAgICAgICBzcGFuLmlubmVySFRNTCA9IGAke3NwYW4udGV4dENvbnRlbnR9Jm5ic3A7YFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gc3BhbnNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZSAoc3BhbnMpIHtcbiAgY29uc3QgbGluZXMgPSBbXVxuICBsZXQgd29yZHMgPSBbXVxuXG4gIGxldCBwb3NpdGlvbiA9IHNwYW5zWzBdLm9mZnNldFRvcFxuXG4gIGVhY2goc3BhbnMsIChzcGFuLCBpbmRleCkgPT4ge1xuICAgIGlmIChzcGFuLm9mZnNldFRvcCA9PT0gcG9zaXRpb24pIHtcbiAgICAgIHdvcmRzLnB1c2goc3BhbilcbiAgICB9XG5cbiAgICBpZiAoc3Bhbi5vZmZzZXRUb3AgIT09IHBvc2l0aW9uKSB7XG4gICAgICBsaW5lcy5wdXNoKHdvcmRzKVxuXG4gICAgICB3b3JkcyA9IFtdXG4gICAgICB3b3Jkcy5wdXNoKHNwYW4pXG5cbiAgICAgIHBvc2l0aW9uID0gc3Bhbi5vZmZzZXRUb3BcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBzcGFucy5sZW5ndGgpIHtcbiAgICAgIGxpbmVzLnB1c2god29yZHMpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBsaW5lc1xufVxuXG5mdW5jdGlvbiBzcGxpdFRleHQgKHRleHQsIGV4cHJlc3Npb24pIHtcbiAgY29uc3Qgc3BsaXRzID0gdGV4dC5zcGxpdCgnPGJyPicpXG5cbiAgbGV0IHdvcmRzID0gW11cblxuICBlYWNoKHNwbGl0cywgKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgd29yZHMucHVzaCgnPGJyPicpXG4gICAgfVxuXG4gICAgd29yZHMgPSB3b3Jkcy5jb25jYXQoaXRlbS5zcGxpdChleHByZXNzaW9uKSlcblxuICAgIGxldCBpc0xpbmsgPSBmYWxzZVxuICAgIGxldCBsaW5rID0gJydcblxuICAgIGNvbnN0IGlubmVySFRNTCA9IFtdXG5cbiAgICBlYWNoKHdvcmRzLCB3b3JkID0+IHtcbiAgICAgIGlmICghaXNMaW5rICYmICh3b3JkLmluY2x1ZGVzKCc8YScpIHx8IHdvcmQuaW5jbHVkZXMoJzxzdHJvbmcnKSkpIHtcbiAgICAgICAgbGluayA9ICcnXG5cbiAgICAgICAgaXNMaW5rID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMaW5rKSB7XG4gICAgICAgIGxpbmsgKz0gYCAke3dvcmR9YFxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMaW5rICYmICh3b3JkLmluY2x1ZGVzKCcvYT4nKSB8fCB3b3JkLmluY2x1ZGVzKCcvc3Ryb25nPicpKSkge1xuICAgICAgICBpbm5lckhUTUwucHVzaChsaW5rKVxuXG4gICAgICAgIGxpbmsgPSAnJ1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTGluayAmJiBsaW5rID09PSAnJykge1xuICAgICAgICBpbm5lckhUTUwucHVzaCh3b3JkKVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMaW5rICYmICh3b3JkLmluY2x1ZGVzKCcvYT4nKSB8fCB3b3JkLmluY2x1ZGVzKCcvc3Ryb25nPicpKSkge1xuICAgICAgICBpc0xpbmsgPSBmYWxzZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB3b3JkcyA9IGlubmVySFRNTFxuICB9KVxuXG4gIHJldHVybiB3b3Jkc1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbmUgKGxpbmUpIHtcbiAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgcmV0dXJuIGxpbmVcbiAgfSBlbHNlIGlmIChsaW5lID09PSAnICcpIHtcbiAgICByZXR1cm4gJyZuYnNwOydcbiAgfSBlbHNlIHtcbiAgICBsaW5lID0gbGluZS50cmltKClcblxuICAgIHJldHVybiAobGluZSA9PT0gJzxicj4nKSA/ICc8YnI+JyA6IGA8c3Bhbj4ke2xpbmV9PC9zcGFuPmAgKyAoKGxpbmUubGVuZ3RoID4gMSkgPyAnICcgOiAnJylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKyltL2csIGZ1bmN0aW9uIChtYXRjaCwgc2VxKSB7XG4gICAgdmFyIG90ID0gX29wZW5UYWdzW3NlcV1cbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgICByZXR1cm4gJzwvc3Bhbj4nXG4gICAgICB9XG4gICAgICAvLyBPcGVuIHRhZy5cbiAgICAgIGFuc2lDb2Rlcy5wdXNoKHNlcSlcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPidcbiAgICB9XG5cbiAgICB2YXIgY3QgPSBfY2xvc2VUYWdzW3NlcV1cbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICByZXR1cm4gY3RcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0pXG5cbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cbiAgdmFyIGwgPSBhbnNpQ29kZXMubGVuZ3RoXG4gIDsobCA+IDApICYmIChyZXQgKz0gQXJyYXkobCArIDEpLmpvaW4oJzwvc3Bhbj4nKSlcblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQ3VzdG9taXplIGNvbG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgcmVmZXJlbmNlIHRvIF9kZWZDb2xvcnNcbiAqL1xuYW5zaUhUTUwuc2V0Q29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICBpZiAodHlwZW9mIGNvbG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bjb2xvcnNgIHBhcmFtZXRlciBtdXN0IGJlIGFuIE9iamVjdC4nKVxuICB9XG5cbiAgdmFyIF9maW5hbENvbG9ycyA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBfZGVmQ29sb3JzKSB7XG4gICAgdmFyIGhleCA9IGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29sb3JzW2tleV0gOiBudWxsXG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoJ3Jlc2V0JyA9PT0ga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gW2hleF1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJ1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgICB9XG4gICAgICB2YXIgZGVmSGV4Q29sb3IgPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdXG4gICAgICB9XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XG4gICAgICAgIGhleCA9IFtoZXhbMF1dXG4gICAgICAgIGhleC5wdXNoKGRlZkhleENvbG9yWzFdKVxuICAgICAgfVxuXG4gICAgICBoZXggPSBoZXguc2xpY2UoMCwgMilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleFxuICB9XG4gIF9zZXRUYWdzKF9maW5hbENvbG9ycylcbn1cblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKVxufVxuXG4vKipcbiAqIEV4cG9zZSB0YWdzLCBpbmNsdWRpbmcgb3BlbiBhbmQgY2xvc2UuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5hbnNpSFRNTC50YWdzID0ge31cblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ29wZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfb3BlblRhZ3MgfVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Nsb3NlVGFncyB9XG4gIH0pXG59IGVsc2Uge1xuICBhbnNpSFRNTC50YWdzLm9wZW4gPSBfb3BlblRhZ3NcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3Ncbn1cblxuZnVuY3Rpb24gX3NldFRhZ3MgKGNvbG9ycykge1xuICAvLyByZXNldCBhbGxcbiAgX29wZW5UYWdzWycwJ10gPSAnZm9udC13ZWlnaHQ6bm9ybWFsO29wYWNpdHk6MTtjb2xvcjojJyArIGNvbG9ycy5yZXNldFswXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFsxXVxuICAvLyBpbnZlcnNlXG4gIF9vcGVuVGFnc1snNyddID0gJ2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzFdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzBdXG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXlcblxuICBmb3IgKHZhciBjb2RlIGluIF9zdHlsZXMpIHtcbiAgICB2YXIgY29sb3IgPSBfc3R5bGVzW2NvZGVdXG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJ1xuICAgIF9vcGVuVGFnc1tjb2RlXSA9ICdjb2xvcjojJyArIG9yaUNvbG9yXG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUpXG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvclxuICB9XG59XG5cbmFuc2lIVE1MLnJlc2V0KClcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKiFcbiAqIENTU1BsdWdpbiAzLjguMFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0gLy9mb3IgdGhlIGNvbW1lbnRlZC1vdXQgY2xhc3NOYW1lIGZlYXR1cmUuXG59IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuXG52YXIgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbGVtZW50LFxuICAgIF9wbHVnaW5Jbml0dGVkLFxuICAgIF90ZW1wRGl2LFxuICAgIF90ZW1wRGl2U3R5bGVyLFxuICAgIF9yZWNlbnRTZXR0ZXJQbHVnaW4sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcHMgPSB7fSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX2hvcml6b250YWxFeHAgPSAvKD86bGVmdHxyaWdodHx3aWR0aHxtYXJnaW58cGFkZGluZ3x4KS9pLFxuICAgIF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXVxcUy8sXG4gICAgX3Byb3BlcnR5QWxpYXNlcyA9IHtcbiAgYXV0b0FscGhhOiBcIm9wYWNpdHksdmlzaWJpbGl0eVwiLFxuICBzY2FsZTogXCJzY2FsZVgsc2NhbGVZXCIsXG4gIGFscGhhOiBcIm9wYWNpdHlcIlxufSxcbiAgICBfcmVuZGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIC8vaWYgdW5pdHMgY2hhbmdlLCB3ZSBuZWVkIGEgd2F5IHRvIHJlbmRlciB0aGUgb3JpZ2luYWwgdW5pdC92YWx1ZSB3aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZyAocmF0aW86MClcbl9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJSb3VuZGVkQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLnMgKyBkYXRhLmMgKiByYXRpbztcbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIH5+KHZhbHVlICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gIT09IDEgPyBkYXRhLmIgOiBkYXRhLmUsIGRhdGEpO1xufSxcbiAgICBfc2V0dGVyQ1NTU3R5bGUgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTU3R5bGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckNTU1Byb3AgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTUHJvcCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXBbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwLnNjYWxlWCA9IHRhcmdldC5fZ3NhcC5zY2FsZVkgPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9zdXBwb3J0czNELFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XG4gIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgcmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICFza2lwUHJlZml4RmFsbGJhY2sgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSwgMSkgfHwgXCJcIjsgLy9jc3MgdmFyaWFibGVzIG1heSBub3QgbmVlZCBjYXBzIHN3YXBwZWQgb3V0IGZvciBkYXNoZXMgYW5kIGxvd2VyY2FzZS5cbn0sXG4gICAgX3ByZWZpeGVzID0gXCJPLE1veixtcyxNcyxXZWJraXRcIi5zcGxpdChcIixcIiksXG4gICAgX2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkge1xuICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXG4gICAgICBzID0gZS5zdHlsZSxcbiAgICAgIGkgPSA1O1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBzICYmICFwcmVmZXJQcmVmaXgpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXG4gIHdoaWxlIChpLS0gJiYgIShfcHJlZml4ZXNbaV0gKyBwcm9wZXJ0eSBpbiBzKSkge31cblxuICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gX3dpbi5kb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfHwge1xuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgICBfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XG4gICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICB9XG59LFxuICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIG9sZFBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSxcbiAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgb2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgYmJveDtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblxuICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcbiAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgfVxuXG4gIGlmIChvbGRQYXJlbnQpIHtcbiAgICBpZiAob2xkU2libGluZykge1xuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBvbGRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICByZXR1cm4gYmJveDtcbn0sXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgdmFyIGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICB2YXIgYm91bmRzO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IHRhcmdldC5nZXRCQm94ID09PSBfZ2V0QkJveEhhY2sgfHwgKGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSkpOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xuICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgeTogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsIFwiY3lcIiwgXCJ5MVwiXSkgfHwgMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IGJvdW5kcztcbn0sXG4gICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgcmV0dXJuICEhKGUuZ2V0Q1RNICYmICghZS5wYXJlbnROb2RlIHx8IGUub3duZXJTVkdFbGVtZW50KSAmJiBfZ2V0QkJveChlKSk7XG59LFxuICAgIC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5fcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG5cbiAgICBpZiAocHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCkge1xuICAgICAgcHJvcGVydHkgPSBfdHJhbnNmb3JtUHJvcDtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUucmVtb3ZlUHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eS5zdWJzdHIoMCwgMikgPT09IFwibXNcIiB8fCBwcm9wZXJ0eS5zdWJzdHIoMCwgNikgPT09IFwid2Via2l0XCIpIHtcbiAgICAgICAgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuICAgICAgICBwcm9wZXJ0eSA9IFwiLVwiICsgcHJvcGVydHk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25vdGU6IG9sZCB2ZXJzaW9ucyBvZiBJRSB1c2UgXCJyZW1vdmVBdHRyaWJ1dGUoKVwiIGluc3RlYWQgb2YgXCJyZW1vdmVQcm9wZXJ0eSgpXCJcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9hZGROb25Ud2VlbmluZ1BUID0gZnVuY3Rpb24gX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBiZWdpbm5pbmcsIGVuZCwgb25seVNldEF0RW5kKSB7XG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgb25seVNldEF0RW5kID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSk7XG4gIHBsdWdpbi5fcHQgPSBwdDtcbiAgcHQuYiA9IGJlZ2lubmluZztcbiAgcHQuZSA9IGVuZDtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX25vbkNvbnZlcnRpYmxlVW5pdHMgPSB7XG4gIGRlZzogMSxcbiAgcmFkOiAxLFxuICB0dXJuOiAxXG59LFxuICAgIC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cbl9jb252ZXJ0VG9Vbml0ID0gZnVuY3Rpb24gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIGN1clZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCxcbiAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgLy8gc29tZSBicm93c2VycyBsZWF2ZSBleHRyYSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ1NTIHZhcmlhYmxlcywgaGVuY2UgdGhlIG5lZWQgdG8gdHJpbSgpXG4gIHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG4gICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICBpc1Jvb3RTVkcgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiLFxuICAgICAgbWVhc3VyZVByb3BlcnR5ID0gKGlzUm9vdFNWRyA/IFwiY2xpZW50XCIgOiBcIm9mZnNldFwiKSArIChob3Jpem9udGFsID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIiksXG4gICAgICBhbW91bnQgPSAxMDAsXG4gICAgICB0b1BpeGVscyA9IHVuaXQgPT09IFwicHhcIixcbiAgICAgIHRvUGVyY2VudCA9IHVuaXQgPT09IFwiJVwiLFxuICAgICAgcHgsXG4gICAgICBwYXJlbnQsXG4gICAgICBjYWNoZSxcbiAgICAgIGlzU1ZHO1xuXG4gIGlmICh1bml0ID09PSBjdXJVbml0IHx8ICFjdXJWYWx1ZSB8fCBfbm9uQ29udmVydGlibGVVbml0c1t1bml0XSB8fCBfbm9uQ29udmVydGlibGVVbml0c1tjdXJVbml0XSkge1xuICAgIHJldHVybiBjdXJWYWx1ZTtcbiAgfVxuXG4gIGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMgJiYgKGN1clZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIFwicHhcIikpO1xuICBpc1NWRyA9IHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCk7XG5cbiAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgcHggPSBpc1NWRyA/IHRhcmdldC5nZXRCQm94KClbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIDogdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgcmV0dXJuIF9yb3VuZCh0b1BlcmNlbnQgPyBjdXJWYWx1ZSAvIHB4ICogYW1vdW50IDogY3VyVmFsdWUgLyAxMDAgKiBweCk7XG4gIH1cblxuICBzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG4gIHBhcmVudCA9IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG4gICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHB4ID0gX3RlbXBEaXZbbWVhc3VyZVByb3BlcnR5XTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogdmFsdWUuc3ZnID8gdmFsdWUub3JpZ2luIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcbn0sXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA9PT0gXCJub25lXCIpIHtcbiAgICAvLyBzb21lIGJyb3dzZXJzIGxpa2UgU2FmYXJpIGFjdHVhbGx5IFBSRUZFUiB0aGUgcHJlZml4ZWQgcHJvcGVydHkgYW5kIG1pcy1yZXBvcnQgdGhlIHVucHJlZml4ZWQgdmFsdWUgbGlrZSBjbGlwUGF0aCAoQlVHKS4gSW4gb3RoZXIgd29yZHMsIGV2ZW4gdGhvdWdoIGNsaXBQYXRoIGV4aXN0cyBpbiB0aGUgc3R5bGUgKFwiY2xpcFBhdGhcIiBpbiB0YXJnZXQuc3R5bGUpIGFuZCBpdCdzIHNldCBpbiB0aGUgQ1NTIHByb3Blcmx5IChhbG9uZyB3aXRoIC13ZWJraXQtY2xpcC1wYXRoKSwgU2FmYXJpIHJlcG9ydHMgY2xpcFBhdGggYXMgXCJub25lXCIgd2hlcmVhcyBXZWJraXRDbGlwUGF0aCByZXBvcnRzIGFjY3VyYXRlbHkgbGlrZSBcImVsbGlwc2UoMTAwJSAwJSBhdCA1MCUgMCUpXCIsIHNvIGluIHRoaXMgY2FzZSB3ZSBtdXN0IFNXSVRDSCB0byB1c2luZyB0aGUgcHJlZml4ZWQgcHJvcGVydHkgaW5zdGVhZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMTgzMTAtY2xpcHBhdGgtZG9lc250LXdvcmstb24taW9zL1xuICAgIHZhciBwID0gX2NoZWNrUHJvcFByZWZpeChwcm9wLCB0YXJnZXQsIDEpLFxuICAgICAgICBzID0gcCAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHAsIDEpO1xuXG4gICAgaWYgKHMgJiYgcyAhPT0gc3RhcnQpIHtcbiAgICAgIHByb3AgPSBwO1xuICAgICAgc3RhcnQgPSBzO1xuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJib3JkZXJDb2xvclwiKSB7XG4gICAgICBzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTsgLy8gRmlyZWZveCBidWc6IGFsd2F5cyByZXBvcnRzIFwiYm9yZGVyQ29sb3JcIiBhcyBcIlwiLCBzbyB3ZSBtdXN0IGZhbGwgYmFjayB0byBib3JkZXJUb3BDb2xvci4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuICAgIH1cbiAgfVxuXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBhLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnRWYWx1ZXMsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGNvbG9yLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBlbmRVbml0LFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBlbmRWYWx1ZXM7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBlbmQ7XG4gICAgZW5kID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB8fCBlbmQ7XG4gICAgdGFyZ2V0LnN0eWxlW3Byb3BdID0gc3RhcnQ7XG4gIH1cblxuICBhID0gW3N0YXJ0LCBlbmRdO1xuXG4gIF9jb2xvclN0cmluZ0ZpbHRlcihhKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLiBJZiBjb2xvcnMgYXJlIGZvdW5kLCBpdCByZXR1cm5zIHRydWUgYW5kIHRoZW4gd2UgbXVzdCBtYXRjaCB3aGVyZSB0aGUgY29sb3Igc2hvd3MgdXAgb3JkZXItd2lzZSBiZWNhdXNlIGZvciB0aGluZ3MgbGlrZSBib3hTaGFkb3csIHNvbWV0aW1lcyB0aGUgYnJvd3NlciBwcm92aWRlcyB0aGUgY29tcHV0ZWQgdmFsdWVzIHdpdGggdGhlIGNvbG9yIEZJUlNULCBidXQgdGhlIHVzZXIgcHJvdmlkZXMgaXQgd2l0aCB0aGUgY29sb3IgTEFTVCwgc28gZmxpcCB0aGVtIGlmIG5lY2Vzc2FyeS4gU2FtZSBmb3IgZHJvcC1zaGFkb3coKS5cblxuXG4gIHN0YXJ0ID0gYVswXTtcbiAgZW5kID0gYVsxXTtcbiAgc3RhcnRWYWx1ZXMgPSBzdGFydC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICBlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblxuICBpZiAoZW5kVmFsdWVzLmxlbmd0aCkge1xuICAgIHdoaWxlIChyZXN1bHQgPSBfbnVtV2l0aFVuaXRFeHAuZXhlYyhlbmQpKSB7XG4gICAgICBlbmRWYWx1ZSA9IHJlc3VsdFswXTtcbiAgICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIgfHwgY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJoc2xhKFwiKSB7XG4gICAgICAgIGNvbG9yID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZhbHVlICE9PSAoc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWVzW21hdGNoSW5kZXgrK10gfHwgXCJcIikpIHtcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XG4gICAgICAgIHN0YXJ0VW5pdCA9IHN0YXJ0VmFsdWUuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIHJlbGF0aXZlID0gZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/ICsoZW5kVmFsdWUuY2hhckF0KDApICsgXCIxXCIpIDogMDtcblxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLnN1YnN0cigyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgICBlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBpbmRleCA9IF9udW1XaXRoVW5pdEV4cC5sYXN0SW5kZXggLSBlbmRVbml0Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIWVuZFVuaXQpIHtcbiAgICAgICAgICAvL2lmIHNvbWV0aGluZyBsaWtlIFwicGVyc3BlY3RpdmU6MzAwXCIgaXMgcGFzc2VkIGluIGFuZCB3ZSBtdXN0IGFkZCBhIHVuaXQgdG8gdGhlIGVuZFxuICAgICAgICAgIGVuZFVuaXQgPSBlbmRVbml0IHx8IF9jb25maWcudW5pdHNbcHJvcF0gfHwgc3RhcnRVbml0O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgKz0gZW5kVW5pdDtcbiAgICAgICAgICAgIHB0LmUgKz0gZW5kVW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG4gICAgICAgIH0gLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG5cbiAgICAgICAgcHQuX3B0ID0ge1xuICAgICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgICAgYzogcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCB8fCBwcm9wID09PSBcInpJbmRleFwiID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG4gIH0gZWxzZSB7XG4gICAgcHQuciA9IHByb3AgPT09IFwiZGlzcGxheVwiICYmIGVuZCA9PT0gXCJub25lXCIgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlO1xuICB9XG5cbiAgX3JlbEV4cC50ZXN0KGVuZCkgJiYgKHB0LmUgPSAwKTsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9rZXl3b3JkVG9QZXJjZW50ID0ge1xuICB0b3A6IFwiMCVcIixcbiAgYm90dG9tOiBcIjEwMCVcIixcbiAgbGVmdDogXCIwJVwiLFxuICByaWdodDogXCIxMDAlXCIsXG4gIGNlbnRlcjogXCI1MCVcIlxufSxcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XG4gIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgIHggPSBzcGxpdFswXSxcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXG4gIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXG4gICAgdmFsdWUgPSB4O1xuICAgIHggPSB5O1xuICAgIHkgPSB2YWx1ZTtcbiAgfVxuXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcbiAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICByZXR1cm4gc3BsaXQuam9pbihcIiBcIik7XG59LFxuICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgaWYgKGRhdGEudHdlZW4gJiYgZGF0YS50d2Vlbi5fdGltZSA9PT0gZGF0YS50d2Vlbi5fZHVyKSB7XG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHByb3BzID0gZGF0YS51LFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgY2xlYXJUcmFuc2Zvcm1zLFxuICAgICAgICBpO1xuXG4gICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICBwcm9wID0gcHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTsgLy8gZm9yY2UgYWxsIHRoZSBjYWNoZWQgdmFsdWVzIGJhY2sgdG8gXCJub3JtYWxcIi9pZGVudGl0eSwgb3RoZXJ3aXNlIGlmIHRoZXJlJ3MgYW5vdGhlciB0d2VlbiB0aGF0J3MgYWxyZWFkeSBzZXQgdG8gcmVuZGVyIHRyYW5zZm9ybXMgb24gdGhpcyBlbGVtZW50LCBpdCBjb3VsZCBkaXNwbGF5IHRoZSB3cm9uZyB2YWx1ZXMuXG5cblxuICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgLy8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cbl9zcGVjaWFsUHJvcHMgPSB7XG4gIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XG4gICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICBwdC5wciA9IC0xMDtcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICAvKiBjbGFzc05hbWUgZmVhdHVyZSAoYWJvdXQgMC40a2IgZ3ppcHBlZCkuXG4gICwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcbiAgXHRcdFx0ZGF0YS5jc3MucmVuZGVyKHJhdGlvLCBkYXRhLmNzcyk7XG4gIFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG4gIFx0XHRcdFx0XHR0YXJnZXQgPSBkYXRhLnQsXG4gIFx0XHRcdFx0XHRwO1xuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG4gIFx0XHRcdFx0Zm9yIChwIGluIGlubGluZSkge1xuICBcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcbiAgXHRcdFx0bGV0IHN0eWxlcyA9IHt9LFxuICBcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICBcdFx0XHRcdHA7XG4gIFx0XHRcdGZvciAocCBpbiBjb21wdXRlZCkge1xuICBcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuICBcdFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdFx0fSxcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICBcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gIFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICBcdFx0Y2xhc3NQVCA9IGNhY2hlLmNsYXNzUFQsXG4gIFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG4gIFx0XHRjaGFuZ2luZ1ZhcnMgPSB7fSxcbiAgXHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcbiAgXHRcdGVuZFZhcnMsIHA7XG4gIFx0aWYgKGNsYXNzUFQpIHtcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuICBcdFx0X3JlbW92ZUxpbmtlZExpc3RJdGVtKGNsYXNzUFQuZC5wbHVnaW4sIGNsYXNzUFQsIFwiX3B0XCIpO1xuICBcdH1cbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcbiAgXHRlbmRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIHRydWUpO1xuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcbiAgXHRcdGlmIChlbmRWYXJzW3BdICE9PSBzdGFydFZhcnNbcF0gJiYgIXRyYW5zZm9ybVJlbGF0ZWQudGVzdChwKSkge1xuICBcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuICBcdFx0XHRcdGlubGluZVRvUmVtb3ZlQXRFbmRbcF0gPSAxO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG4gIFx0fVxuICBcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XG4gIFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuICBcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuICBcdHJldHVybiAxO1xuICB9XG4gICovXG5cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFJBTlNGT1JNU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgX2lzTnVsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9pc051bGxUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG59LFxuICAgIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCkge1xuICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbn0sXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgcGFyZW50LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICB0ZW1wLFxuICAgICAgYWRkZWRUb0RPTTtcblxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICByZXR1cm4gbWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcbiAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgLy9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cbiAgICB0ZW1wID0gc3R5bGUuZGlzcGxheTtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIC8vIG5vdGU6IGluIDMuMy4wIHdlIHN3aXRjaGVkIHRhcmdldC5vZmZzZXRQYXJlbnQgdG8gX2RvYy5ib2R5LmNvbnRhaW5zKHRhcmdldCkgdG8gYXZvaWQgW3NvbWV0aW1lcyB1bm5lY2Vzc2FyeV0gTXV0YXRpb25PYnNlcnZlciBjYWxscyBidXQgdGhhdCB3YXNuJ3QgYWRlcXVhdGUgYmVjYXVzZSB0aGVyZSBhcmUgZWRnZSBjYXNlcyB3aGVyZSBuZXN0ZWQgcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIG5lZWQgdG8gZ2V0IHJlcGFyZW50ZWQgdG8gYWNjdXJhdGVseSBzZW5zZSB0cmFuc2Zvcm1zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zODggYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzc1XG4gICAgICBhZGRlZFRvRE9NID0gMTsgLy9mbGFnXG5cbiAgICAgIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTtcbiAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XG4gICAgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG4gICAgeCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB4T3JpZ2luID0geDtcbiAgICB5T3JpZ2luID0geTtcbiAgfVxuXG4gIGlmIChzbW9vdGggfHwgc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpIHtcbiAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuICAgIHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG4gICAgY2FjaGUueE9mZnNldCA9IHhPZmZzZXRPbGQgKyAodHggKiBhICsgdHkgKiBjKSAtIHR4O1xuICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIH1cblxuICBjYWNoZS54T3JpZ2luID0geE9yaWdpbjtcbiAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG4gIGNhY2hlLnNtb290aCA9ICEhc21vb3RoO1xuICBjYWNoZS5vcmlnaW4gPSBvcmlnaW47XG4gIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjBweCAwcHhcIjsgLy9vdGhlcndpc2UsIGlmIHNvbWVvbmUgc2V0cyAgYW4gb3JpZ2luIHZpYSBDU1MsIGl0IHdpbGwgbGlrZWx5IGludGVyZmVyZSB3aXRoIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvbmVzIChiZWNhdXNlIHJlbWVtYmVyLCB3ZSdyZSBiYWtpbmcgdGhlIG9yaWdpbiBpbnRvIHRoZSBtYXRyaXgoKSB2YWx1ZSkuXG5cbiAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG4gIH1cblxuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xufSxcbiAgICBfcGFyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBuZXcgR1NDYWNoZSh0YXJnZXQpO1xuXG4gIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGludmVydGVkU2NhbGVYID0gY2FjaGUuc2NhbGVYIDwgMCxcbiAgICAgIHB4ID0gXCJweFwiLFxuICAgICAgZGVnID0gXCJkZWdcIixcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XG5cbiAgaWYgKGNhY2hlLnN2Zykge1xuICAgIHQxID0gKCFjYWNoZS51bmNhY2hlIHx8IG9yaWdpbiA9PT0gXCIwcHggMHB4XCIpICYmICF1bmNhY2hlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7IC8vIGlmIG9yaWdpbiBpcyAwLDAgYW5kIGNhY2hlLnVuY2FjaGUgaXMgdHJ1ZSwgbGV0IHRoZSByZWNvcmRlZCBkYXRhLXN2Zy1vcmlnaW4gc3RheS4gT3RoZXJ3aXNlLCB3aGVuZXZlciB3ZSBzZXQgY2FjaGUudW5jYWNoZSB0byB0cnVlLCB3ZSdkIG5lZWQgdG8gc2V0IGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gKGNhY2hlLnhPcmlnaW4gLSBiYm94LngpICsgXCJweCBcIiArIChjYWNoZS55T3JpZ2luIC0gYmJveC55KSArIFwicHhcIi4gUmVtZW1iZXIsIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIHdlIGFsd2F5cyBmb3JjZSBTVkcgZWxlbWVudHMnIHRyYW5zZm9ybU9yaWdpbiB0byAwLDAgYW5kIG9mZnNldCB0aGUgdHJhbnNsYXRpb24gYWNjb3JkaW5nbHkuXG5cbiAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCB0MSB8fCBvcmlnaW4sICEhdDEgfHwgY2FjaGUub3JpZ2luSXNBYnNvbHV0ZSwgY2FjaGUuc21vb3RoICE9PSBmYWxzZSwgbWF0cml4KTtcbiAgfVxuXG4gIHhPcmlnaW4gPSBjYWNoZS54T3JpZ2luIHx8IDA7XG4gIHlPcmlnaW4gPSBjYWNoZS55T3JpZ2luIHx8IDA7XG5cbiAgaWYgKG1hdHJpeCAhPT0gX2lkZW50aXR5MkRNYXRyaXgpIHtcbiAgICBhID0gbWF0cml4WzBdOyAvL2ExMVxuXG4gICAgYiA9IG1hdHJpeFsxXTsgLy9hMjFcblxuICAgIGMgPSBtYXRyaXhbMl07IC8vYTMxXG5cbiAgICBkID0gbWF0cml4WzNdOyAvL2E0MVxuXG4gICAgeCA9IGExMiA9IG1hdHJpeFs0XTtcbiAgICB5ID0gYTIyID0gbWF0cml4WzVdOyAvLzJEIG1hdHJpeFxuXG4gICAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDYpIHtcbiAgICAgIHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgIHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcbiAgICAgIHJvdGF0aW9uID0gYSB8fCBiID8gX2F0YW4yKGIsIGEpICogX1JBRDJERUcgOiAwOyAvL25vdGU6IGlmIHNjYWxlWCBpcyAwLCB3ZSBjYW5ub3QgYWNjdXJhdGVseSBtZWFzdXJlIHJvdGF0aW9uLiBTYW1lIGZvciBza2V3WCB3aXRoIGEgc2NhbGVZIG9mIDAuIFRoZXJlZm9yZSwgd2UgZGVmYXVsdCB0byB0aGUgcHJldmlvdXNseSByZWNvcmRlZCB2YWx1ZSAob3IgemVybyBpZiB0aGF0IGRvZXNuJ3QgZXhpc3QpLlxuXG4gICAgICBza2V3WCA9IGMgfHwgZCA/IF9hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiAwO1xuICAgICAgc2tld1ggJiYgKHNjYWxlWSAqPSBNYXRoLmFicyhNYXRoLmNvcyhza2V3WCAqIF9ERUcyUkFEKSkpO1xuXG4gICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgIHggLT0geE9yaWdpbiAtICh4T3JpZ2luICogYSArIHlPcmlnaW4gKiBjKTtcbiAgICAgICAgeSAtPSB5T3JpZ2luIC0gKHhPcmlnaW4gKiBiICsgeU9yaWdpbiAqIGQpO1xuICAgICAgfSAvLzNEIG1hdHJpeFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGEzMiA9IG1hdHJpeFs2XTtcbiAgICAgIGE0MiA9IG1hdHJpeFs3XTtcbiAgICAgIGExMyA9IG1hdHJpeFs4XTtcbiAgICAgIGEyMyA9IG1hdHJpeFs5XTtcbiAgICAgIGEzMyA9IG1hdHJpeFsxMF07XG4gICAgICBhNDMgPSBtYXRyaXhbMTFdO1xuICAgICAgeCA9IG1hdHJpeFsxMl07XG4gICAgICB5ID0gbWF0cml4WzEzXTtcbiAgICAgIHogPSBtYXRyaXhbMTRdO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTMyLCBhMzMpO1xuICAgICAgcm90YXRpb25YID0gYW5nbGUgKiBfUkFEMkRFRzsgLy9yb3RhdGlvblhcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYTEyICogY29zICsgYTEzICogc2luO1xuICAgICAgICB0MiA9IGEyMiAqIGNvcyArIGEyMyAqIHNpbjtcbiAgICAgICAgdDMgPSBhMzIgKiBjb3MgKyBhMzMgKiBzaW47XG4gICAgICAgIGExMyA9IGExMiAqIC1zaW4gKyBhMTMgKiBjb3M7XG4gICAgICAgIGEyMyA9IGEyMiAqIC1zaW4gKyBhMjMgKiBjb3M7XG4gICAgICAgIGEzMyA9IGEzMiAqIC1zaW4gKyBhMzMgKiBjb3M7XG4gICAgICAgIGE0MyA9IGE0MiAqIC1zaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGExMiA9IHQxO1xuICAgICAgICBhMjIgPSB0MjtcbiAgICAgICAgYTMyID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25ZXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoLWMsIGEzMyk7XG4gICAgICByb3RhdGlvblkgPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zIC0gYTEzICogc2luO1xuICAgICAgICB0MiA9IGIgKiBjb3MgLSBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYyAqIGNvcyAtIGEzMyAqIHNpbjtcbiAgICAgICAgYTQzID0gZCAqIHNpbiArIGE0MyAqIGNvcztcbiAgICAgICAgYSA9IHQxO1xuICAgICAgICBiID0gdDI7XG4gICAgICAgIGMgPSB0MztcbiAgICAgIH0gLy9yb3RhdGlvblpcblxuXG4gICAgICBhbmdsZSA9IF9hdGFuMihiLCBhKTtcbiAgICAgIHJvdGF0aW9uID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB0MSA9IGEgKiBjb3MgKyBiICogc2luO1xuICAgICAgICB0MiA9IGExMiAqIGNvcyArIGEyMiAqIHNpbjtcbiAgICAgICAgYiA9IGIgKiBjb3MgLSBhICogc2luO1xuICAgICAgICBhMjIgPSBhMjIgKiBjb3MgLSBhMTIgKiBzaW47XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYTEyID0gdDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3RhdGlvblggJiYgTWF0aC5hYnMocm90YXRpb25YKSArIE1hdGguYWJzKHJvdGF0aW9uKSA+IDM1OS45KSB7XG4gICAgICAgIC8vd2hlbiByb3RhdGlvblkgaXMgc2V0LCBpdCB3aWxsIG9mdGVuIGJlIHBhcnNlZCBhcyAxODAgZGVncmVlcyBkaWZmZXJlbnQgdGhhbiBpdCBzaG91bGQgYmUsIGFuZCByb3RhdGlvblggYW5kIHJvdGF0aW9uIGJvdGggYmVpbmcgMTgwIChpdCBsb29rcyB0aGUgc2FtZSksIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBoZXJlLlxuICAgICAgICByb3RhdGlvblggPSByb3RhdGlvbiA9IDA7XG4gICAgICAgIHJvdGF0aW9uWSA9IDE4MCAtIHJvdGF0aW9uWTtcbiAgICAgIH1cblxuICAgICAgc2NhbGVYID0gX3JvdW5kKE1hdGguc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpKTtcbiAgICAgIHNjYWxlWSA9IF9yb3VuZChNYXRoLnNxcnQoYTIyICogYTIyICsgYTMyICogYTMyKSk7XG4gICAgICBhbmdsZSA9IF9hdGFuMihhMTIsIGEyMik7XG4gICAgICBza2V3WCA9IE1hdGguYWJzKGFuZ2xlKSA+IDAuMDAwMiA/IGFuZ2xlICogX1JBRDJERUcgOiAwO1xuICAgICAgcGVyc3BlY3RpdmUgPSBhNDMgPyAxIC8gKGE0MyA8IDAgPyAtYTQzIDogYTQzKSA6IDA7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgLy9zZW5zZSBpZiB0aGVyZSBhcmUgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCBvbiBhbiBTVkcgZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gd2hlbiByZW5kZXJpbmcuIFRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlzIG1vcmUgcmVsaWFibGUgY3Jvc3MtYnJvd3NlciwgYnV0IHdlIGNhbid0IGp1c3QgcmVtb3ZlIHRoZSBDU1Mgb25lcyBiZWNhdXNlIHRoZXkgbWF5IGJlIGFwcGxpZWQgaW4gYSBDU1MgcnVsZSBzb21ld2hlcmUgKG5vdCBqdXN0IGlubGluZSkuXG4gICAgICB0MSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICBjYWNoZS5mb3JjZUNTUyA9IHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIikgfHwgIV9pc051bGxUcmFuc2Zvcm0oX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCkpO1xuICAgICAgdDEgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0MSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKE1hdGguYWJzKHNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHNrZXdYKSA8IDI3MCkge1xuICAgIGlmIChpbnZlcnRlZFNjYWxlWCkge1xuICAgICAgc2NhbGVYICo9IC0xO1xuICAgICAgc2tld1ggKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgICByb3RhdGlvbiArPSByb3RhdGlvbiA8PSAwID8gMTgwIDogLTE4MDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVZICo9IC0xO1xuICAgICAgc2tld1ggKz0gc2tld1ggPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfVxuICB9XG5cbiAgY2FjaGUueCA9IHggLSAoKGNhY2hlLnhQZXJjZW50ID0geCAmJiAoY2FjaGUueFBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldFdpZHRoIC8gMikgPT09IE1hdGgucm91bmQoLXgpID8gLTUwIDogMCkpKSA/IHRhcmdldC5vZmZzZXRXaWR0aCAqIGNhY2hlLnhQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgY2FjaGUueSA9IHkgLSAoKGNhY2hlLnlQZXJjZW50ID0geSAmJiAoY2FjaGUueVBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldEhlaWdodCAvIDIpID09PSBNYXRoLnJvdW5kKC15KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0SGVpZ2h0ICogY2FjaGUueVBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuICBjYWNoZS56ID0geiArIHB4O1xuICBjYWNoZS5zY2FsZVggPSBfcm91bmQoc2NhbGVYKTtcbiAgY2FjaGUuc2NhbGVZID0gX3JvdW5kKHNjYWxlWSk7XG4gIGNhY2hlLnJvdGF0aW9uID0gX3JvdW5kKHJvdGF0aW9uKSArIGRlZztcbiAgY2FjaGUucm90YXRpb25YID0gX3JvdW5kKHJvdGF0aW9uWCkgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWSA9IF9yb3VuZChyb3RhdGlvblkpICsgZGVnO1xuICBjYWNoZS5za2V3WCA9IHNrZXdYICsgZGVnO1xuICBjYWNoZS5za2V3WSA9IHNrZXdZICsgZGVnO1xuICBjYWNoZS50cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlICsgcHg7XG5cbiAgaWYgKGNhY2hlLnpPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpbi5zcGxpdChcIiBcIilbMl0pIHx8IDApIHtcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gIH1cblxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybSA9IGNhY2hlLnN2ZyA/IF9yZW5kZXJTVkdUcmFuc2Zvcm1zIDogX3N1cHBvcnRzM0QgPyBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA6IF9yZW5kZXJOb24zRFRyYW5zZm9ybXM7XG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xuICByZXR1cm4gY2FjaGU7XG59LFxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbn0sXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuX2FkZFB4VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgc3RhcnQsIHZhbHVlKSB7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcbn0sXG4gICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIGNhY2hlLnogPSBcIjBweFwiO1xuICBjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcbiAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICBfemVyb1B4ID0gXCIwcHhcIixcbiAgICBfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB6ID0gX3JlZi56LFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25ZID0gX3JlZi5yb3RhdGlvblksXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgIHNrZXdYID0gX3JlZi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IF9yZWYudHJhbnNmb3JtUGVyc3BlY3RpdmUsXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB6T3JpZ2luID0gX3JlZi56T3JpZ2luLFxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICB1c2UzRCA9IGZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHJhdGlvICYmIHJhdGlvICE9PSAxIHx8IGZvcmNlM0QgPT09IHRydWU7IC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblxuXG4gIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgdmFyIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjb3M7XG5cbiAgICBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xuICAgIHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICB9XG5cbiAgaWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblggIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXMgfHwgXCJ0cmFuc2xhdGUoMCwgMClcIjtcbn0sXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYyID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYyLngsXG4gICAgICB5ID0gX3JlZjIueSxcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXG4gICAgICBza2V3WCA9IF9yZWYyLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxuICAgICAgeU9yaWdpbiA9IF9yZWYyLnlPcmlnaW4sXG4gICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxuICAgICAgZm9yY2VDU1MgPSBfcmVmMi5mb3JjZUNTUyxcbiAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcbiAgICAgIGExMSxcbiAgICAgIGEyMSxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHRlbXA7XG5cbiAgcm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcbiAgc2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICBpZiAoc2tld1kpIHtcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuICAgIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG4gICAgc2tld1ggKz0gc2tld1k7XG4gICAgcm90YXRpb24gKz0gc2tld1k7XG4gIH1cblxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcbiAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICBza2V3WCAqPSBfREVHMlJBRDtcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgIGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcblxuICAgIGlmIChza2V3WCkge1xuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XG4gICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG4gICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICBhMTIgKj0gdGVtcDtcbiAgICAgIGEyMiAqPSB0ZW1wO1xuXG4gICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdZKTtcbiAgICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgYTIxICo9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYTExID0gX3JvdW5kKGExMSk7XG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XG4gICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgYTIyID0gX3JvdW5kKGEyMik7XG4gIH0gZWxzZSB7XG4gICAgYTExID0gc2NhbGVYO1xuICAgIGEyMiA9IHNjYWxlWTtcbiAgICBhMjEgPSBhMTIgPSAwO1xuICB9XG5cbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xuICAgIHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcbiAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gIH1cblxuICBpZiAoeE9yaWdpbiB8fCB5T3JpZ2luIHx8IHhPZmZzZXQgfHwgeU9mZnNldCkge1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeFBlcmNlbnQgLyAxMDAgKiB0ZW1wLndpZHRoKTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuICB9XG5cbiAgdGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcbiAgZm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTsgLy9zb21lIGJyb3dzZXJzIHByaW9yaXRpemUgQ1NTIHRyYW5zZm9ybXMgb3ZlciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZS4gV2hlbiB3ZSBzZW5zZSB0aGF0IHRoZSB1c2VyIGhhcyBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkLCB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHRoaXMgd2F5IChvdGhlcndpc2Ugc29tZSBicm93c2VyIHNpbXBseSB3b24ndCByZW5kZXIgdGhlICB0cmFuc2Zvcm0gYXR0cmlidXRlIGNoYW5nZXMhKVxufSxcbiAgICBfYWRkUm90YXRpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGVuZFZhbHVlLCByZWxhdGl2ZSkge1xuICB2YXIgY2FwID0gMzYwLFxuICAgICAgaXNTdHJpbmcgPSBfaXNTdHJpbmcoZW5kVmFsdWUpLFxuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSkgKiAoaXNTdHJpbmcgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYWRcIikgPyBfUkFEMkRFRyA6IDEpLFxuICAgICAgY2hhbmdlID0gcmVsYXRpdmUgPyBlbmROdW0gKiByZWxhdGl2ZSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgZmluYWxWYWx1ZSA9IHN0YXJ0TnVtICsgY2hhbmdlICsgXCJkZWdcIixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHB0O1xuXG4gIGlmIChpc1N0cmluZykge1xuICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xuICAgICAgY2hhbmdlICU9IGNhcDtcblxuICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgIGNoYW5nZSArPSBjaGFuZ2UgPCAwID8gY2FwIDogLWNhcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImN3XCIgJiYgY2hhbmdlIDwgMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSArIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJjY3dcIiAmJiBjaGFuZ2UgPiAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlIC0gY2FwICogX2JpZ051bSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgcHQuZSA9IGZpbmFsVmFsdWU7XG4gIHB0LnUgPSBcImRlZ1wiO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYXNzaWduID0gZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IGhhdmUgT2JqZWN0LmFzc2lnbigpLCBzbyB3ZSByZWNyZWF0ZSBpdCBoZXJlLlxuICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgIHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59LFxuICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHMgPSBmdW5jdGlvbiBfYWRkUmF3VHJhbnNmb3JtUFRzKHBsdWdpbiwgdHJhbnNmb3JtcywgdGFyZ2V0KSB7XG4gIC8vZm9yIGhhbmRsaW5nIGNhc2VzIHdoZXJlIHNvbWVvbmUgcGFzc2VzIGluIGEgd2hvbGUgdHJhbnNmb3JtIHN0cmluZywgbGlrZSB0cmFuc2Zvcm06IFwic2NhbGUoMiwgMykgcm90YXRlKDIwZGVnKSB0cmFuc2xhdGVZKDMwZW0pXCJcbiAgdmFyIHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxuICAgICAgZXhjbHVkZSA9IFwicGVyc3BlY3RpdmUsZm9yY2UzRCx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luXCIsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGVuZENhY2hlLFxuICAgICAgcCxcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgZW5kTnVtLFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVW5pdDtcblxuICBpZiAoc3RhcnRDYWNoZS5zdmcpIHtcbiAgICBzdGFydFZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcblxuICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgc3RhcnRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVtfdHJhbnNmb3JtUHJvcF07XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcztcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHN0YXJ0VmFsdWU7XG4gIH1cblxuICBmb3IgKHAgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG4gICAgc3RhcnRWYWx1ZSA9IHN0YXJ0Q2FjaGVbcF07XG4gICAgZW5kVmFsdWUgPSBlbmRDYWNoZVtwXTtcblxuICAgIGlmIChzdGFydFZhbHVlICE9PSBlbmRWYWx1ZSAmJiBleGNsdWRlLmluZGV4T2YocCkgPCAwKSB7XG4gICAgICAvL3R3ZWVuaW5nIHRvIG5vIHBlcnNwZWN0aXZlIGdpdmVzIHZlcnkgdW5pbnR1aXRpdmUgcmVzdWx0cyAtIGp1c3Qga2VlcCB0aGUgc2FtZSBwZXJzcGVjdGl2ZSBpbiB0aGF0IGNhc2UuXG4gICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgc3RhcnROdW0gPSBzdGFydFVuaXQgIT09IGVuZFVuaXQgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgZW5kQ2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmROdW0gLSBzdGFydE51bSwgX3JlbmRlckNTU1Byb3ApO1xuICAgICAgcGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG5cbiAgX2Fzc2lnbihlbmRDYWNoZSwgc3RhcnRDYWNoZSk7XG59OyAvLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5cblxuX2ZvckVhY2hOYW1lKFwicGFkZGluZyxtYXJnaW4sV2lkdGgsUmFkaXVzXCIsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICB2YXIgdCA9IFwiVG9wXCIsXG4gICAgICByID0gXCJSaWdodFwiLFxuICAgICAgYiA9IFwiQm90dG9tXCIsXG4gICAgICBsID0gXCJMZWZ0XCIsXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWU7XG4gIH0pO1xuXG4gIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBhLCB2YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAvLyBnZXR0ZXIsIHBhc3NlZCB0YXJnZXQsIHByb3BlcnR5LCBhbmQgdW5pdCAoZnJvbSBfZ2V0KCkpXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpO1xuICAgICAgfSk7XG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgIHJldHVybiB2YXJzLnNwbGl0KGFbMF0pLmxlbmd0aCA9PT0gNSA/IGFbMF0gOiB2YXJzO1xuICAgIH1cblxuICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgdmFycyA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgIH0pO1xuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuICB9O1xufSk7XG5cbmV4cG9ydCB2YXIgQ1NTUGx1Z2luID0ge1xuICBuYW1lOiBcImNzc1wiLFxuICByZWdpc3RlcjogX2luaXRDb3JlLFxuICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgIHAsXG4gICAgICAgIHN0YXJ0VW5pdCxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcbiAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgc21vb3RoLFxuICAgICAgICBoYXNQcmlvcml0eTtcbiAgICBfcGx1Z2luSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBpZiAocCA9PT0gXCJhdXRvUm91bmRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZW5kVmFsdWUgPSB2YXJzW3BdO1xuXG4gICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgX2NoZWNrUGx1Z2luKHAsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSkge1xuICAgICAgICAvLyBwbHVnaW5zXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZW9mIGVuZFZhbHVlO1xuICAgICAgc3BlY2lhbFByb3AgPSBfc3BlY2lhbFByb3BzW3BdO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgICAgICBlbmRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKGVuZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWNpYWxQcm9wKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wKHRoaXMsIHRhcmdldCwgcCwgZW5kVmFsdWUsIHR3ZWVuKSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH0gZWxzZSBpZiAocC5zdWJzdHIoMCwgMikgPT09IFwiLS1cIikge1xuICAgICAgICAvL0NTUyB2YXJpYWJsZVxuICAgICAgICBzdGFydFZhbHVlID0gKGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKHApICsgXCJcIikudHJpbSgpO1xuICAgICAgICBlbmRWYWx1ZSArPSBcIlwiO1xuICAgICAgICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICAgICAgICBpZiAoIV9jb2xvckV4cC50ZXN0KHN0YXJ0VmFsdWUpKSB7XG4gICAgICAgICAgLy8gY29sb3JzIGRvbid0IGhhdmUgdW5pdHNcbiAgICAgICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZFVuaXQgPyBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0VmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpICsgZW5kVW5pdCkgOiBzdGFydFVuaXQgJiYgKGVuZFZhbHVlICs9IHN0YXJ0VW5pdCk7XG4gICAgICAgIHRoaXMuYWRkKHN0eWxlLCBcInNldFByb3BlcnR5XCIsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHN0YXJ0QXQgJiYgcCBpbiBzdGFydEF0KSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBzb21lb25lIGhhcmQtY29kZXMgYSBjb21wbGV4IHZhbHVlIGFzIHRoZSBzdGFydCwgbGlrZSB0b3A6IFwiY2FsYygydmggLyAyKVwiLiBXaXRob3V0IHRoaXMsIGl0J2QgdXNlIHRoZSBjb21wdXRlZCB2YWx1ZSAoYWx3YXlzIGluIHB4KVxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSB0eXBlb2Ygc3RhcnRBdFtwXSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBdFtwXS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHN0YXJ0QXRbcF07XG4gICAgICAgICAgcCBpbiBfY29uZmlnLnVuaXRzICYmICFnZXRVbml0KHN0YXJ0VmFsdWUpICYmIChzdGFydFZhbHVlICs9IF9jb25maWcudW5pdHNbcF0pOyAvLyBmb3IgY2FzZXMgd2hlbiBzb21lb25lIHBhc3NlcyBpbiBhIHVuaXRsZXNzIHZhbHVlIGxpa2Uge3g6IDEwMH07IGlmIHdlIHRyeSBzZXR0aW5nIHRyYW5zbGF0ZSgxMDAsIDBweCkgaXQgd29uJ3Qgd29yay5cblxuICAgICAgICAgIF9pc1N0cmluZyhzdGFydFZhbHVlKSAmJiB+c3RhcnRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSAmJiAoc3RhcnRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKHN0YXJ0VmFsdWUpKTtcbiAgICAgICAgICAoc3RhcnRWYWx1ZSArIFwiXCIpLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgKHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCkpOyAvLyBjYW4ndCB3b3JrIHdpdGggcmVsYXRpdmUgdmFsdWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgICAgcmVsYXRpdmUgPSB0eXBlID09PSBcInN0cmluZ1wiICYmIGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyArKGVuZFZhbHVlLmNoYXJBdCgwKSArIFwiMVwiKSA6IDA7XG4gICAgICAgIHJlbGF0aXZlICYmIChlbmRWYWx1ZSA9IGVuZFZhbHVlLnN1YnN0cigyKSk7XG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuXG4gICAgICAgIGlmIChwIGluIF9wcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICAgICAgICBpZiAocCA9PT0gXCJhdXRvQWxwaGFcIikge1xuICAgICAgICAgICAgLy9zcGVjaWFsIGNhc2Ugd2hlcmUgd2UgY29udHJvbCB0aGUgdmlzaWJpbGl0eSBhbG9uZyB3aXRoIG9wYWNpdHkuIFdlIHN0aWxsIGFsbG93IHRoZSBvcGFjaXR5IHZhbHVlIHRvIHBhc3MgdGhyb3VnaCBhbmQgZ2V0IHR3ZWVuZWQuXG4gICAgICAgICAgICBpZiAoc3RhcnROdW0gPT09IDEgJiYgX2dldCh0YXJnZXQsIFwidmlzaWJpbGl0eVwiKSA9PT0gXCJoaWRkZW5cIiAmJiBlbmROdW0pIHtcbiAgICAgICAgICAgICAgLy9pZiB2aXNpYmlsaXR5IGlzIGluaXRpYWxseSBzZXQgdG8gXCJoaWRkZW5cIiwgd2Ugc2hvdWxkIGludGVycHJldCB0aGF0IGFzIGludGVudCB0byBtYWtlIG9wYWNpdHkgMCAoYSBjb252ZW5pZW5jZSlcbiAgICAgICAgICAgICAgc3RhcnROdW0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBzdHlsZSwgXCJ2aXNpYmlsaXR5XCIsIHN0YXJ0TnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCBlbmROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsICFlbmROdW0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwICE9PSBcInNjYWxlXCIgJiYgcCAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgcCA9IF9wcm9wZXJ0eUFsaWFzZXNbcF07XG4gICAgICAgICAgICB+cC5pbmRleE9mKFwiLFwiKSAmJiAocCA9IHAuc3BsaXQoXCIsXCIpWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQgPSBwIGluIF90cmFuc2Zvcm1Qcm9wczsgLy8tLS0gVFJBTlNGT1JNLVJFTEFURUQgLS0tXG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCkge1xuICAgICAgICAgIGlmICghdHJhbnNmb3JtUHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgICAgICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSAmJiAhdmFycy5wYXJzZVRyYW5zZm9ybSB8fCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB2YXJzLnBhcnNlVHJhbnNmb3JtKTsgLy8gaWYsIGZvciBleGFtcGxlLCBnc2FwLnNldCguLi4ge3RyYW5zZm9ybTpcInRyYW5zbGF0ZVgoNTB2dylcIn0pLCB0aGUgX2dldCgpIGNhbGwgZG9lc24ndCBwYXJzZSB0aGUgdHJhbnNmb3JtLCB0aHVzIGNhY2hlLnJlbmRlclRyYW5zZm9ybSB3b24ndCBiZSBzZXQgeWV0IHNvIGZvcmNlIHRoZSBwYXJzaW5nIG9mIHRoZSB0cmFuc2Zvcm0gaGVyZS5cblxuICAgICAgICAgICAgc21vb3RoID0gdmFycy5zbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIGNhY2hlLnNtb290aDtcbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2VlbiA9IHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgc3R5bGUsIF90cmFuc2Zvcm1Qcm9wLCAwLCAxLCBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0sIGNhY2hlLCAwLCAtMSk7IC8vdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCwgY3JlYXRlIHRoZSByZW5kZXJpbmcgUHJvcFR3ZWVuIHNvIHRoYXQgaXQgcnVucyBMQVNUIChpbiB0aGUgbGlua2VkIGxpc3QsIHdlIGtlZXAgYWRkaW5nIHRvIHRoZSBiZWdpbm5pbmcpXG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2Vlbi5kZXAgPSAxOyAvL2ZsYWcgaXQgYXMgZGVwZW5kZW50IHNvIHRoYXQgaWYgdGhpbmdzIGdldCBraWxsZWQvb3ZlcndyaXR0ZW4gYW5kIHRoaXMgaXMgdGhlIG9ubHkgUHJvcFR3ZWVuIGxlZnQsIHdlIGNhbiBzYWZlbHkga2lsbCB0aGUgd2hvbGUgdHdlZW4uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBjYWNoZSwgXCJzY2FsZVlcIiwgY2FjaGUuc2NhbGVZLCAocmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIGNhY2hlLnNjYWxlWSkgfHwgMCk7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKFwic2NhbGVZXCIsIHApO1xuICAgICAgICAgICAgcCArPSBcIlhcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMoZW5kVmFsdWUpOyAvL2luIGNhc2Ugc29tZXRoaW5nIGxpa2UgXCJsZWZ0IHRvcFwiIG9yIFwiYm90dG9tIHJpZ2h0XCIgaXMgcGFzc2VkIGluLiBDb252ZXJ0IHRvIHBlcmNlbnRhZ2VzLlxuXG4gICAgICAgICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAwLCBzbW9vdGgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW5kVW5pdCA9IHBhcnNlRmxvYXQoZW5kVmFsdWUuc3BsaXQoXCIgXCIpWzJdKSB8fCAwOyAvL2hhbmRsZSB0aGUgek9yaWdpbiBzZXBhcmF0ZWx5IVxuXG4gICAgICAgICAgICAgIGVuZFVuaXQgIT09IGNhY2hlLnpPcmlnaW4gJiYgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgY2FjaGUsIFwiek9yaWdpblwiLCBjYWNoZS56T3JpZ2luLCBlbmRVbml0KTtcblxuICAgICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBzdHlsZSwgcCwgX2ZpcnN0VHdvT25seShzdGFydFZhbHVlKSwgX2ZpcnN0VHdvT25seShlbmRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic3ZnT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAxLCBzbW9vdGgsIDAsIHRoaXMpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgaW4gX3JvdGF0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBfYWRkUm90YXRpb25hbFByb3BUd2Vlbih0aGlzLCBjYWNoZSwgcCwgc3RhcnROdW0sIGVuZFZhbHVlLCByZWxhdGl2ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzbW9vdGhPcmlnaW5cIikge1xuICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgY2FjaGUsIFwic21vb3RoXCIsIGNhY2hlLnNtb290aCwgZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwiZm9yY2UzRFwiKSB7XG4gICAgICAgICAgICBjYWNoZVtwXSA9IGVuZFZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBfYWRkUmF3VHJhbnNmb3JtUFRzKHRoaXMsIGVuZFZhbHVlLCB0YXJnZXQpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuICAgICAgICAgIHAgPSBfY2hlY2tQcm9wUHJlZml4KHApIHx8IHA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkIHx8IChlbmROdW0gfHwgZW5kTnVtID09PSAwKSAmJiAoc3RhcnROdW0gfHwgc3RhcnROdW0gPT09IDApICYmICFfY29tcGxleEV4cC50ZXN0KGVuZFZhbHVlKSAmJiBwIGluIHN0eWxlKSB7XG4gICAgICAgICAgc3RhcnRVbml0ID0gKHN0YXJ0VmFsdWUgKyBcIlwiKS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgICBlbmROdW0gfHwgKGVuZE51bSA9IDApOyAvLyBwcm90ZWN0IGFnYWluc3QgTmFOXG5cbiAgICAgICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSkgfHwgKHAgaW4gX2NvbmZpZy51bml0cyA/IF9jb25maWcudW5pdHNbcF0gOiBzdGFydFVuaXQpO1xuICAgICAgICAgIHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpKTtcbiAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGlzVHJhbnNmb3JtUmVsYXRlZCA/IGNhY2hlIDogc3R5bGUsIHAsIHN0YXJ0TnVtLCByZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gc3RhcnROdW0sICFpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgKGVuZFVuaXQgPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSAmJiB2YXJzLmF1dG9Sb3VuZCAhPT0gZmFsc2UgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgdGhpcy5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgZW5kVW5pdCAhPT0gXCIlXCIpIHtcbiAgICAgICAgICAgIC8vd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmV2ZXJ0IGl0IHRvIHRoZSBPTEQvT1JJR0lOQUwgdmFsdWUgKHdpdGggdGhvc2UgdW5pdHMpLiBXZSByZWNvcmQgdGhhdCBhcyBhIFwiYlwiIChiZWdpbm5pbmcpIHByb3BlcnR5IGFuZCBwb2ludCB0byBhIHJlbmRlciBtZXRob2QgdGhhdCBoYW5kbGVzIHRoYXQuIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG4gICAgICAgICAgICB0aGlzLl9wdC5iID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBpZiAocCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vbWF5YmUgaXQncyBub3QgYSBzdHlsZSAtIGl0IGNvdWxkIGJlIGEgcHJvcGVydHkgYWRkZWQgZGlyZWN0bHkgdG8gYW4gZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlJ2xsIHRyeSB0byBhbmltYXRlIHRoYXQuXG4gICAgICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUgfHwgdGFyZ2V0W3BdLCBlbmRWYWx1ZSwgaW5kZXgsIHRhcmdldHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbWlzc2luZ1BsdWdpbihwLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwodGhpcywgdGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5wdXNoKHApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodGhpcyk7XG4gIH0sXG4gIGdldDogX2dldCxcbiAgYWxpYXNlczogX3Byb3BlcnR5QWxpYXNlcyxcbiAgZ2V0U2V0dGVyOiBmdW5jdGlvbiBnZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSwgcGx1Z2luKSB7XG4gICAgLy9yZXR1cm5zIGEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSBhbmQgYXBwbGllcyBpdCBhY2NvcmRpbmdseS4gUmVtZW1iZXIsIHByb3BlcnRpZXMgbGlrZSBcInhcIiBhcmVuJ3QgYXMgc2ltcGxlIGFzIHRhcmdldC5zdHlsZS5wcm9wZXJ0eSA9IHZhbHVlIGJlY2F1c2UgdGhleSd2ZSBnb3QgdG8gYmUgYXBwbGllZCB0byBhIHByb3h5IG9iamVjdCBhbmQgdGhlbiBtZXJnZWQgaW50byBhIHRyYW5zZm9ybSBzdHJpbmcgaW4gYSByZW5kZXJlci5cbiAgICB2YXIgcCA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldO1xuICAgIHAgJiYgcC5pbmRleE9mKFwiLFwiKSA8IDAgJiYgKHByb3BlcnR5ID0gcCk7XG4gICAgcmV0dXJuIHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3AgJiYgKHRhcmdldC5fZ3NhcC54IHx8IF9nZXQodGFyZ2V0LCBcInhcIikpID8gcGx1Z2luICYmIF9yZWNlbnRTZXR0ZXJQbHVnaW4gPT09IHBsdWdpbiA/IHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGUgOiBfc2V0dGVyVHJhbnNmb3JtIDogKF9yZWNlbnRTZXR0ZXJQbHVnaW4gPSBwbHVnaW4gfHwge30pICYmIChwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlV2l0aFJlbmRlciA6IF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKSA6IHRhcmdldC5zdHlsZSAmJiAhX2lzVW5kZWZpbmVkKHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0pID8gX3NldHRlckNTU1N0eWxlIDogfnByb3BlcnR5LmluZGV4T2YoXCItXCIpID8gX3NldHRlckNTU1Byb3AgOiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpO1xuICB9LFxuICBjb3JlOiB7XG4gICAgX3JlbW92ZVByb3BlcnR5OiBfcmVtb3ZlUHJvcGVydHksXG4gICAgX2dldE1hdHJpeDogX2dldE1hdHJpeFxuICB9XG59O1xuZ3NhcC51dGlscy5jaGVja1ByZWZpeCA9IF9jaGVja1Byb3BQcmVmaXg7XG5cbihmdW5jdGlvbiAocG9zaXRpb25BbmRTY2FsZSwgcm90YXRpb24sIG90aGVycywgYWxpYXNlcykge1xuICB2YXIgYWxsID0gX2ZvckVhY2hOYW1lKHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uICsgXCIsXCIgKyBvdGhlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX3RyYW5zZm9ybVByb3BzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX2ZvckVhY2hOYW1lKHJvdGF0aW9uLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF9jb25maWcudW5pdHNbbmFtZV0gPSBcImRlZ1wiO1xuICAgIF9yb3RhdGlvbmFsUHJvcGVydGllc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9wcm9wZXJ0eUFsaWFzZXNbYWxsWzEzXV0gPSBwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbjtcblxuICBfZm9yRWFjaE5hbWUoYWxpYXNlcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3BsaXQgPSBuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICBfcHJvcGVydHlBbGlhc2VzW3NwbGl0WzFdXSA9IGFsbFtzcGxpdFswXV07XG4gIH0pO1xufSkoXCJ4LHkseixzY2FsZSxzY2FsZVgsc2NhbGVZLHhQZXJjZW50LHlQZXJjZW50XCIsIFwicm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxza2V3WCxza2V3WVwiLCBcInRyYW5zZm9ybSx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLGZvcmNlM0Qsc21vb3RoT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsIFwiMDp0cmFuc2xhdGVYLDE6dHJhbnNsYXRlWSwyOnRyYW5zbGF0ZVosODpyb3RhdGUsODpyb3RhdGlvblosODpyb3RhdGVaLDk6cm90YXRlWCwxMDpyb3RhdGVZXCIpO1xuXG5fZm9yRWFjaE5hbWUoXCJ4LHkseix0b3AscmlnaHQsYm90dG9tLGxlZnQsd2lkdGgsaGVpZ2h0LGZvbnRTaXplLHBhZGRpbmcsbWFyZ2luLHBlcnNwZWN0aXZlXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIF9jb25maWcudW5pdHNbbmFtZV0gPSBcInB4XCI7XG59KTtcblxuZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pO1xuZXhwb3J0IHsgQ1NTUGx1Z2luIGFzIGRlZmF1bHQsIF9nZXRCQm94LCBfY3JlYXRlRWxlbWVudCwgX2NoZWNrUHJvcFByZWZpeCBhcyBjaGVja1ByZWZpeCB9OyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyohXG4gKiBHU0FQIDMuOC4wXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9jb25maWcgPSB7XG4gIGF1dG9TbGVlcDogMTIwLFxuICBmb3JjZTNEOiBcImF1dG9cIixcbiAgbnVsbFRhcmdldFdhcm46IDEsXG4gIHVuaXRzOiB7XG4gICAgbGluZUhlaWdodDogXCJcIlxuICB9XG59LFxuICAgIF9kZWZhdWx0cyA9IHtcbiAgZHVyYXRpb246IC41LFxuICBvdmVyd3JpdGU6IGZhbHNlLFxuICBkZWxheTogMFxufSxcbiAgICBfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgIF9iaWdOdW0gPSAxZTgsXG4gICAgX3RpbnlOdW0gPSAxIC8gX2JpZ051bSxcbiAgICBfMlBJID0gTWF0aC5QSSAqIDIsXG4gICAgX0hBTEZfUEkgPSBfMlBJIC8gNCxcbiAgICBfZ3NJRCA9IDAsXG4gICAgX3NxcnQgPSBNYXRoLnNxcnQsXG4gICAgX2NvcyA9IE1hdGguY29zLFxuICAgIF9zaW4gPSBNYXRoLnNpbixcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBfaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2lzT2JqZWN0ID0gZnVuY3Rpb24gX2lzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59LFxuICAgIF9pc05vdEZhbHNlID0gZnVuY3Rpb24gX2lzTm90RmFsc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbn0sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfaXNGdW5jT3JTdHJpbmcgPSBmdW5jdGlvbiBfaXNGdW5jT3JTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSB8fCBfaXNTdHJpbmcodmFsdWUpO1xufSxcbiAgICBfaXNUeXBlZEFycmF5ID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgIC8vIG5vdGU6IElFMTAgaGFzIEFycmF5QnVmZmVyLCBidXQgTk9UIEFycmF5QnVmZmVyLmlzVmlldygpLlxuX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIF9zdHJpY3ROdW1FeHAgPSAvKD86LT9cXC4/XFxkfFxcLikrL2dpLFxuICAgIC8vb25seSBudW1iZXJzIChpbmNsdWRpbmcgbmVnYXRpdmVzIGFuZCBkZWNpbWFscykgYnV0IE5PVCByZWxhdGl2ZSB2YWx1ZXMuXG5fbnVtRXhwID0gL1stKz0uXSpcXGQrWy5lXFwtK10qXFxkKltlXFwtK10qXFxkKi9nLFxuICAgIC8vZmluZHMgYW55IG51bWJlcnMsIGluY2x1ZGluZyBvbmVzIHRoYXQgc3RhcnQgd2l0aCArPSBvciAtPSwgbmVnYXRpdmUgbnVtYmVycywgYW5kIG9uZXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIDFlLTguXG5fbnVtV2l0aFVuaXRFeHAgPSAvWy0rPS5dKlxcZCtbLmUtXSpcXGQqW2EteiVdKi9nLFxuICAgIF9jb21wbGV4U3RyaW5nTnVtRXhwID0gL1stKz0uXSpcXGQrXFwuP1xcZCooPzplLXxlXFwrKT9cXGQqL2dpLFxuICAgIC8vZHVwbGljYXRlIHNvIHRoYXQgd2hpbGUgd2UncmUgbG9vcGluZyB0aHJvdWdoIG1hdGNoZXMgZnJvbSBleGVjKCksIGl0IGRvZXNuJ3QgY29udGFtaW5hdGUgdGhlIGxhc3RJbmRleCBvZiBfbnVtRXhwIHdoaWNoIHdlIHVzZSB0byBzZWFyY2ggZm9yIGNvbG9ycyB0b28uXG5fcmVsRXhwID0gL1srLV09LT9bLlxcZF0rLyxcbiAgICBfZGVsaW1pdGVkVmFsdWVFeHAgPSAvW14sJ1wiXFxbXFxdXFxzXSsvZ2ksXG4gICAgLy8gcHJldmlvdXNseSAvWyNcXC0rLl0qXFxiW2EtelxcZFxcLT0rJS5dKy9naSBidXQgZGlkbid0IGNhdGNoIHNwZWNpYWwgY2hhcmFjdGVycy5cbl91bml0RXhwID0gL1tcXGQuK1xcLT1dKyg/OmVbLStdXFxkKikqL2ksXG4gICAgX2dsb2JhbFRpbWVsaW5lLFxuICAgIF93aW4sXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF9kb2MsXG4gICAgX2dsb2JhbHMgPSB7fSxcbiAgICBfaW5zdGFsbFNjb3BlID0ge30sXG4gICAgX2NvcmVSZWFkeSxcbiAgICBfaW5zdGFsbCA9IGZ1bmN0aW9uIF9pbnN0YWxsKHNjb3BlKSB7XG4gIHJldHVybiAoX2luc3RhbGxTY29wZSA9IF9tZXJnZShzY29wZSwgX2dsb2JhbHMpKSAmJiBnc2FwO1xufSxcbiAgICBfbWlzc2luZ1BsdWdpbiA9IGZ1bmN0aW9uIF9taXNzaW5nUGx1Z2luKHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgXCJzZXQgdG9cIiwgdmFsdWUsIFwiTWlzc2luZyBwbHVnaW4/IGdzYXAucmVnaXN0ZXJQbHVnaW4oKVwiKTtcbn0sXG4gICAgX3dhcm4gPSBmdW5jdGlvbiBfd2FybihtZXNzYWdlLCBzdXBwcmVzcykge1xuICByZXR1cm4gIXN1cHByZXNzICYmIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2FkZEdsb2JhbCA9IGZ1bmN0aW9uIF9hZGRHbG9iYWwobmFtZSwgb2JqKSB7XG4gIHJldHVybiBuYW1lICYmIChfZ2xvYmFsc1tuYW1lXSA9IG9iaikgJiYgX2luc3RhbGxTY29wZSAmJiAoX2luc3RhbGxTY29wZVtuYW1lXSA9IG9iaikgfHwgX2dsb2JhbHM7XG59LFxuICAgIF9lbXB0eUZ1bmMgPSBmdW5jdGlvbiBfZW1wdHlGdW5jKCkge1xuICByZXR1cm4gMDtcbn0sXG4gICAgX3Jlc2VydmVkUHJvcHMgPSB7fSxcbiAgICBfbGF6eVR3ZWVucyA9IFtdLFxuICAgIF9sYXp5TG9va3VwID0ge30sXG4gICAgX2xhc3RSZW5kZXJlZEZyYW1lLFxuICAgIF9wbHVnaW5zID0ge30sXG4gICAgX2VmZmVjdHMgPSB7fSxcbiAgICBfbmV4dEdDRnJhbWUgPSAzMCxcbiAgICBfaGFybmVzc1BsdWdpbnMgPSBbXSxcbiAgICBfY2FsbGJhY2tOYW1lcyA9IFwiXCIsXG4gICAgX2hhcm5lc3MgPSBmdW5jdGlvbiBfaGFybmVzcyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdLFxuICAgICAgaGFybmVzc1BsdWdpbixcbiAgICAgIGk7XG4gIF9pc09iamVjdCh0YXJnZXQpIHx8IF9pc0Z1bmN0aW9uKHRhcmdldCkgfHwgKHRhcmdldHMgPSBbdGFyZ2V0c10pO1xuXG4gIGlmICghKGhhcm5lc3NQbHVnaW4gPSAodGFyZ2V0Ll9nc2FwIHx8IHt9KS5oYXJuZXNzKSkge1xuICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRhcmdldCB3aXRoIGEgaGFybmVzcy4gV2UgYXNzdW1lIHRhcmdldHMgcGFzc2VkIGludG8gYW4gYW5pbWF0aW9uIHdpbGwgYmUgb2Ygc2ltaWxhciB0eXBlLCBtZWFuaW5nIHRoZSBzYW1lIGtpbmQgb2YgaGFybmVzcyBjYW4gYmUgdXNlZCBmb3IgdGhlbSBhbGwgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcbiAgICBpID0gX2hhcm5lc3NQbHVnaW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0gJiYgIV9oYXJuZXNzUGx1Z2luc1tpXS50YXJnZXRUZXN0KHRhcmdldCkpIHt9XG5cbiAgICBoYXJuZXNzUGx1Z2luID0gX2hhcm5lc3NQbHVnaW5zW2ldO1xuICB9XG5cbiAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0YXJnZXRzW2ldICYmICh0YXJnZXRzW2ldLl9nc2FwIHx8ICh0YXJnZXRzW2ldLl9nc2FwID0gbmV3IEdTQ2FjaGUodGFyZ2V0c1tpXSwgaGFybmVzc1BsdWdpbikpKSB8fCB0YXJnZXRzLnNwbGljZShpLCAxKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRzO1xufSxcbiAgICBfZ2V0Q2FjaGUgPSBmdW5jdGlvbiBfZ2V0Q2FjaGUodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModG9BcnJheSh0YXJnZXQpKVswXS5fZ3NhcDtcbn0sXG4gICAgX2dldFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHYpIHtcbiAgcmV0dXJuICh2ID0gdGFyZ2V0W3Byb3BlcnR5XSkgJiYgX2lzRnVuY3Rpb24odikgPyB0YXJnZXRbcHJvcGVydHldKCkgOiBfaXNVbmRlZmluZWQodikgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKHByb3BlcnR5KSB8fCB2O1xufSxcbiAgICBfZm9yRWFjaE5hbWUgPSBmdW5jdGlvbiBfZm9yRWFjaE5hbWUobmFtZXMsIGZ1bmMpIHtcbiAgcmV0dXJuIChuYW1lcyA9IG5hbWVzLnNwbGl0KFwiLFwiKSkuZm9yRWFjaChmdW5jKSB8fCBuYW1lcztcbn0sXG4gICAgLy9zcGxpdCBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIG5hbWVzIGludG8gYW4gYXJyYXksIHRoZW4gcnVuIGEgZm9yRWFjaCgpIGZ1bmN0aW9uIGFuZCByZXR1cm4gdGhlIHNwbGl0IGFycmF5ICh0aGlzIGlzIGp1c3QgYSB3YXkgdG8gY29uc29saWRhdGUvc2hvcnRlbiBzb21lIGNvZGUpLlxuX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xufSxcbiAgICBfcm91bmRQcmVjaXNlID0gZnVuY3Rpb24gX3JvdW5kUHJlY2lzZSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMDAwKSAvIDEwMDAwMDAwIHx8IDA7XG59LFxuICAgIC8vIGluY3JlYXNlZCBwcmVjaXNpb24gbW9zdGx5IGZvciB0aW1pbmcgdmFsdWVzLlxuX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IHAgPT09IFwiZHVyYXRpb25cIiB8fCBwID09PSBcImVhc2VcIiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICB9XG59LFxuICAgIF9tZXJnZSA9IGZ1bmN0aW9uIF9tZXJnZShiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIGJhc2VbcF0gPSB0b01lcmdlW3BdO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59LFxuICAgIF9tZXJnZURlZXAgPSBmdW5jdGlvbiBfbWVyZ2VEZWVwKGJhc2UsIHRvTWVyZ2UpIHtcbiAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgcCAhPT0gXCJfX3Byb3RvX19cIiAmJiBwICE9PSBcImNvbnN0cnVjdG9yXCIgJiYgcCAhPT0gXCJwcm90b3R5cGVcIiAmJiAoYmFzZVtwXSA9IF9pc09iamVjdCh0b01lcmdlW3BdKSA/IF9tZXJnZURlZXAoYmFzZVtwXSB8fCAoYmFzZVtwXSA9IHt9KSwgdG9NZXJnZVtwXSkgOiB0b01lcmdlW3BdKTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfY29weUV4Y2x1ZGluZyA9IGZ1bmN0aW9uIF9jb3B5RXhjbHVkaW5nKG9iaiwgZXhjbHVkaW5nKSB7XG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBwIGluIGV4Y2x1ZGluZyB8fCAoY29weVtwXSA9IG9ialtwXSk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2luaGVyaXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9pbmhlcml0RGVmYXVsdHModmFycykge1xuICB2YXIgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuICAgICAgZnVuYyA9IHZhcnMua2V5ZnJhbWVzID8gX3NldEtleWZyYW1lRGVmYXVsdHMgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICBjaGlsZC5fYWN0ID0gMDtcbn0sXG4gICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XG4gIGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHtcbiAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGlmIGEgY2hpbGQgYW5pbWF0aW9uIGlzIHBhc3NlZCBpbiB3ZSBzaG91bGQgb25seSB1bmNhY2hlIGlmIHRoYXQgY2hpbGQgRVhURU5EUyB0aGUgYW5pbWF0aW9uIChpdHMgZW5kIHRpbWUgaXMgYmV5b25kIHRoZSBlbmQpXG4gICAgdmFyIGEgPSBhbmltYXRpb247XG5cbiAgICB3aGlsZSAoYSkge1xuICAgICAgYS5fZGlydHkgPSAxO1xuICAgICAgYSA9IGEucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBmdW5jdGlvbiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xufSxcbiAgICBfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBmdW5jdGlvbiBfZWxhcHNlZEN5Y2xlRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG59LFxuICAgIC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgdmFyIHdob2xlID0gTWF0aC5mbG9vcih0VGltZSAvPSBjeWNsZUR1cmF0aW9uKTtcbiAgcmV0dXJuIHRUaW1lICYmIHdob2xlID09PSB0VGltZSA/IHdob2xlIC0gMSA6IHdob2xlO1xufSxcbiAgICBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSA9IGZ1bmN0aW9uIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudFRpbWUsIGNoaWxkKSB7XG4gIHJldHVybiAocGFyZW50VGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgKyAoY2hpbGQuX3RzID49IDAgPyAwIDogY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpO1xufSxcbiAgICBfc2V0RW5kID0gZnVuY3Rpb24gX3NldEVuZChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fZW5kID0gX3JvdW5kUHJlY2lzZShhbmltYXRpb24uX3N0YXJ0ICsgKGFuaW1hdGlvbi5fdER1ciAvIE1hdGguYWJzKGFuaW1hdGlvbi5fdHMgfHwgYW5pbWF0aW9uLl9ydHMgfHwgX3RpbnlOdW0pIHx8IDApKTtcbn0sXG4gICAgX2FsaWduUGxheWhlYWQgPSBmdW5jdGlvbiBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIHRvdGFsVGltZSkge1xuICAvLyBhZGp1c3RzIHRoZSBhbmltYXRpb24ncyBfc3RhcnQgYW5kIF9lbmQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCB0b3RhbFRpbWUgKG9ubHkgaWYgdGhlIHBhcmVudCdzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUgYW5kIHRoZSBhbmltYXRpb24gaXNuJ3QgcGF1c2VkKS4gSXQgZG9lc24ndCBkbyBhbnkgcmVuZGVyaW5nIG9yIGZvcmNpbmcgdGhpbmdzIGJhY2sgaW50byBwYXJlbnQgdGltZWxpbmVzLCBldGMuIC0gdGhhdCdzIHdoYXQgdG90YWxUaW1lKCkgaXMgZm9yLlxuICB2YXIgcGFyZW50ID0gYW5pbWF0aW9uLl9kcDtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiBhbmltYXRpb24uX3RzKSB7XG4gICAgYW5pbWF0aW9uLl9zdGFydCA9IF9yb3VuZFByZWNpc2UocGFyZW50Ll90aW1lIC0gKGFuaW1hdGlvbi5fdHMgPiAwID8gdG90YWxUaW1lIC8gYW5pbWF0aW9uLl90cyA6ICgoYW5pbWF0aW9uLl9kaXJ0eSA/IGFuaW1hdGlvbi50b3RhbER1cmF0aW9uKCkgOiBhbmltYXRpb24uX3REdXIpIC0gdG90YWxUaW1lKSAvIC1hbmltYXRpb24uX3RzKSk7XG5cbiAgICBfc2V0RW5kKGFuaW1hdGlvbik7XG5cbiAgICBwYXJlbnQuX2RpcnR5IHx8IF91bmNhY2hlKHBhcmVudCwgYW5pbWF0aW9uKTsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcblxuLypcbl90b3RhbFRpbWVUb1RpbWUgPSAoY2xhbXBlZFRvdGFsVGltZSwgZHVyYXRpb24sIHJlcGVhdCwgcmVwZWF0RGVsYXksIHlveW8pID0+IHtcblx0bGV0IGN5Y2xlRHVyYXRpb24gPSBkdXJhdGlvbiArIHJlcGVhdERlbGF5LFxuXHRcdHRpbWUgPSBfcm91bmQoY2xhbXBlZFRvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24pO1xuXHRpZiAodGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0dGltZSA9IGR1cmF0aW9uO1xuXHR9XG5cdHJldHVybiAoeW95byAmJiAofn4oY2xhbXBlZFRvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pICYgMSkpID8gZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbn0sXG4qL1xuX3Bvc3RBZGRDaGVja3MgPSBmdW5jdGlvbiBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpIHtcbiAgdmFyIHQ7XG5cbiAgaWYgKGNoaWxkLl90aW1lIHx8IGNoaWxkLl9pbml0dGVkICYmICFjaGlsZC5fZHVyKSB7XG4gICAgLy9pbiBjYXNlLCBmb3IgZXhhbXBsZSwgdGhlIF9zdGFydCBpcyBtb3ZlZCBvbiBhIHR3ZWVuIHRoYXQgaGFzIGFscmVhZHkgcmVuZGVyZWQuIEltYWdpbmUgaXQncyBhdCBpdHMgZW5kIHN0YXRlLCB0aGVuIHRoZSBzdGFydFRpbWUgaXMgbW92ZWQgV0FZIGxhdGVyIChhZnRlciB0aGUgZW5kIG9mIHRoaXMgdGltZWxpbmUpLCBpdCBzaG91bGQgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuXG4gICAgdCA9IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWVsaW5lLnJhd1RpbWUoKSwgY2hpbGQpO1xuXG4gICAgaWYgKCFjaGlsZC5fZHVyIHx8IF9jbGFtcCgwLCBjaGlsZC50b3RhbER1cmF0aW9uKCksIHQpIC0gY2hpbGQuX3RUaW1lID4gX3RpbnlOdW0pIHtcbiAgICAgIGNoaWxkLnJlbmRlcih0LCB0cnVlKTtcbiAgICB9XG4gIH0gLy9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cblxuICBpZiAoX3VuY2FjaGUodGltZWxpbmUsIGNoaWxkKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG4gICAgaWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG4gICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cbiAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cbiAgfVxufSxcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgY2hpbGQuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZSgoX2lzTnVtYmVyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogcG9zaXRpb24gfHwgdGltZWxpbmUgIT09IF9nbG9iYWxUaW1lbGluZSA/IF9wYXJzZVBvc2l0aW9uKHRpbWVsaW5lLCBwb3NpdGlvbiwgY2hpbGQpIDogdGltZWxpbmUuX3RpbWUpICsgY2hpbGQuX2RlbGF5KTtcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZFByZWNpc2UoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICBfaXNGcm9tT3JGcm9tU3RhcnQoY2hpbGQpIHx8ICh0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQpO1xuICBza2lwQ2hlY2tzIHx8IF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCk7XG4gIHJldHVybiB0aW1lbGluZTtcbn0sXG4gICAgX3Njcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2Nyb2xsVHJpZ2dlcihhbmltYXRpb24sIHRyaWdnZXIpIHtcbiAgcmV0dXJuIChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKTtcbn0sXG4gICAgX2F0dGVtcHRJbml0VHdlZW4gPSBmdW5jdGlvbiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgX2luaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lKTtcblxuICBpZiAoIXR3ZWVuLl9pbml0dGVkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoIWZvcmNlICYmIHR3ZWVuLl9wdCAmJiAodHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkgIT09IGZhbHNlIHx8ICF0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSkgJiYgX2xhc3RSZW5kZXJlZEZyYW1lICE9PSBfdGlja2VyLmZyYW1lKSB7XG4gICAgX2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XG5cbiAgICB0d2Vlbi5fbGF6eSA9IFt0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcbiAgICByZXR1cm4gMTtcbiAgfVxufSxcbiAgICBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydChfcmVmKSB7XG4gIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudDtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpO1xufSxcbiAgICAvLyBjaGVjayBwYXJlbnQncyBfbG9jayBiZWNhdXNlIHdoZW4gYSB0aW1lbGluZSByZXBlYXRzL3lveW9zIGFuZCBkb2VzIGl0cyBhcnRpZmljaWFsIHdyYXBwaW5nLCB3ZSBzaG91bGRuJ3QgZm9yY2UgdGhlIHJhdGlvIGJhY2sgdG8gMFxuX2lzRnJvbU9yRnJvbVN0YXJ0ID0gZnVuY3Rpb24gX2lzRnJvbU9yRnJvbVN0YXJ0KF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgcmV0dXJuIGRhdGEgPT09IFwiaXNGcm9tU3RhcnRcIiB8fCBkYXRhID09PSBcImlzU3RhcnRcIjtcbn0sXG4gICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICB2YXIgcHJldlJhdGlvID0gdHdlZW4ucmF0aW8sXG4gICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiAoIXR3ZWVuLl9zdGFydCAmJiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHR3ZWVuKSAmJiAhKCF0d2Vlbi5faW5pdHRlZCAmJiBfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSB8fCAodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpID8gMCA6IDEsXG4gICAgICAvLyBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLiBFZGdlIGNhc2U6IGlmIGEgZnJvbSgpIG9yIGZyb21UbygpIHN0YWdnZXIgdHdlZW4gaXMgcGxhY2VkIGxhdGVyIGluIGEgdGltZWxpbmUsIHRoZSBcInN0YXJ0QXRcIiB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGNvdWxkIGluaXRpYWxseSByZW5kZXIgYXQgYSB0aW1lIHdoZW4gdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGlzIHRlY2huaWNhbGx5IEJFRk9SRSB3aGVyZSB0aGlzIHR3ZWVuIGlzLCBzbyBtYWtlIHN1cmUgdGhhdCBhbnkgXCJmcm9tXCIgYW5kIFwiZnJvbVRvXCIgc3RhcnRBdCB0d2VlbnMgYXJlIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lIGF0IGEgcmF0aW8gb2YgMS5cbiAgcmVwZWF0RGVsYXkgPSB0d2Vlbi5fckRlbGF5LFxuICAgICAgdFRpbWUgPSAwLFxuICAgICAgcHQsXG4gICAgICBpdGVyYXRpb24sXG4gICAgICBwcmV2SXRlcmF0aW9uO1xuXG4gIGlmIChyZXBlYXREZWxheSAmJiB0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy8gaW4gY2FzZSB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiB0aGF0IGhhcyBhIHJlcGVhdCB3aXRoIGEgcmVwZWF0RGVsYXlcbiAgICB0VGltZSA9IF9jbGFtcCgwLCB0d2Vlbi5fdER1ciwgdG90YWxUaW1lKTtcbiAgICBpdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIHJlcGVhdERlbGF5KTtcbiAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHR3ZWVuLl90VGltZSwgcmVwZWF0RGVsYXkpO1xuICAgIHR3ZWVuLl95b3lvICYmIGl0ZXJhdGlvbiAmIDEgJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcblxuICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgIHByZXZSYXRpbyA9IDEgLSByYXRpbztcbiAgICAgIHR3ZWVuLnZhcnMucmVwZWF0UmVmcmVzaCAmJiB0d2Vlbi5faW5pdHRlZCAmJiB0d2Vlbi5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhdGlvICE9PSBwcmV2UmF0aW8gfHwgZm9yY2UgfHwgdHdlZW4uX3pUaW1lID09PSBfdGlueU51bSB8fCAhdG90YWxUaW1lICYmIHR3ZWVuLl96VGltZSkge1xuICAgIGlmICghdHdlZW4uX2luaXR0ZWQgJiYgX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSkge1xuICAgICAgLy8gaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByZXZJdGVyYXRpb24gPSB0d2Vlbi5felRpbWU7XG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lIHx8IChzdXBwcmVzc0V2ZW50cyA/IF90aW55TnVtIDogMCk7IC8vIHdoZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgc3VwcHJlc3NFdmVudHMgfHwgKHN1cHByZXNzRXZlbnRzID0gdG90YWxUaW1lICYmICFwcmV2SXRlcmF0aW9uKTsgLy8gaWYgaXQgd2FzIHJlbmRlcmVkIHByZXZpb3VzbHkgYXQgZXhhY3RseSAwIChfelRpbWUpIGFuZCBub3cgdGhlIHBsYXloZWFkIGlzIG1vdmluZyBhd2F5LCBET04nVCBmaXJlIGNhbGxiYWNrcyBvdGhlcndpc2UgdGhleSdsbCBzZWVtIGxpa2UgZHVwbGljYXRlcy5cblxuICAgIHR3ZWVuLnJhdGlvID0gcmF0aW87XG4gICAgdHdlZW4uX2Zyb20gJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcbiAgICB0d2Vlbi5fdGltZSA9IDA7XG4gICAgdHdlZW4uX3RUaW1lID0gdFRpbWU7XG4gICAgcHQgPSB0d2Vlbi5fcHQ7XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICB0d2Vlbi5fc3RhcnRBdCAmJiB0b3RhbFRpbWUgPCAwICYmIHR3ZWVuLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xuICAgIHR3ZWVuLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uVXBkYXRlXCIpO1xuICAgIHRUaW1lICYmIHR3ZWVuLl9yZXBlYXQgJiYgIXN1cHByZXNzRXZlbnRzICYmIHR3ZWVuLnBhcmVudCAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25SZXBlYXRcIik7XG5cbiAgICBpZiAoKHRvdGFsVGltZSA+PSB0d2Vlbi5fdER1ciB8fCB0b3RhbFRpbWUgPCAwKSAmJiB0d2Vlbi5yYXRpbyA9PT0gcmF0aW8pIHtcbiAgICAgIHJhdGlvICYmIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLCAxKTtcblxuICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICBfY2FsbGJhY2sodHdlZW4sIHJhdGlvID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgIHR3ZWVuLl9wcm9tICYmIHR3ZWVuLl9wcm9tKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCF0d2Vlbi5felRpbWUpIHtcbiAgICB0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWU7XG4gIH1cbn0sXG4gICAgX2ZpbmROZXh0UGF1c2VUd2VlbiA9IGZ1bmN0aW9uIF9maW5kTmV4dFBhdXNlVHdlZW4oYW5pbWF0aW9uLCBwcmV2VGltZSwgdGltZSkge1xuICB2YXIgY2hpbGQ7XG5cbiAgaWYgKHRpbWUgPiBwcmV2VGltZSkge1xuICAgIGNoaWxkID0gYW5pbWF0aW9uLl9maXJzdDtcblxuICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPD0gdGltZSkge1xuICAgICAgaWYgKCFjaGlsZC5fZHVyICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA+IHByZXZUaW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2xhc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQuX3N0YXJ0ID49IHRpbWUpIHtcbiAgICAgIGlmICghY2hpbGQuX2R1ciAmJiBjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPCBwcmV2VGltZSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX3ByZXY7XG4gICAgfVxuICB9XG59LFxuICAgIF9zZXREdXJhdGlvbiA9IGZ1bmN0aW9uIF9zZXREdXJhdGlvbihhbmltYXRpb24sIGR1cmF0aW9uLCBza2lwVW5jYWNoZSwgbGVhdmVQbGF5aGVhZCkge1xuICB2YXIgcmVwZWF0ID0gYW5pbWF0aW9uLl9yZXBlYXQsXG4gICAgICBkdXIgPSBfcm91bmRQcmVjaXNlKGR1cmF0aW9uKSB8fCAwLFxuICAgICAgdG90YWxQcm9ncmVzcyA9IGFuaW1hdGlvbi5fdFRpbWUgLyBhbmltYXRpb24uX3REdXI7XG4gIHRvdGFsUHJvZ3Jlc3MgJiYgIWxlYXZlUGxheWhlYWQgJiYgKGFuaW1hdGlvbi5fdGltZSAqPSBkdXIgLyBhbmltYXRpb24uX2R1cik7XG4gIGFuaW1hdGlvbi5fZHVyID0gZHVyO1xuICBhbmltYXRpb24uX3REdXIgPSAhcmVwZWF0ID8gZHVyIDogcmVwZWF0IDwgMCA/IDFlMTAgOiBfcm91bmRQcmVjaXNlKGR1ciAqIChyZXBlYXQgKyAxKSArIGFuaW1hdGlvbi5fckRlbGF5ICogcmVwZWF0KTtcbiAgdG90YWxQcm9ncmVzcyAmJiAhbGVhdmVQbGF5aGVhZCA/IF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl90VGltZSA9IGFuaW1hdGlvbi5fdER1ciAqIHRvdGFsUHJvZ3Jlc3MpIDogYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG4gIHNraXBVbmNhY2hlIHx8IF91bmNhY2hlKGFuaW1hdGlvbi5wYXJlbnQsIGFuaW1hdGlvbik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpO1xufSxcbiAgICBfemVyb1Bvc2l0aW9uID0ge1xuICBfc3RhcnQ6IDAsXG4gIGVuZFRpbWU6IF9lbXB0eUZ1bmMsXG4gIHRvdGFsRHVyYXRpb246IF9lbXB0eUZ1bmNcbn0sXG4gICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLCBwZXJjZW50QW5pbWF0aW9uKSB7XG4gIHZhciBsYWJlbHMgPSBhbmltYXRpb24ubGFiZWxzLFxuICAgICAgcmVjZW50ID0gYW5pbWF0aW9uLl9yZWNlbnQgfHwgX3plcm9Qb3NpdGlvbixcbiAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcbiAgICAgIC8vaW4gY2FzZSB0aGVyZSdzIGEgY2hpbGQgdGhhdCBpbmZpbml0ZWx5IHJlcGVhdHMsIHVzZXJzIGFsbW9zdCBuZXZlciBpbnRlbmQgZm9yIHRoZSBpbnNlcnRpb24gcG9pbnQgb2YgYSBuZXcgY2hpbGQgdG8gYmUgYmFzZWQgb24gYSBTVVBFUiBsb25nIHZhbHVlIGxpa2UgdGhhdCBzbyB3ZSBjbGlwIGl0IGFuZCBhc3N1bWUgdGhlIG1vc3QgcmVjZW50bHktYWRkZWQgY2hpbGQncyBlbmRUaW1lIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gIGksXG4gICAgICBvZmZzZXQsXG4gICAgICBpc1BlcmNlbnQ7XG5cbiAgaWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XG4gICAgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cbiAgICBvZmZzZXQgPSBwb3NpdGlvbi5jaGFyQXQoMCk7XG4gICAgaXNQZXJjZW50ID0gcG9zaXRpb24uc3Vic3RyKC0xKSA9PT0gXCIlXCI7XG4gICAgaSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXG4gICAgaWYgKG9mZnNldCA9PT0gXCI8XCIgfHwgb2Zmc2V0ID09PSBcIj5cIikge1xuICAgICAgaSA+PSAwICYmIChwb3NpdGlvbiA9IHBvc2l0aW9uLnJlcGxhY2UoLz0vLCBcIlwiKSk7XG4gICAgICByZXR1cm4gKG9mZnNldCA9PT0gXCI8XCIgPyByZWNlbnQuX3N0YXJ0IDogcmVjZW50LmVuZFRpbWUocmVjZW50Ll9yZXBlYXQgPj0gMCkpICsgKHBhcnNlRmxvYXQocG9zaXRpb24uc3Vic3RyKDEpKSB8fCAwKSAqIChpc1BlcmNlbnQgPyAoaSA8IDAgPyByZWNlbnQgOiBwZXJjZW50QW5pbWF0aW9uKS50b3RhbER1cmF0aW9uKCkgLyAxMDAgOiAxKTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHBvc2l0aW9uIGluIGxhYmVscyB8fCAobGFiZWxzW3Bvc2l0aW9uXSA9IGNsaXBwZWREdXJhdGlvbik7XG4gICAgICByZXR1cm4gbGFiZWxzW3Bvc2l0aW9uXTtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KHBvc2l0aW9uLmNoYXJBdChpIC0gMSkgKyBwb3NpdGlvbi5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChpc1BlcmNlbnQgJiYgcGVyY2VudEFuaW1hdGlvbikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IC8gMTAwICogKF9pc0FycmF5KHBlcmNlbnRBbmltYXRpb24pID8gcGVyY2VudEFuaW1hdGlvblswXSA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaSA+IDEgPyBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLnN1YnN0cigwLCBpIC0gMSksIHBlcmNlbnRBbmltYXRpb24pICsgb2Zmc2V0IDogY2xpcHBlZER1cmF0aW9uICsgb2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uID09IG51bGwgPyBjbGlwcGVkRHVyYXRpb24gOiArcG9zaXRpb247XG59LFxuICAgIF9jcmVhdGVUd2VlblR5cGUgPSBmdW5jdGlvbiBfY3JlYXRlVHdlZW5UeXBlKHR5cGUsIHBhcmFtcywgdGltZWxpbmUpIHtcbiAgdmFyIGlzTGVnYWN5ID0gX2lzTnVtYmVyKHBhcmFtc1sxXSksXG4gICAgICB2YXJzSW5kZXggPSAoaXNMZWdhY3kgPyAyIDogMSkgKyAodHlwZSA8IDIgPyAwIDogMSksXG4gICAgICB2YXJzID0gcGFyYW1zW3ZhcnNJbmRleF0sXG4gICAgICBpclZhcnMsXG4gICAgICBwYXJlbnQ7XG5cbiAgaXNMZWdhY3kgJiYgKHZhcnMuZHVyYXRpb24gPSBwYXJhbXNbMV0pO1xuICB2YXJzLnBhcmVudCA9IHRpbWVsaW5lO1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaXJWYXJzID0gdmFycztcbiAgICBwYXJlbnQgPSB0aW1lbGluZTtcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgIShcImltbWVkaWF0ZVJlbmRlclwiIGluIGlyVmFycykpIHtcbiAgICAgIC8vIGluaGVyaXRhbmNlIGhhc24ndCBoYXBwZW5lZCB5ZXQsIGJ1dCBzb21lb25lIG1heSBoYXZlIHNldCBhIGRlZmF1bHQgaW4gYW4gYW5jZXN0b3IgdGltZWxpbmUuIFdlIGNvdWxkIGRvIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIpIGJ1dCB0aGF0J2QgZXhhY3QgYSBzbGlnaHQgcGVyZm9ybWFuY2UgcGVuYWx0eSBiZWNhdXNlIF9pbmhlcml0RGVmYXVsdHMoKSBhbHNvIHJ1bnMgaW4gdGhlIFR3ZWVuIGNvbnN0cnVjdG9yLiBXZSdyZSBwYXlpbmcgYSBzbWFsbCBrYiBwcmljZSBoZXJlIHRvIGdhaW4gc3BlZWQuXG4gICAgICBpclZhcnMgPSBwYXJlbnQudmFycy5kZWZhdWx0cyB8fCB7fTtcbiAgICAgIHBhcmVudCA9IF9pc05vdEZhbHNlKHBhcmVudC52YXJzLmluaGVyaXQpICYmIHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShpclZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICB0eXBlIDwgMiA/IHZhcnMucnVuQmFja3dhcmRzID0gMSA6IHZhcnMuc3RhcnRBdCA9IHBhcmFtc1t2YXJzSW5kZXggLSAxXTsgLy8gXCJmcm9tXCIgdmFyc1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUd2VlbihwYXJhbXNbMF0sIHZhcnMsIHBhcmFtc1t2YXJzSW5kZXggKyAxXSk7XG59LFxuICAgIF9jb25kaXRpb25hbFJldHVybiA9IGZ1bmN0aW9uIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuYykge1xuICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyBmdW5jKHZhbHVlKSA6IGZ1bmM7XG59LFxuICAgIF9jbGFtcCA9IGZ1bmN0aW9uIF9jbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbn0sXG4gICAgZ2V0VW5pdCA9IGZ1bmN0aW9uIGdldFVuaXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgdmFyIHYgPSBfdW5pdEV4cC5leGVjKHZhbHVlKTtcblxuICByZXR1cm4gdiA/IHZhbHVlLnN1YnN0cih2LmluZGV4ICsgdlswXS5sZW5ndGgpIDogXCJcIjtcbn0sXG4gICAgLy8gbm90ZTogcHJvdGVjdCBhZ2FpbnN0IHBhZGRlZCBudW1iZXJzIGFzIHN0cmluZ3MsIGxpa2UgXCIxMDAuMTAwXCIuIFRoYXQgc2hvdWxkbid0IHJldHVybiBcIjAwXCIgYXMgdGhlIHVuaXQuIElmIGl0J3MgbnVtZXJpYywgcmV0dXJuIG5vIHVuaXQuXG5jbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBfY2xhbXAobWluLCBtYXgsIHYpO1xuICB9KTtcbn0sXG4gICAgX3NsaWNlID0gW10uc2xpY2UsXG4gICAgX2lzQXJyYXlMaWtlID0gZnVuY3Rpb24gX2lzQXJyYXlMaWtlKHZhbHVlLCBub25FbXB0eSkge1xuICByZXR1cm4gdmFsdWUgJiYgX2lzT2JqZWN0KHZhbHVlKSAmJiBcImxlbmd0aFwiIGluIHZhbHVlICYmICghbm9uRW1wdHkgJiYgIXZhbHVlLmxlbmd0aCB8fCB2YWx1ZS5sZW5ndGggLSAxIGluIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZVswXSkpICYmICF2YWx1ZS5ub2RlVHlwZSAmJiB2YWx1ZSAhPT0gX3dpbjtcbn0sXG4gICAgX2ZsYXR0ZW4gPSBmdW5jdGlvbiBfZmxhdHRlbihhciwgbGVhdmVTdHJpbmdzLCBhY2N1bXVsYXRvcikge1xuICBpZiAoYWNjdW11bGF0b3IgPT09IHZvaWQgMCkge1xuICAgIGFjY3VtdWxhdG9yID0gW107XG4gIH1cblxuICByZXR1cm4gYXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgX2FjY3VtdWxhdG9yO1xuXG4gICAgcmV0dXJuIF9pc1N0cmluZyh2YWx1ZSkgJiYgIWxlYXZlU3RyaW5ncyB8fCBfaXNBcnJheUxpa2UodmFsdWUsIDEpID8gKF9hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yKS5wdXNoLmFwcGx5KF9hY2N1bXVsYXRvciwgdG9BcnJheSh2YWx1ZSkpIDogYWNjdW11bGF0b3IucHVzaCh2YWx1ZSk7XG4gIH0pIHx8IGFjY3VtdWxhdG9yO1xufSxcbiAgICAvL3Rha2VzIGFueSB2YWx1ZSBhbmQgcmV0dXJucyBhbiBhcnJheS4gSWYgaXQncyBhIHN0cmluZyAoYW5kIGxlYXZlU3RyaW5ncyBpc24ndCB0cnVlKSwgaXQnbGwgdXNlIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKSBhbmQgY29udmVydCB0aGF0IHRvIGFuIGFycmF5LiBJdCdsbCBhbHNvIGFjY2VwdCBpdGVyYWJsZXMgbGlrZSBqUXVlcnkgb2JqZWN0cy5cbnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KHZhbHVlLCBzY29wZSwgbGVhdmVTdHJpbmdzKSB7XG4gIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgJiYgKF9jb3JlSW5pdHRlZCB8fCAhX3dha2UoKSkgPyBfc2xpY2UuY2FsbCgoc2NvcGUgfHwgX2RvYykucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSksIDApIDogX2lzQXJyYXkodmFsdWUpID8gX2ZsYXR0ZW4odmFsdWUsIGxlYXZlU3RyaW5ncykgOiBfaXNBcnJheUxpa2UodmFsdWUpID8gX3NsaWNlLmNhbGwodmFsdWUsIDApIDogdmFsdWUgPyBbdmFsdWVdIDogW107XG59LFxuICAgIHNlbGVjdG9yID0gZnVuY3Rpb24gc2VsZWN0b3IodmFsdWUpIHtcbiAgdmFsdWUgPSB0b0FycmF5KHZhbHVlKVswXSB8fCBfd2FybihcIkludmFsaWQgc2NvcGVcIikgfHwge307XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIHZhciBlbCA9IHZhbHVlLmN1cnJlbnQgfHwgdmFsdWUubmF0aXZlRWxlbWVudCB8fCB2YWx1ZTtcbiAgICByZXR1cm4gdG9BcnJheSh2LCBlbC5xdWVyeVNlbGVjdG9yQWxsID8gZWwgOiBlbCA9PT0gdmFsdWUgPyBfd2FybihcIkludmFsaWQgc2NvcGVcIikgfHwgX2RvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpIDogdmFsdWUpO1xuICB9O1xufSxcbiAgICBzaHVmZmxlID0gZnVuY3Rpb24gc2h1ZmZsZShhKSB7XG4gIHJldHVybiBhLnNvcnQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAuNSAtIE1hdGgucmFuZG9tKCk7XG4gIH0pO1xufSxcbiAgICAvLyBhbHRlcm5hdGl2ZSB0aGF0J3MgYSBiaXQgZmFzdGVyIGFuZCBtb3JlIHJlbGlhYmx5IGRpdmVyc2UgYnV0IGJpZ2dlcjogICBmb3IgKGxldCBqLCB2LCBpID0gYS5sZW5ndGg7IGk7IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKSwgdiA9IGFbLS1pXSwgYVtpXSA9IGFbal0sIGFbal0gPSB2KTsgcmV0dXJuIGE7XG4vL2ZvciBkaXN0cmlidXRpbmcgdmFsdWVzIGFjcm9zcyBhbiBhcnJheS4gQ2FuIGFjY2VwdCBhIG51bWJlciwgYSBmdW5jdGlvbiBvciAobW9zdCBjb21tb25seSkgYSBmdW5jdGlvbiB3aGljaCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IHtiYXNlLCBhbW91bnQsIGZyb20sIGVhc2UsIGdyaWQsIGF4aXMsIGxlbmd0aCwgZWFjaH0uIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOiBpbmRleCwgdGFyZ2V0LCBhcnJheS4gUmVjb2duaXplcyB0aGUgZm9sbG93aW5nXG5kaXN0cmlidXRlID0gZnVuY3Rpb24gZGlzdHJpYnV0ZSh2KSB7XG4gIGlmIChfaXNGdW5jdGlvbih2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgdmFyIHZhcnMgPSBfaXNPYmplY3QodikgPyB2IDoge1xuICAgIGVhY2g6IHZcbiAgfSxcbiAgICAgIC8vbjoxIGlzIGp1c3QgdG8gaW5kaWNhdGUgdiB3YXMgYSBudW1iZXI7IHdlIGxldmVyYWdlIHRoYXQgbGF0ZXIgdG8gc2V0IHYgYWNjb3JkaW5nIHRvIHRoZSBsZW5ndGggd2UgZ2V0LiBJZiBhIG51bWJlciBpcyBwYXNzZWQgaW4sIHdlIHRyZWF0IGl0IGxpa2UgdGhlIG9sZCBzdGFnZ2VyIHZhbHVlIHdoZXJlIDAuMSwgZm9yIGV4YW1wbGUsIHdvdWxkIG1lYW4gdGhhdCB0aGluZ3Mgd291bGQgYmUgZGlzdHJpYnV0ZWQgd2l0aCAwLjEgYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHJhdGhlciB0aGFuIGEgdG90YWwgXCJhbW91bnRcIiB0aGF0J3MgY2h1bmtlZCBvdXQgYW1vbmcgdGhlbSBhbGwuXG4gIGVhc2UgPSBfcGFyc2VFYXNlKHZhcnMuZWFzZSksXG4gICAgICBmcm9tID0gdmFycy5mcm9tIHx8IDAsXG4gICAgICBiYXNlID0gcGFyc2VGbG9hdCh2YXJzLmJhc2UpIHx8IDAsXG4gICAgICBjYWNoZSA9IHt9LFxuICAgICAgaXNEZWNpbWFsID0gZnJvbSA+IDAgJiYgZnJvbSA8IDEsXG4gICAgICByYXRpb3MgPSBpc05hTihmcm9tKSB8fCBpc0RlY2ltYWwsXG4gICAgICBheGlzID0gdmFycy5heGlzLFxuICAgICAgcmF0aW9YID0gZnJvbSxcbiAgICAgIHJhdGlvWSA9IGZyb207XG5cbiAgaWYgKF9pc1N0cmluZyhmcm9tKSkge1xuICAgIHJhdGlvWCA9IHJhdGlvWSA9IHtcbiAgICAgIGNlbnRlcjogLjUsXG4gICAgICBlZGdlczogLjUsXG4gICAgICBlbmQ6IDFcbiAgICB9W2Zyb21dIHx8IDA7XG4gIH0gZWxzZSBpZiAoIWlzRGVjaW1hbCAmJiByYXRpb3MpIHtcbiAgICByYXRpb1ggPSBmcm9tWzBdO1xuICAgIHJhdGlvWSA9IGZyb21bMV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGksIHRhcmdldCwgYSkge1xuICAgIHZhciBsID0gKGEgfHwgdmFycykubGVuZ3RoLFxuICAgICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSxcbiAgICAgICAgb3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZCxcbiAgICAgICAgaixcbiAgICAgICAgbWF4LFxuICAgICAgICBtaW4sXG4gICAgICAgIHdyYXBBdDtcblxuICAgIGlmICghZGlzdGFuY2VzKSB7XG4gICAgICB3cmFwQXQgPSB2YXJzLmdyaWQgPT09IFwiYXV0b1wiID8gMCA6ICh2YXJzLmdyaWQgfHwgWzEsIF9iaWdOdW1dKVsxXTtcblxuICAgICAgaWYgKCF3cmFwQXQpIHtcbiAgICAgICAgbWF4ID0gLV9iaWdOdW07XG5cbiAgICAgICAgd2hpbGUgKG1heCA8IChtYXggPSBhW3dyYXBBdCsrXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSAmJiB3cmFwQXQgPCBsKSB7fVxuXG4gICAgICAgIHdyYXBBdC0tO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSA9IFtdO1xuICAgICAgb3JpZ2luWCA9IHJhdGlvcyA/IE1hdGgubWluKHdyYXBBdCwgbCkgKiByYXRpb1ggLSAuNSA6IGZyb20gJSB3cmFwQXQ7XG4gICAgICBvcmlnaW5ZID0gcmF0aW9zID8gbCAqIHJhdGlvWSAvIHdyYXBBdCAtIC41IDogZnJvbSAvIHdyYXBBdCB8IDA7XG4gICAgICBtYXggPSAwO1xuICAgICAgbWluID0gX2JpZ051bTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICB4ID0gaiAlIHdyYXBBdCAtIG9yaWdpblg7XG4gICAgICAgIHkgPSBvcmlnaW5ZIC0gKGogLyB3cmFwQXQgfCAwKTtcbiAgICAgICAgZGlzdGFuY2VzW2pdID0gZCA9ICFheGlzID8gX3NxcnQoeCAqIHggKyB5ICogeSkgOiBNYXRoLmFicyhheGlzID09PSBcInlcIiA/IHkgOiB4KTtcbiAgICAgICAgZCA+IG1heCAmJiAobWF4ID0gZCk7XG4gICAgICAgIGQgPCBtaW4gJiYgKG1pbiA9IGQpO1xuICAgICAgfVxuXG4gICAgICBmcm9tID09PSBcInJhbmRvbVwiICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcbiAgICAgIGRpc3RhbmNlcy5tYXggPSBtYXggLSBtaW47XG4gICAgICBkaXN0YW5jZXMubWluID0gbWluO1xuICAgICAgZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpIHx8IDApICogKGZyb20gPT09IFwiZWRnZXNcIiA/IC0xIDogMSk7XG4gICAgICBkaXN0YW5jZXMuYiA9IGwgPCAwID8gYmFzZSAtIGwgOiBiYXNlO1xuICAgICAgZGlzdGFuY2VzLnUgPSBnZXRVbml0KHZhcnMuYW1vdW50IHx8IHZhcnMuZWFjaCkgfHwgMDsgLy91bml0XG5cbiAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuICAgIH1cblxuICAgIGwgPSAoZGlzdGFuY2VzW2ldIC0gZGlzdGFuY2VzLm1pbikgLyBkaXN0YW5jZXMubWF4IHx8IDA7XG4gICAgcmV0dXJuIF9yb3VuZFByZWNpc2UoZGlzdGFuY2VzLmIgKyAoZWFzZSA/IGVhc2UobCkgOiBsKSAqIGRpc3RhbmNlcy52KSArIGRpc3RhbmNlcy51OyAvL3JvdW5kIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuICB9O1xufSxcbiAgICBfcm91bmRNb2RpZmllciA9IGZ1bmN0aW9uIF9yb3VuZE1vZGlmaWVyKHYpIHtcbiAgLy9wYXNzIGluIDAuMSBnZXQgYSBmdW5jdGlvbiB0aGF0J2xsIHJvdW5kIHRvIHRoZSBuZWFyZXN0IHRlbnRoLCBvciA1IHRvIHJvdW5kIHRvIHRoZSBjbG9zZXN0IDUsIG9yIDAuMDAxIHRvIHRoZSBjbG9zZXN0IDEwMDB0aCwgZXRjLlxuICB2YXIgcCA9IE1hdGgucG93KDEwLCAoKHYgKyBcIlwiKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoKTsgLy90byBhdm9pZCBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAobGlrZSAyNCAqIDAuMSA9PSAyLjQwMDAwMDAwMDAwMDAwMDQpLCB3ZSBjaG9wIG9mZiBhdCBhIHNwZWNpZmljIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyAobXVjaCBmYXN0ZXIgdGhhbiB0b0ZpeGVkKCkpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgbiA9IE1hdGgucm91bmQocGFyc2VGbG9hdChyYXcpIC8gdikgKiB2ICogcDtcbiAgICByZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7IC8vIG4gLSBuICUgMSByZXBsYWNlcyBNYXRoLmZsb29yKCkgaW4gb3JkZXIgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBwcm9wZXJseS4gRm9yIGV4YW1wbGUsIE1hdGguZmxvb3IoLTE1MC4wMDAwMDAwMDAwMDAwMykgaXMgMTUxIVxuICB9O1xufSxcbiAgICBzbmFwID0gZnVuY3Rpb24gc25hcChzbmFwVG8sIHZhbHVlKSB7XG4gIHZhciBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGlzMkQ7XG5cbiAgaWYgKCFpc0FycmF5ICYmIF9pc09iamVjdChzbmFwVG8pKSB7XG4gICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblxuICAgIGlmIChzbmFwVG8udmFsdWVzKSB7XG4gICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXG4gICAgICBpZiAoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkge1xuICAgICAgICByYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCAhaXNBcnJheSA/IF9yb3VuZE1vZGlmaWVyKHNuYXBUbykgOiBfaXNGdW5jdGlvbihzbmFwVG8pID8gZnVuY3Rpb24gKHJhdykge1xuICAgIGlzMkQgPSBzbmFwVG8ocmF3KTtcbiAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcbiAgfSA6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG4gICAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGlzMkQpIHtcbiAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XG4gICAgICAgIGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuICAgICAgICBkeCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGR4IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGR4O1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZXN0ID0gIXJhZGl1cyB8fCBtaW4gPD0gcmFkaXVzID8gc25hcFRvW2Nsb3Nlc3RdIDogcmF3O1xuICAgIHJldHVybiBpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSA/IGNsb3Nlc3QgOiBjbG9zZXN0ICsgZ2V0VW5pdChyYXcpO1xuICB9KTtcbn0sXG4gICAgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNBcnJheShtaW4pID8gbWluW35+KE1hdGgucmFuZG9tKCkgKiBtaW4ubGVuZ3RoKV0gOiAocm91bmRpbmdJbmNyZW1lbnQgPSByb3VuZGluZ0luY3JlbWVudCB8fCAxZS01KSAmJiAocmV0dXJuRnVuY3Rpb24gPSByb3VuZGluZ0luY3JlbWVudCA8IDEgPyBNYXRoLnBvdygxMCwgKHJvdW5kaW5nSW5jcmVtZW50ICsgXCJcIikubGVuZ3RoIC0gMikgOiAxKSAmJiBNYXRoLmZsb29yKE1hdGgucm91bmQoKG1pbiAtIHJvdW5kaW5nSW5jcmVtZW50IC8gMiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgcm91bmRpbmdJbmNyZW1lbnQgKiAuOTkpKSAvIHJvdW5kaW5nSW5jcmVtZW50KSAqIHJvdW5kaW5nSW5jcmVtZW50ICogcmV0dXJuRnVuY3Rpb24pIC8gcmV0dXJuRnVuY3Rpb247XG4gIH0pO1xufSxcbiAgICBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgIHJldHVybiBmKHYpO1xuICAgIH0sIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmMocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHVuaXQgfHwgZ2V0VW5pdCh2YWx1ZSkpO1xuICB9O1xufSxcbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xufSxcbiAgICBfd3JhcEFycmF5ID0gZnVuY3Rpb24gX3dyYXBBcnJheShhLCB3cmFwcGVyLCB2YWx1ZSkge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gYVt+fndyYXBwZXIoaW5kZXgpXTtcbiAgfSk7XG59LFxuICAgIHdyYXAgPSBmdW5jdGlvbiB3cmFwKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAvLyBOT1RFOiB3cmFwKCkgQ0FOTk9UIGJlIGFuIGFycm93IGZ1bmN0aW9uISBBIHZlcnkgb2RkIGNvbXBpbGluZyBidWcgY2F1c2VzIHByb2JsZW1zICh1bnJlbGF0ZWQgdG8gR1NBUCkuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcCgwLCBtaW4ubGVuZ3RoKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSArIG1pbjtcbiAgfSk7XG59LFxuICAgIHdyYXBZb3lvID0gZnVuY3Rpb24gd3JhcFlveW8obWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgIHRvdGFsID0gcmFuZ2UgKiAyO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XG4gICAgcmV0dXJuIG1pbiArICh2YWx1ZSA+IHJhbmdlID8gdG90YWwgLSB2YWx1ZSA6IHZhbHVlKTtcbiAgfSk7XG59LFxuICAgIF9yZXBsYWNlUmFuZG9tID0gZnVuY3Rpb24gX3JlcGxhY2VSYW5kb20odmFsdWUpIHtcbiAgLy9yZXBsYWNlcyBhbGwgb2NjdXJyZW5jZXMgb2YgcmFuZG9tKC4uLikgaW4gYSBzdHJpbmcgd2l0aCB0aGUgY2FsY3VsYXRlZCByYW5kb20gdmFsdWUuIGNhbiBiZSBhIHJhbmdlIGxpa2UgcmFuZG9tKC0xMDAsIDEwMCwgNSkgb3IgYW4gYXJyYXkgbGlrZSByYW5kb20oWzAsIDEwMCwgNTAwXSlcbiAgdmFyIHByZXYgPSAwLFxuICAgICAgcyA9IFwiXCIsXG4gICAgICBpLFxuICAgICAgbnVtcyxcbiAgICAgIGVuZCxcbiAgICAgIGlzQXJyYXk7XG5cbiAgd2hpbGUgKH4oaSA9IHZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIsIHByZXYpKSkge1xuICAgIGVuZCA9IHZhbHVlLmluZGV4T2YoXCIpXCIsIGkpO1xuICAgIGlzQXJyYXkgPSB2YWx1ZS5jaGFyQXQoaSArIDcpID09PSBcIltcIjtcbiAgICBudW1zID0gdmFsdWUuc3Vic3RyKGkgKyA3LCBlbmQgLSBpIC0gNykubWF0Y2goaXNBcnJheSA/IF9kZWxpbWl0ZWRWYWx1ZUV4cCA6IF9zdHJpY3ROdW1FeHApO1xuICAgIHMgKz0gdmFsdWUuc3Vic3RyKHByZXYsIGkgLSBwcmV2KSArIHJhbmRvbShpc0FycmF5ID8gbnVtcyA6ICtudW1zWzBdLCBpc0FycmF5ID8gMCA6ICtudW1zWzFdLCArbnVtc1syXSB8fCAxZS01KTtcbiAgICBwcmV2ID0gZW5kICsgMTtcbiAgfVxuXG4gIHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xufSxcbiAgICBtYXBSYW5nZSA9IGZ1bmN0aW9uIG1hcFJhbmdlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgsIHZhbHVlKSB7XG4gIHZhciBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcbiAgICAgIG91dFJhbmdlID0gb3V0TWF4IC0gb3V0TWluO1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcbiAgfSk7XG59LFxuICAgIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkge1xuICB2YXIgZnVuYyA9IGlzTmFOKHN0YXJ0ICsgZW5kKSA/IDAgOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoMSAtIHApICogc3RhcnQgKyBwICogZW5kO1xuICB9O1xuXG4gIGlmICghZnVuYykge1xuICAgIHZhciBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXG4gICAgICAgIG1hc3RlciA9IHt9LFxuICAgICAgICBwLFxuICAgICAgICBpLFxuICAgICAgICBpbnRlcnBvbGF0b3JzLFxuICAgICAgICBsLFxuICAgICAgICBpbDtcblxuICAgIHByb2dyZXNzID09PSB0cnVlICYmIChtdXRhdGUgPSAxKSAmJiAocHJvZ3Jlc3MgPSBudWxsKTtcblxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgc3RhcnQgPSB7XG4gICAgICAgIHA6IHN0YXJ0XG4gICAgICB9O1xuICAgICAgZW5kID0ge1xuICAgICAgICBwOiBlbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaXNBcnJheShzdGFydCkgJiYgIV9pc0FycmF5KGVuZCkpIHtcbiAgICAgIGludGVycG9sYXRvcnMgPSBbXTtcbiAgICAgIGwgPSBzdGFydC5sZW5ndGg7XG4gICAgICBpbCA9IGwgLSAyO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludGVycG9sYXRvcnMucHVzaChpbnRlcnBvbGF0ZShzdGFydFtpIC0gMV0sIHN0YXJ0W2ldKSk7IC8vYnVpbGQgdGhlIGludGVycG9sYXRvcnMgdXAgZnJvbnQgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gdGhhdCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgbWFueSB0aW1lcywgaXQgY2FuIGp1c3QgcmV1c2UgdGhlbS5cbiAgICAgIH1cblxuICAgICAgbC0tO1xuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHAgKj0gbDtcbiAgICAgICAgdmFyIGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvcnNbaV0ocCAtIGkpO1xuICAgICAgfTtcblxuICAgICAgcHJvZ3Jlc3MgPSBlbmQ7XG4gICAgfSBlbHNlIGlmICghbXV0YXRlKSB7XG4gICAgICBzdGFydCA9IF9tZXJnZShfaXNBcnJheShzdGFydCkgPyBbXSA6IHt9LCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JzKSB7XG4gICAgICBmb3IgKHAgaW4gZW5kKSB7XG4gICAgICAgIF9hZGRQcm9wVHdlZW4uY2FsbChtYXN0ZXIsIHN0YXJ0LCBwLCBcImdldFwiLCBlbmRbcF0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4ocHJvZ3Jlc3MsIGZ1bmMpO1xufSxcbiAgICBfZ2V0TGFiZWxJbkRpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRpbWVsaW5lLCBmcm9tVGltZSwgYmFja3dhcmQpIHtcbiAgLy91c2VkIGZvciBuZXh0TGFiZWwoKSBhbmQgcHJldmlvdXNMYWJlbCgpXG4gIHZhciBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgcCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgbGFiZWw7XG5cbiAgZm9yIChwIGluIGxhYmVscykge1xuICAgIGRpc3RhbmNlID0gbGFiZWxzW3BdIC0gZnJvbVRpbWU7XG5cbiAgICBpZiAoZGlzdGFuY2UgPCAwID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcbiAgICAgIGxhYmVsID0gcDtcbiAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbDtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKGFuaW1hdGlvbiwgdHlwZSwgZXhlY3V0ZUxhenlGaXJzdCkge1xuICB2YXIgdiA9IGFuaW1hdGlvbi52YXJzLFxuICAgICAgY2FsbGJhY2sgPSB2W3R5cGVdLFxuICAgICAgcGFyYW1zLFxuICAgICAgc2NvcGU7XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcmFtcyA9IHZbdHlwZSArIFwiUGFyYW1zXCJdO1xuICBzY29wZSA9IHYuY2FsbGJhY2tTY29wZSB8fCBhbmltYXRpb247XG4gIGV4ZWN1dGVMYXp5Rmlyc3QgJiYgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXG4gIHJldHVybiBwYXJhbXMgPyBjYWxsYmFjay5hcHBseShzY29wZSwgcGFyYW1zKSA6IGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdChhbmltYXRpb24pIHtcbiAgX3JlbW92ZUZyb21QYXJlbnQoYW5pbWF0aW9uKTtcblxuICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciAmJiBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5raWxsKGZhbHNlKTtcbiAgYW5pbWF0aW9uLnByb2dyZXNzKCkgPCAxICYmIF9jYWxsYmFjayhhbmltYXRpb24sIFwib25JbnRlcnJ1cHRcIik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9xdWlja1R3ZWVuLFxuICAgIF9jcmVhdGVQbHVnaW4gPSBmdW5jdGlvbiBfY3JlYXRlUGx1Z2luKGNvbmZpZykge1xuICBjb25maWcgPSAhY29uZmlnLm5hbWUgJiYgY29uZmlnW1wiZGVmYXVsdFwiXSB8fCBjb25maWc7IC8vVU1EIHBhY2thZ2luZyB3cmFwcyB0aGluZ3Mgb2RkbHksIHNvIGZvciBleGFtcGxlIE1vdGlvblBhdGhIZWxwZXIgYmVjb21lcyB7TW90aW9uUGF0aEhlbHBlcjpNb3Rpb25QYXRoSGVscGVyLCBkZWZhdWx0Ok1vdGlvblBhdGhIZWxwZXJ9LlxuXG4gIHZhciBuYW1lID0gY29uZmlnLm5hbWUsXG4gICAgICBpc0Z1bmMgPSBfaXNGdW5jdGlvbihjb25maWcpLFxuICAgICAgUGx1Z2luID0gbmFtZSAmJiAhaXNGdW5jICYmIGNvbmZpZy5pbml0ID8gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb3BzID0gW107XG4gIH0gOiBjb25maWcsXG4gICAgICAvL2luIGNhc2Ugc29tZW9uZSBwYXNzZXMgaW4gYW4gb2JqZWN0IHRoYXQncyBub3QgYSBwbHVnaW4sIGxpa2UgQ3VzdG9tRWFzZVxuICBpbnN0YW5jZURlZmF1bHRzID0ge1xuICAgIGluaXQ6IF9lbXB0eUZ1bmMsXG4gICAgcmVuZGVyOiBfcmVuZGVyUHJvcFR3ZWVucyxcbiAgICBhZGQ6IF9hZGRQcm9wVHdlZW4sXG4gICAga2lsbDogX2tpbGxQcm9wVHdlZW5zT2YsXG4gICAgbW9kaWZpZXI6IF9hZGRQbHVnaW5Nb2RpZmllcixcbiAgICByYXdWYXJzOiAwXG4gIH0sXG4gICAgICBzdGF0aWNzID0ge1xuICAgIHRhcmdldFRlc3Q6IDAsXG4gICAgZ2V0OiAwLFxuICAgIGdldFNldHRlcjogX2dldFNldHRlcixcbiAgICBhbGlhc2VzOiB7fSxcbiAgICByZWdpc3RlcjogMFxuICB9O1xuXG4gIF93YWtlKCk7XG5cbiAgaWYgKGNvbmZpZyAhPT0gUGx1Z2luKSB7XG4gICAgaWYgKF9wbHVnaW5zW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3NldERlZmF1bHRzKFBsdWdpbiwgX3NldERlZmF1bHRzKF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgaW5zdGFuY2VEZWZhdWx0cyksIHN0YXRpY3MpKTsgLy9zdGF0aWMgbWV0aG9kc1xuXG5cbiAgICBfbWVyZ2UoUGx1Z2luLnByb3RvdHlwZSwgX21lcmdlKGluc3RhbmNlRGVmYXVsdHMsIF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgc3RhdGljcykpKTsgLy9pbnN0YW5jZSBtZXRob2RzXG5cblxuICAgIF9wbHVnaW5zW1BsdWdpbi5wcm9wID0gbmFtZV0gPSBQbHVnaW47XG5cbiAgICBpZiAoY29uZmlnLnRhcmdldFRlc3QpIHtcbiAgICAgIF9oYXJuZXNzUGx1Z2lucy5wdXNoKFBsdWdpbik7XG5cbiAgICAgIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcbiAgICB9XG5cbiAgICBuYW1lID0gKG5hbWUgPT09IFwiY3NzXCIgPyBcIkNTU1wiIDogbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpKSArIFwiUGx1Z2luXCI7IC8vZm9yIHRoZSBnbG9iYWwgbmFtZS4gXCJtb3Rpb25QYXRoXCIgc2hvdWxkIGJlY29tZSBNb3Rpb25QYXRoUGx1Z2luXG4gIH1cblxuICBfYWRkR2xvYmFsKG5hbWUsIFBsdWdpbik7XG5cbiAgY29uZmlnLnJlZ2lzdGVyICYmIGNvbmZpZy5yZWdpc3Rlcihnc2FwLCBQbHVnaW4sIFByb3BUd2Vlbik7XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENPTE9SU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXzI1NSA9IDI1NSxcbiAgICBfY29sb3JMb29rdXAgPSB7XG4gIGFxdWE6IFswLCBfMjU1LCBfMjU1XSxcbiAgbGltZTogWzAsIF8yNTUsIDBdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgYmx1ZTogWzAsIDAsIF8yNTVdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgd2hpdGU6IFtfMjU1LCBfMjU1LCBfMjU1XSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIHllbGxvdzogW18yNTUsIF8yNTUsIDBdLFxuICBvcmFuZ2U6IFtfMjU1LCAxNjUsIDBdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICByZWQ6IFtfMjU1LCAwLCAwXSxcbiAgcGluazogW18yNTUsIDE5MiwgMjAzXSxcbiAgY3lhbjogWzAsIF8yNTUsIF8yNTVdLFxuICB0cmFuc3BhcmVudDogW18yNTUsIF8yNTUsIF8yNTUsIDBdXG59LFxuICAgIF9odWUgPSBmdW5jdGlvbiBfaHVlKGgsIG0xLCBtMikge1xuICBoID0gaCA8IDAgPyBoICsgMSA6IGggPiAxID8gaCAtIDEgOiBoO1xuICByZXR1cm4gKGggKiA2IDwgMSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiBoIDwgLjUgPyBtMiA6IGggKiAzIDwgMiA/IG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2IDogbTEpICogXzI1NSArIC41IHwgMDtcbn0sXG4gICAgc3BsaXRDb2xvciA9IGZ1bmN0aW9uIHNwbGl0Q29sb3IodiwgdG9IU0wsIGZvcmNlQWxwaGEpIHtcbiAgdmFyIGEgPSAhdiA/IF9jb2xvckxvb2t1cC5ibGFjayA6IF9pc051bWJlcih2KSA/IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV0gOiAwLFxuICAgICAgcixcbiAgICAgIGcsXG4gICAgICBiLFxuICAgICAgaCxcbiAgICAgIHMsXG4gICAgICBsLFxuICAgICAgbWF4LFxuICAgICAgbWluLFxuICAgICAgZCxcbiAgICAgIHdhc0hTTDtcblxuICBpZiAoIWEpIHtcbiAgICBpZiAodi5zdWJzdHIoLTEpID09PSBcIixcIikge1xuICAgICAgLy9zb21ldGltZXMgYSB0cmFpbGluZyBjb21tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cbiAgICAgIHYgPSB2LnN1YnN0cigwLCB2Lmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChfY29sb3JMb29rdXBbdl0pIHtcbiAgICAgIGEgPSBfY29sb3JMb29rdXBbdl07XG4gICAgfSBlbHNlIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgIGlmICh2Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgLy9mb3Igc2hvcnRoYW5kIGxpa2UgIzlGMCBvciAjOUYwRiAoY291bGQgaGF2ZSBhbHBoYSlcbiAgICAgICAgciA9IHYuY2hhckF0KDEpO1xuICAgICAgICBnID0gdi5jaGFyQXQoMik7XG4gICAgICAgIGIgPSB2LmNoYXJBdCgzKTtcbiAgICAgICAgdiA9IFwiI1wiICsgciArIHIgKyBnICsgZyArIGIgKyBiICsgKHYubGVuZ3RoID09PSA1ID8gdi5jaGFyQXQoNCkgKyB2LmNoYXJBdCg0KSA6IFwiXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgLy8gaGV4IHdpdGggYWxwaGEsIGxpa2UgI2ZkNWU1M2ZmXG4gICAgICAgIGEgPSBwYXJzZUludCh2LnN1YnN0cigxLCA2KSwgMTYpO1xuICAgICAgICByZXR1cm4gW2EgPj4gMTYsIGEgPj4gOCAmIF8yNTUsIGEgJiBfMjU1LCBwYXJzZUludCh2LnN1YnN0cig3KSwgMTYpIC8gMjU1XTtcbiAgICAgIH1cblxuICAgICAgdiA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XG4gICAgICBhID0gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XTtcbiAgICB9IGVsc2UgaWYgKHYuc3Vic3RyKDAsIDMpID09PSBcImhzbFwiKSB7XG4gICAgICBhID0gd2FzSFNMID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKTtcblxuICAgICAgaWYgKCF0b0hTTCkge1xuICAgICAgICBoID0gK2FbMF0gJSAzNjAgLyAzNjA7XG4gICAgICAgIHMgPSArYVsxXSAvIDEwMDtcbiAgICAgICAgbCA9ICthWzJdIC8gMTAwO1xuICAgICAgICBnID0gbCA8PSAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgciA9IGwgKiAyIC0gZztcbiAgICAgICAgYS5sZW5ndGggPiAzICYmIChhWzNdICo9IDEpOyAvL2Nhc3QgYXMgbnVtYmVyXG5cbiAgICAgICAgYVswXSA9IF9odWUoaCArIDEgLyAzLCByLCBnKTtcbiAgICAgICAgYVsxXSA9IF9odWUoaCwgciwgZyk7XG4gICAgICAgIGFbMl0gPSBfaHVlKGggLSAxIC8gMywgciwgZyk7XG4gICAgICB9IGVsc2UgaWYgKH52LmluZGV4T2YoXCI9XCIpKSB7XG4gICAgICAgIC8vaWYgcmVsYXRpdmUgdmFsdWVzIGFyZSBmb3VuZCwganVzdCByZXR1cm4gdGhlIHJhdyBzdHJpbmdzIHdpdGggdGhlIHJlbGF0aXZlIHByZWZpeGVzIGluIHBsYWNlLlxuICAgICAgICBhID0gdi5tYXRjaChfbnVtRXhwKTtcbiAgICAgICAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApIHx8IF9jb2xvckxvb2t1cC50cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICBhID0gYS5tYXAoTnVtYmVyKTtcbiAgfVxuXG4gIGlmICh0b0hTTCAmJiAhd2FzSFNMKSB7XG4gICAgciA9IGFbMF0gLyBfMjU1O1xuICAgIGcgPSBhWzFdIC8gXzI1NTtcbiAgICBiID0gYVsyXSAvIF8yNTU7XG4gICAgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgaCA9IHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gbWF4IC0gbWluO1xuICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgICAgaCA9IG1heCA9PT0gciA/IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApIDogbWF4ID09PSBnID8gKGIgLSByKSAvIGQgKyAyIDogKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgaCAqPSA2MDtcbiAgICB9XG5cbiAgICBhWzBdID0gfn4oaCArIC41KTtcbiAgICBhWzFdID0gfn4ocyAqIDEwMCArIC41KTtcbiAgICBhWzJdID0gfn4obCAqIDEwMCArIC41KTtcbiAgfVxuXG4gIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG4gIHJldHVybiBhO1xufSxcbiAgICBfY29sb3JPcmRlckRhdGEgPSBmdW5jdGlvbiBfY29sb3JPcmRlckRhdGEodikge1xuICAvLyBzdHJpcHMgb3V0IHRoZSBjb2xvcnMgZnJvbSB0aGUgc3RyaW5nLCBmaW5kcyBhbGwgdGhlIG51bWVyaWMgc2xvdHMgKHdpdGggdW5pdHMpIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRob3NlLiBUaGUgQXJyYXkgYWxzbyBoYXMgYSBcImNcIiBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheSBvZiB0aGUgaW5kZXggdmFsdWVzIHdoZXJlIHRoZSBjb2xvcnMgYmVsb25nLiBUaGlzIGlzIHRvIGhlbHAgd29yayBhcm91bmQgaXNzdWVzIHdoZXJlIHRoZXJlJ3MgYSBtaXMtbWF0Y2hlZCBvcmRlciBvZiBjb2xvci9udW1lcmljIGRhdGEgbGlrZSBkcm9wLXNoYWRvdygjZjAwIDBweCAxcHggMnB4KSBhbmQgZHJvcC1zaGFkb3coMHggMXB4IDJweCAjZjAwKS4gVGhpcyBpcyBiYXNpY2FsbHkgYSBoZWxwZXIgZnVuY3Rpb24gdXNlZCBpbiBfZm9ybWF0Q29sb3JzKClcbiAgdmFyIHZhbHVlcyA9IFtdLFxuICAgICAgYyA9IFtdLFxuICAgICAgaSA9IC0xO1xuICB2LnNwbGl0KF9jb2xvckV4cCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIHZhciBhID0gdi5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgYSk7XG4gICAgYy5wdXNoKGkgKz0gYS5sZW5ndGggKyAxKTtcbiAgfSk7XG4gIHZhbHVlcy5jID0gYztcbiAgcmV0dXJuIHZhbHVlcztcbn0sXG4gICAgX2Zvcm1hdENvbG9ycyA9IGZ1bmN0aW9uIF9mb3JtYXRDb2xvcnMocywgdG9IU0wsIG9yZGVyTWF0Y2hEYXRhKSB7XG4gIHZhciByZXN1bHQgPSBcIlwiLFxuICAgICAgY29sb3JzID0gKHMgKyByZXN1bHQpLm1hdGNoKF9jb2xvckV4cCksXG4gICAgICB0eXBlID0gdG9IU0wgPyBcImhzbGEoXCIgOiBcInJnYmEoXCIsXG4gICAgICBpID0gMCxcbiAgICAgIGMsXG4gICAgICBzaGVsbCxcbiAgICAgIGQsXG4gICAgICBsO1xuXG4gIGlmICghY29sb3JzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBjb2xvcnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHJldHVybiAoY29sb3IgPSBzcGxpdENvbG9yKGNvbG9yLCB0b0hTTCwgMSkpICYmIHR5cGUgKyAodG9IU0wgPyBjb2xvclswXSArIFwiLFwiICsgY29sb3JbMV0gKyBcIiUsXCIgKyBjb2xvclsyXSArIFwiJSxcIiArIGNvbG9yWzNdIDogY29sb3Iuam9pbihcIixcIikpICsgXCIpXCI7XG4gIH0pO1xuXG4gIGlmIChvcmRlck1hdGNoRGF0YSkge1xuICAgIGQgPSBfY29sb3JPcmRlckRhdGEocyk7XG4gICAgYyA9IG9yZGVyTWF0Y2hEYXRhLmM7XG5cbiAgICBpZiAoYy5qb2luKHJlc3VsdCkgIT09IGQuYy5qb2luKHJlc3VsdCkpIHtcbiAgICAgIHNoZWxsID0gcy5yZXBsYWNlKF9jb2xvckV4cCwgXCIxXCIpLnNwbGl0KF9udW1XaXRoVW5pdEV4cCk7XG4gICAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgKH5jLmluZGV4T2YoaSkgPyBjb2xvcnMuc2hpZnQoKSB8fCB0eXBlICsgXCIwLDAsMCwwKVwiIDogKGQubGVuZ3RoID8gZCA6IGNvbG9ycy5sZW5ndGggPyBjb2xvcnMgOiBvcmRlck1hdGNoRGF0YSkuc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaGVsbCkge1xuICAgIHNoZWxsID0gcy5zcGxpdChfY29sb3JFeHApO1xuICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBzaGVsbFtpXSArIGNvbG9yc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICsgc2hlbGxbbF07XG59LFxuICAgIF9jb2xvckV4cCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHMgPSBcIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjKD86WzAtOWEtZl17Myw0fSl7MSwyfVxcXFxiXCIsXG4gICAgICAvL3dlJ2xsIGR5bmFtaWNhbGx5IGJ1aWxkIHRoaXMgUmVndWxhciBFeHByZXNzaW9uIHRvIGNvbnNlcnZlIGZpbGUgc2l6ZS4gQWZ0ZXIgYnVpbGRpbmcgaXQsIGl0IHdpbGwgYmUgYWJsZSB0byBmaW5kIHJnYigpLCByZ2JhKCksICMgKGhleGFkZWNpbWFsKSwgYW5kIG5hbWVkIGNvbG9yIHZhbHVlcyBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuLFxuICBwO1xuXG4gIGZvciAocCBpbiBfY29sb3JMb29rdXApIHtcbiAgICBzICs9IFwifFwiICsgcCArIFwiXFxcXGJcIjtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHMgKyBcIilcIiwgXCJnaVwiKTtcbn0oKSxcbiAgICBfaHNsRXhwID0gL2hzbFthXT9cXCgvLFxuICAgIF9jb2xvclN0cmluZ0ZpbHRlciA9IGZ1bmN0aW9uIF9jb2xvclN0cmluZ0ZpbHRlcihhKSB7XG4gIHZhciBjb21iaW5lZCA9IGEuam9pbihcIiBcIiksXG4gICAgICB0b0hTTDtcbiAgX2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cbiAgaWYgKF9jb2xvckV4cC50ZXN0KGNvbWJpbmVkKSkge1xuICAgIHRvSFNMID0gX2hzbEV4cC50ZXN0KGNvbWJpbmVkKTtcbiAgICBhWzFdID0gX2Zvcm1hdENvbG9ycyhhWzFdLCB0b0hTTCk7XG4gICAgYVswXSA9IF9mb3JtYXRDb2xvcnMoYVswXSwgdG9IU0wsIF9jb2xvck9yZGVyRGF0YShhWzFdKSk7IC8vIG1ha2Ugc3VyZSB0aGUgb3JkZXIgb2YgbnVtYmVycy9jb2xvcnMgbWF0Y2ggd2l0aCB0aGUgRU5EIHZhbHVlLlxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElDS0VSXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fdGlja2VyQWN0aXZlLFxuICAgIF90aWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfZ2V0VGltZSA9IERhdGUubm93LFxuICAgICAgX2xhZ1RocmVzaG9sZCA9IDUwMCxcbiAgICAgIF9hZGp1c3RlZExhZyA9IDMzLFxuICAgICAgX3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG4gICAgICBfbGFzdFVwZGF0ZSA9IF9zdGFydFRpbWUsXG4gICAgICBfZ2FwID0gMTAwMCAvIDI0MCxcbiAgICAgIF9uZXh0VGltZSA9IF9nYXAsXG4gICAgICBfbGlzdGVuZXJzID0gW10sXG4gICAgICBfaWQsXG4gICAgICBfcmVxLFxuICAgICAgX3JhZixcbiAgICAgIF9zZWxmLFxuICAgICAgX2RlbHRhLFxuICAgICAgX2ksXG4gICAgICBfdGljayA9IGZ1bmN0aW9uIF90aWNrKHYpIHtcbiAgICB2YXIgZWxhcHNlZCA9IF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSxcbiAgICAgICAgbWFudWFsID0gdiA9PT0gdHJ1ZSxcbiAgICAgICAgb3ZlcmxhcCxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGZyYW1lO1xuXG4gICAgZWxhcHNlZCA+IF9sYWdUaHJlc2hvbGQgJiYgKF9zdGFydFRpbWUgKz0gZWxhcHNlZCAtIF9hZGp1c3RlZExhZyk7XG4gICAgX2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcbiAgICB0aW1lID0gX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lO1xuICAgIG92ZXJsYXAgPSB0aW1lIC0gX25leHRUaW1lO1xuXG4gICAgaWYgKG92ZXJsYXAgPiAwIHx8IG1hbnVhbCkge1xuICAgICAgZnJhbWUgPSArK19zZWxmLmZyYW1lO1xuICAgICAgX2RlbHRhID0gdGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwO1xuICAgICAgX3NlbGYudGltZSA9IHRpbWUgPSB0aW1lIC8gMTAwMDtcbiAgICAgIF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG4gICAgICBkaXNwYXRjaCA9IDE7XG4gICAgfVxuXG4gICAgbWFudWFsIHx8IChfaWQgPSBfcmVxKF90aWNrKSk7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGZvciAoX2kgPSAwOyBfaSA8IF9saXN0ZW5lcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIC8vIHVzZSBfaSBhbmQgY2hlY2sgX2xpc3RlbmVycy5sZW5ndGggaW5zdGVhZCBvZiBhIHZhcmlhYmxlIGJlY2F1c2UgYSBsaXN0ZW5lciBjb3VsZCBnZXQgcmVtb3ZlZCBkdXJpbmcgdGhlIGxvb3AsIGFuZCBpZiB0aGF0IGhhcHBlbnMgdG8gYW4gZWxlbWVudCBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgaW5kZXgsIGl0J2QgdGhyb3cgdGhpbmdzIG9mZiBpbiB0aGUgbG9vcC5cbiAgICAgICAgX2xpc3RlbmVyc1tfaV0odGltZSwgX2RlbHRhLCBmcmFtZSwgdik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9zZWxmID0ge1xuICAgIHRpbWU6IDAsXG4gICAgZnJhbWU6IDAsXG4gICAgdGljazogZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIF90aWNrKHRydWUpO1xuICAgIH0sXG4gICAgZGVsdGFSYXRpbzogZnVuY3Rpb24gZGVsdGFSYXRpbyhmcHMpIHtcbiAgICAgIHJldHVybiBfZGVsdGEgLyAoMTAwMCAvIChmcHMgfHwgNjApKTtcbiAgICB9LFxuICAgIHdha2U6IGZ1bmN0aW9uIHdha2UoKSB7XG4gICAgICBpZiAoX2NvcmVSZWFkeSkge1xuICAgICAgICBpZiAoIV9jb3JlSW5pdHRlZCAmJiBfd2luZG93RXhpc3RzKCkpIHtcbiAgICAgICAgICBfd2luID0gX2NvcmVJbml0dGVkID0gd2luZG93O1xuICAgICAgICAgIF9kb2MgPSBfd2luLmRvY3VtZW50IHx8IHt9O1xuICAgICAgICAgIF9nbG9iYWxzLmdzYXAgPSBnc2FwO1xuICAgICAgICAgIChfd2luLmdzYXBWZXJzaW9ucyB8fCAoX3dpbi5nc2FwVmVyc2lvbnMgPSBbXSkpLnB1c2goZ3NhcC52ZXJzaW9uKTtcblxuICAgICAgICAgIF9pbnN0YWxsKF9pbnN0YWxsU2NvcGUgfHwgX3dpbi5HcmVlblNvY2tHbG9iYWxzIHx8ICFfd2luLmdzYXAgJiYgX3dpbiB8fCB7fSk7XG5cbiAgICAgICAgICBfcmFmID0gX3dpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIH1cblxuICAgICAgICBfaWQgJiYgX3NlbGYuc2xlZXAoKTtcblxuICAgICAgICBfcmVxID0gX3JhZiB8fCBmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIF9uZXh0VGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwICsgMSB8IDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aWNrZXJBY3RpdmUgPSAxO1xuXG4gICAgICAgIF90aWNrKDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2xlZXA6IGZ1bmN0aW9uIHNsZWVwKCkge1xuICAgICAgKF9yYWYgPyBfd2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lIDogY2xlYXJUaW1lb3V0KShfaWQpO1xuICAgICAgX3RpY2tlckFjdGl2ZSA9IDA7XG4gICAgICBfcmVxID0gX2VtcHR5RnVuYztcbiAgICB9LFxuICAgIGxhZ1Ntb290aGluZzogZnVuY3Rpb24gbGFnU21vb3RoaW5nKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcbiAgICAgIF9sYWdUaHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgMSAvIF90aW55TnVtOyAvL3plcm8gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2ljYWxseSB1bmxpbWl0ZWRcblxuICAgICAgX2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcsIF9sYWdUaHJlc2hvbGQsIDApO1xuICAgIH0sXG4gICAgZnBzOiBmdW5jdGlvbiBmcHMoX2Zwcykge1xuICAgICAgX2dhcCA9IDEwMDAgLyAoX2ZwcyB8fCAyNDApO1xuICAgICAgX25leHRUaW1lID0gX3NlbGYudGltZSAqIDEwMDAgKyBfZ2FwO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoY2FsbGJhY2spIHtcbiAgICAgIF9saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykgPCAwICYmIF9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG5cbiAgICAgIF93YWtlKCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFjaykge1xuICAgICAgdmFyIGk7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBfbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBfc2VsZjtcbn0oKSxcbiAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICByZXR1cm4gIV90aWNrZXJBY3RpdmUgJiYgX3RpY2tlci53YWtlKCk7XG59LFxuICAgIC8vYWxzbyBlbnN1cmVzIHRoZSBjb3JlIGNsYXNzZXMgYXJlIGluaXRpYWxpemVkLlxuXG4vKlxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIEVBU0lOR1xuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuX2Vhc2VNYXAgPSB7fSxcbiAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgIF9xdW90ZXNFeHAgPSAvW1wiJ10vZyxcbiAgICBfcGFyc2VPYmplY3RJblN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZU9iamVjdEluU3RyaW5nKHZhbHVlKSB7XG4gIC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxuICB2YXIgb2JqID0ge30sXG4gICAgICBzcGxpdCA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAzKS5zcGxpdChcIjpcIiksXG4gICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbCA9IHNwbGl0Lmxlbmd0aCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsLFxuICAgICAgcGFyc2VkVmFsO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFsID0gc3BsaXRbaV07XG4gICAgaW5kZXggPSBpICE9PSBsIC0gMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xuICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgIG9ialtrZXldID0gaXNOYU4ocGFyc2VkVmFsKSA/IHBhcnNlZFZhbC5yZXBsYWNlKF9xdW90ZXNFeHAsIFwiXCIpLnRyaW0oKSA6ICtwYXJzZWRWYWw7XG4gICAga2V5ID0gdmFsLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gIHZhciBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxuICAgICAgY2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwiKVwiKSxcbiAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9wZW4sIH5uZXN0ZWQgJiYgbmVzdGVkIDwgY2xvc2UgPyB2YWx1ZS5pbmRleE9mKFwiKVwiLCBjbG9zZSArIDEpIDogY2xvc2UpO1xufSxcbiAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXG4gIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgZWFzZSA9IF9lYXNlTWFwW3NwbGl0WzBdXTtcbiAgcmV0dXJuIGVhc2UgJiYgc3BsaXQubGVuZ3RoID4gMSAmJiBlYXNlLmNvbmZpZyA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiBfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSA/IF9lYXNlTWFwLl9DRShcIlwiLCBuYW1lKSA6IGVhc2U7XG59LFxuICAgIF9pbnZlcnRFYXNlID0gZnVuY3Rpb24gX2ludmVydEVhc2UoZWFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICB9O1xufSxcbiAgICAvLyBhbGxvdyB5b3lvRWFzZSB0byBiZSBzZXQgaW4gY2hpbGRyZW4gYW5kIGhhdmUgdGhvc2UgYWZmZWN0ZWQgd2hlbiB0aGUgcGFyZW50L2FuY2VzdG9yIHRpbWVsaW5lIHlveW9zLlxuX3Byb3BhZ2F0ZVlveW9FYXNlID0gZnVuY3Rpb24gX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pIHtcbiAgdmFyIGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LFxuICAgICAgZWFzZTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG4gICAgICBpZiAoY2hpbGQudGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZSA9IGNoaWxkLl9lYXNlO1xuICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgY2hpbGQuX3lFYXNlID0gZWFzZTtcbiAgICAgICAgY2hpbGQuX3lveW8gPSBpc1lveW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgfVxufSxcbiAgICBfcGFyc2VFYXNlID0gZnVuY3Rpb24gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xufSxcbiAgICBfaW5zZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnNlcnRFYXNlKG5hbWVzLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCkge1xuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHApO1xuICAgIH07XG4gIH1cblxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgcmV0dXJuIHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyO1xuICAgIH07XG4gIH1cblxuICB2YXIgZWFzZSA9IHtcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XG4gIH0sXG4gICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9nbG9iYWxzW25hbWVdID0gZWFzZTtcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICBmb3IgKHZhciBwIGluIGVhc2UpIHtcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgfTtcbn0sXG4gICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXG4gICAgICAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuICBwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IHAxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMTtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2NvbmZpZ0JhY2sgPSBmdW5jdGlvbiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpIHtcbiAgaWYgKG92ZXJzaG9vdCA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgfVxuXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChvdmVyc2hvb3QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG4vLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbi8vIH0sXG4vLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xuLy8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuLy8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcbi8vIFx0XHRjID0gcmF0aW8gKyBvO1xuLy8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG4vLyB9O1xuXG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuICB2YXIgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocCwgcG93ZXIpO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSBwLCBwb3dlcik7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/IE1hdGgucG93KHAgKiAyLCBwb3dlcikgLyAyIDogMSAtIE1hdGgucG93KCgxIC0gcCkgKiAyLCBwb3dlcikgLyAyO1xuICB9KTtcbn0pO1xuXG5fZWFzZU1hcC5MaW5lYXIuZWFzZU5vbmUgPSBfZWFzZU1hcC5ub25lID0gX2Vhc2VNYXAuTGluZWFyLmVhc2VJbjtcblxuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcblxuKGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBuMSA9IDEgLyBjLFxuICAgICAgbjIgPSAyICogbjEsXG4gICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwIDwgbjEgPyBuICogcCAqIHAgOiBwIDwgbjIgPyBuICogTWF0aC5wb3cocCAtIDEuNSAvIGMsIDIpICsgLjc1IDogcCA8IG4zID8gbiAqIChwIC09IDIuMjUgLyBjKSAqIHAgKyAuOTM3NSA6IG4gKiBNYXRoLnBvdyhwIC0gMi42MjUgLyBjLCAyKSArIC45ODQzNzU7XG4gIH07XG5cbiAgX2luc2VydEVhc2UoXCJCb3VuY2VcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9LCBlYXNlT3V0KTtcbn0pKDcuNTYyNSwgMi43NSk7XG5cbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG59KTtcblxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQmFja1wiLCBfY29uZmlnQmFjayhcImluXCIpLCBfY29uZmlnQmFjayhcIm91dFwiKSwgX2NvbmZpZ0JhY2soKSk7XG5cbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoc3RlcHMsIGltbWVkaWF0ZVN0YXJ0KSB7XG4gICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXBzID0gMTtcbiAgICB9XG5cbiAgICB2YXIgcDEgPSAxIC8gc3RlcHMsXG4gICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgIHAzID0gaW1tZWRpYXRlU3RhcnQgPyAxIDogMCxcbiAgICAgICAgbWF4ID0gMSAtIF90aW55TnVtO1xuICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICgocDIgKiBfY2xhbXAoMCwgbWF4LCBwKSB8IDApICsgcDMpICogcDE7XG4gICAgfTtcbiAgfVxufTtcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcblxuX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCI7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ0FDSEVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICB0aGlzLmlkID0gX2dzSUQrKztcbiAgdGFyZ2V0Ll9nc2FwID0gdGhpcztcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuaGFybmVzcyA9IGhhcm5lc3M7XG4gIHRoaXMuZ2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0IDogX2dldFByb3BlcnR5O1xuICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG59O1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBTklNQVRJT05cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IHZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb24odmFycykge1xuICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgdGhpcy5fZGVsYXkgPSArdmFycy5kZWxheSB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3JlcGVhdCA9IHZhcnMucmVwZWF0ID09PSBJbmZpbml0eSA/IC0yIDogdmFycy5yZXBlYXQgfHwgMCkge1xuICAgICAgLy8gVE9ETzogcmVwZWF0OiBJbmZpbml0eSBvbiBhIHRpbWVsaW5lJ3MgY2hpbGRyZW4gbXVzdCBmbGFnIHRoYXQgdGltZWxpbmUgaW50ZXJuYWxseSBhbmQgYWZmZWN0IGl0cyB0b3RhbER1cmF0aW9uLCBvdGhlcndpc2UgaXQnbGwgc3RvcCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIHdoZW4gcmVhY2hpbmcgdGhlIHN0YXJ0LlxuICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuICAgICAgdGhpcy5feW95byA9ICEhdmFycy55b3lvIHx8ICEhdmFycy55b3lvRWFzZTtcbiAgICB9XG5cbiAgICB0aGlzLl90cyA9IDE7XG5cbiAgICBfc2V0RHVyYXRpb24odGhpcywgK3ZhcnMuZHVyYXRpb24sIDEsIDEpO1xuXG4gICAgdGhpcy5kYXRhID0gdmFycy5kYXRhO1xuICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICB9O1xuXG4gIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3REdXI7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSAwO1xuICAgIHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gdGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSAvICh0aGlzLl9yZXBlYXQgKyAxKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgX2FsaWduUGxheWhlYWQodGhpcywgX3RvdGFsVGltZSk7XG5cbiAgICAgICFwYXJlbnQuX2RwIHx8IHBhcmVudC5wYXJlbnQgfHwgX3Bvc3RBZGRDaGVja3MocGFyZW50LCB0aGlzKTsgLy8gZWRnZSBjYXNlOiBpZiB0aGlzIGlzIGEgY2hpbGQgb2YgYSB0aW1lbGluZSB0aGF0IGFscmVhZHkgY29tcGxldGVkLCBmb3IgZXhhbXBsZSwgd2UgbXVzdCByZS1hY3RpdmF0ZSB0aGUgcGFyZW50LlxuICAgICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0IG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKHRoaXMuX3RzID4gMCAmJiBfdG90YWxUaW1lIDwgdGhpcy5fdER1ciB8fCB0aGlzLl90cyA8IDAgJiYgX3RvdGFsVGltZSA+IDAgfHwgIXRoaXMuX3REdXIgJiYgIV90b3RhbFRpbWUpKSB7XG4gICAgICAgIC8vaWYgdGhlIGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHB1dCBpdCBiYWNrIGludG8gaXRzIGxhc3QgcGFyZW50IChyZWNvcmRlZCBhcyBfZHAgZm9yIGV4YWN0bHkgY2FzZXMgbGlrZSB0aGlzKS4gTGltaXQgdG8gcGFyZW50cyB3aXRoIGF1dG9SZW1vdmVDaGlsZHJlbiAobGlrZSBnbG9iYWxUaW1lbGluZSkgc28gdGhhdCBpZiB0aGUgdXNlciBtYW51YWxseSByZW1vdmVzIGFuIGFuaW1hdGlvbiBmcm9tIGEgdGltZWxpbmUgYW5kIHRoZW4gYWx0ZXJzIGl0cyBwbGF5aGVhZCwgaXQgZG9lc24ndCBnZXQgYWRkZWQgYmFjayBpbi5cbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90VGltZSAhPT0gX3RvdGFsVGltZSB8fCAhdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cyB8fCB0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0gfHwgIV90b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuYWRkIHx8IHRoaXMuX3B0TG9va3VwKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIF9wdExvb2t1cCBvbiBhIFR3ZWVuIGluc3RhbmNlIHRvIGVuc3VyZSBpdCBoYXMgYWN0dWFsbHkgZmluaXNoZWQgYmVpbmcgaW5zdGFudGlhdGVkLCBvdGhlcndpc2UgaWYgdGhpcy5yZXZlcnNlKCkgZ2V0cyBjYWxsZWQgaW4gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgaXQgY291bGQgdHJpZ2dlciBhIHJlbmRlcigpIGhlcmUgZXZlbiB0aG91Z2ggdGhlIF90YXJnZXRzIHdlcmVuJ3QgcG9wdWxhdGVkLCB0aHVzIHdoZW4gX2luaXQoKSBpcyBjYWxsZWQgdGhlcmUgd29uJ3QgYmUgYW55IFByb3BUd2VlbnMgKGl0J2xsIGFjdCBsaWtlIHRoZSB0d2VlbiBpcyBub24tZnVuY3Rpb25hbClcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuICAgICAgLy9pZiAoIXRoaXMuX2xvY2spIHsgLy8gYXZvaWQgZW5kbGVzcyByZWN1cnNpb24gKG5vdCBzdXJlIHdlIG5lZWQgdGhpcyB5ZXQgb3IgaWYgaXQncyB3b3J0aCB0aGUgcGVyZm9ybWFuY2UgaGl0KVxuICAgICAgLy8gICB0aGlzLl9sb2NrID0gMTtcblxuICAgICAgX2xhenlTYWZlUmVuZGVyKHRoaXMsIF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTsgLy8gICB0aGlzLl9sb2NrID0gMDtcbiAgICAgIC8vfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lOyAvLyBub3RlOiBpZiB0aGUgbW9kdWx1cyByZXN1bHRzIGluIDAsIHRoZSBwbGF5aGVhZCBjb3VsZCBiZSBleGFjdGx5IGF0IHRoZSBlbmQgb3IgdGhlIGJlZ2lubmluZywgYW5kIHdlIGFsd2F5cyBkZWZlciB0byB0aGUgRU5EIHdpdGggYSBub24temVybyB2YWx1ZSwgb3RoZXJ3aXNlIGlmIHlvdSBzZXQgdGhlIHRpbWUoKSB0byB0aGUgdmVyeSBlbmQgKGR1cmF0aW9uKCkpLCBpdCB3b3VsZCByZW5kZXIgYXQgdGhlIFNUQVJUIVxuICB9O1xuXG4gIF9wcm90by50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdG90YWxQcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMudG90YWxEdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdFRpbWUgLyB0aGlzLl90RHVyKSA6IHRoaXMucmF0aW87XG4gIH07XG5cbiAgX3Byb3RvLnByb2dyZXNzID0gZnVuY3Rpb24gcHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkgKiAodGhpcy5feW95byAmJiAhKHRoaXMuaXRlcmF0aW9uKCkgJiAxKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5kdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdGltZSAvIHRoaXMuX2R1cikgOiB0aGlzLnJhdGlvO1xuICB9O1xuXG4gIF9wcm90by5pdGVyYXRpb24gPSBmdW5jdGlvbiBpdGVyYXRpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgdmFyIGN5Y2xlRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCkgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWUgKyAodmFsdWUgLSAxKSAqIGN5Y2xlRHVyYXRpb24sIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbikgKyAxIDogMTtcbiAgfSAvLyBwb3RlbnRpYWwgZnV0dXJlIGFkZGl0aW9uOlxuICAvLyBpc1BsYXlpbmdCYWNrd2FyZHMoKSB7XG4gIC8vIFx0bGV0IGFuaW1hdGlvbiA9IHRoaXMsXG4gIC8vIFx0XHRvcmllbnRhdGlvbiA9IDE7IC8vIDEgPSBmb3J3YXJkLCAtMSA9IGJhY2t3YXJkXG4gIC8vIFx0d2hpbGUgKGFuaW1hdGlvbikge1xuICAvLyBcdFx0b3JpZW50YXRpb24gKj0gYW5pbWF0aW9uLnJldmVyc2VkKCkgfHwgKGFuaW1hdGlvbi5yZXBlYXQoKSAmJiAhKGFuaW1hdGlvbi5pdGVyYXRpb24oKSAmIDEpKSA/IC0xIDogMTtcbiAgLy8gXHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXJlbnQ7XG4gIC8vIFx0fVxuICAvLyBcdHJldHVybiBvcmllbnRhdGlvbiA8IDA7XG4gIC8vIH1cbiAgO1xuXG4gIF9wcm90by50aW1lU2NhbGUgPSBmdW5jdGlvbiB0aW1lU2NhbGUodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIHJlY29yZGVkIHRpbWVTY2FsZS4gU3BlY2lhbCBjYXNlOiBpZiBzb21lb25lIGNhbGxzIHJldmVyc2UoKSBvbiBhbiBhbmltYXRpb24gd2l0aCB0aW1lU2NhbGUgb2YgMCwgd2UgYXNzaWduIGl0IC1fdGlueU51bSB0byByZW1lbWJlciBpdCdzIHJldmVyc2VkLlxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lOyAvLyBtYWtlIHN1cmUgdG8gZG8gdGhlIHBhcmVudFRvQ2hpbGRUb3RhbFRpbWUoKSBCRUZPUkUgc2V0dGluZyB0aGUgbmV3IF90cyBiZWNhdXNlIHRoZSBvbGQgb25lIG11c3QgYmUgdXNlZCBpbiB0aGF0IGNhbGN1bGF0aW9uLlxuICAgIC8vIGZ1dHVyZSBhZGRpdGlvbj8gVXAgc2lkZTogZmFzdCBhbmQgbWluaW1hbCBmaWxlIHNpemUuIERvd24gc2lkZTogb25seSB3b3JrcyBvbiB0aGlzIGFuaW1hdGlvbjsgaWYgYSB0aW1lbGluZSBpcyByZXZlcnNlZCwgZm9yIGV4YW1wbGUsIGl0cyBjaGlsZHJlbnMnIG9uUmV2ZXJzZSB3b3VsZG4ndCBnZXQgY2FsbGVkLlxuICAgIC8vKCt2YWx1ZSA8IDAgJiYgdGhpcy5fcnRzID49IDApICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmV2ZXJzZVwiLCB0cnVlKTtcbiAgICAvLyBwcmlvcml0aXplIHJlbmRlcmluZyB3aGVyZSB0aGUgcGFyZW50J3MgcGxheWhlYWQgbGluZXMgdXAgaW5zdGVhZCBvZiB0aGlzLl90VGltZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIGEgdHdlZW4gdGhhdCdzIGFuaW1hdGluZyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIGluIHRoZSBzYW1lIHJlbmRlcmluZyBsb29wIChzYW1lIHBhcmVudCksIHRodXMgaWYgdGhlIHRpbWVTY2FsZSB0d2VlbiByZW5kZXJzIGZpcnN0LCBpdCB3b3VsZCBhbHRlciBfc3RhcnQgQkVGT1JFIF90VGltZSB3YXMgc2V0IG9uIHRoYXQgdGljayAoaW4gdGhlIHJlbmRlcmluZyBsb29wKSwgZWZmZWN0aXZlbHkgZnJlZXppbmcgaXQgdW50aWwgdGhlIHRpbWVTY2FsZSB0d2VlbiBmaW5pc2hlcy5cblxuICAgIHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xuICAgIHRoaXMuX3RzID0gdGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUgd2hpY2ggd291bGQgYmUgMCBpZiB0aGUgYW5pbWF0aW9uIGlzIHBhdXNlZC5cblxuICAgIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMudG90YWxUaW1lKF9jbGFtcCgtdGhpcy5fZGVsYXksIHRoaXMuX3REdXIsIHRUaW1lKSwgdHJ1ZSkpO1xuXG4gICAgX3NldEVuZCh0aGlzKTsgLy8gaWYgcGFyZW50LnNtb290aENoaWxkVGltaW5nIHdhcyBmYWxzZSwgdGhlIGVuZCB0aW1lIGRpZG4ndCBnZXQgdXBkYXRlZCBpbiB0aGUgX2FsaWduUGxheWhlYWQoKSBtZXRob2QsIHNvIGRvIGl0IGhlcmUuXG5cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzIHx8IDEpO1xuICB9O1xuXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YWNoZWQgcGFyZW50XG5cbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2xvYmFsVGltZSA9IGZ1bmN0aW9uIGdsb2JhbFRpbWUocmF3VGltZSkge1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLFxuICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXG4gICAgd2hpbGUgKGFuaW1hdGlvbikge1xuICAgICAgdGltZSA9IGFuaW1hdGlvbi5fc3RhcnQgKyB0aW1lIC8gKGFuaW1hdGlvbi5fdHMgfHwgMSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgIH1cblxuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIF9wcm90by5yZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcmVwZWF0ID0gdmFsdWUgPT09IEluZmluaXR5ID8gLTIgOiB2YWx1ZTtcbiAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBlYXQgPT09IC0yID8gSW5maW5pdHkgOiB0aGlzLl9yZXBlYXQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24gcmVwZWF0RGVsYXkodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5fckRlbGF5ID0gdmFsdWU7XG5cbiAgICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG5cbiAgICAgIHJldHVybiB0aW1lID8gdGhpcy50aW1lKHRpbWUpIDogdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fckRlbGF5O1xuICB9O1xuXG4gIF9wcm90by55b3lvID0gZnVuY3Rpb24geW95byh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl95b3lvID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5feW95bztcbiAgfTtcblxuICBfcHJvdG8uc2VlayA9IGZ1bmN0aW9uIHNlZWsocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzdGFydCA9IGZ1bmN0aW9uIHJlc3RhcnQoaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiB0aGlzLnBsYXkoKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGxheSA9IGZ1bmN0aW9uIHBsYXkoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCksIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBhdFRpbWUgIT0gbnVsbCAmJiB0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZWQgPSBmdW5jdGlvbiByZXZlcnNlZCh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAhIXZhbHVlICE9PSB0aGlzLnJldmVyc2VkKCkgJiYgdGhpcy50aW1lU2NhbGUoLXRoaXMuX3J0cyB8fCAodmFsdWUgPyAtX3RpbnlOdW0gOiAwKSk7IC8vIGluIGNhc2UgdGltZVNjYWxlIGlzIHplcm8sIHJldmVyc2luZyB3b3VsZCBoYXZlIG5vIGVmZmVjdCBzbyB3ZSB1c2UgX3RpbnlOdW0uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9pbml0dGVkID0gdGhpcy5fYWN0ID0gMDtcbiAgICB0aGlzLl96VGltZSA9IC1fdGlueU51bTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHAsXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fc3RhcnQsXG4gICAgICAgIHJhd1RpbWU7XG4gICAgcmV0dXJuICEhKCFwYXJlbnQgfHwgdGhpcy5fdHMgJiYgdGhpcy5faW5pdHRlZCAmJiBwYXJlbnQuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHBhcmVudC5yYXdUaW1lKHRydWUpKSA+PSBzdGFydCAmJiByYXdUaW1lIDwgdGhpcy5lbmRUaW1lKHRydWUpIC0gX3RpbnlOdW0pO1xuICB9O1xuXG4gIF9wcm90by5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gZXZlbnRDYWxsYmFjayh0eXBlLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHZhcnMgPSB0aGlzLnZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgZGVsZXRlIHZhcnNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIHBhcmFtcyAmJiAodmFyc1t0eXBlICsgXCJQYXJhbXNcIl0gPSBwYXJhbXMpO1xuICAgICAgICB0eXBlID09PSBcIm9uVXBkYXRlXCIgJiYgKHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFyc1t0eXBlXTtcbiAgfTtcblxuICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgZiA9IF9pc0Z1bmN0aW9uKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogX3Bhc3NUaHJvdWdoLFxuICAgICAgICAgIF9yZXNvbHZlID0gZnVuY3Rpb24gX3Jlc29sdmUoKSB7XG4gICAgICAgIHZhciBfdGhlbiA9IHNlbGYudGhlbjtcbiAgICAgICAgc2VsZi50aGVuID0gbnVsbDsgLy8gdGVtcG9yYXJpbHkgbnVsbCB0aGUgdGhlbigpIG1ldGhvZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zMjIpXG5cbiAgICAgICAgX2lzRnVuY3Rpb24oZikgJiYgKGYgPSBmKHNlbGYpKSAmJiAoZi50aGVuIHx8IGYgPT09IHNlbGYpICYmIChzZWxmLnRoZW4gPSBfdGhlbik7XG4gICAgICAgIHJlc29sdmUoZik7XG4gICAgICAgIHNlbGYudGhlbiA9IF90aGVuO1xuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGYuX2luaXR0ZWQgJiYgc2VsZi50b3RhbFByb2dyZXNzKCkgPT09IDEgJiYgc2VsZi5fdHMgPj0gMCB8fCAhc2VsZi5fdFRpbWUgJiYgc2VsZi5fdHMgPCAwKSB7XG4gICAgICAgIF9yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9wcm9tID0gX3Jlc29sdmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIF9pbnRlcnJ1cHQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGlvbjtcbn0oKTtcblxuX3NldERlZmF1bHRzKEFuaW1hdGlvbi5wcm90b3R5cGUsIHtcbiAgX3RpbWU6IDAsXG4gIF9zdGFydDogMCxcbiAgX2VuZDogMCxcbiAgX3RUaW1lOiAwLFxuICBfdER1cjogMCxcbiAgX2RpcnR5OiAwLFxuICBfcmVwZWF0OiAwLFxuICBfeW95bzogZmFsc2UsXG4gIHBhcmVudDogbnVsbCxcbiAgX2luaXR0ZWQ6IGZhbHNlLFxuICBfckRlbGF5OiAwLFxuICBfdHM6IDEsXG4gIF9kcDogMCxcbiAgcmF0aW86IDAsXG4gIF96VGltZTogLV90aW55TnVtLFxuICBfcHJvbTogMCxcbiAgX3BzOiBmYWxzZSxcbiAgX3J0czogMVxufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElNRUxJTkVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVGltZWxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoVGltZWxpbmUsIF9BbmltYXRpb24pO1xuXG4gIGZ1bmN0aW9uIFRpbWVsaW5lKHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX0FuaW1hdGlvbi5jYWxsKHRoaXMsIHZhcnMpIHx8IHRoaXM7XG4gICAgX3RoaXMubGFiZWxzID0ge307XG4gICAgX3RoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAhIXZhcnMuc21vb3RoQ2hpbGRUaW1pbmc7XG4gICAgX3RoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gISF2YXJzLmF1dG9SZW1vdmVDaGlsZHJlbjtcbiAgICBfdGhpcy5fc29ydCA9IF9pc05vdEZhbHNlKHZhcnMuc29ydENoaWxkcmVuKTtcbiAgICBfZ2xvYmFsVGltZWxpbmUgJiYgX2FkZFRvVGltZWxpbmUodmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgcG9zaXRpb24pO1xuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMucmV2ZXJzZSgpO1xuICAgIHZhcnMucGF1c2VkICYmIF90aGlzLnBhdXNlZCh0cnVlKTtcbiAgICB2YXJzLnNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhcnMuc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBUaW1lbGluZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50byA9IGZ1bmN0aW9uIHRvKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgwLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICEhdmFycy5pbW1lZGlhdGVSZW5kZXI7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5jYWxsID0gZnVuY3Rpb24gY2FsbChjYWxsYmFjaywgcGFyYW1zLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBfYWRkVG9UaW1lbGluZSh0aGlzLCBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zKSwgcG9zaXRpb24pO1xuICB9IC8vT05MWSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSEgTWF5YmUgZGVsZXRlP1xuICA7XG5cbiAgX3Byb3RvMi5zdGFnZ2VyVG8gPSBmdW5jdGlvbiBzdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHZhcnMuc3RhZ2dlciA9IHZhcnMuc3RhZ2dlciB8fCBzdGFnZ2VyO1xuICAgIHZhcnMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVBbGw7XG4gICAgdmFycy5vbkNvbXBsZXRlUGFyYW1zID0gb25Db21wbGV0ZUFsbFBhcmFtcztcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbVRvKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh0b1ZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICB2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuICAgICAgICB0RHVyID0gdGhpcy5fZGlydHkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPD0gMCA/IDAgOiBfcm91bmRQcmVjaXNlKHRvdGFsVGltZSksXG4gICAgICAgIC8vIGlmIGEgcGF1c2VkIHRpbWVsaW5lIGlzIHJlc3VtZWQgKG9yIGl0cyBfc3RhcnQgaXMgdXBkYXRlZCBmb3IgYW5vdGhlciByZWFzb24uLi53aGljaCByb3VuZHMgaXQpLCB0aGF0IGNvdWxkIHJlc3VsdCBpbiB0aGUgcGxheWhlYWQgc2hpZnRpbmcgYSAqKnRpbnkqKiBhbW91bnQgYW5kIGEgemVyby1kdXJhdGlvbiBjaGlsZCBhdCB0aGF0IHNwb3QgbWF5IGdldCByZW5kZXJlZCBhdCBhIGRpZmZlcmVudCByYXRpbywgbGlrZSBpdHMgdG90YWxUaW1lIGluIHJlbmRlcigpIG1heSBiZSAxZS0xNyBpbnN0ZWFkIG9mIDAsIGZvciBleGFtcGxlLlxuICAgIGNyb3NzaW5nU3RhcnQgPSB0aGlzLl96VGltZSA8IDAgIT09IHRvdGFsVGltZSA8IDAgJiYgKHRoaXMuX2luaXR0ZWQgfHwgIWR1ciksXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0LFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgIHByZXZQYXVzZWQsXG4gICAgICAgIHBhdXNlVHdlZW4sXG4gICAgICAgIHRpbWVTY2FsZSxcbiAgICAgICAgcHJldlN0YXJ0LFxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICB5b3lvLFxuICAgICAgICBpc1lveW87XG4gICAgdGhpcyAhPT0gX2dsb2JhbFRpbWVsaW5lICYmIHRUaW1lID4gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCAmJiAodFRpbWUgPSB0RHVyKTtcblxuICAgIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgZm9yY2UgfHwgY3Jvc3NpbmdTdGFydCkge1xuICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikge1xuICAgICAgICAvL2lmIHRvdGFsRHVyYXRpb24oKSBmaW5kcyBhIGNoaWxkIHdpdGggYSBuZWdhdGl2ZSBzdGFydFRpbWUgYW5kIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHRoaW5ncyBnZXQgc2hpZnRlZCBhcm91bmQgaW50ZXJuYWxseSBzbyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgdGltZSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIGEgdHdlZW4gc3RhcnRzIGF0IC0zMCB3ZSBtdXN0IHNoaWZ0IEVWRVJZVEhJTkcgZm9yd2FyZCAzMCBzZWNvbmRzIGFuZCBtb3ZlIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgYmFja3dhcmQgYnkgMzAgc2Vjb25kcyBzbyB0aGF0IHRoaW5ncyBhbGlnbiB3aXRoIHRoZSBwbGF5aGVhZCAobm8ganVtcCkuXG4gICAgICAgIHRUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgICAgdG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgIH1cblxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgcHJldlN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICB0aW1lU2NhbGUgPSB0aGlzLl90cztcbiAgICAgIHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xuXG4gICAgICBpZiAoY3Jvc3NpbmdTdGFydCkge1xuICAgICAgICBkdXIgfHwgKHByZXZUaW1lID0gdGhpcy5felRpbWUpOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIXN1cHByZXNzRXZlbnRzKSAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICB5b3lvID0gdGhpcy5feW95bztcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcblxuICAgICAgICBpZiAodGhpcy5fcmVwZWF0IDwgLTEgJiYgdG90YWxUaW1lIDwgMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IF9yb3VuZFByZWNpc2UodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gdFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcbiAgICAgICAgIXByZXZUaW1lICYmIHRoaXMuX3RUaW1lICYmIHByZXZJdGVyYXRpb24gIT09IGl0ZXJhdGlvbiAmJiAocHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbik7IC8vIGVkZ2UgY2FzZSAtIGlmIHNvbWVvbmUgZG9lcyBhZGRQYXVzZSgpIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHJlcGVhdGluZyB0aW1lbGluZSwgdGhhdCBwYXVzZSBpcyB0ZWNobmljYWxseSBhdCB0aGUgc2FtZSBzcG90IGFzIHRoZSBlbmQgd2hpY2ggY2F1c2VzIHRoaXMuX3RpbWUgdG8gZ2V0IHNldCB0byAwIHdoZW4gdGhlIHRvdGFsVGltZSB3b3VsZCBub3JtYWxseSBwbGFjZSB0aGUgcGxheWhlYWQgYXQgdGhlIGVuZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjM4MjMtY2xvc2luZy1uYXYtYW5pbWF0aW9uLW5vdC13b3JraW5nLW9uLWllLWFuZC1pcGhvbmUtNi1tYXliZS1vdGhlci1vbGRlci1icm93c2VyLz90YWI9Y29tbWVudHMjY29tbWVudC0xMTMwMDVcblxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgaXNZb3lvID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuICAgICAgICB3b3VsZCBnZXQgdHJhbnNsYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcbiAgICAgICAgY291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcbiAgICAgICAgZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmUgd29yay5cbiAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcbiAgICAgICAgICAgICAgZG9lc1dyYXAgPSByZXdpbmRpbmcgPT09ICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpO1xuICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IGR1cjtcbiAgICAgICAgICB0aGlzLl9sb2NrID0gMTtcbiAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSB8fCAoaXNZb3lvID8gMCA6IF9yb3VuZFByZWNpc2UoaXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbikpLCBzdXBwcmVzc0V2ZW50cywgIWR1cikuX2xvY2sgPSAwO1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7IC8vIGlmIGEgdXNlciBnZXRzIHRoZSBpdGVyYXRpb24oKSBpbnNpZGUgdGhlIG9uUmVwZWF0LCBmb3IgZXhhbXBsZSwgaXQgc2hvdWxkIGJlIGFjY3VyYXRlLlxuXG4gICAgICAgICAgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cbiAgICAgICAgICBpZiAocHJldlRpbWUgJiYgcHJldlRpbWUgIT09IHRoaXMuX3RpbWUgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzIHx8IHRoaXMudmFycy5vblJlcGVhdCAmJiAhdGhpcy5wYXJlbnQgJiYgIXRoaXMuX2FjdCkge1xuICAgICAgICAgICAgLy8gaWYgcHJldlRpbWUgaXMgMCBhbmQgd2UgcmVuZGVyIGF0IHRoZSB2ZXJ5IGVuZCwgX3RpbWUgd2lsbCBiZSB0aGUgZW5kLCB0aHVzIHdvbid0IG1hdGNoLiBTbyBpbiB0aGlzIGVkZ2UgY2FzZSwgcHJldlRpbWUgd29uJ3QgbWF0Y2ggX3RpbWUgYnV0IHRoYXQncyBva2F5LiBJZiBpdCBnZXRzIGtpbGxlZCBpbiB0aGUgb25SZXBlYXQsIGVqZWN0IGFzIHdlbGwuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkdXIgPSB0aGlzLl9kdXI7IC8vIGluIGNhc2UgdGhlIGR1cmF0aW9uIGNoYW5nZWQgaW4gdGhlIG9uUmVwZWF0XG5cbiAgICAgICAgICB0RHVyID0gdGhpcy5fdER1cjtcblxuICAgICAgICAgIGlmIChkb2VzV3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IDI7XG4gICAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IGR1ciA6IC0wLjAwMDE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSAvL2luIG9yZGVyIGZvciB5b3lvRWFzZSB0byB3b3JrIHByb3Blcmx5IHdoZW4gdGhlcmUncyBhIHN0YWdnZXIsIHdlIG11c3Qgc3dhcCBvdXQgdGhlIGVhc2UgaW4gZWFjaCBzdWItdHdlZW4uXG5cblxuICAgICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZSh0aGlzLCBpc1lveW8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZyAmJiB0aGlzLl9sb2NrIDwgMikge1xuICAgICAgICBwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmRQcmVjaXNlKHByZXZUaW1lKSwgX3JvdW5kUHJlY2lzZSh0aW1lKSk7XG5cbiAgICAgICAgaWYgKHBhdXNlVHdlZW4pIHtcbiAgICAgICAgICB0VGltZSAtPSB0aW1lIC0gKHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgICAgdGhpcy5fYWN0ID0gIXRpbWVTY2FsZTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgIGlmICghdGhpcy5faW5pdHRlZCkge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcbiAgICAgICAgdGhpcy5faW5pdHRlZCA9IDE7XG4gICAgICAgIHRoaXMuX3pUaW1lID0gdG90YWxUaW1lO1xuICAgICAgICBwcmV2VGltZSA9IDA7IC8vIHVwb24gaW5pdCwgdGhlIHBsYXloZWFkIHNob3VsZCBhbHdheXMgZ28gZm9yd2FyZDsgc29tZW9uZSBjb3VsZCBpbnZhbGlkYXRlKCkgYSBjb21wbGV0ZWQgdGltZWxpbmUgYW5kIHRoZW4gaWYgdGhleSByZXN0YXJ0KCksIHRoYXQgd291bGQgbWFrZSBjaGlsZCB0d2VlbnMgcmVuZGVyIGluIHJldmVyc2Ugb3JkZXIgd2hpY2ggY291bGQgbG9jayBpbiB0aGUgd3Jvbmcgc3RhcnRpbmcgdmFsdWVzIGlmIHRoZXkgYnVpbGQgb24gZWFjaCBvdGhlciwgbGlrZSB0bC50byhvYmosIHt4OiAxMDB9KS50byhvYmosIHt4OiAwfSkuXG4gICAgICB9XG5cbiAgICAgIGlmICghcHJldlRpbWUgJiYgdGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZSA+PSBwcmV2VGltZSAmJiB0b3RhbFRpbWUgPj0gMCkge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCB0aW1lID49IGNoaWxkLl9zdGFydCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSAtX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gZmxhZyB6VGltZSBhcyBuZWdhdGl2ZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5fbGFzdDtcbiAgICAgICAgdmFyIGFkanVzdGVkVGltZSA9IHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lOyAvL3doZW4gdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBtdXN0IHBhc3MgdGhhdCBpbmZvcm1hdGlvbiBkb3duIHRvIHRoZSBjaGlsZCBhbmltYXRpb25zIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMga25vdyB3aGV0aGVyIHRvIHJlbmRlciB0aGVpciBzdGFydGluZyBvciBlbmRpbmcgdmFsdWVzLlxuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fcHJldjtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gYWRqdXN0ZWRUaW1lID8gLV90aW55TnVtIDogX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gYWRqdXN0IHpUaW1lIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF1c2VUd2VlbiAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSA+PSBwcmV2VGltZSA/IDEgOiAtMTtcblxuICAgICAgICBpZiAodGhpcy5fdHMpIHtcbiAgICAgICAgICAvL3RoZSBjYWxsYmFjayByZXN1bWVkIHBsYXliYWNrISBTbyBzaW5jZSB3ZSBtYXkgaGF2ZSBoZWxkIGJhY2sgdGhlIHBsYXloZWFkIGR1ZSB0byB3aGVyZSB0aGUgcGF1c2UgaXMgcG9zaXRpb25lZCwgZ28gYWhlYWQgYW5kIGp1bXAgdG8gd2hlcmUgaXQncyBTVVBQT1NFRCB0byBiZSAoaWYgbm8gcGF1c2UgaGFwcGVuZWQpLlxuICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gcHJldlN0YXJ0OyAvL2lmIHRoZSBwYXVzZSB3YXMgYXQgYW4gZWFybGllciB0aW1lIGFuZCB0aGUgdXNlciByZXN1bWVkIGluIHRoZSBjYWxsYmFjaywgaXQgY291bGQgcmVwb3NpdGlvbiB0aGUgdGltZWxpbmUgKGNoYW5naW5nIGl0cyBzdGFydFRpbWUpLCB0aHJvd2luZyB0aGluZ3Mgb2ZmIHNsaWdodGx5LCBzbyB3ZSBtYWtlIHN1cmUgdGhlIF9zdGFydCBkb2Vzbid0IHNoaWZ0LlxuXG4gICAgICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuICAgICAgaWYgKHRUaW1lID09PSB0RHVyICYmIHREdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkgfHwgIXRUaW1lICYmIHByZXZUaW1lKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydCB8fCBNYXRoLmFicyh0aW1lU2NhbGUpICE9PSBNYXRoLmFicyh0aGlzLl90cykpIGlmICghdGhpcy5fbG9jaykge1xuICAgICAgICAodG90YWxUaW1lIHx8ICFkdXIpICYmICh0VGltZSA9PT0gdER1ciAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7IC8vIGRvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8ICF0RHVyKSkge1xuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCB0VGltZSA9PT0gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICAgIHRoaXMuX3Byb20gJiYgISh0VGltZSA8IHREdXIgJiYgdGhpcy50aW1lU2NhbGUoKSA+IDApICYmIHRoaXMuX3Byb20oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkID0gZnVuY3Rpb24gYWRkKGNoaWxkLCBwb3NpdGlvbikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgX2lzTnVtYmVyKHBvc2l0aW9uKSB8fCAocG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiwgY2hpbGQpKTtcblxuICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xuICAgICAgaWYgKF9pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFkZChvYmosIHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYWJlbChjaGlsZCwgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMgIT09IGNoaWxkID8gX2FkZFRvVGltZWxpbmUodGhpcywgY2hpbGQsIHBvc2l0aW9uKSA6IHRoaXM7IC8vZG9uJ3QgYWxsb3cgYSB0aW1lbGluZSB0byBiZSBhZGRlZCB0byBpdHNlbGYgYXMgYSBjaGlsZCFcbiAgfTtcblxuICBfcHJvdG8yLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChuZXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgbmVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHdlZW5zID09PSB2b2lkIDApIHtcbiAgICAgIHR3ZWVucyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVsaW5lcyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aW1lbGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IFtdLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgICB0d2VlbnMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lbGluZXMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBuZXN0ZWQgJiYgYS5wdXNoLmFwcGx5KGEsIGNoaWxkLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBfcHJvdG8yLmdldEJ5SWQgPSBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmdldENoaWxkcmVuKDEsIDEsIDEpLFxuICAgICAgICBpID0gYW5pbWF0aW9ucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoY2hpbGQpIHtcbiAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwoY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmtpbGxUd2VlbnNPZihjaGlsZCk7XG4gICAgfVxuXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIGNoaWxkKTtcblxuICAgIGlmIChjaGlsZCA9PT0gdGhpcy5fcmVjZW50KSB7XG4gICAgICB0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMTtcblxuICAgIGlmICghdGhpcy5fZHAgJiYgdGhpcy5fdHMpIHtcbiAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciB0aGUgZ2xvYmFsIHRpbWVsaW5lIChvciBhbnkgb3RoZXIgdGhhdCBoYXMgbm8gcGFyZW50IG9yIGRldGFjaGVkIHBhcmVudCkuXG4gICAgICB0aGlzLl9zdGFydCA9IF9yb3VuZFByZWNpc2UoX3RpY2tlci50aW1lIC0gKHRoaXMuX3RzID4gMCA/IF90b3RhbFRpbWUyIC8gdGhpcy5fdHMgOiAodGhpcy50b3RhbER1cmF0aW9uKCkgLSBfdG90YWxUaW1lMikgLyAtdGhpcy5fdHMpKTtcbiAgICB9XG5cbiAgICBfQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuY2FsbCh0aGlzLCBfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpO1xuXG4gICAgdGhpcy5fZm9yY2luZyA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRMYWJlbCA9IGZ1bmN0aW9uIGFkZExhYmVsKGxhYmVsLCBwb3NpdGlvbikge1xuICAgIHRoaXMubGFiZWxzW2xhYmVsXSA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24gcmVtb3ZlTGFiZWwobGFiZWwpIHtcbiAgICBkZWxldGUgdGhpcy5sYWJlbHNbbGFiZWxdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkUGF1c2UgPSBmdW5jdGlvbiBhZGRQYXVzZShwb3NpdGlvbiwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgIHZhciB0ID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2sgfHwgX2VtcHR5RnVuYywgcGFyYW1zKTtcbiAgICB0LmRhdGEgPSBcImlzUGF1c2VcIjtcbiAgICB0aGlzLl9oYXNQYXVzZSA9IDE7XG4gICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIHQsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmVQYXVzZSA9IGZ1bmN0aW9uIHJlbW92ZVBhdXNlKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgcG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPT09IHBvc2l0aW9uICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICB2YXIgdHdlZW5zID0gdGhpcy5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSxcbiAgICAgICAgaSA9IHR3ZWVucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiAhPT0gdHdlZW5zW2ldICYmIHR3ZWVuc1tpXS5raWxsKHRhcmdldHMsIHByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmdldFR3ZWVuc09mID0gZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgIHZhciBhID0gW10sXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBpc0dsb2JhbFRpbWUgPSBfaXNOdW1iZXIob25seUFjdGl2ZSksXG4gICAgICAgIC8vIGEgbnVtYmVyIGlzIGludGVycHJldGVkIGFzIGEgZ2xvYmFsIHRpbWUuIElmIHRoZSBhbmltYXRpb24gc3BhbnNcbiAgICBjaGlsZHJlbjtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgaWYgKF9hcnJheUNvbnRhaW5zQW55KGNoaWxkLl90YXJnZXRzLCBwYXJzZWRUYXJnZXRzKSAmJiAoaXNHbG9iYWxUaW1lID8gKCFfb3ZlcndyaXRpbmdUd2VlbiB8fCBjaGlsZC5faW5pdHRlZCAmJiBjaGlsZC5fdHMpICYmIGNoaWxkLmdsb2JhbFRpbWUoMCkgPD0gb25seUFjdGl2ZSAmJiBjaGlsZC5nbG9iYWxUaW1lKGNoaWxkLnRvdGFsRHVyYXRpb24oKSkgPiBvbmx5QWN0aXZlIDogIW9ubHlBY3RpdmUgfHwgY2hpbGQuaXNBY3RpdmUoKSkpIHtcbiAgICAgICAgICAvLyBub3RlOiBpZiB0aGlzIGlzIGZvciBvdmVyd3JpdGluZywgaXQgc2hvdWxkIG9ubHkgYmUgZm9yIHR3ZWVucyB0aGF0IGFyZW4ndCBwYXVzZWQgYW5kIGFyZSBpbml0dGVkLlxuICAgICAgICAgIGEucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKGNoaWxkcmVuID0gY2hpbGQuZ2V0VHdlZW5zT2YocGFyc2VkVGFyZ2V0cywgb25seUFjdGl2ZSkpLmxlbmd0aCkge1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9IC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAtIHRhcmdldHMoKSBvbiB0aW1lbGluZXNcbiAgLy8gdGFyZ2V0cygpIHtcbiAgLy8gXHRsZXQgcmVzdWx0ID0gW107XG4gIC8vIFx0dGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkuZm9yRWFjaCh0ID0+IHJlc3VsdC5wdXNoKC4uLnQudGFyZ2V0cygpKSk7XG4gIC8vIFx0cmV0dXJuIHJlc3VsdC5maWx0ZXIoKHYsIGkpID0+IHJlc3VsdC5pbmRleE9mKHYpID09PSBpKTtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvMi50d2VlblRvID0gZnVuY3Rpb24gdHdlZW5Ubyhwb3NpdGlvbiwgdmFycykge1xuICAgIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gICAgdmFyIHRsID0gdGhpcyxcbiAgICAgICAgZW5kVGltZSA9IF9wYXJzZVBvc2l0aW9uKHRsLCBwb3NpdGlvbiksXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgc3RhcnRBdCA9IF92YXJzLnN0YXJ0QXQsXG4gICAgICAgIF9vblN0YXJ0ID0gX3ZhcnMub25TdGFydCxcbiAgICAgICAgb25TdGFydFBhcmFtcyA9IF92YXJzLm9uU3RhcnRQYXJhbXMsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF92YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgdHdlZW4gPSBUd2Vlbi50byh0bCwgX3NldERlZmF1bHRzKHtcbiAgICAgIGVhc2U6IHZhcnMuZWFzZSB8fCBcIm5vbmVcIixcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIHRpbWU6IGVuZFRpbWUsXG4gICAgICBvdmVyd3JpdGU6IFwiYXV0b1wiLFxuICAgICAgZHVyYXRpb246IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSAoc3RhcnRBdCAmJiBcInRpbWVcIiBpbiBzdGFydEF0ID8gc3RhcnRBdC50aW1lIDogdGwuX3RpbWUpKSAvIHRsLnRpbWVTY2FsZSgpKSB8fCBfdGlueU51bSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIHRsLnBhdXNlKCk7XG5cbiAgICAgICAgaWYgKCFpbml0dGVkKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpO1xuICAgICAgICAgIHR3ZWVuLl9kdXIgIT09IGR1cmF0aW9uICYmIF9zZXREdXJhdGlvbih0d2VlbiwgZHVyYXRpb24sIDAsIDEpLnJlbmRlcih0d2Vlbi5fdGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5pdHRlZCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBfb25TdGFydCAmJiBfb25TdGFydC5hcHBseSh0d2Vlbiwgb25TdGFydFBhcmFtcyB8fCBbXSk7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuICAgICAgfVxuICAgIH0sIHZhcnMpKTtcblxuICAgIHJldHVybiBpbW1lZGlhdGVSZW5kZXIgPyB0d2Vlbi5yZW5kZXIoMCkgOiB0d2VlbjtcbiAgfTtcblxuICBfcHJvdG8yLnR3ZWVuRnJvbVRvID0gZnVuY3Rpb24gdHdlZW5Gcm9tVG8oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgc3RhcnRBdDoge1xuICAgICAgICB0aW1lOiBfcGFyc2VQb3NpdGlvbih0aGlzLCBmcm9tUG9zaXRpb24pXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuICB9O1xuXG4gIF9wcm90bzIucmVjZW50ID0gZnVuY3Rpb24gcmVjZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNlbnQ7XG4gIH07XG5cbiAgX3Byb3RvMi5uZXh0TGFiZWwgPSBmdW5jdGlvbiBuZXh0TGFiZWwoYWZ0ZXJUaW1lKSB7XG4gICAgaWYgKGFmdGVyVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBhZnRlclRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBhZnRlclRpbWUpKTtcbiAgfTtcblxuICBfcHJvdG8yLnByZXZpb3VzTGFiZWwgPSBmdW5jdGlvbiBwcmV2aW91c0xhYmVsKGJlZm9yZVRpbWUpIHtcbiAgICBpZiAoYmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBiZWZvcmVUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYmVmb3JlVGltZSksIDEpO1xuICB9O1xuXG4gIF9wcm90bzIuY3VycmVudExhYmVsID0gZnVuY3Rpb24gY3VycmVudExhYmVsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNlZWsodmFsdWUsIHRydWUpIDogdGhpcy5wcmV2aW91c0xhYmVsKHRoaXMuX3RpbWUgKyBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvMi5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24gc2hpZnRDaGlsZHJlbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAwO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBsYWJlbHMgPSB0aGlzLmxhYmVscyxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgIGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XG4gICAgICAgIGNoaWxkLl9lbmQgKz0gYW1vdW50O1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChhZGp1c3RMYWJlbHMpIHtcbiAgICAgIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICAgICAgaWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgICAgbGFiZWxzW3BdICs9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBjaGlsZC5pbnZhbGlkYXRlKCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBfQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKGluY2x1ZGVMYWJlbHMpIHtcbiAgICBpZiAoaW5jbHVkZUxhYmVscyA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmNsdWRlTGFiZWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdCxcbiAgICAgICAgbmV4dDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xuICAgICAgY2hpbGQgPSBuZXh0O1xuICAgIH1cblxuICAgIHRoaXMuX2RwICYmICh0aGlzLl90aW1lID0gdGhpcy5fdFRpbWUgPSB0aGlzLl9wVGltZSA9IDApO1xuICAgIGluY2x1ZGVMYWJlbHMgJiYgKHRoaXMubGFiZWxzID0ge30pO1xuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiB0b3RhbER1cmF0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG1heCA9IDAsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjaGlsZCA9IHNlbGYuX2xhc3QsXG4gICAgICAgIHByZXZTdGFydCA9IF9iaWdOdW0sXG4gICAgICAgIHByZXYsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBwYXJlbnQ7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNlbGYudGltZVNjYWxlKChzZWxmLl9yZXBlYXQgPCAwID8gc2VsZi5kdXJhdGlvbigpIDogc2VsZi50b3RhbER1cmF0aW9uKCkpIC8gKHNlbGYucmV2ZXJzZWQoKSA/IC12YWx1ZSA6IHZhbHVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2RpcnR5KSB7XG4gICAgICBwYXJlbnQgPSBzZWxmLnBhcmVudDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHByZXYgPSBjaGlsZC5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBpbiBjYXNlIHRoZSB0d2VlbiBjaGFuZ2VzIHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZS4uLlxuXG4gICAgICAgIGNoaWxkLl9kaXJ0eSAmJiBjaGlsZC50b3RhbER1cmF0aW9uKCk7IC8vY291bGQgY2hhbmdlIHRoZSB0d2Vlbi5fc3RhcnRUaW1lLCBzbyBtYWtlIHN1cmUgdGhlIGFuaW1hdGlvbidzIGNhY2hlIGlzIGNsZWFuIGJlZm9yZSBhbmFseXppbmcgaXQuXG5cbiAgICAgICAgc3RhcnQgPSBjaGlsZC5fc3RhcnQ7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID4gcHJldlN0YXJ0ICYmIHNlbGYuX3NvcnQgJiYgY2hpbGQuX3RzICYmICFzZWxmLl9sb2NrKSB7XG4gICAgICAgICAgLy9pbiBjYXNlIG9uZSBvZiB0aGUgdHdlZW5zIHNoaWZ0ZWQgb3V0IG9mIG9yZGVyLCBpdCBuZWVkcyB0byBiZSByZS1pbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICAgICAgICAgIHNlbGYuX2xvY2sgPSAxOyAvL3ByZXZlbnQgZW5kbGVzcyByZWN1cnNpdmUgY2FsbHMgLSB0aGVyZSBhcmUgbWV0aG9kcyB0aGF0IGdldCB0cmlnZ2VyZWQgdGhhdCBjaGVjayBkdXJhdGlvbi90b3RhbER1cmF0aW9uIHdoZW4gd2UgYWRkKCkuXG5cbiAgICAgICAgICBfYWRkVG9UaW1lbGluZShzZWxmLCBjaGlsZCwgc3RhcnQgLSBjaGlsZC5fZGVsYXksIDEpLl9sb2NrID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2U3RhcnQgPSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IDAgJiYgY2hpbGQuX3RzKSB7XG4gICAgICAgICAgLy9jaGlsZHJlbiBhcmVuJ3QgYWxsb3dlZCB0byBoYXZlIG5lZ2F0aXZlIHN0YXJ0VGltZXMgdW5sZXNzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHNvIGFkanVzdCBoZXJlIGlmIG9uZSBpcyBmb3VuZC5cbiAgICAgICAgICBtYXggLT0gc3RhcnQ7XG5cbiAgICAgICAgICBpZiAoIXBhcmVudCAmJiAhc2VsZi5fZHAgfHwgcGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZykge1xuICAgICAgICAgICAgc2VsZi5fc3RhcnQgKz0gc3RhcnQgLyBzZWxmLl90cztcbiAgICAgICAgICAgIHNlbGYuX3RpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgICBzZWxmLl90VGltZSAtPSBzdGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnNoaWZ0Q2hpbGRyZW4oLXN0YXJ0LCBmYWxzZSwgLTFlOTk5KTtcbiAgICAgICAgICBwcmV2U3RhcnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQuX2VuZCA+IG1heCAmJiBjaGlsZC5fdHMgJiYgKG1heCA9IGNoaWxkLl9lbmQpO1xuICAgICAgICBjaGlsZCA9IHByZXY7XG4gICAgICB9XG5cbiAgICAgIF9zZXREdXJhdGlvbihzZWxmLCBzZWxmID09PSBfZ2xvYmFsVGltZWxpbmUgJiYgc2VsZi5fdGltZSA+IG1heCA/IHNlbGYuX3RpbWUgOiBtYXgsIDEsIDEpO1xuXG4gICAgICBzZWxmLl9kaXJ0eSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuX3REdXI7XG4gIH07XG5cbiAgVGltZWxpbmUudXBkYXRlUm9vdCA9IGZ1bmN0aW9uIHVwZGF0ZVJvb3QodGltZSkge1xuICAgIGlmIChfZ2xvYmFsVGltZWxpbmUuX3RzKSB7XG4gICAgICBfbGF6eVNhZmVSZW5kZXIoX2dsb2JhbFRpbWVsaW5lLCBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lLCBfZ2xvYmFsVGltZWxpbmUpKTtcblxuICAgICAgX2xhc3RSZW5kZXJlZEZyYW1lID0gX3RpY2tlci5mcmFtZTtcbiAgICB9XG5cbiAgICBpZiAoX3RpY2tlci5mcmFtZSA+PSBfbmV4dEdDRnJhbWUpIHtcbiAgICAgIF9uZXh0R0NGcmFtZSArPSBfY29uZmlnLmF1dG9TbGVlcCB8fCAxMjA7XG4gICAgICB2YXIgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuICAgICAgaWYgKCFjaGlsZCB8fCAhY2hpbGQuX3RzKSBpZiAoX2NvbmZpZy5hdXRvU2xlZXAgJiYgX3RpY2tlci5fbGlzdGVuZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgd2hpbGUgKGNoaWxkICYmICFjaGlsZC5fdHMpIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgfHwgX3RpY2tlci5zbGVlcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGltZWxpbmU7XG59KEFuaW1hdGlvbik7XG5cbl9zZXREZWZhdWx0cyhUaW1lbGluZS5wcm90b3R5cGUsIHtcbiAgX2xvY2s6IDAsXG4gIF9oYXNQYXVzZTogMCxcbiAgX2ZvcmNpbmc6IDBcbn0pO1xuXG52YXIgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIHNldHRlciwgc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pIHtcbiAgLy9ub3RlOiB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHByb3AsIDAsIDEsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBudWxsLCBzZXR0ZXIpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICByZXN1bHQsXG4gICAgICBzdGFydE51bXMsXG4gICAgICBjb2xvcixcbiAgICAgIGVuZE51bSxcbiAgICAgIGNodW5rLFxuICAgICAgc3RhcnROdW0sXG4gICAgICBoYXNSYW5kb20sXG4gICAgICBhO1xuICBwdC5iID0gc3RhcnQ7XG4gIHB0LmUgPSBlbmQ7XG4gIHN0YXJ0ICs9IFwiXCI7IC8vZW5zdXJlIHZhbHVlcyBhcmUgc3RyaW5nc1xuXG4gIGVuZCArPSBcIlwiO1xuXG4gIGlmIChoYXNSYW5kb20gPSB+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgZW5kID0gX3JlcGxhY2VSYW5kb20oZW5kKTtcbiAgfVxuXG4gIGlmIChzdHJpbmdGaWx0ZXIpIHtcbiAgICBhID0gW3N0YXJ0LCBlbmRdO1xuICAgIHN0cmluZ0ZpbHRlcihhLCB0YXJnZXQsIHByb3ApOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuXG5cbiAgICBzdGFydCA9IGFbMF07XG4gICAgZW5kID0gYVsxXTtcbiAgfVxuXG4gIHN0YXJ0TnVtcyA9IHN0YXJ0Lm1hdGNoKF9jb21wbGV4U3RyaW5nTnVtRXhwKSB8fCBbXTtcblxuICB3aGlsZSAocmVzdWx0ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAuZXhlYyhlbmQpKSB7XG4gICAgZW5kTnVtID0gcmVzdWx0WzBdO1xuICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblxuICAgIGlmIChjb2xvcikge1xuICAgICAgY29sb3IgPSAoY29sb3IgKyAxKSAlIDU7XG4gICAgfSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIpIHtcbiAgICAgIGNvbG9yID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZW5kTnVtICE9PSBzdGFydE51bXNbbWF0Y2hJbmRleCsrXSkge1xuICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0TnVtc1ttYXRjaEluZGV4IC0gMV0pIHx8IDA7IC8vdGhlc2UgbmVzdGVkIFByb3BUd2VlbnMgYXJlIGhhbmRsZWQgaW4gYSBzcGVjaWFsIHdheSAtIHdlJ2xsIG5ldmVyIGFjdHVhbGx5IGNhbGwgYSByZW5kZXIgb3Igc2V0dGVyIG1ldGhvZCBvbiB0aGVtLiBXZSdsbCBqdXN0IGxvb3AgdGhyb3VnaCB0aGVtIGluIHRoZSBwYXJlbnQgY29tcGxleCBzdHJpbmcgUHJvcFR3ZWVuJ3MgcmVuZGVyIG1ldGhvZC5cblxuICAgICAgcHQuX3B0ID0ge1xuICAgICAgICBfbmV4dDogcHQuX3B0LFxuICAgICAgICBwOiBjaHVuayB8fCBtYXRjaEluZGV4ID09PSAxID8gY2h1bmsgOiBcIixcIixcbiAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG4gICAgICAgIHM6IHN0YXJ0TnVtLFxuICAgICAgICBjOiBlbmROdW0uY2hhckF0KDEpID09PSBcIj1cIiA/IHBhcnNlRmxvYXQoZW5kTnVtLnN1YnN0cigyKSkgKiAoZW5kTnVtLmNoYXJBdCgwKSA9PT0gXCItXCIgPyAtMSA6IDEpIDogcGFyc2VGbG9hdChlbmROdW0pIC0gc3RhcnROdW0sXG4gICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCA/IE1hdGgucm91bmQgOiAwXG4gICAgICB9O1xuICAgICAgaW5kZXggPSBfY29tcGxleFN0cmluZ051bUV4cC5sYXN0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcHQuYyA9IGluZGV4IDwgZW5kLmxlbmd0aCA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuXG4gIHB0LmZwID0gZnVuY1BhcmFtO1xuXG4gIGlmIChfcmVsRXhwLnRlc3QoZW5kKSB8fCBoYXNSYW5kb20pIHtcbiAgICBwdC5lID0gMDsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuICB9XG5cbiAgdGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBpbmRleCwgdGFyZ2V0cywgbW9kaWZpZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XG4gIF9pc0Z1bmN0aW9uKGVuZCkgJiYgKGVuZCA9IGVuZChpbmRleCB8fCAwLCB0YXJnZXQsIHRhcmdldHMpKTtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXSxcbiAgICAgIHBhcnNlZFN0YXJ0ID0gc3RhcnQgIT09IFwiZ2V0XCIgPyBzdGFydCA6ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlIDogZnVuY1BhcmFtID8gdGFyZ2V0W3Byb3AuaW5kZXhPZihcInNldFwiKSB8fCAhX2lzRnVuY3Rpb24odGFyZ2V0W1wiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0pID8gcHJvcCA6IFwiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0oZnVuY1BhcmFtKSA6IHRhcmdldFtwcm9wXSgpLFxuICAgICAgc2V0dGVyID0gIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBfc2V0dGVyUGxhaW4gOiBmdW5jUGFyYW0gPyBfc2V0dGVyRnVuY1dpdGhQYXJhbSA6IF9zZXR0ZXJGdW5jLFxuICAgICAgcHQ7XG5cbiAgaWYgKF9pc1N0cmluZyhlbmQpKSB7XG4gICAgaWYgKH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKGVuZC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG4gICAgICBwdCA9IHBhcnNlRmxvYXQocGFyc2VkU3RhcnQpICsgcGFyc2VGbG9hdChlbmQuc3Vic3RyKDIpKSAqIChlbmQuY2hhckF0KDApID09PSBcIi1cIiA/IC0xIDogMSkgKyAoZ2V0VW5pdChwYXJzZWRTdGFydCkgfHwgMCk7XG5cbiAgICAgIGlmIChwdCB8fCBwdCA9PT0gMCkge1xuICAgICAgICAvLyB0byBhdm9pZCBpc05hTiwgbGlrZSBpZiBzb21lb25lIHBhc3NlcyBpbiBhIHZhbHVlIGxpa2UgXCIhPSB3aGF0ZXZlclwiXG4gICAgICAgIGVuZCA9IHB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZWRTdGFydCAhPT0gZW5kKSB7XG4gICAgaWYgKCFpc05hTihwYXJzZWRTdGFydCAqIGVuZCkgJiYgZW5kICE9PSBcIlwiKSB7XG4gICAgICAvLyBmdW4gZmFjdDogYW55IG51bWJlciBtdWx0aXBsaWVkIGJ5IFwiXCIgaXMgZXZhbHVhdGVkIGFzIHRoZSBudW1iZXIgMCFcbiAgICAgIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCArcGFyc2VkU3RhcnQgfHwgMCwgZW5kIC0gKHBhcnNlZFN0YXJ0IHx8IDApLCB0eXBlb2YgY3VycmVudFZhbHVlID09PSBcImJvb2xlYW5cIiA/IF9yZW5kZXJCb29sZWFuIDogX3JlbmRlclBsYWluLCAwLCBzZXR0ZXIpO1xuICAgICAgZnVuY1BhcmFtICYmIChwdC5mcCA9IGZ1bmNQYXJhbSk7XG4gICAgICBtb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdGhpcywgdGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzLl9wdCA9IHB0O1xuICAgIH1cblxuICAgICFjdXJyZW50VmFsdWUgJiYgIShwcm9wIGluIHRhcmdldCkgJiYgX21pc3NpbmdQbHVnaW4ocHJvcCwgZW5kKTtcbiAgICByZXR1cm4gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0aGlzLCB0YXJnZXQsIHByb3AsIHBhcnNlZFN0YXJ0LCBlbmQsIHNldHRlciwgc3RyaW5nRmlsdGVyIHx8IF9jb25maWcuc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pO1xuICB9XG59LFxuICAgIC8vY3JlYXRlcyBhIGNvcHkgb2YgdGhlIHZhcnMgb2JqZWN0IGFuZCBwcm9jZXNzZXMgYW55IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyAocHV0dGluZyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBkaXJlY3RseSBpbnRvIHRoZSBjb3B5KSBhcyB3ZWxsIGFzIHN0cmluZ3Mgd2l0aCBcInJhbmRvbSgpXCIgaW4gdGhlbS4gSXQgZG9lcyBOT1QgcHJvY2VzcyByZWxhdGl2ZSB2YWx1ZXMuXG5fcHJvY2Vzc1ZhcnMgPSBmdW5jdGlvbiBfcHJvY2Vzc1ZhcnModmFycywgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pIHtcbiAgX2lzRnVuY3Rpb24odmFycykgJiYgKHZhcnMgPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcblxuICBpZiAoIV9pc09iamVjdCh2YXJzKSB8fCB2YXJzLnN0eWxlICYmIHZhcnMubm9kZVR5cGUgfHwgX2lzQXJyYXkodmFycykgfHwgX2lzVHlwZWRBcnJheSh2YXJzKSkge1xuICAgIHJldHVybiBfaXNTdHJpbmcodmFycykgPyBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFycztcbiAgfVxuXG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiB2YXJzKSB7XG4gICAgY29weVtwXSA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzW3BdLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2NoZWNrUGx1Z2luID0gZnVuY3Rpb24gX2NoZWNrUGx1Z2luKHByb3BlcnR5LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykge1xuICB2YXIgcGx1Z2luLCBwdCwgcHRMb29rdXAsIGk7XG5cbiAgaWYgKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiAocGx1Z2luID0gbmV3IF9wbHVnaW5zW3Byb3BlcnR5XSgpKS5pbml0KHRhcmdldCwgcGx1Z2luLnJhd1ZhcnMgPyB2YXJzW3Byb3BlcnR5XSA6IF9wcm9jZXNzVmFycyh2YXJzW3Byb3BlcnR5XSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgIGlmICh0d2VlbiAhPT0gX3F1aWNrVHdlZW4pIHtcbiAgICAgIHB0TG9va3VwID0gdHdlZW4uX3B0TG9va3VwW3R3ZWVuLl90YXJnZXRzLmluZGV4T2YodGFyZ2V0KV07IC8vbm90ZTogd2UgY2FuJ3QgdXNlIHR3ZWVuLl9wdExvb2t1cFtpbmRleF0gYmVjYXVzZSBmb3Igc3RhZ2dlcmVkIHR3ZWVucywgdGhlIGluZGV4IGZyb20gdGhlIGZ1bGxUYXJnZXRzIGFycmF5IHdvbid0IG1hdGNoIHdoYXQgaXQgaXMgaW4gZWFjaCBpbmRpdmlkdWFsIHR3ZWVuIHRoYXQgc3Bhd25zIGZyb20gdGhlIHN0YWdnZXIuXG5cbiAgICAgIGkgPSBwbHVnaW4uX3Byb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBwdExvb2t1cFtwbHVnaW4uX3Byb3BzW2ldXSA9IHB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59LFxuICAgIF9vdmVyd3JpdGluZ1R3ZWVuLFxuICAgIC8vc3RvcmUgYSByZWZlcmVuY2UgdGVtcG9yYXJpbHkgc28gd2UgY2FuIGF2b2lkIG92ZXJ3cml0aW5nIGl0c2VsZi5cbl9pbml0VHdlZW4gPSBmdW5jdGlvbiBfaW5pdFR3ZWVuKHR3ZWVuLCB0aW1lKSB7XG4gIHZhciB2YXJzID0gdHdlZW4udmFycyxcbiAgICAgIGVhc2UgPSB2YXJzLmVhc2UsXG4gICAgICBzdGFydEF0ID0gdmFycy5zdGFydEF0LFxuICAgICAgaW1tZWRpYXRlUmVuZGVyID0gdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICBsYXp5ID0gdmFycy5sYXp5LFxuICAgICAgb25VcGRhdGUgPSB2YXJzLm9uVXBkYXRlLFxuICAgICAgb25VcGRhdGVQYXJhbXMgPSB2YXJzLm9uVXBkYXRlUGFyYW1zLFxuICAgICAgY2FsbGJhY2tTY29wZSA9IHZhcnMuY2FsbGJhY2tTY29wZSxcbiAgICAgIHJ1bkJhY2t3YXJkcyA9IHZhcnMucnVuQmFja3dhcmRzLFxuICAgICAgeW95b0Vhc2UgPSB2YXJzLnlveW9FYXNlLFxuICAgICAga2V5ZnJhbWVzID0gdmFycy5rZXlmcmFtZXMsXG4gICAgICBhdXRvUmV2ZXJ0ID0gdmFycy5hdXRvUmV2ZXJ0LFxuICAgICAgZHVyID0gdHdlZW4uX2R1cixcbiAgICAgIHByZXZTdGFydEF0ID0gdHdlZW4uX3N0YXJ0QXQsXG4gICAgICB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwYXJlbnQgPSB0d2Vlbi5wYXJlbnQsXG4gICAgICBmdWxsVGFyZ2V0cyA9IHBhcmVudCAmJiBwYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIiA/IHBhcmVudC5wYXJlbnQuX3RhcmdldHMgOiB0YXJnZXRzLFxuICAgICAgYXV0b092ZXJ3cml0ZSA9IHR3ZWVuLl9vdmVyd3JpdGUgPT09IFwiYXV0b1wiICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgICAgdGwgPSB0d2Vlbi50aW1lbGluZSxcbiAgICAgIGNsZWFuVmFycyxcbiAgICAgIGksXG4gICAgICBwLFxuICAgICAgcHQsXG4gICAgICB0YXJnZXQsXG4gICAgICBoYXNQcmlvcml0eSxcbiAgICAgIGdzRGF0YSxcbiAgICAgIGhhcm5lc3MsXG4gICAgICBwbHVnaW4sXG4gICAgICBwdExvb2t1cCxcbiAgICAgIGluZGV4LFxuICAgICAgaGFybmVzc1ZhcnMsXG4gICAgICBvdmVyd3JpdHRlbjtcbiAgdGwgJiYgKCFrZXlmcmFtZXMgfHwgIWVhc2UpICYmIChlYXNlID0gXCJub25lXCIpO1xuICB0d2Vlbi5fZWFzZSA9IF9wYXJzZUVhc2UoZWFzZSwgX2RlZmF1bHRzLmVhc2UpO1xuICB0d2Vlbi5feUVhc2UgPSB5b3lvRWFzZSA/IF9pbnZlcnRFYXNlKF9wYXJzZUVhc2UoeW95b0Vhc2UgPT09IHRydWUgPyBlYXNlIDogeW95b0Vhc2UsIF9kZWZhdWx0cy5lYXNlKSkgOiAwO1xuXG4gIGlmICh5b3lvRWFzZSAmJiB0d2Vlbi5feW95byAmJiAhdHdlZW4uX3JlcGVhdCkge1xuICAgIC8vdGhlcmUgbXVzdCBoYXZlIGJlZW4gYSBwYXJlbnQgdGltZWxpbmUgd2l0aCB5b3lvOnRydWUgdGhhdCBpcyBjdXJyZW50bHkgaW4gaXRzIHlveW8gcGhhc2UsIHNvIGZsaXAgdGhlIGVhc2VzLlxuICAgIHlveW9FYXNlID0gdHdlZW4uX3lFYXNlO1xuICAgIHR3ZWVuLl95RWFzZSA9IHR3ZWVuLl9lYXNlO1xuICAgIHR3ZWVuLl9lYXNlID0geW95b0Vhc2U7XG4gIH1cblxuICB0d2Vlbi5fZnJvbSA9ICF0bCAmJiAhIXZhcnMucnVuQmFja3dhcmRzOyAvL25lc3RlZCB0aW1lbGluZXMgc2hvdWxkIG5ldmVyIHJ1biBiYWNrd2FyZHMgLSB0aGUgYmFja3dhcmRzLW5lc3MgaXMgaW4gdGhlIGNoaWxkIHR3ZWVucy5cblxuICBpZiAoIXRsKSB7XG4gICAgLy9pZiB0aGVyZSdzIGFuIGludGVybmFsIHRpbWVsaW5lLCBza2lwIGFsbCB0aGUgcGFyc2luZyBiZWNhdXNlIHdlIHBhc3NlZCB0aGF0IHRhc2sgZG93biB0aGUgY2hhaW4uXG4gICAgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDA7XG4gICAgaGFybmVzc1ZhcnMgPSBoYXJuZXNzICYmIHZhcnNbaGFybmVzcy5wcm9wXTsgLy9zb21lb25lIG1heSBuZWVkIHRvIHNwZWNpZnkgQ1NTLXNwZWNpZmljIHZhbHVlcyBBTkQgbm9uLUNTUyB2YWx1ZXMsIGxpa2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFuIFwieFwiIHByb3BlcnR5IHBsdXMgaXQncyBhIHN0YW5kYXJkIERPTSBlbGVtZW50LiBXZSBhbGxvdyBwZW9wbGUgdG8gZGlzdGluZ3Vpc2ggYnkgd3JhcHBpbmcgcGx1Z2luLXNwZWNpZmljIHN0dWZmIGluIGEgY3NzOnt9IG9iamVjdCBmb3IgZXhhbXBsZS5cblxuICAgIGNsZWFuVmFycyA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9yZXNlcnZlZFByb3BzKTtcbiAgICBwcmV2U3RhcnRBdCAmJiBwcmV2U3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpLmtpbGwoKTtcblxuICAgIGlmIChzdGFydEF0KSB7XG4gICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgICBkYXRhOiBcImlzU3RhcnRcIixcbiAgICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlcjogdHJ1ZSxcbiAgICAgICAgbGF6eTogX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgIHN0YXJ0QXQ6IG51bGwsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBvblVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIG9uVXBkYXRlUGFyYW1zOiBvblVwZGF0ZVBhcmFtcyxcbiAgICAgICAgY2FsbGJhY2tTY29wZTogY2FsbGJhY2tTY29wZSxcbiAgICAgICAgc3RhZ2dlcjogMFxuICAgICAgfSwgc3RhcnRBdCkpKTsgLy9jb3B5IHRoZSBwcm9wZXJ0aWVzL3ZhbHVlcyBpbnRvIGEgbmV3IG9iamVjdCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlIHZhciB0byA9IHt4OjB9LCBmcm9tID0ge3g6NTAwfTsgdGltZWxpbmUuZnJvbVRvKGUsIGZyb20sIHRvKS5mcm9tVG8oZSwgdG8sIGZyb20pO1xuXG5cbiAgICAgIHRpbWUgPCAwICYmICFpbW1lZGlhdGVSZW5kZXIgJiYgIWF1dG9SZXZlcnQgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTsgLy8gcmFyZSBlZGdlIGNhc2UsIGxpa2UgaWYgYSByZW5kZXIgaXMgZm9yY2VkIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gb2YgYSBub24taW5pdHRlZCB0d2Vlbi5cblxuICAgICAgaWYgKGltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICB0aW1lID4gMCAmJiAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmUgaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2Ugb3Igd2hlbiBhdXRvUmV2ZXJ0IGlzIGV4cGxpY2l0bHkgc2V0IHRvIHRydWUuXG5cbiAgICAgICAgaWYgKGR1ciAmJiB0aW1lIDw9IDApIHtcbiAgICAgICAgICB0aW1lICYmICh0d2Vlbi5felRpbWUgPSB0aW1lKTtcbiAgICAgICAgICByZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG4gICAgICAgIH0gLy8gaWYgKHRpbWUgPiAwKSB7XG4gICAgICAgIC8vIFx0YXV0b1JldmVydCB8fCAodHdlZW4uX3N0YXJ0QXQgPSAwKTsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmUgaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2Ugb3Igd2hlbiBhdXRvUmV2ZXJ0IGlzIGV4cGxpY2l0bHkgc2V0IHRvIHRydWUuXG4gICAgICAgIC8vIH0gZWxzZSBpZiAoZHVyICYmICEodGltZSA8IDAgJiYgcHJldlN0YXJ0QXQpKSB7XG4gICAgICAgIC8vIFx0dGltZSAmJiAodHdlZW4uX3pUaW1lID0gdGltZSk7XG4gICAgICAgIC8vIFx0cmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lLCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuICAgICAgICAvLyB9XG5cbiAgICAgIH0gZWxzZSBpZiAoYXV0b1JldmVydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHdlZW4uX3N0YXJ0QXQgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocnVuQmFja3dhcmRzICYmIGR1cikge1xuICAgICAgLy9mcm9tKCkgdHdlZW5zIG11c3QgYmUgaGFuZGxlZCB1bmlxdWVseTogdGhlaXIgYmVnaW5uaW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkIGJ1dCB3ZSBkb24ndCB3YW50IG92ZXJ3cml0aW5nIHRvIG9jY3VyIHlldCAod2hlbiB0aW1lIGlzIHN0aWxsIDApLiBXYWl0IHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMgYmVmb3JlIGRvaW5nIGFsbCB0aGUgcm91dGluZXMgbGlrZSBvdmVyd3JpdGluZy4gQXQgdGhhdCB0aW1lLCB3ZSBzaG91bGQgcmVuZGVyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIHRvIGVuc3VyZSB0aGF0IHRoaW5ncyBpbml0aWFsaXplIGNvcnJlY3RseSAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgZ28gYmFja3dhcmRzKVxuICAgICAgaWYgKHByZXZTdGFydEF0KSB7XG4gICAgICAgICFhdXRvUmV2ZXJ0ICYmICh0d2Vlbi5fc3RhcnRBdCA9IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZSAmJiAoaW1tZWRpYXRlUmVuZGVyID0gZmFsc2UpOyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXG4gICAgICAgIHAgPSBfc2V0RGVmYXVsdHMoe1xuICAgICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgICAgZGF0YTogXCJpc0Zyb21TdGFydFwiLFxuICAgICAgICAgIC8vd2UgdGFnIHRoZSB0d2VlbiB3aXRoIGFzIFwiaXNGcm9tU3RhcnRcIiBzbyB0aGF0IGlmIFtpbnNpZGUgYSBwbHVnaW5dIHdlIG5lZWQgdG8gb25seSBkbyBzb21ldGhpbmcgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4sIHdlIGhhdmUgYSB3YXkgb2YgaWRlbnRpZnlpbmcgdGhpcyB0d2VlbiBhcyBtZXJlbHkgdGhlIG9uZSB0aGF0J3Mgc2V0dGluZyB0aGUgYmVnaW5uaW5nIHZhbHVlcyBmb3IgYSBcImZyb20oKVwiIHR3ZWVuLiBGb3IgZXhhbXBsZSwgY2xlYXJQcm9wcyBpbiBDU1NQbHVnaW4gc2hvdWxkIG9ubHkgZ2V0IGFwcGxpZWQgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4gYW5kIHdpdGhvdXQgdGhpcyB0YWcsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluLlxuICAgICAgICAgIGxhenk6IGltbWVkaWF0ZVJlbmRlciAmJiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IGltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgICAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG4gICAgICAgICAgc3RhZ2dlcjogMCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCAvL2Vuc3VyZXMgdGhhdCBuZXN0ZWQgdHdlZW5zIHRoYXQgaGFkIGEgc3RhZ2dlciBhcmUgaGFuZGxlZCBwcm9wZXJseSwgbGlrZSBnc2FwLmZyb20oXCIuY2xhc3NcIiwge3k6Z3NhcC51dGlscy53cmFwKFstMTAwLDEwMF0pfSlcblxuICAgICAgICB9LCBjbGVhblZhcnMpO1xuICAgICAgICBoYXJuZXNzVmFycyAmJiAocFtoYXJuZXNzLnByb3BdID0gaGFybmVzc1ZhcnMpOyAvLyBpbiBjYXNlIHNvbWVvbmUgZG9lcyBzb21ldGhpbmcgbGlrZSAuZnJvbSguLi4sIHtjc3M6e319KVxuXG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIHApKTtcblxuICAgICAgICB0aW1lIDwgMCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpOyAvLyByYXJlIGVkZ2UgY2FzZSwgbGlrZSBpZiBhIHJlbmRlciBpcyBmb3JjZWQgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbiBvZiBhIG5vbi1pbml0dGVkIGZyb20oKSB0d2Vlbi5cblxuICAgICAgICBpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4uX3N0YXJ0QXQsIF90aW55TnVtKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0d2Vlbi5fcHQgPSAwO1xuICAgIGxhenkgPSBkdXIgJiYgX2lzTm90RmFsc2UobGF6eSkgfHwgbGF6eSAmJiAhZHVyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICBnc0RhdGEgPSB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModGFyZ2V0cylbaV0uX2dzYXA7XG4gICAgICB0d2Vlbi5fcHRMb29rdXBbaV0gPSBwdExvb2t1cCA9IHt9O1xuICAgICAgX2xhenlMb29rdXBbZ3NEYXRhLmlkXSAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblxuICAgICAgaW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIGlmIChoYXJuZXNzICYmIChwbHVnaW4gPSBuZXcgaGFybmVzcygpKS5pbml0KHRhcmdldCwgaGFybmVzc1ZhcnMgfHwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIGZ1bGxUYXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwbHVnaW4ubmFtZSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHB0TG9va3VwW25hbWVdID0gcHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXJuZXNzIHx8IGhhcm5lc3NWYXJzKSB7XG4gICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcbiAgICAgICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IF9jaGVja1BsdWdpbihwLCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCBmdWxsVGFyZ2V0cykpKSB7XG4gICAgICAgICAgICBwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB0TG9va3VwW3BdID0gcHQgPSBfYWRkUHJvcFR3ZWVuLmNhbGwodHdlZW4sIHRhcmdldCwgcCwgXCJnZXRcIiwgY2xlYW5WYXJzW3BdLCBpbmRleCwgZnVsbFRhcmdldHMsIDAsIHZhcnMuc3RyaW5nRmlsdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHdlZW4uX29wICYmIHR3ZWVuLl9vcFtpXSAmJiB0d2Vlbi5raWxsKHRhcmdldCwgdHdlZW4uX29wW2ldKTtcblxuICAgICAgaWYgKGF1dG9PdmVyd3JpdGUgJiYgdHdlZW4uX3B0KSB7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gdHdlZW47XG5cbiAgICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXQsIHB0TG9va3VwLCB0d2Vlbi5nbG9iYWxUaW1lKHRpbWUpKTsgLy8gbWFrZSBzdXJlIHRoZSBvdmVyd3JpdGluZyBkb2Vzbid0IG92ZXJ3cml0ZSBUSElTIHR3ZWVuISEhXG5cblxuICAgICAgICBvdmVyd3JpdHRlbiA9ICF0d2Vlbi5wYXJlbnQ7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgdHdlZW4uX3B0ICYmIGxhenkgJiYgKF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxKTtcbiAgICB9XG5cbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHR3ZWVuKTtcbiAgICB0d2Vlbi5fb25Jbml0ICYmIHR3ZWVuLl9vbkluaXQodHdlZW4pOyAvL3BsdWdpbnMgbGlrZSBSb3VuZFByb3BzIG11c3Qgd2FpdCB1bnRpbCBBTEwgb2YgdGhlIFByb3BUd2VlbnMgYXJlIGluc3RhbnRpYXRlZC4gSW4gdGhlIHBsdWdpbidzIGluaXQoKSBmdW5jdGlvbiwgaXQgc2V0cyB0aGUgX29uSW5pdCBvbiB0aGUgdHdlZW4gaW5zdGFuY2UuIE1heSBub3QgYmUgcHJldHR5L2ludHVpdGl2ZSwgYnV0IGl0J3MgZmFzdCBhbmQga2VlcHMgZmlsZSBzaXplIGRvd24uXG4gIH1cblxuICB0d2Vlbi5fb25VcGRhdGUgPSBvblVwZGF0ZTtcbiAgdHdlZW4uX2luaXR0ZWQgPSAoIXR3ZWVuLl9vcCB8fCB0d2Vlbi5fcHQpICYmICFvdmVyd3JpdHRlbjsgLy8gaWYgb3ZlcndyaXR0ZW5Qcm9wcyByZXN1bHRlZCBpbiB0aGUgZW50aXJlIHR3ZWVuIGJlaW5nIGtpbGxlZCwgZG8gTk9UIGZsYWcgaXQgYXMgaW5pdHRlZCBvciBlbHNlIGl0IG1heSByZW5kZXIgZm9yIG9uZSB0aWNrLlxufSxcbiAgICBfYWRkQWxpYXNlc1RvVmFycyA9IGZ1bmN0aW9uIF9hZGRBbGlhc2VzVG9WYXJzKHRhcmdldHMsIHZhcnMpIHtcbiAgdmFyIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwLFxuICAgICAgcHJvcGVydHlBbGlhc2VzID0gaGFybmVzcyAmJiBoYXJuZXNzLmFsaWFzZXMsXG4gICAgICBjb3B5LFxuICAgICAgcCxcbiAgICAgIGksXG4gICAgICBhbGlhc2VzO1xuXG4gIGlmICghcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgcmV0dXJuIHZhcnM7XG4gIH1cblxuICBjb3B5ID0gX21lcmdlKHt9LCB2YXJzKTtcblxuICBmb3IgKHAgaW4gcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgaWYgKHAgaW4gY29weSkge1xuICAgICAgYWxpYXNlcyA9IHByb3BlcnR5QWxpYXNlc1twXS5zcGxpdChcIixcIik7XG4gICAgICBpID0gYWxpYXNlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29weVthbGlhc2VzW2ldXSA9IGNvcHlbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9wYXJzZUZ1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZUZ1bmNPclN0cmluZyh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbCh0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgfnZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpID8gX3JlcGxhY2VSYW5kb20odmFsdWUpIDogdmFsdWU7XG59LFxuICAgIF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlXCIsXG4gICAgX3N0YWdnZXJQcm9wc1RvU2tpcCA9IChfc3RhZ2dlclR3ZWVuUHJvcHMgKyBcIixpZCxzdGFnZ2VyLGRlbGF5LGR1cmF0aW9uLHBhdXNlZCxzY3JvbGxUcmlnZ2VyXCIpLnNwbGl0KFwiLFwiKTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uMikge1xuICBfaW5oZXJpdHNMb29zZShUd2VlbiwgX0FuaW1hdGlvbjIpO1xuXG4gIGZ1bmN0aW9uIFR3ZWVuKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uLCBza2lwSW5oZXJpdCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBpZiAodHlwZW9mIHZhcnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHBvc2l0aW9uLmR1cmF0aW9uID0gdmFycztcbiAgICAgIHZhcnMgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBfdGhpczMgPSBfQW5pbWF0aW9uMi5jYWxsKHRoaXMsIHNraXBJbmhlcml0ID8gdmFycyA6IF9pbmhlcml0RGVmYXVsdHModmFycykpIHx8IHRoaXM7XG4gICAgdmFyIF90aGlzMyR2YXJzID0gX3RoaXMzLnZhcnMsXG4gICAgICAgIGR1cmF0aW9uID0gX3RoaXMzJHZhcnMuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5ID0gX3RoaXMzJHZhcnMuZGVsYXksXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF90aGlzMyR2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgc3RhZ2dlciA9IF90aGlzMyR2YXJzLnN0YWdnZXIsXG4gICAgICAgIG92ZXJ3cml0ZSA9IF90aGlzMyR2YXJzLm92ZXJ3cml0ZSxcbiAgICAgICAga2V5ZnJhbWVzID0gX3RoaXMzJHZhcnMua2V5ZnJhbWVzLFxuICAgICAgICBkZWZhdWx0cyA9IF90aGlzMyR2YXJzLmRlZmF1bHRzLFxuICAgICAgICBzY3JvbGxUcmlnZ2VyID0gX3RoaXMzJHZhcnMuc2Nyb2xsVHJpZ2dlcixcbiAgICAgICAgeW95b0Vhc2UgPSBfdGhpczMkdmFycy55b3lvRWFzZSxcbiAgICAgICAgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuICAgICAgICBwYXJzZWRUYXJnZXRzID0gKF9pc0FycmF5KHRhcmdldHMpIHx8IF9pc1R5cGVkQXJyYXkodGFyZ2V0cykgPyBfaXNOdW1iZXIodGFyZ2V0c1swXSkgOiBcImxlbmd0aFwiIGluIHZhcnMpID8gW3RhcmdldHNdIDogdG9BcnJheSh0YXJnZXRzKSxcbiAgICAgICAgdGwsXG4gICAgICAgIGksXG4gICAgICAgIGNvcHksXG4gICAgICAgIGwsXG4gICAgICAgIHAsXG4gICAgICAgIGN1clRhcmdldCxcbiAgICAgICAgc3RhZ2dlckZ1bmMsXG4gICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZTtcbiAgICBfdGhpczMuX3RhcmdldHMgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aCA/IF9oYXJuZXNzKHBhcnNlZFRhcmdldHMpIDogX3dhcm4oXCJHU0FQIHRhcmdldCBcIiArIHRhcmdldHMgKyBcIiBub3QgZm91bmQuIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVwiLCAhX2NvbmZpZy5udWxsVGFyZ2V0V2FybikgfHwgW107XG4gICAgX3RoaXMzLl9wdExvb2t1cCA9IFtdOyAvL1Byb3BUd2VlbiBsb29rdXAuIEFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIHRhcmdldCwgaGF2aW5nIGtleXMgZm9yIGVhY2ggdHdlZW5pbmcgcHJvcGVydHlcblxuICAgIF90aGlzMy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuXG4gICAgaWYgKGtleWZyYW1lcyB8fCBzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xuICAgICAgdmFycyA9IF90aGlzMy52YXJzO1xuICAgICAgdGwgPSBfdGhpczMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICAgICAgICBkYXRhOiBcIm5lc3RlZFwiLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMgfHwge31cbiAgICAgIH0pO1xuICAgICAgdGwua2lsbCgpO1xuICAgICAgdGwucGFyZW50ID0gdGwuX2RwID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuICAgICAgdGwuX3N0YXJ0ID0gMDtcblxuICAgICAgaWYgKGtleWZyYW1lcykge1xuICAgICAgICBfaW5oZXJpdERlZmF1bHRzKF9zZXREZWZhdWx0cyh0bC52YXJzLmRlZmF1bHRzLCB7XG4gICAgICAgICAgZWFzZTogXCJub25lXCJcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHN0YWdnZXIgPyBwYXJzZWRUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lLCBqKSB7XG4gICAgICAgICAgICByZXR1cm4gdGwudG8odCwgZnJhbWUsIGogPyBcIj5cIiA6IGkgKiBzdGFnZ2VyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkgOiBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG4gICAgICAgIHN0YWdnZXJGdW5jID0gc3RhZ2dlciA/IGRpc3RyaWJ1dGUoc3RhZ2dlcikgOiBfZW1wdHlGdW5jO1xuXG4gICAgICAgIGlmIChfaXNPYmplY3Qoc3RhZ2dlcikpIHtcbiAgICAgICAgICAvL3VzZXJzIGNhbiBwYXNzIGluIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQvb25Db21wbGV0ZSBpbiB0aGUgc3RhZ2dlciBvYmplY3QuIFRoZXNlIHNob3VsZCBmaXJlIHdpdGggZWFjaCBpbmRpdmlkdWFsIHR3ZWVuLlxuICAgICAgICAgIGZvciAocCBpbiBzdGFnZ2VyKSB7XG4gICAgICAgICAgICBpZiAofl9zdGFnZ2VyVHdlZW5Qcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSB8fCAoc3RhZ2dlclZhcnNUb01lcmdlID0ge30pO1xuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2VbcF0gPSBzdGFnZ2VyW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgaWYgKF9zdGFnZ2VyUHJvcHNUb1NraXAuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgICAgICAgICAgY29weVtwXSA9IHZhcnNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29weS5zdGFnZ2VyID0gMDtcbiAgICAgICAgICB5b3lvRWFzZSAmJiAoY29weS55b3lvRWFzZSA9IHlveW9FYXNlKTtcbiAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgJiYgX21lcmdlKGNvcHksIHN0YWdnZXJWYXJzVG9NZXJnZSk7XG4gICAgICAgICAgY3VyVGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c1tpXTsgLy9kb24ndCBqdXN0IGNvcHkgZHVyYXRpb24gb3IgZGVsYXkgYmVjYXVzZSBpZiB0aGV5J3JlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uLCB3ZSdkIGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wIGJlY2F1c2UgX2lzRnVuY09yU3RyaW5nKCkgd291bGQgZXZhbHVhdGUgYXMgdHJ1ZSBpbiB0aGUgY2hpbGQgdHdlZW5zLCBlbnRlcmluZyB0aGlzIGxvb3AsIGV0Yy4gU28gd2UgcGFyc2UgdGhlIHZhbHVlIHN0cmFpZ2h0IGZyb20gdmFycyBhbmQgZGVmYXVsdCB0byAwLlxuXG4gICAgICAgICAgY29weS5kdXJhdGlvbiA9ICtfcGFyc2VGdW5jT3JTdHJpbmcoZHVyYXRpb24sIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKTtcbiAgICAgICAgICBjb3B5LmRlbGF5ID0gKCtfcGFyc2VGdW5jT3JTdHJpbmcoZGVsYXksIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSB8fCAwKSAtIF90aGlzMy5fZGVsYXk7XG5cbiAgICAgICAgICBpZiAoIXN0YWdnZXIgJiYgbCA9PT0gMSAmJiBjb3B5LmRlbGF5KSB7XG4gICAgICAgICAgICAvLyBpZiBzb21lb25lIGRvZXMgZGVsYXk6XCJyYW5kb20oMSwgNSlcIiwgcmVwZWF0Oi0xLCBmb3IgZXhhbXBsZSwgdGhlIGRlbGF5IHNob3VsZG4ndCBiZSBpbnNpZGUgdGhlIHJlcGVhdC5cbiAgICAgICAgICAgIF90aGlzMy5fZGVsYXkgPSBkZWxheSA9IGNvcHkuZGVsYXk7XG4gICAgICAgICAgICBfdGhpczMuX3N0YXJ0ICs9IGRlbGF5O1xuICAgICAgICAgICAgY29weS5kZWxheSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGwudG8oY3VyVGFyZ2V0LCBjb3B5LCBzdGFnZ2VyRnVuYyhpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRsLmR1cmF0aW9uKCkgPyBkdXJhdGlvbiA9IGRlbGF5ID0gMCA6IF90aGlzMy50aW1lbGluZSA9IDA7IC8vIGlmIHRoZSB0aW1lbGluZSdzIGR1cmF0aW9uIGlzIDAsIHdlIGRvbid0IG5lZWQgYSB0aW1lbGluZSBpbnRlcm5hbGx5IVxuICAgICAgfVxuXG4gICAgICBkdXJhdGlvbiB8fCBfdGhpczMuZHVyYXRpb24oZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMzLnRpbWVsaW5lID0gMDsgLy9zcGVlZCBvcHRpbWl6YXRpb24sIGZhc3RlciBsb29rdXBzIChubyBnb2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluKVxuICAgIH1cblxuICAgIGlmIChvdmVyd3JpdGUgPT09IHRydWUgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMpIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgfVxuXG4gICAgX2FkZFRvVGltZWxpbmUocGFyZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHBvc2l0aW9uKTtcblxuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMzLnJldmVyc2UoKTtcbiAgICB2YXJzLnBhdXNlZCAmJiBfdGhpczMucGF1c2VkKHRydWUpO1xuXG4gICAgaWYgKGltbWVkaWF0ZVJlbmRlciB8fCAhZHVyYXRpb24gJiYgIWtleWZyYW1lcyAmJiBfdGhpczMuX3N0YXJ0ID09PSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgX3RoaXMzLl90VGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cbiAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXG4gICAgfVxuXG4gICAgc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmIHRvdGFsVGltZSA+PSAwID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgcHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgaXNZb3lvLFxuICAgICAgICByYXRpbyxcbiAgICAgICAgdGltZWxpbmUsXG4gICAgICAgIHlveW9FYXNlO1xuXG4gICAgaWYgKCFkdXIpIHtcbiAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgfSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCAhdGhpcy5faW5pdHRlZCAmJiB0aGlzLl90VGltZSB8fCB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCkge1xuICAgICAgLy90aGlzIHNlbnNlcyBpZiB3ZSdyZSBjcm9zc2luZyBvdmVyIHRoZSBzdGFydCB0aW1lLCBpbiB3aGljaCBjYXNlIHdlIG11c3QgcmVjb3JkIF96VGltZSBhbmQgZm9yY2UgdGhlIHJlbmRlciwgYnV0IHdlIGRvIGl0IGluIHRoaXMgbGVuZ3RoeSBjb25kaXRpb25hbCB3YXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKHVzdWFsbHkgd2UgY2FuIHNraXAgdGhlIGNhbGN1bGF0aW9ucyk6IHRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKVxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0VGltZSA9PT0gdER1cikge1xuICAgICAgICAgIC8vIHRoZSB0RHVyID09PSB0VGltZSBpcyBmb3IgZWRnZSBjYXNlcyB3aGVyZSB0aGVyZSdzIGEgbGVuZ3RoeSBkZWNpbWFsIG9uIHRoZSBkdXJhdGlvbiBhbmQgaXQgbWF5IHJlYWNoIHRoZSB2ZXJ5IGVuZCBidXQgdGhlIHRpbWUgaXMgcmVuZGVyZWQgYXMgbm90LXF1aXRlLXRoZXJlIChyZW1lbWJlciwgdER1ciBpcyByb3VuZGVkIHRvIDQgZGVjaW1hbHMgd2hlcmVhcyBkdXIgaXNuJ3QpXG4gICAgICAgICAgaXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzWW95byA9IHRoaXMuX3lveW8gJiYgaXRlcmF0aW9uICYgMTtcblxuICAgICAgICBpZiAoaXNZb3lvKSB7XG4gICAgICAgICAgeW95b0Vhc2UgPSB0aGlzLl95RWFzZTtcbiAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCkge1xuICAgICAgICAgIC8vY291bGQgYmUgZHVyaW5nIHRoZSByZXBlYXREZWxheSBwYXJ0LiBObyBuZWVkIHRvIHJlbmRlciBhbmQgZmlyZSBjYWxsYmFja3MuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgdGltZWxpbmUgJiYgdGhpcy5feUVhc2UgJiYgX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pOyAvL3JlcGVhdFJlZnJlc2ggZnVuY3Rpb25hbGl0eVxuXG4gICAgICAgICAgaWYgKHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSBmb3JjZSA9IDE7IC8vZm9yY2UsIG90aGVyd2lzZSBpZiBsYXp5IGlzIHRydWUsIHRoZSBfYXR0ZW1wdEluaXRUd2VlbigpIHdpbGwgcmV0dXJuIGFuZCB3ZSdsbCBqdW1wIG91dCBhbmQgZ2V0IGNhdWdodCBib3VuY2luZyBvbiBlYWNoIHRpY2suXG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyKF9yb3VuZFByZWNpc2UoY3ljbGVEdXJhdGlvbiAqIGl0ZXJhdGlvbiksIHRydWUpLmludmFsaWRhdGUoKS5fbG9jayA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5pdHRlZCkge1xuICAgICAgICBpZiAoX2F0dGVtcHRJbml0VHdlZW4odGhpcywgdG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6IHRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykpIHtcbiAgICAgICAgICB0aGlzLl90VGltZSA9IDA7IC8vIGluIGNvbnN0cnVjdG9yIGlmIGltbWVkaWF0ZVJlbmRlciBpcyB0cnVlLCB3ZSBzZXQgX3RUaW1lIHRvIC1fdGlueU51bSB0byBoYXZlIHRoZSBwbGF5aGVhZCBjcm9zcyB0aGUgc3RhcnRpbmcgcG9pbnQgYnV0IHdlIGNhbid0IGxlYXZlIF90VGltZSBhcyBhIG5lZ2F0aXZlIG51bWJlci5cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR1ciAhPT0gdGhpcy5fZHVyKSB7XG4gICAgICAgICAgLy8gd2hpbGUgaW5pdHRpbmcsIGEgcGx1Z2luIGxpa2UgSW5lcnRpYVBsdWdpbiBtaWdodCBhbHRlciB0aGUgZHVyYXRpb24sIHNvIHJlcnVuIGZyb20gdGhlIHN0YXJ0IHRvIGVuc3VyZSBldmVyeXRoaW5nIHJlbmRlcnMgYXMgaXQgc2hvdWxkLlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICBpZiAoIXRoaXMuX2FjdCAmJiB0aGlzLl90cykge1xuICAgICAgICB0aGlzLl9hY3QgPSAxOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgICB0aGlzLl9sYXp5ID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gKHlveW9FYXNlIHx8IHRoaXMuX2Vhc2UpKHRpbWUgLyBkdXIpO1xuXG4gICAgICBpZiAodGhpcy5fZnJvbSkge1xuICAgICAgICB0aGlzLnJhdGlvID0gcmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lICYmICFwcmV2VGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwdCA9IHRoaXMuX3B0O1xuXG4gICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnJlbmRlcih0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogIXRpbWUgJiYgaXNZb3lvID8gLV90aW55TnVtIDogdGltZWxpbmUuX2R1ciAqIHJhdGlvLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHx8IHRoaXMuX3N0YXJ0QXQgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcblxuICAgICAgaWYgKHRoaXMuX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICB0b3RhbFRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcGVhdCAmJiBpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgdGhpcy52YXJzLm9uUmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcblxuICAgICAgaWYgKCh0VGltZSA9PT0gdGhpcy5fdER1ciB8fCAhdFRpbWUpICYmIHRoaXMuX3RUaW1lID09PSB0VGltZSkge1xuICAgICAgICB0b3RhbFRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgIXRoaXMuX29uVXBkYXRlICYmIHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0aGlzLl90RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHdlJ3JlIHJlbmRlcmluZyBhdCBleGFjdGx5IGEgdGltZSBvZiAwLCBhcyB0aGVyZSBjb3VsZCBiZSBhdXRvUmV2ZXJ0IHZhbHVlcyB0aGF0IHNob3VsZCBnZXQgc2V0IG9uIHRoZSBuZXh0IHRpY2sgKGlmIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnRUaW1lLCBuZWdhdGl2ZSB0b3RhbFRpbWUpLiBEb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblxuICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEodG90YWxUaW1lIDwgMCAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSkpIHtcbiAgICAgICAgICAvLyBpZiBwcmV2VGltZSBhbmQgdFRpbWUgYXJlIHplcm8sIHdlIHNob3VsZG4ndCBmaXJlIHRoZSBvblJldmVyc2VDb21wbGV0ZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWYgeW91IGdzYXAudG8oLi4uIHtwYXVzZWQ6dHJ1ZX0pLnBsYXkoKTtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8zLnRhcmdldHMgPSBmdW5jdGlvbiB0YXJnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXRzO1xuICB9O1xuXG4gIF9wcm90bzMuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdGhpcy5fcHQgPSB0aGlzLl9vcCA9IHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9vblVwZGF0ZSA9IHRoaXMuX2xhenkgPSB0aGlzLnJhdGlvID0gMDtcbiAgICB0aGlzLl9wdExvb2t1cCA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgJiYgdGhpcy50aW1lbGluZS5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIF9BbmltYXRpb24yLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMy5raWxsID0gZnVuY3Rpb24ga2lsbCh0YXJnZXRzLCB2YXJzKSB7XG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IFwiYWxsXCI7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRzICYmICghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSkge1xuICAgICAgdGhpcy5fbGF6eSA9IHRoaXMuX3B0ID0gMDtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IF9pbnRlcnJ1cHQodGhpcykgOiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICB2YXIgdER1ciA9IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpO1xuICAgICAgdGhpcy50aW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgdmFycywgX292ZXJ3cml0aW5nVHdlZW4gJiYgX292ZXJ3cml0aW5nVHdlZW4udmFycy5vdmVyd3JpdGUgIT09IHRydWUpLl9maXJzdCB8fCBfaW50ZXJydXB0KHRoaXMpOyAvLyBpZiBub3RoaW5nIGlzIGxlZnQgdHdlZW5pbmcsIGludGVycnVwdC5cblxuICAgICAgdGhpcy5wYXJlbnQgJiYgdER1ciAhPT0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCkgJiYgX3NldER1cmF0aW9uKHRoaXMsIHRoaXMuX2R1ciAqIHRoaXMudGltZWxpbmUuX3REdXIgLyB0RHVyLCAwLCAxKTsgLy8gaWYgYSBuZXN0ZWQgdHdlZW4gaXMga2lsbGVkIHRoYXQgY2hhbmdlcyB0aGUgZHVyYXRpb24sIGl0IHNob3VsZCBhZmZlY3QgdGhpcyB0d2VlbidzIGR1cmF0aW9uLiBXZSBtdXN0IHVzZSB0aGUgcmF0aW8sIHRob3VnaCwgYmVjYXVzZSBzb21ldGltZXMgdGhlIGludGVybmFsIHRpbWVsaW5lIGlzIHN0cmV0Y2hlZCBsaWtlIGZvciBrZXlmcmFtZXMgd2hlcmUgdGhleSBkb24ndCBhbGwgYWRkIHVwIHRvIHdoYXRldmVyIHRoZSBwYXJlbnQgdHdlZW4ncyBkdXJhdGlvbiB3YXMgc2V0IHRvLlxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkVGFyZ2V0cyA9IHRoaXMuX3RhcmdldHMsXG4gICAgICAgIGtpbGxpbmdUYXJnZXRzID0gdGFyZ2V0cyA/IHRvQXJyYXkodGFyZ2V0cykgOiBwYXJzZWRUYXJnZXRzLFxuICAgICAgICBwcm9wVHdlZW5Mb29rdXAgPSB0aGlzLl9wdExvb2t1cCxcbiAgICAgICAgZmlyc3RQVCA9IHRoaXMuX3B0LFxuICAgICAgICBvdmVyd3JpdHRlblByb3BzLFxuICAgICAgICBjdXJMb29rdXAsXG4gICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcCxcbiAgICAgICAgcHQsXG4gICAgICAgIGk7XG5cbiAgICBpZiAoKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpICYmIF9hcnJheXNNYXRjaChwYXJzZWRUYXJnZXRzLCBraWxsaW5nVGFyZ2V0cykpIHtcbiAgICAgIHZhcnMgPT09IFwiYWxsXCIgJiYgKHRoaXMuX3B0ID0gMCk7XG4gICAgICByZXR1cm4gX2ludGVycnVwdCh0aGlzKTtcbiAgICB9XG5cbiAgICBvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3AgPSB0aGlzLl9vcCB8fCBbXTtcblxuICAgIGlmICh2YXJzICE9PSBcImFsbFwiKSB7XG4gICAgICAvL3NvIHBlb3BsZSBjYW4gcGFzcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzXG4gICAgICBpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG4gICAgICAgIHAgPSB7fTtcblxuICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcFtuYW1lXSA9IDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhcnMgPSBwO1xuICAgICAgfVxuXG4gICAgICB2YXJzID0gX2FkZEFsaWFzZXNUb1ZhcnMocGFyc2VkVGFyZ2V0cywgdmFycyk7XG4gICAgfVxuXG4gICAgaSA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKH5raWxsaW5nVGFyZ2V0cy5pbmRleE9mKHBhcnNlZFRhcmdldHNbaV0pKSB7XG4gICAgICAgIGN1ckxvb2t1cCA9IHByb3BUd2Vlbkxvb2t1cFtpXTtcblxuICAgICAgICBpZiAodmFycyA9PT0gXCJhbGxcIikge1xuICAgICAgICAgIG92ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzO1xuICAgICAgICAgIHByb3BzID0gY3VyTG9va3VwO1xuICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdHRlblByb3BzW2ldID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fTtcbiAgICAgICAgICBwcm9wcyA9IHZhcnM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHAgaW4gcHJvcHMpIHtcbiAgICAgICAgICBwdCA9IGN1ckxvb2t1cCAmJiBjdXJMb29rdXBbcF07XG5cbiAgICAgICAgICBpZiAocHQpIHtcbiAgICAgICAgICAgIGlmICghKFwia2lsbFwiIGluIHB0LmQpIHx8IHB0LmQua2lsbChwKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgY3VyTG9va3VwW3BdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJPdmVyd3JpdGVQcm9wcyAhPT0gXCJhbGxcIikge1xuICAgICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHNbcF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2luaXR0ZWQgJiYgIXRoaXMuX3B0ICYmIGZpcnN0UFQgJiYgX2ludGVycnVwdCh0aGlzKTsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBhcmUga2lsbGVkLCBraWxsIHRoZSB0d2Vlbi4gV2l0aG91dCB0aGlzIGxpbmUsIGlmIHRoZXJlJ3MgYSB0d2VlbiB3aXRoIG11bHRpcGxlIHRhcmdldHMgYW5kIHRoZW4geW91IGtpbGxUd2VlbnNPZigpIGVhY2ggdGFyZ2V0IGluZGl2aWR1YWxseSwgdGhlIHR3ZWVuIHdvdWxkIHRlY2huaWNhbGx5IHN0aWxsIHJlbWFpbiBhY3RpdmUgYW5kIGZpcmUgaXRzIG9uQ29tcGxldGUgZXZlbiB0aG91Z2ggdGhlcmUgYXJlbid0IGFueSBtb3JlIHByb3BlcnRpZXMgdHdlZW5pbmcuXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBUd2Vlbi50byA9IGZ1bmN0aW9uIHRvKHRhcmdldHMsIHZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIGFyZ3VtZW50c1syXSk7XG4gIH07XG5cbiAgVHdlZW4uZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycykge1xuICAgIHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgVHdlZW4uZGVsYXllZENhbGwgPSBmdW5jdGlvbiBkZWxheWVkQ2FsbChkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKGNhbGxiYWNrLCAwLCB7XG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgb25Db21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICBvblJldmVyc2VDb21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICBvbkNvbXBsZXRlUGFyYW1zOiBwYXJhbXMsXG4gICAgICBvblJldmVyc2VDb21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgY2FsbGJhY2tTY29wZTogc2NvcGVcbiAgICB9KTtcbiAgfTtcblxuICBUd2Vlbi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycykge1xuICAgIHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDIsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgVHdlZW4uc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycyk7XG4gIH07XG5cbiAgVHdlZW4ua2lsbFR3ZWVuc09mID0gZnVuY3Rpb24ga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpO1xuICB9O1xuXG4gIHJldHVybiBUd2Vlbjtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFR3ZWVuLnByb3RvdHlwZSwge1xuICBfdGFyZ2V0czogW10sXG4gIF9sYXp5OiAwLFxuICBfc3RhcnRBdDogMCxcbiAgX29wOiAwLFxuICBfb25Jbml0OiAwXG59KTsgLy9hZGQgdGhlIHBlcnRpbmVudCB0aW1lbGluZSBtZXRob2RzIHRvIFR3ZWVuIGluc3RhbmNlcyBzbyB0aGF0IHVzZXJzIGNhbiBjaGFpbiBjb252ZW5pZW50bHkgYW5kIGNyZWF0ZSBhIHRpbWVsaW5lIGF1dG9tYXRpY2FsbHkuIChyZW1vdmVkIGR1ZSB0byBjb25jZXJucyB0aGF0IGl0J2QgdWx0aW1hdGVseSBhZGQgdG8gbW9yZSBjb25mdXNpb24gZXNwZWNpYWxseSBmb3IgYmVnaW5uZXJzKVxuLy8gX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sc2V0LGNhbGwsYWRkLGFkZExhYmVsLGFkZFBhdXNlXCIsIG5hbWUgPT4ge1xuLy8gXHRUd2Vlbi5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbi8vIFx0XHRsZXQgdGwgPSBuZXcgVGltZWxpbmUoKTtcbi8vIFx0XHRyZXR1cm4gX2FkZFRvVGltZWxpbmUodGwsIHRoaXMpW25hbWVdLmFwcGx5KHRsLCB0b0FycmF5KGFyZ3VtZW50cykpO1xuLy8gXHR9XG4vLyB9KTtcbi8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIExldmVyYWdlIHRoZSB0aW1lbGluZSBjYWxscy5cblxuXG5fZm9yRWFjaE5hbWUoXCJzdGFnZ2VyVG8sc3RhZ2dlckZyb20sc3RhZ2dlckZyb21Ub1wiLCBmdW5jdGlvbiAobmFtZSkge1xuICBUd2VlbltuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUoKSxcbiAgICAgICAgcGFyYW1zID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHBhcmFtcy5zcGxpY2UobmFtZSA9PT0gXCJzdGFnZ2VyRnJvbVRvXCIgPyA1IDogNCwgMCwgMCk7XG4gICAgcmV0dXJuIHRsW25hbWVdLmFwcGx5KHRsLCBwYXJhbXMpO1xuICB9O1xufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFBST1BUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbnZhciBfc2V0dGVyUGxhaW4gPSBmdW5jdGlvbiBfc2V0dGVyUGxhaW4odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckZ1bmMgPSBmdW5jdGlvbiBfc2V0dGVyRnVuYyh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSh2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJGdW5jV2l0aFBhcmFtID0gZnVuY3Rpb24gX3NldHRlckZ1bmNXaXRoUGFyYW0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0oZGF0YS5mcCwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyQXR0cmlidXRlID0gZnVuY3Rpb24gX3NldHRlckF0dHJpYnV0ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfZ2V0U2V0dGVyID0gZnVuY3Rpb24gX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih0YXJnZXRbcHJvcGVydHldKSA/IF9zZXR0ZXJGdW5jIDogX2lzVW5kZWZpbmVkKHRhcmdldFtwcm9wZXJ0eV0pICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUgPyBfc2V0dGVyQXR0cmlidXRlIDogX3NldHRlclBsYWluO1xufSxcbiAgICBfcmVuZGVyUGxhaW4gPSBmdW5jdGlvbiBfcmVuZGVyUGxhaW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMDAwKSAvIDEwMDAwMDAsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQm9vbGVhbiA9IGZ1bmN0aW9uIF9yZW5kZXJCb29sZWFuKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgISEoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckNvbXBsZXhTdHJpbmcgPSBmdW5jdGlvbiBfcmVuZGVyQ29tcGxleFN0cmluZyhyYXRpbywgZGF0YSkge1xuICB2YXIgcHQgPSBkYXRhLl9wdCxcbiAgICAgIHMgPSBcIlwiO1xuXG4gIGlmICghcmF0aW8gJiYgZGF0YS5iKSB7XG4gICAgLy9iID0gYmVnaW5uaW5nIHN0cmluZ1xuICAgIHMgPSBkYXRhLmI7XG4gIH0gZWxzZSBpZiAocmF0aW8gPT09IDEgJiYgZGF0YS5lKSB7XG4gICAgLy9lID0gZW5kaW5nIHN0cmluZ1xuICAgIHMgPSBkYXRhLmU7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBzID0gcHQucCArIChwdC5tID8gcHQubShwdC5zICsgcHQuYyAqIHJhdGlvKSA6IE1hdGgucm91bmQoKHB0LnMgKyBwdC5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDApICsgczsgLy93ZSB1c2UgdGhlIFwicFwiIHByb3BlcnR5IGZvciB0aGUgdGV4dCBpbmJldHdlZW4gKGxpa2UgYSBzdWZmaXgpLiBBbmQgaW4gdGhlIGNvbnRleHQgb2YgYSBjb21wbGV4IHN0cmluZywgdGhlIG1vZGlmaWVyIChtKSBpcyB0eXBpY2FsbHkganVzdCBNYXRoLnJvdW5kKCksIGxpa2UgZm9yIFJHQiBjb2xvcnMuXG5cbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgcyArPSBkYXRhLmM7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBjaHVuayBvZiBub24tbnVtZXJpYyB0ZXh0LlxuICB9XG5cbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHMsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyUHJvcFR3ZWVucyA9IGZ1bmN0aW9uIF9yZW5kZXJQcm9wVHdlZW5zKHJhdGlvLCBkYXRhKSB7XG4gIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgIHB0ID0gcHQuX25leHQ7XG4gIH1cbn0sXG4gICAgX2FkZFBsdWdpbk1vZGlmaWVyID0gZnVuY3Rpb24gX2FkZFBsdWdpbk1vZGlmaWVyKG1vZGlmaWVyLCB0d2VlbiwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgIG5leHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgIHB0LnAgPT09IHByb3BlcnR5ICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0d2VlbiwgdGFyZ2V0KTtcbiAgICBwdCA9IG5leHQ7XG4gIH1cbn0sXG4gICAgX2tpbGxQcm9wVHdlZW5zT2YgPSBmdW5jdGlvbiBfa2lsbFByb3BUd2VlbnNPZihwcm9wZXJ0eSkge1xuICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyxcbiAgICAgIG5leHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuXG4gICAgaWYgKHB0LnAgPT09IHByb3BlcnR5ICYmICFwdC5vcCB8fCBwdC5vcCA9PT0gcHJvcGVydHkpIHtcbiAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgfSBlbHNlIGlmICghcHQuZGVwKSB7XG4gICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcgPSAxO1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHJldHVybiAhaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nO1xufSxcbiAgICBfc2V0dGVyV2l0aE1vZGlmaWVyID0gZnVuY3Rpb24gX3NldHRlcldpdGhNb2RpZmllcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICBkYXRhLm1TZXQodGFyZ2V0LCBwcm9wZXJ0eSwgZGF0YS5tLmNhbGwoZGF0YS50d2VlbiwgdmFsdWUsIGRhdGEubXQpLCBkYXRhKTtcbn0sXG4gICAgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSA9IGZ1bmN0aW9uIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkocGFyZW50KSB7XG4gIHZhciBwdCA9IHBhcmVudC5fcHQsXG4gICAgICBuZXh0LFxuICAgICAgcHQyLFxuICAgICAgZmlyc3QsXG4gICAgICBsYXN0OyAvL3NvcnRzIHRoZSBQcm9wVHdlZW4gbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHJpb3JpdHkgYmVjYXVzZSBzb21lIHBsdWdpbnMgbmVlZCB0byBkbyB0aGVpciB3b3JrIGFmdGVyIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyB3ZXJlIGNyZWF0ZWQgKGxpa2UgUm91bmRQcm9wc1BsdWdpbiBhbmQgTW9kaWZpZXJzUGx1Z2luKVxuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICBwdDIgPSBmaXJzdDtcblxuICAgIHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcbiAgICAgIHB0MiA9IHB0Mi5fbmV4dDtcbiAgICB9XG5cbiAgICBpZiAocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSB7XG4gICAgICBwdC5fcHJldi5fbmV4dCA9IHB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdCA9IHB0O1xuICAgIH1cblxuICAgIGlmIChwdC5fbmV4dCA9IHB0Mikge1xuICAgICAgcHQyLl9wcmV2ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBwdDtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cblxuICBwYXJlbnQuX3B0ID0gZmlyc3Q7XG59OyAvL1Byb3BUd2VlbiBrZXk6IHQgPSB0YXJnZXQsIHAgPSBwcm9wLCByID0gcmVuZGVyZXIsIGQgPSBkYXRhLCBzID0gc3RhcnQsIGMgPSBjaGFuZ2UsIG9wID0gb3ZlcndyaXRlUHJvcGVydHkgKE9OTFkgcG9wdWxhdGVkIHdoZW4gaXQncyBkaWZmZXJlbnQgdGhhbiBwKSwgcHIgPSBwcmlvcml0eSwgX25leHQvX3ByZXYgZm9yIHRoZSBsaW5rZWQgbGlzdCBzaWJsaW5ncywgc2V0ID0gc2V0dGVyLCBtID0gbW9kaWZpZXIsIG1TZXQgPSBtb2RpZmllclNldHRlciAodGhlIG9yaWdpbmFsIHNldHRlciwgYmVmb3JlIGEgbW9kaWZpZXIgd2FzIGFkZGVkKVxuXG5cbmV4cG9ydCB2YXIgUHJvcFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvcFR3ZWVuKG5leHQsIHRhcmdldCwgcHJvcCwgc3RhcnQsIGNoYW5nZSwgcmVuZGVyZXIsIGRhdGEsIHNldHRlciwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgdGhpcy5zID0gc3RhcnQ7XG4gICAgdGhpcy5jID0gY2hhbmdlO1xuICAgIHRoaXMucCA9IHByb3A7XG4gICAgdGhpcy5yID0gcmVuZGVyZXIgfHwgX3JlbmRlclBsYWluO1xuICAgIHRoaXMuZCA9IGRhdGEgfHwgdGhpcztcbiAgICB0aGlzLnNldCA9IHNldHRlciB8fCBfc2V0dGVyUGxhaW47XG4gICAgdGhpcy5wciA9IHByaW9yaXR5IHx8IDA7XG4gICAgdGhpcy5fbmV4dCA9IG5leHQ7XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgbmV4dC5fcHJldiA9IHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90bzQgPSBQcm9wVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzQubW9kaWZpZXIgPSBmdW5jdGlvbiBtb2RpZmllcihmdW5jLCB0d2VlbiwgdGFyZ2V0KSB7XG4gICAgdGhpcy5tU2V0ID0gdGhpcy5tU2V0IHx8IHRoaXMuc2V0OyAvL2luIGNhc2UgaXQgd2FzIGFscmVhZHkgc2V0IChhIFByb3BUd2VlbiBjYW4gb25seSBoYXZlIG9uZSBtb2RpZmllcilcblxuICAgIHRoaXMuc2V0ID0gX3NldHRlcldpdGhNb2RpZmllcjtcbiAgICB0aGlzLm0gPSBmdW5jO1xuICAgIHRoaXMubXQgPSB0YXJnZXQ7IC8vbW9kaWZpZXIgdGFyZ2V0XG5cbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XG4gIH07XG5cbiAgcmV0dXJuIFByb3BUd2Vlbjtcbn0oKTsgLy9Jbml0aWFsaXphdGlvbiB0YXNrc1xuXG5fZm9yRWFjaE5hbWUoX2NhbGxiYWNrTmFtZXMgKyBcInBhcmVudCxkdXJhdGlvbixlYXNlLGRlbGF5LG92ZXJ3cml0ZSxydW5CYWNrd2FyZHMsc3RhcnRBdCx5b3lvLGltbWVkaWF0ZVJlbmRlcixyZXBlYXQscmVwZWF0RGVsYXksZGF0YSxwYXVzZWQscmV2ZXJzZWQsbGF6eSxjYWxsYmFja1Njb3BlLHN0cmluZ0ZpbHRlcixpZCx5b3lvRWFzZSxzdGFnZ2VyLGluaGVyaXQscmVwZWF0UmVmcmVzaCxrZXlmcmFtZXMsYXV0b1JldmVydCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG59KTtcblxuX2dsb2JhbHMuVHdlZW5NYXggPSBfZ2xvYmFscy5Ud2VlbkxpdGUgPSBUd2Vlbjtcbl9nbG9iYWxzLlRpbWVsaW5lTGl0ZSA9IF9nbG9iYWxzLlRpbWVsaW5lTWF4ID0gVGltZWxpbmU7XG5fZ2xvYmFsVGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICBzb3J0Q2hpbGRyZW46IGZhbHNlLFxuICBkZWZhdWx0czogX2RlZmF1bHRzLFxuICBhdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWUsXG4gIGlkOiBcInJvb3RcIixcbiAgc21vb3RoQ2hpbGRUaW1pbmc6IHRydWVcbn0pO1xuX2NvbmZpZy5zdHJpbmdGaWx0ZXIgPSBfY29sb3JTdHJpbmdGaWx0ZXI7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEdTQVBcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIF9nc2FwID0ge1xuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlUGx1Z2luKGNvbmZpZyk7XG4gICAgfSk7XG4gIH0sXG4gIHRpbWVsaW5lOiBmdW5jdGlvbiB0aW1lbGluZSh2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lbGluZSh2YXJzKTtcbiAgfSxcbiAgZ2V0VHdlZW5zT2Y6IGZ1bmN0aW9uIGdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpO1xuICB9LFxuICBnZXRQcm9wZXJ0eTogZnVuY3Rpb24gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgIF9pc1N0cmluZyh0YXJnZXQpICYmICh0YXJnZXQgPSB0b0FycmF5KHRhcmdldClbMF0pOyAvL2luIGNhc2Ugc2VsZWN0b3IgdGV4dCBvciBhbiBhcnJheSBpcyBwYXNzZWQgaW5cblxuICAgIHZhciBnZXR0ZXIgPSBfZ2V0Q2FjaGUodGFyZ2V0IHx8IHt9KS5nZXQsXG4gICAgICAgIGZvcm1hdCA9IHVuaXQgPyBfcGFzc1Rocm91Z2ggOiBfbnVtZXJpY0lmUG9zc2libGU7XG5cbiAgICB1bml0ID09PSBcIm5hdGl2ZVwiICYmICh1bml0ID0gXCJcIik7XG4gICAgcmV0dXJuICF0YXJnZXQgPyB0YXJnZXQgOiAhcHJvcGVydHkgPyBmdW5jdGlvbiAocHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiBfcGx1Z2luc1twcm9wZXJ0eV0uZ2V0IHx8IGdldHRlcikodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkpO1xuICAgIH0gOiBmb3JtYXQoKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiBfcGx1Z2luc1twcm9wZXJ0eV0uZ2V0IHx8IGdldHRlcikodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkpO1xuICB9LFxuICBxdWlja1NldHRlcjogZnVuY3Rpb24gcXVpY2tTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCkge1xuICAgIHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KTtcblxuICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIHNldHRlcnMgPSB0YXJnZXQubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBnc2FwLnF1aWNrU2V0dGVyKHQsIHByb3BlcnR5LCB1bml0KTtcbiAgICAgIH0pLFxuICAgICAgICAgIGwgPSBzZXR0ZXJzLmxlbmd0aDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSBsO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBzZXR0ZXJzW2ldKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXRbMF0gfHwge307XG5cbiAgICB2YXIgUGx1Z2luID0gX3BsdWdpbnNbcHJvcGVydHldLFxuICAgICAgICBjYWNoZSA9IF9nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgICBwID0gY2FjaGUuaGFybmVzcyAmJiAoY2FjaGUuaGFybmVzcy5hbGlhc2VzIHx8IHt9KVtwcm9wZXJ0eV0gfHwgcHJvcGVydHksXG4gICAgICAgIC8vIGluIGNhc2UgaXQncyBhbiBhbGlhcywgbGlrZSBcInJvdGF0ZVwiIGZvciBcInJvdGF0aW9uXCIuXG4gICAgc2V0dGVyID0gUGx1Z2luID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgcCA9IG5ldyBQbHVnaW4oKTtcbiAgICAgIF9xdWlja1R3ZWVuLl9wdCA9IDA7XG4gICAgICBwLmluaXQodGFyZ2V0LCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIF9xdWlja1R3ZWVuLCAwLCBbdGFyZ2V0XSk7XG4gICAgICBwLnJlbmRlcigxLCBwKTtcbiAgICAgIF9xdWlja1R3ZWVuLl9wdCAmJiBfcmVuZGVyUHJvcFR3ZWVucygxLCBfcXVpY2tUd2Vlbik7XG4gICAgfSA6IGNhY2hlLnNldCh0YXJnZXQsIHApO1xuXG4gICAgcmV0dXJuIFBsdWdpbiA/IHNldHRlciA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNldHRlcih0YXJnZXQsIHAsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgY2FjaGUsIDEpO1xuICAgIH07XG4gIH0sXG4gIGlzVHdlZW5pbmc6IGZ1bmN0aW9uIGlzVHdlZW5pbmcodGFyZ2V0cykge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHZhbHVlKSB7XG4gICAgdmFsdWUgJiYgdmFsdWUuZWFzZSAmJiAodmFsdWUuZWFzZSA9IF9wYXJzZUVhc2UodmFsdWUuZWFzZSwgX2RlZmF1bHRzLmVhc2UpKTtcbiAgICByZXR1cm4gX21lcmdlRGVlcChfZGVmYXVsdHMsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcodmFsdWUpIHtcbiAgICByZXR1cm4gX21lcmdlRGVlcChfY29uZmlnLCB2YWx1ZSB8fCB7fSk7XG4gIH0sXG4gIHJlZ2lzdGVyRWZmZWN0OiBmdW5jdGlvbiByZWdpc3RlckVmZmVjdChfcmVmMykge1xuICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0LFxuICAgICAgICBwbHVnaW5zID0gX3JlZjMucGx1Z2lucyxcbiAgICAgICAgZGVmYXVsdHMgPSBfcmVmMy5kZWZhdWx0cyxcbiAgICAgICAgZXh0ZW5kVGltZWxpbmUgPSBfcmVmMy5leHRlbmRUaW1lbGluZTtcbiAgICAocGx1Z2lucyB8fCBcIlwiKS5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xuICAgICAgcmV0dXJuIHBsdWdpbk5hbWUgJiYgIV9wbHVnaW5zW3BsdWdpbk5hbWVdICYmICFfZ2xvYmFsc1twbHVnaW5OYW1lXSAmJiBfd2FybihuYW1lICsgXCIgZWZmZWN0IHJlcXVpcmVzIFwiICsgcGx1Z2luTmFtZSArIFwiIHBsdWdpbi5cIik7XG4gICAgfSk7XG5cbiAgICBfZWZmZWN0c1tuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCB0bCkge1xuICAgICAgcmV0dXJuIGVmZmVjdCh0b0FycmF5KHRhcmdldHMpLCBfc2V0RGVmYXVsdHModmFycyB8fCB7fSwgZGVmYXVsdHMpLCB0bCk7XG4gICAgfTtcblxuICAgIGlmIChleHRlbmRUaW1lbGluZSkge1xuICAgICAgVGltZWxpbmUucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChfZWZmZWN0c1tuYW1lXSh0YXJnZXRzLCBfaXNPYmplY3QodmFycykgPyB2YXJzIDogKHBvc2l0aW9uID0gdmFycykgJiYge30sIHRoaXMpLCBwb3NpdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgcmVnaXN0ZXJFYXNlOiBmdW5jdGlvbiByZWdpc3RlckVhc2UobmFtZSwgZWFzZSkge1xuICAgIF9lYXNlTWFwW25hbWVdID0gX3BhcnNlRWFzZShlYXNlKTtcbiAgfSxcbiAgcGFyc2VFYXNlOiBmdW5jdGlvbiBwYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIDogX2Vhc2VNYXA7XG4gIH0sXG4gIGdldEJ5SWQ6IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldEJ5SWQoaWQpO1xuICB9LFxuICBleHBvcnRSb290OiBmdW5jdGlvbiBleHBvcnRSb290KHZhcnMsIGluY2x1ZGVEZWxheWVkQ2FsbHMpIHtcbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0ge307XG4gICAgfVxuXG4gICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lKHZhcnMpLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dDtcbiAgICB0bC5zbW9vdGhDaGlsZFRpbWluZyA9IF9pc05vdEZhbHNlKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcpO1xuXG4gICAgX2dsb2JhbFRpbWVsaW5lLnJlbW92ZSh0bCk7XG5cbiAgICB0bC5fZHAgPSAwOyAvL290aGVyd2lzZSBpdCdsbCBnZXQgcmUtYWN0aXZhdGVkIHdoZW4gYWRkaW5nIGNoaWxkcmVuIGFuZCBiZSByZS1pbnRyb2R1Y2VkIGludG8gX2dsb2JhbFRpbWVsaW5lJ3MgbGlua2VkIGxpc3QgKHRoZW4gYWRkZWQgdG8gaXRzZWxmKS5cblxuICAgIHRsLl90aW1lID0gdGwuX3RUaW1lID0gX2dsb2JhbFRpbWVsaW5lLl90aW1lO1xuICAgIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gICAgICBpZiAoaW5jbHVkZURlbGF5ZWRDYWxscyB8fCAhKCFjaGlsZC5fZHVyICYmIGNoaWxkIGluc3RhbmNlb2YgVHdlZW4gJiYgY2hpbGQudmFycy5vbkNvbXBsZXRlID09PSBjaGlsZC5fdGFyZ2V0c1swXSkpIHtcbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGwsIGNoaWxkLCBjaGlsZC5fc3RhcnQgLSBjaGlsZC5fZGVsYXkpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgX2FkZFRvVGltZWxpbmUoX2dsb2JhbFRpbWVsaW5lLCB0bCwgMCk7XG5cbiAgICByZXR1cm4gdGw7XG4gIH0sXG4gIHV0aWxzOiB7XG4gICAgd3JhcDogd3JhcCxcbiAgICB3cmFwWW95bzogd3JhcFlveW8sXG4gICAgZGlzdHJpYnV0ZTogZGlzdHJpYnV0ZSxcbiAgICByYW5kb206IHJhbmRvbSxcbiAgICBzbmFwOiBzbmFwLFxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICAgIGdldFVuaXQ6IGdldFVuaXQsXG4gICAgY2xhbXA6IGNsYW1wLFxuICAgIHNwbGl0Q29sb3I6IHNwbGl0Q29sb3IsXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgbWFwUmFuZ2U6IG1hcFJhbmdlLFxuICAgIHBpcGU6IHBpcGUsXG4gICAgdW5pdGl6ZTogdW5pdGl6ZSxcbiAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG4gICAgc2h1ZmZsZTogc2h1ZmZsZVxuICB9LFxuICBpbnN0YWxsOiBfaW5zdGFsbCxcbiAgZWZmZWN0czogX2VmZmVjdHMsXG4gIHRpY2tlcjogX3RpY2tlcixcbiAgdXBkYXRlUm9vdDogVGltZWxpbmUudXBkYXRlUm9vdCxcbiAgcGx1Z2luczogX3BsdWdpbnMsXG4gIGdsb2JhbFRpbWVsaW5lOiBfZ2xvYmFsVGltZWxpbmUsXG4gIGNvcmU6IHtcbiAgICBQcm9wVHdlZW46IFByb3BUd2VlbixcbiAgICBnbG9iYWxzOiBfYWRkR2xvYmFsLFxuICAgIFR3ZWVuOiBUd2VlbixcbiAgICBUaW1lbGluZTogVGltZWxpbmUsXG4gICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXG4gICAgZ2V0Q2FjaGU6IF9nZXRDYWNoZSxcbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW06IF9yZW1vdmVMaW5rZWRMaXN0SXRlbSxcbiAgICBzdXBwcmVzc092ZXJ3cml0ZXM6IGZ1bmN0aW9uIHN1cHByZXNzT3ZlcndyaXRlcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbl9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLGRlbGF5ZWRDYWxsLHNldCxraWxsVHdlZW5zT2ZcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9nc2FwW25hbWVdID0gVHdlZW5bbmFtZV07XG59KTtcblxuX3RpY2tlci5hZGQoVGltZWxpbmUudXBkYXRlUm9vdCk7XG5cbl9xdWlja1R3ZWVuID0gX2dzYXAudG8oe30sIHtcbiAgZHVyYXRpb246IDBcbn0pOyAvLyAtLS0tIEVYVFJBIFBMVUdJTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIF9nZXRQbHVnaW5Qcm9wVHdlZW4gPSBmdW5jdGlvbiBfZ2V0UGx1Z2luUHJvcFR3ZWVuKHBsdWdpbiwgcHJvcCkge1xuICB2YXIgcHQgPSBwbHVnaW4uX3B0O1xuXG4gIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wICYmIHB0Lm9wICE9PSBwcm9wICYmIHB0LmZwICE9PSBwcm9wKSB7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZE1vZGlmaWVycyA9IGZ1bmN0aW9uIF9hZGRNb2RpZmllcnModHdlZW4sIG1vZGlmaWVycykge1xuICB2YXIgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcCxcbiAgICAgIGksXG4gICAgICBwdDtcblxuICBmb3IgKHAgaW4gbW9kaWZpZXJzKSB7XG4gICAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHQgPSB0d2Vlbi5fcHRMb29rdXBbaV1bcF07XG5cbiAgICAgIGlmIChwdCAmJiAocHQgPSBwdC5kKSkge1xuICAgICAgICBpZiAocHQuX3B0KSB7XG4gICAgICAgICAgLy8gaXMgYSBwbHVnaW5cbiAgICAgICAgICBwdCA9IF9nZXRQbHVnaW5Qcm9wVHdlZW4ocHQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcHQgJiYgcHQubW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXJzW3BdLCB0d2VlbiwgdGFyZ2V0c1tpXSwgcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuICAgIF9idWlsZE1vZGlmaWVyUGx1Z2luID0gZnVuY3Rpb24gX2J1aWxkTW9kaWZpZXJQbHVnaW4obmFtZSwgbW9kaWZpZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJhd1ZhcnM6IDEsXG4gICAgLy9kb24ndCBwcmUtcHJvY2VzcyBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgb3IgXCJyYW5kb20oKVwiIHN0cmluZ3MuXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG4gICAgICB0d2Vlbi5fb25Jbml0ID0gZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgIHZhciB0ZW1wLCBwO1xuXG4gICAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wW25hbWVdID0gMTtcbiAgICAgICAgICB9KTsgLy9pZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0byByb3VuZFByb3BzLCBsaWtlIFwieCx5XCIsIHdlIHJvdW5kIHRvIHdob2xlIG51bWJlcnMuXG5cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgICAgICAgIHRlbXBbcF0gPSBtb2RpZmllcih2YXJzW3BdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXJzID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hZGRNb2RpZmllcnModHdlZW4sIHZhcnMpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59OyAvL3JlZ2lzdGVyIGNvcmUgcGx1Z2luc1xuXG5cbmV4cG9ydCB2YXIgZ3NhcCA9IF9nc2FwLnJlZ2lzdGVyUGx1Z2luKHtcbiAgbmFtZTogXCJhdHRyXCIsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICB2YXIgcCwgcHQ7XG5cbiAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgcHQgPSB0aGlzLmFkZCh0YXJnZXQsIFwic2V0QXR0cmlidXRlXCIsICh0YXJnZXQuZ2V0QXR0cmlidXRlKHApIHx8IDApICsgXCJcIiwgdmFyc1twXSwgaW5kZXgsIHRhcmdldHMsIDAsIDAsIHApO1xuICAgICAgcHQgJiYgKHB0Lm9wID0gcCk7XG5cbiAgICAgIHRoaXMuX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6IFwiZW5kQXJyYXlcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmFkZCh0YXJnZXQsIGksIHRhcmdldFtpXSB8fCAwLCB2YWx1ZVtpXSk7XG4gICAgfVxuICB9XG59LCBfYnVpbGRNb2RpZmllclBsdWdpbihcInJvdW5kUHJvcHNcIiwgX3JvdW5kTW9kaWZpZXIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcIm1vZGlmaWVyc1wiKSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJzbmFwXCIsIHNuYXApKSB8fCBfZ3NhcDsgLy90byBwcmV2ZW50IHRoZSBjb3JlIHBsdWdpbnMgZnJvbSBiZWluZyBkcm9wcGVkIHZpYSBhZ2dyZXNzaXZlIHRyZWUgc2hha2luZywgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGluIHRoaXMgd2F5LlxuXG5Ud2Vlbi52ZXJzaW9uID0gVGltZWxpbmUudmVyc2lvbiA9IGdzYXAudmVyc2lvbiA9IFwiMy44LjBcIjtcbl9jb3JlUmVhZHkgPSAxO1xuX3dpbmRvd0V4aXN0cygpICYmIF93YWtlKCk7XG52YXIgUG93ZXIwID0gX2Vhc2VNYXAuUG93ZXIwLFxuICAgIFBvd2VyMSA9IF9lYXNlTWFwLlBvd2VyMSxcbiAgICBQb3dlcjIgPSBfZWFzZU1hcC5Qb3dlcjIsXG4gICAgUG93ZXIzID0gX2Vhc2VNYXAuUG93ZXIzLFxuICAgIFBvd2VyNCA9IF9lYXNlTWFwLlBvd2VyNCxcbiAgICBMaW5lYXIgPSBfZWFzZU1hcC5MaW5lYXIsXG4gICAgUXVhZCA9IF9lYXNlTWFwLlF1YWQsXG4gICAgQ3ViaWMgPSBfZWFzZU1hcC5DdWJpYyxcbiAgICBRdWFydCA9IF9lYXNlTWFwLlF1YXJ0LFxuICAgIFF1aW50ID0gX2Vhc2VNYXAuUXVpbnQsXG4gICAgU3Ryb25nID0gX2Vhc2VNYXAuU3Ryb25nLFxuICAgIEVsYXN0aWMgPSBfZWFzZU1hcC5FbGFzdGljLFxuICAgIEJhY2sgPSBfZWFzZU1hcC5CYWNrLFxuICAgIFN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuU3RlcHBlZEVhc2UsXG4gICAgQm91bmNlID0gX2Vhc2VNYXAuQm91bmNlLFxuICAgIFNpbmUgPSBfZWFzZU1hcC5TaW5lLFxuICAgIEV4cG8gPSBfZWFzZU1hcC5FeHBvLFxuICAgIENpcmMgPSBfZWFzZU1hcC5DaXJjO1xuZXhwb3J0IHsgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07XG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIHNlbGVjdG9yLCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTsgLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXG5cbmV4cG9ydCB7IF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX3JlcGxhY2VSYW5kb20sIF9jaGVja1BsdWdpbiwgX3BsdWdpbnMsIF90aWNrZXIsIF9jb25maWcsIF9yb3VuZE1vZGlmaWVyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCB9OyIsImltcG9ydCB7IGdzYXAsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYywgVHdlZW5MaXRlLCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4IH0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5pbXBvcnQgeyBDU1NQbHVnaW4gfSBmcm9tIFwiLi9DU1NQbHVnaW4uanNcIjtcbnZhciBnc2FwV2l0aENTUyA9IGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKSB8fCBnc2FwLFxuICAgIC8vIHRvIHByb3RlY3QgZnJvbSB0cmVlIHNoYWtpbmdcblR3ZWVuTWF4V2l0aENTUyA9IGdzYXBXaXRoQ1NTLmNvcmUuVHdlZW47XG5leHBvcnQgeyBnc2FwV2l0aENTUyBhcyBnc2FwLCBnc2FwV2l0aENTUyBhcyBkZWZhdWx0LCBDU1NQbHVnaW4sIFR3ZWVuTWF4V2l0aENTUyBhcyBUd2Vlbk1heCwgVHdlZW5MaXRlLCBUaW1lbGluZU1heCwgVGltZWxpbmVMaXRlLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZWRfcmVmZXJlbmNlc18xID0gcmVxdWlyZShcIi4vbmFtZWQtcmVmZXJlbmNlc1wiKTtcbnZhciBudW1lcmljX3VuaWNvZGVfbWFwXzEgPSByZXF1aXJlKFwiLi9udW1lcmljLXVuaWNvZGUtbWFwXCIpO1xudmFyIHN1cnJvZ2F0ZV9wYWlyc18xID0gcmVxdWlyZShcIi4vc3Vycm9nYXRlLXBhaXJzXCIpO1xudmFyIGFsbE5hbWVkUmVmZXJlbmNlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBuYW1lZF9yZWZlcmVuY2VzXzEubmFtZWRSZWZlcmVuY2VzKSwgeyBhbGw6IG5hbWVkX3JlZmVyZW5jZXNfMS5uYW1lZFJlZmVyZW5jZXMuaHRtbDUgfSk7XG52YXIgZW5jb2RlUmVnRXhwcyA9IHtcbiAgICBzcGVjaWFsQ2hhcnM6IC9bPD4nXCImXS9nLFxuICAgIG5vbkFzY2lpOiAvKD86Wzw+J1wiJlxcdTAwODAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZyxcbiAgICBub25Bc2NpaVByaW50YWJsZTogLyg/Ols8PidcIiZcXHgwMS1cXHgwOFxceDExLVxceDE1XFx4MTctXFx4MUZcXHg3Zi1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS9nLFxuICAgIGV4dGVuc2l2ZTogLyg/OltcXHgwMS1cXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4MmNcXHgyZS1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3ZFxceDdmLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pL2dcbn07XG52YXIgZGVmYXVsdEVuY29kZU9wdGlvbnMgPSB7XG4gICAgbW9kZTogJ3NwZWNpYWxDaGFycycsXG4gICAgbGV2ZWw6ICdhbGwnLFxuICAgIG51bWVyaWM6ICdkZWNpbWFsJ1xufTtcbi8qKiBFbmNvZGVzIGFsbCB0aGUgbmVjZXNzYXJ5IChzcGVjaWZpZWQgYnkgYGxldmVsYCkgY2hhcmFjdGVycyBpbiB0aGUgdGV4dCAqL1xuZnVuY3Rpb24gZW5jb2RlKHRleHQsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IGRlZmF1bHRFbmNvZGVPcHRpb25zIDogX2EsIF9jID0gX2IubW9kZSwgbW9kZSA9IF9jID09PSB2b2lkIDAgPyAnc3BlY2lhbENoYXJzJyA6IF9jLCBfZCA9IF9iLm51bWVyaWMsIG51bWVyaWMgPSBfZCA9PT0gdm9pZCAwID8gJ2RlY2ltYWwnIDogX2QsIF9lID0gX2IubGV2ZWwsIGxldmVsID0gX2UgPT09IHZvaWQgMCA/ICdhbGwnIDogX2U7XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIGVuY29kZVJlZ0V4cCA9IGVuY29kZVJlZ0V4cHNbbW9kZV07XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBhbGxOYW1lZFJlZmVyZW5jZXNbbGV2ZWxdLmNoYXJhY3RlcnM7XG4gICAgdmFyIGlzSGV4ID0gbnVtZXJpYyA9PT0gJ2hleGFkZWNpbWFsJztcbiAgICBlbmNvZGVSZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgX2IgPSBlbmNvZGVSZWdFeHAuZXhlYyh0ZXh0KTtcbiAgICB2YXIgX2M7XG4gICAgaWYgKF9iKSB7XG4gICAgICAgIF9jID0gJyc7XG4gICAgICAgIHZhciBfZCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChfZCAhPT0gX2IuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBfYyArPSB0ZXh0LnN1YnN0cmluZyhfZCwgX2IuaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9lID0gX2JbMF07XG4gICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSByZWZlcmVuY2VzW19lXTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0XzEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZV8xID0gX2UubGVuZ3RoID4gMSA/IHN1cnJvZ2F0ZV9wYWlyc18xLmdldENvZGVQb2ludChfZSwgMCkgOiBfZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIHJlc3VsdF8xID0gKGlzSGV4ID8gJyYjeCcgKyBjb2RlXzEudG9TdHJpbmcoMTYpIDogJyYjJyArIGNvZGVfMSkgKyAnOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYyArPSByZXN1bHRfMTtcbiAgICAgICAgICAgIF9kID0gX2IuaW5kZXggKyBfZS5sZW5ndGg7XG4gICAgICAgIH0gd2hpbGUgKChfYiA9IGVuY29kZVJlZ0V4cC5leGVjKHRleHQpKSk7XG4gICAgICAgIGlmIChfZCAhPT0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIF9jICs9IHRleHQuc3Vic3RyaW5nKF9kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2MgPVxuICAgICAgICAgICAgdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIF9jO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG52YXIgZGVmYXVsdERlY29kZU9wdGlvbnMgPSB7XG4gICAgc2NvcGU6ICdib2R5JyxcbiAgICBsZXZlbDogJ2FsbCdcbn07XG52YXIgc3RyaWN0ID0gLyYoPzojXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspOy9nO1xudmFyIGF0dHJpYnV0ZSA9IC8mKD86I1xcZCt8I1t4WF1bXFxkYS1mQS1GXSt8WzAtOWEtekEtWl0rKVs7PV0/L2c7XG52YXIgYmFzZURlY29kZVJlZ0V4cHMgPSB7XG4gICAgeG1sOiB7XG4gICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICAgICAgYm9keTogbmFtZWRfcmVmZXJlbmNlc18xLmJvZHlSZWdFeHBzLnhtbFxuICAgIH0sXG4gICAgaHRtbDQ6IHtcbiAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlLFxuICAgICAgICBib2R5OiBuYW1lZF9yZWZlcmVuY2VzXzEuYm9keVJlZ0V4cHMuaHRtbDRcbiAgICB9LFxuICAgIGh0bWw1OiB7XG4gICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICAgICAgYm9keTogbmFtZWRfcmVmZXJlbmNlc18xLmJvZHlSZWdFeHBzLmh0bWw1XG4gICAgfVxufTtcbnZhciBkZWNvZGVSZWdFeHBzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGJhc2VEZWNvZGVSZWdFeHBzKSwgeyBhbGw6IGJhc2VEZWNvZGVSZWdFeHBzLmh0bWw1IH0pO1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgb3V0T2ZCb3VuZHNDaGFyID0gZnJvbUNoYXJDb2RlKDY1NTMzKTtcbnZhciBkZWZhdWx0RGVjb2RlRW50aXR5T3B0aW9ucyA9IHtcbiAgICBsZXZlbDogJ2FsbCdcbn07XG4vKiogRGVjb2RlcyBhIHNpbmdsZSBlbnRpdHkgKi9cbmZ1bmN0aW9uIGRlY29kZUVudGl0eShlbnRpdHksIF9hKSB7XG4gICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyBkZWZhdWx0RGVjb2RlRW50aXR5T3B0aW9ucyA6IF9hKS5sZXZlbCwgbGV2ZWwgPSBfYiA9PT0gdm9pZCAwID8gJ2FsbCcgOiBfYjtcbiAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBfYiA9IGVudGl0eTtcbiAgICB2YXIgZGVjb2RlRW50aXR5TGFzdENoYXJfMSA9IGVudGl0eVtlbnRpdHkubGVuZ3RoIC0gMV07XG4gICAgaWYgKGZhbHNlXG4gICAgICAgICYmIGRlY29kZUVudGl0eUxhc3RDaGFyXzEgPT09ICc9Jykge1xuICAgICAgICBfYiA9XG4gICAgICAgICAgICBlbnRpdHk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZhbHNlXG4gICAgICAgICYmIGRlY29kZUVudGl0eUxhc3RDaGFyXzEgIT09ICc7Jykge1xuICAgICAgICBfYiA9XG4gICAgICAgICAgICBlbnRpdHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2VfMSA9IGFsbE5hbWVkUmVmZXJlbmNlc1tsZXZlbF0uZW50aXRpZXNbZW50aXR5XTtcbiAgICAgICAgaWYgKGRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlXzEpIHtcbiAgICAgICAgICAgIF9iID0gZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2VfMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRpdHlbMF0gPT09ICcmJyAmJiBlbnRpdHlbMV0gPT09ICcjJykge1xuICAgICAgICAgICAgdmFyIGRlY29kZVNlY29uZENoYXJfMSA9IGVudGl0eVsyXTtcbiAgICAgICAgICAgIHZhciBkZWNvZGVDb2RlXzEgPSBkZWNvZGVTZWNvbmRDaGFyXzEgPT0gJ3gnIHx8IGRlY29kZVNlY29uZENoYXJfMSA9PSAnWCdcbiAgICAgICAgICAgICAgICA/IHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMyksIDE2KVxuICAgICAgICAgICAgICAgIDogcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKSk7XG4gICAgICAgICAgICBfYiA9XG4gICAgICAgICAgICAgICAgZGVjb2RlQ29kZV8xID49IDB4MTBmZmZmXG4gICAgICAgICAgICAgICAgICAgID8gb3V0T2ZCb3VuZHNDaGFyXG4gICAgICAgICAgICAgICAgICAgIDogZGVjb2RlQ29kZV8xID4gNjU1MzVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3Vycm9nYXRlX3BhaXJzXzEuZnJvbUNvZGVQb2ludChkZWNvZGVDb2RlXzEpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZyb21DaGFyQ29kZShudW1lcmljX3VuaWNvZGVfbWFwXzEubnVtZXJpY1VuaWNvZGVNYXBbZGVjb2RlQ29kZV8xXSB8fCBkZWNvZGVDb2RlXzEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYjtcbn1cbmV4cG9ydHMuZGVjb2RlRW50aXR5ID0gZGVjb2RlRW50aXR5O1xuLyoqIERlY29kZXMgYWxsIGVudGl0aWVzIGluIHRoZSB0ZXh0ICovXG5mdW5jdGlvbiBkZWNvZGUodGV4dCwgX2EpIHtcbiAgICB2YXIgZGVjb2RlU2Vjb25kQ2hhcl8xID0gX2EgPT09IHZvaWQgMCA/IGRlZmF1bHREZWNvZGVPcHRpb25zIDogX2EsIGRlY29kZUNvZGVfMSA9IGRlY29kZVNlY29uZENoYXJfMS5sZXZlbCwgbGV2ZWwgPSBkZWNvZGVDb2RlXzEgPT09IHZvaWQgMCA/ICdhbGwnIDogZGVjb2RlQ29kZV8xLCBfYiA9IGRlY29kZVNlY29uZENoYXJfMS5zY29wZSwgc2NvcGUgPSBfYiA9PT0gdm9pZCAwID8gbGV2ZWwgPT09ICd4bWwnID8gJ3N0cmljdCcgOiAnYm9keScgOiBfYjtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgZGVjb2RlUmVnRXhwID0gZGVjb2RlUmVnRXhwc1tsZXZlbF1bc2NvcGVdO1xuICAgIHZhciByZWZlcmVuY2VzID0gYWxsTmFtZWRSZWZlcmVuY2VzW2xldmVsXS5lbnRpdGllcztcbiAgICB2YXIgaXNBdHRyaWJ1dGUgPSBzY29wZSA9PT0gJ2F0dHJpYnV0ZSc7XG4gICAgdmFyIGlzU3RyaWN0ID0gc2NvcGUgPT09ICdzdHJpY3QnO1xuICAgIGRlY29kZVJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgIHZhciByZXBsYWNlTWF0Y2hfMSA9IGRlY29kZVJlZ0V4cC5leGVjKHRleHQpO1xuICAgIHZhciByZXBsYWNlUmVzdWx0XzE7XG4gICAgaWYgKHJlcGxhY2VNYXRjaF8xKSB7XG4gICAgICAgIHJlcGxhY2VSZXN1bHRfMSA9ICcnO1xuICAgICAgICB2YXIgcmVwbGFjZUxhc3RJbmRleF8xID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VMYXN0SW5kZXhfMSAhPT0gcmVwbGFjZU1hdGNoXzEuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlUmVzdWx0XzEgKz0gdGV4dC5zdWJzdHJpbmcocmVwbGFjZUxhc3RJbmRleF8xLCByZXBsYWNlTWF0Y2hfMS5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVwbGFjZUlucHV0XzEgPSByZXBsYWNlTWF0Y2hfMVswXTtcbiAgICAgICAgICAgIHZhciBkZWNvZGVSZXN1bHRfMSA9IHJlcGxhY2VJbnB1dF8xO1xuICAgICAgICAgICAgdmFyIGRlY29kZUVudGl0eUxhc3RDaGFyXzIgPSByZXBsYWNlSW5wdXRfMVtyZXBsYWNlSW5wdXRfMS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChpc0F0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICYmIGRlY29kZUVudGl0eUxhc3RDaGFyXzIgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIGRlY29kZVJlc3VsdF8xID0gcmVwbGFjZUlucHV0XzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmljdFxuICAgICAgICAgICAgICAgICYmIGRlY29kZUVudGl0eUxhc3RDaGFyXzIgIT09ICc7Jykge1xuICAgICAgICAgICAgICAgIGRlY29kZVJlc3VsdF8xID0gcmVwbGFjZUlucHV0XzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2VfMiA9IHJlZmVyZW5jZXNbcmVwbGFjZUlucHV0XzFdO1xuICAgICAgICAgICAgICAgIGlmIChkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZV8yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVJlc3VsdF8xID0gZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2VfMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZUlucHV0XzFbMF0gPT09ICcmJyAmJiByZXBsYWNlSW5wdXRfMVsxXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNvZGVTZWNvbmRDaGFyXzIgPSByZXBsYWNlSW5wdXRfMVsyXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29kZUNvZGVfMiA9IGRlY29kZVNlY29uZENoYXJfMiA9PSAneCcgfHwgZGVjb2RlU2Vjb25kQ2hhcl8yID09ICdYJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludChyZXBsYWNlSW5wdXRfMS5zdWJzdHIoMyksIDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJzZUludChyZXBsYWNlSW5wdXRfMS5zdWJzdHIoMikpO1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVSZXN1bHRfMSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVDb2RlXzIgPj0gMHgxMGZmZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG91dE9mQm91bmRzQ2hhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGVjb2RlQ29kZV8yID4gNjU1MzVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdXJyb2dhdGVfcGFpcnNfMS5mcm9tQ29kZVBvaW50KGRlY29kZUNvZGVfMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmcm9tQ2hhckNvZGUobnVtZXJpY191bmljb2RlX21hcF8xLm51bWVyaWNVbmljb2RlTWFwW2RlY29kZUNvZGVfMl0gfHwgZGVjb2RlQ29kZV8yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlUmVzdWx0XzEgKz0gZGVjb2RlUmVzdWx0XzE7XG4gICAgICAgICAgICByZXBsYWNlTGFzdEluZGV4XzEgPSByZXBsYWNlTWF0Y2hfMS5pbmRleCArIHJlcGxhY2VJbnB1dF8xLmxlbmd0aDtcbiAgICAgICAgfSB3aGlsZSAoKHJlcGxhY2VNYXRjaF8xID0gZGVjb2RlUmVnRXhwLmV4ZWModGV4dCkpKTtcbiAgICAgICAgaWYgKHJlcGxhY2VMYXN0SW5kZXhfMSAhPT0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcGxhY2VSZXN1bHRfMSArPSB0ZXh0LnN1YnN0cmluZyhyZXBsYWNlTGFzdEluZGV4XzEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXBsYWNlUmVzdWx0XzEgPVxuICAgICAgICAgICAgdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VSZXN1bHRfMTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzLmJvZHlSZWdFeHBzPXt4bWw6LyYoPzojXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspOz8vZyxodG1sNDovJig/Om5ic3B8aWV4Y2x8Y2VudHxwb3VuZHxjdXJyZW58eWVufGJydmJhcnxzZWN0fHVtbHxjb3B5fG9yZGZ8bGFxdW98bm90fHNoeXxyZWd8bWFjcnxkZWd8cGx1c21ufHN1cDJ8c3VwM3xhY3V0ZXxtaWNyb3xwYXJhfG1pZGRvdHxjZWRpbHxzdXAxfG9yZG18cmFxdW98ZnJhYzE0fGZyYWMxMnxmcmFjMzR8aXF1ZXN0fEFncmF2ZXxBYWN1dGV8QWNpcmN8QXRpbGRlfEF1bWx8QXJpbmd8QUVsaWd8Q2NlZGlsfEVncmF2ZXxFYWN1dGV8RWNpcmN8RXVtbHxJZ3JhdmV8SWFjdXRlfEljaXJjfEl1bWx8RVRIfE50aWxkZXxPZ3JhdmV8T2FjdXRlfE9jaXJjfE90aWxkZXxPdW1sfHRpbWVzfE9zbGFzaHxVZ3JhdmV8VWFjdXRlfFVjaXJjfFV1bWx8WWFjdXRlfFRIT1JOfHN6bGlnfGFncmF2ZXxhYWN1dGV8YWNpcmN8YXRpbGRlfGF1bWx8YXJpbmd8YWVsaWd8Y2NlZGlsfGVncmF2ZXxlYWN1dGV8ZWNpcmN8ZXVtbHxpZ3JhdmV8aWFjdXRlfGljaXJjfGl1bWx8ZXRofG50aWxkZXxvZ3JhdmV8b2FjdXRlfG9jaXJjfG90aWxkZXxvdW1sfGRpdmlkZXxvc2xhc2h8dWdyYXZlfHVhY3V0ZXx1Y2lyY3x1dW1sfHlhY3V0ZXx0aG9ybnx5dW1sfHF1b3R8YW1wfGx0fGd0fCNcXGQrfCNbeFhdW1xcZGEtZkEtRl0rfFswLTlhLXpBLVpdKyk7Py9nLGh0bWw1Oi8mKD86QUVsaWd8QU1QfEFhY3V0ZXxBY2lyY3xBZ3JhdmV8QXJpbmd8QXRpbGRlfEF1bWx8Q09QWXxDY2VkaWx8RVRIfEVhY3V0ZXxFY2lyY3xFZ3JhdmV8RXVtbHxHVHxJYWN1dGV8SWNpcmN8SWdyYXZlfEl1bWx8TFR8TnRpbGRlfE9hY3V0ZXxPY2lyY3xPZ3JhdmV8T3NsYXNofE90aWxkZXxPdW1sfFFVT1R8UkVHfFRIT1JOfFVhY3V0ZXxVY2lyY3xVZ3JhdmV8VXVtbHxZYWN1dGV8YWFjdXRlfGFjaXJjfGFjdXRlfGFlbGlnfGFncmF2ZXxhbXB8YXJpbmd8YXRpbGRlfGF1bWx8YnJ2YmFyfGNjZWRpbHxjZWRpbHxjZW50fGNvcHl8Y3VycmVufGRlZ3xkaXZpZGV8ZWFjdXRlfGVjaXJjfGVncmF2ZXxldGh8ZXVtbHxmcmFjMTJ8ZnJhYzE0fGZyYWMzNHxndHxpYWN1dGV8aWNpcmN8aWV4Y2x8aWdyYXZlfGlxdWVzdHxpdW1sfGxhcXVvfGx0fG1hY3J8bWljcm98bWlkZG90fG5ic3B8bm90fG50aWxkZXxvYWN1dGV8b2NpcmN8b2dyYXZlfG9yZGZ8b3JkbXxvc2xhc2h8b3RpbGRlfG91bWx8cGFyYXxwbHVzbW58cG91bmR8cXVvdHxyYXF1b3xyZWd8c2VjdHxzaHl8c3VwMXxzdXAyfHN1cDN8c3psaWd8dGhvcm58dGltZXN8dWFjdXRlfHVjaXJjfHVncmF2ZXx1bWx8dXVtbHx5YWN1dGV8eWVufHl1bWx8I1xcZCt8I1t4WF1bXFxkYS1mQS1GXSt8WzAtOWEtekEtWl0rKTs/L2d9O2V4cG9ydHMubmFtZWRSZWZlcmVuY2VzPXt4bWw6e2VudGl0aWVzOntcIiZsdDtcIjpcIjxcIixcIiZndDtcIjpcIj5cIixcIiZxdW90O1wiOidcIicsXCImYXBvcztcIjpcIidcIixcIiZhbXA7XCI6XCImXCJ9LGNoYXJhY3RlcnM6e1wiPFwiOlwiJmx0O1wiLFwiPlwiOlwiJmd0O1wiLCdcIic6XCImcXVvdDtcIixcIidcIjpcIiZhcG9zO1wiLFwiJlwiOlwiJmFtcDtcIn19LGh0bWw0OntlbnRpdGllczp7XCImYXBvcztcIjpcIidcIixcIiZuYnNwXCI6XCLCoFwiLFwiJm5ic3A7XCI6XCLCoFwiLFwiJmlleGNsXCI6XCLCoVwiLFwiJmlleGNsO1wiOlwiwqFcIixcIiZjZW50XCI6XCLColwiLFwiJmNlbnQ7XCI6XCLColwiLFwiJnBvdW5kXCI6XCLCo1wiLFwiJnBvdW5kO1wiOlwiwqNcIixcIiZjdXJyZW5cIjpcIsKkXCIsXCImY3VycmVuO1wiOlwiwqRcIixcIiZ5ZW5cIjpcIsKlXCIsXCImeWVuO1wiOlwiwqVcIixcIiZicnZiYXJcIjpcIsKmXCIsXCImYnJ2YmFyO1wiOlwiwqZcIixcIiZzZWN0XCI6XCLCp1wiLFwiJnNlY3Q7XCI6XCLCp1wiLFwiJnVtbFwiOlwiwqhcIixcIiZ1bWw7XCI6XCLCqFwiLFwiJmNvcHlcIjpcIsKpXCIsXCImY29weTtcIjpcIsKpXCIsXCImb3JkZlwiOlwiwqpcIixcIiZvcmRmO1wiOlwiwqpcIixcIiZsYXF1b1wiOlwiwqtcIixcIiZsYXF1bztcIjpcIsKrXCIsXCImbm90XCI6XCLCrFwiLFwiJm5vdDtcIjpcIsKsXCIsXCImc2h5XCI6XCLCrVwiLFwiJnNoeTtcIjpcIsKtXCIsXCImcmVnXCI6XCLCrlwiLFwiJnJlZztcIjpcIsKuXCIsXCImbWFjclwiOlwiwq9cIixcIiZtYWNyO1wiOlwiwq9cIixcIiZkZWdcIjpcIsKwXCIsXCImZGVnO1wiOlwiwrBcIixcIiZwbHVzbW5cIjpcIsKxXCIsXCImcGx1c21uO1wiOlwiwrFcIixcIiZzdXAyXCI6XCLCslwiLFwiJnN1cDI7XCI6XCLCslwiLFwiJnN1cDNcIjpcIsKzXCIsXCImc3VwMztcIjpcIsKzXCIsXCImYWN1dGVcIjpcIsK0XCIsXCImYWN1dGU7XCI6XCLCtFwiLFwiJm1pY3JvXCI6XCLCtVwiLFwiJm1pY3JvO1wiOlwiwrVcIixcIiZwYXJhXCI6XCLCtlwiLFwiJnBhcmE7XCI6XCLCtlwiLFwiJm1pZGRvdFwiOlwiwrdcIixcIiZtaWRkb3Q7XCI6XCLCt1wiLFwiJmNlZGlsXCI6XCLCuFwiLFwiJmNlZGlsO1wiOlwiwrhcIixcIiZzdXAxXCI6XCLCuVwiLFwiJnN1cDE7XCI6XCLCuVwiLFwiJm9yZG1cIjpcIsK6XCIsXCImb3JkbTtcIjpcIsK6XCIsXCImcmFxdW9cIjpcIsK7XCIsXCImcmFxdW87XCI6XCLCu1wiLFwiJmZyYWMxNFwiOlwiwrxcIixcIiZmcmFjMTQ7XCI6XCLCvFwiLFwiJmZyYWMxMlwiOlwiwr1cIixcIiZmcmFjMTI7XCI6XCLCvVwiLFwiJmZyYWMzNFwiOlwiwr5cIixcIiZmcmFjMzQ7XCI6XCLCvlwiLFwiJmlxdWVzdFwiOlwiwr9cIixcIiZpcXVlc3Q7XCI6XCLCv1wiLFwiJkFncmF2ZVwiOlwiw4BcIixcIiZBZ3JhdmU7XCI6XCLDgFwiLFwiJkFhY3V0ZVwiOlwiw4FcIixcIiZBYWN1dGU7XCI6XCLDgVwiLFwiJkFjaXJjXCI6XCLDglwiLFwiJkFjaXJjO1wiOlwiw4JcIixcIiZBdGlsZGVcIjpcIsODXCIsXCImQXRpbGRlO1wiOlwiw4NcIixcIiZBdW1sXCI6XCLDhFwiLFwiJkF1bWw7XCI6XCLDhFwiLFwiJkFyaW5nXCI6XCLDhVwiLFwiJkFyaW5nO1wiOlwiw4VcIixcIiZBRWxpZ1wiOlwiw4ZcIixcIiZBRWxpZztcIjpcIsOGXCIsXCImQ2NlZGlsXCI6XCLDh1wiLFwiJkNjZWRpbDtcIjpcIsOHXCIsXCImRWdyYXZlXCI6XCLDiFwiLFwiJkVncmF2ZTtcIjpcIsOIXCIsXCImRWFjdXRlXCI6XCLDiVwiLFwiJkVhY3V0ZTtcIjpcIsOJXCIsXCImRWNpcmNcIjpcIsOKXCIsXCImRWNpcmM7XCI6XCLDilwiLFwiJkV1bWxcIjpcIsOLXCIsXCImRXVtbDtcIjpcIsOLXCIsXCImSWdyYXZlXCI6XCLDjFwiLFwiJklncmF2ZTtcIjpcIsOMXCIsXCImSWFjdXRlXCI6XCLDjVwiLFwiJklhY3V0ZTtcIjpcIsONXCIsXCImSWNpcmNcIjpcIsOOXCIsXCImSWNpcmM7XCI6XCLDjlwiLFwiJkl1bWxcIjpcIsOPXCIsXCImSXVtbDtcIjpcIsOPXCIsXCImRVRIXCI6XCLDkFwiLFwiJkVUSDtcIjpcIsOQXCIsXCImTnRpbGRlXCI6XCLDkVwiLFwiJk50aWxkZTtcIjpcIsORXCIsXCImT2dyYXZlXCI6XCLDklwiLFwiJk9ncmF2ZTtcIjpcIsOSXCIsXCImT2FjdXRlXCI6XCLDk1wiLFwiJk9hY3V0ZTtcIjpcIsOTXCIsXCImT2NpcmNcIjpcIsOUXCIsXCImT2NpcmM7XCI6XCLDlFwiLFwiJk90aWxkZVwiOlwiw5VcIixcIiZPdGlsZGU7XCI6XCLDlVwiLFwiJk91bWxcIjpcIsOWXCIsXCImT3VtbDtcIjpcIsOWXCIsXCImdGltZXNcIjpcIsOXXCIsXCImdGltZXM7XCI6XCLDl1wiLFwiJk9zbGFzaFwiOlwiw5hcIixcIiZPc2xhc2g7XCI6XCLDmFwiLFwiJlVncmF2ZVwiOlwiw5lcIixcIiZVZ3JhdmU7XCI6XCLDmVwiLFwiJlVhY3V0ZVwiOlwiw5pcIixcIiZVYWN1dGU7XCI6XCLDmlwiLFwiJlVjaXJjXCI6XCLDm1wiLFwiJlVjaXJjO1wiOlwiw5tcIixcIiZVdW1sXCI6XCLDnFwiLFwiJlV1bWw7XCI6XCLDnFwiLFwiJllhY3V0ZVwiOlwiw51cIixcIiZZYWN1dGU7XCI6XCLDnVwiLFwiJlRIT1JOXCI6XCLDnlwiLFwiJlRIT1JOO1wiOlwiw55cIixcIiZzemxpZ1wiOlwiw59cIixcIiZzemxpZztcIjpcIsOfXCIsXCImYWdyYXZlXCI6XCLDoFwiLFwiJmFncmF2ZTtcIjpcIsOgXCIsXCImYWFjdXRlXCI6XCLDoVwiLFwiJmFhY3V0ZTtcIjpcIsOhXCIsXCImYWNpcmNcIjpcIsOiXCIsXCImYWNpcmM7XCI6XCLDolwiLFwiJmF0aWxkZVwiOlwiw6NcIixcIiZhdGlsZGU7XCI6XCLDo1wiLFwiJmF1bWxcIjpcIsOkXCIsXCImYXVtbDtcIjpcIsOkXCIsXCImYXJpbmdcIjpcIsOlXCIsXCImYXJpbmc7XCI6XCLDpVwiLFwiJmFlbGlnXCI6XCLDplwiLFwiJmFlbGlnO1wiOlwiw6ZcIixcIiZjY2VkaWxcIjpcIsOnXCIsXCImY2NlZGlsO1wiOlwiw6dcIixcIiZlZ3JhdmVcIjpcIsOoXCIsXCImZWdyYXZlO1wiOlwiw6hcIixcIiZlYWN1dGVcIjpcIsOpXCIsXCImZWFjdXRlO1wiOlwiw6lcIixcIiZlY2lyY1wiOlwiw6pcIixcIiZlY2lyYztcIjpcIsOqXCIsXCImZXVtbFwiOlwiw6tcIixcIiZldW1sO1wiOlwiw6tcIixcIiZpZ3JhdmVcIjpcIsOsXCIsXCImaWdyYXZlO1wiOlwiw6xcIixcIiZpYWN1dGVcIjpcIsOtXCIsXCImaWFjdXRlO1wiOlwiw61cIixcIiZpY2lyY1wiOlwiw65cIixcIiZpY2lyYztcIjpcIsOuXCIsXCImaXVtbFwiOlwiw69cIixcIiZpdW1sO1wiOlwiw69cIixcIiZldGhcIjpcIsOwXCIsXCImZXRoO1wiOlwiw7BcIixcIiZudGlsZGVcIjpcIsOxXCIsXCImbnRpbGRlO1wiOlwiw7FcIixcIiZvZ3JhdmVcIjpcIsOyXCIsXCImb2dyYXZlO1wiOlwiw7JcIixcIiZvYWN1dGVcIjpcIsOzXCIsXCImb2FjdXRlO1wiOlwiw7NcIixcIiZvY2lyY1wiOlwiw7RcIixcIiZvY2lyYztcIjpcIsO0XCIsXCImb3RpbGRlXCI6XCLDtVwiLFwiJm90aWxkZTtcIjpcIsO1XCIsXCImb3VtbFwiOlwiw7ZcIixcIiZvdW1sO1wiOlwiw7ZcIixcIiZkaXZpZGVcIjpcIsO3XCIsXCImZGl2aWRlO1wiOlwiw7dcIixcIiZvc2xhc2hcIjpcIsO4XCIsXCImb3NsYXNoO1wiOlwiw7hcIixcIiZ1Z3JhdmVcIjpcIsO5XCIsXCImdWdyYXZlO1wiOlwiw7lcIixcIiZ1YWN1dGVcIjpcIsO6XCIsXCImdWFjdXRlO1wiOlwiw7pcIixcIiZ1Y2lyY1wiOlwiw7tcIixcIiZ1Y2lyYztcIjpcIsO7XCIsXCImdXVtbFwiOlwiw7xcIixcIiZ1dW1sO1wiOlwiw7xcIixcIiZ5YWN1dGVcIjpcIsO9XCIsXCImeWFjdXRlO1wiOlwiw71cIixcIiZ0aG9yblwiOlwiw75cIixcIiZ0aG9ybjtcIjpcIsO+XCIsXCImeXVtbFwiOlwiw79cIixcIiZ5dW1sO1wiOlwiw79cIixcIiZxdW90XCI6J1wiJyxcIiZxdW90O1wiOidcIicsXCImYW1wXCI6XCImXCIsXCImYW1wO1wiOlwiJlwiLFwiJmx0XCI6XCI8XCIsXCImbHQ7XCI6XCI8XCIsXCImZ3RcIjpcIj5cIixcIiZndDtcIjpcIj5cIixcIiZPRWxpZztcIjpcIsWSXCIsXCImb2VsaWc7XCI6XCLFk1wiLFwiJlNjYXJvbjtcIjpcIsWgXCIsXCImc2Nhcm9uO1wiOlwixaFcIixcIiZZdW1sO1wiOlwixbhcIixcIiZjaXJjO1wiOlwiy4ZcIixcIiZ0aWxkZTtcIjpcIsucXCIsXCImZW5zcDtcIjpcIuKAglwiLFwiJmVtc3A7XCI6XCLigINcIixcIiZ0aGluc3A7XCI6XCLigIlcIixcIiZ6d25qO1wiOlwi4oCMXCIsXCImendqO1wiOlwi4oCNXCIsXCImbHJtO1wiOlwi4oCOXCIsXCImcmxtO1wiOlwi4oCPXCIsXCImbmRhc2g7XCI6XCLigJNcIixcIiZtZGFzaDtcIjpcIuKAlFwiLFwiJmxzcXVvO1wiOlwi4oCYXCIsXCImcnNxdW87XCI6XCLigJlcIixcIiZzYnF1bztcIjpcIuKAmlwiLFwiJmxkcXVvO1wiOlwi4oCcXCIsXCImcmRxdW87XCI6XCLigJ1cIixcIiZiZHF1bztcIjpcIuKAnlwiLFwiJmRhZ2dlcjtcIjpcIuKAoFwiLFwiJkRhZ2dlcjtcIjpcIuKAoVwiLFwiJnBlcm1pbDtcIjpcIuKAsFwiLFwiJmxzYXF1bztcIjpcIuKAuVwiLFwiJnJzYXF1bztcIjpcIuKAulwiLFwiJmV1cm87XCI6XCLigqxcIixcIiZmbm9mO1wiOlwixpJcIixcIiZBbHBoYTtcIjpcIs6RXCIsXCImQmV0YTtcIjpcIs6SXCIsXCImR2FtbWE7XCI6XCLOk1wiLFwiJkRlbHRhO1wiOlwizpRcIixcIiZFcHNpbG9uO1wiOlwizpVcIixcIiZaZXRhO1wiOlwizpZcIixcIiZFdGE7XCI6XCLOl1wiLFwiJlRoZXRhO1wiOlwizphcIixcIiZJb3RhO1wiOlwizplcIixcIiZLYXBwYTtcIjpcIs6aXCIsXCImTGFtYmRhO1wiOlwizptcIixcIiZNdTtcIjpcIs6cXCIsXCImTnU7XCI6XCLOnVwiLFwiJlhpO1wiOlwizp5cIixcIiZPbWljcm9uO1wiOlwizp9cIixcIiZQaTtcIjpcIs6gXCIsXCImUmhvO1wiOlwizqFcIixcIiZTaWdtYTtcIjpcIs6jXCIsXCImVGF1O1wiOlwizqRcIixcIiZVcHNpbG9uO1wiOlwizqVcIixcIiZQaGk7XCI6XCLOplwiLFwiJkNoaTtcIjpcIs6nXCIsXCImUHNpO1wiOlwizqhcIixcIiZPbWVnYTtcIjpcIs6pXCIsXCImYWxwaGE7XCI6XCLOsVwiLFwiJmJldGE7XCI6XCLOslwiLFwiJmdhbW1hO1wiOlwizrNcIixcIiZkZWx0YTtcIjpcIs60XCIsXCImZXBzaWxvbjtcIjpcIs61XCIsXCImemV0YTtcIjpcIs62XCIsXCImZXRhO1wiOlwizrdcIixcIiZ0aGV0YTtcIjpcIs64XCIsXCImaW90YTtcIjpcIs65XCIsXCIma2FwcGE7XCI6XCLOulwiLFwiJmxhbWJkYTtcIjpcIs67XCIsXCImbXU7XCI6XCLOvFwiLFwiJm51O1wiOlwizr1cIixcIiZ4aTtcIjpcIs6+XCIsXCImb21pY3JvbjtcIjpcIs6/XCIsXCImcGk7XCI6XCLPgFwiLFwiJnJobztcIjpcIs+BXCIsXCImc2lnbWFmO1wiOlwiz4JcIixcIiZzaWdtYTtcIjpcIs+DXCIsXCImdGF1O1wiOlwiz4RcIixcIiZ1cHNpbG9uO1wiOlwiz4VcIixcIiZwaGk7XCI6XCLPhlwiLFwiJmNoaTtcIjpcIs+HXCIsXCImcHNpO1wiOlwiz4hcIixcIiZvbWVnYTtcIjpcIs+JXCIsXCImdGhldGFzeW07XCI6XCLPkVwiLFwiJnVwc2loO1wiOlwiz5JcIixcIiZwaXY7XCI6XCLPllwiLFwiJmJ1bGw7XCI6XCLigKJcIixcIiZoZWxsaXA7XCI6XCLigKZcIixcIiZwcmltZTtcIjpcIuKAslwiLFwiJlByaW1lO1wiOlwi4oCzXCIsXCImb2xpbmU7XCI6XCLigL5cIixcIiZmcmFzbDtcIjpcIuKBhFwiLFwiJndlaWVycDtcIjpcIuKEmFwiLFwiJmltYWdlO1wiOlwi4oSRXCIsXCImcmVhbDtcIjpcIuKEnFwiLFwiJnRyYWRlO1wiOlwi4oSiXCIsXCImYWxlZnN5bTtcIjpcIuKEtVwiLFwiJmxhcnI7XCI6XCLihpBcIixcIiZ1YXJyO1wiOlwi4oaRXCIsXCImcmFycjtcIjpcIuKGklwiLFwiJmRhcnI7XCI6XCLihpNcIixcIiZoYXJyO1wiOlwi4oaUXCIsXCImY3JhcnI7XCI6XCLihrVcIixcIiZsQXJyO1wiOlwi4oeQXCIsXCImdUFycjtcIjpcIuKHkVwiLFwiJnJBcnI7XCI6XCLih5JcIixcIiZkQXJyO1wiOlwi4oeTXCIsXCImaEFycjtcIjpcIuKHlFwiLFwiJmZvcmFsbDtcIjpcIuKIgFwiLFwiJnBhcnQ7XCI6XCLiiIJcIixcIiZleGlzdDtcIjpcIuKIg1wiLFwiJmVtcHR5O1wiOlwi4oiFXCIsXCImbmFibGE7XCI6XCLiiIdcIixcIiZpc2luO1wiOlwi4oiIXCIsXCImbm90aW47XCI6XCLiiIlcIixcIiZuaTtcIjpcIuKIi1wiLFwiJnByb2Q7XCI6XCLiiI9cIixcIiZzdW07XCI6XCLiiJFcIixcIiZtaW51cztcIjpcIuKIklwiLFwiJmxvd2FzdDtcIjpcIuKIl1wiLFwiJnJhZGljO1wiOlwi4oiaXCIsXCImcHJvcDtcIjpcIuKInVwiLFwiJmluZmluO1wiOlwi4oieXCIsXCImYW5nO1wiOlwi4oigXCIsXCImYW5kO1wiOlwi4oinXCIsXCImb3I7XCI6XCLiiKhcIixcIiZjYXA7XCI6XCLiiKlcIixcIiZjdXA7XCI6XCLiiKpcIixcIiZpbnQ7XCI6XCLiiKtcIixcIiZ0aGVyZTQ7XCI6XCLiiLRcIixcIiZzaW07XCI6XCLiiLxcIixcIiZjb25nO1wiOlwi4omFXCIsXCImYXN5bXA7XCI6XCLiiYhcIixcIiZuZTtcIjpcIuKJoFwiLFwiJmVxdWl2O1wiOlwi4omhXCIsXCImbGU7XCI6XCLiiaRcIixcIiZnZTtcIjpcIuKJpVwiLFwiJnN1YjtcIjpcIuKKglwiLFwiJnN1cDtcIjpcIuKKg1wiLFwiJm5zdWI7XCI6XCLiioRcIixcIiZzdWJlO1wiOlwi4oqGXCIsXCImc3VwZTtcIjpcIuKKh1wiLFwiJm9wbHVzO1wiOlwi4oqVXCIsXCImb3RpbWVzO1wiOlwi4oqXXCIsXCImcGVycDtcIjpcIuKKpVwiLFwiJnNkb3Q7XCI6XCLii4VcIixcIiZsY2VpbDtcIjpcIuKMiFwiLFwiJnJjZWlsO1wiOlwi4oyJXCIsXCImbGZsb29yO1wiOlwi4oyKXCIsXCImcmZsb29yO1wiOlwi4oyLXCIsXCImbGFuZztcIjpcIuKMqVwiLFwiJnJhbmc7XCI6XCLijKpcIixcIiZsb3o7XCI6XCLil4pcIixcIiZzcGFkZXM7XCI6XCLimaBcIixcIiZjbHVicztcIjpcIuKZo1wiLFwiJmhlYXJ0cztcIjpcIuKZpVwiLFwiJmRpYW1zO1wiOlwi4pmmXCJ9LGNoYXJhY3RlcnM6e1wiJ1wiOlwiJmFwb3M7XCIsXCLCoFwiOlwiJm5ic3A7XCIsXCLCoVwiOlwiJmlleGNsO1wiLFwiwqJcIjpcIiZjZW50O1wiLFwiwqNcIjpcIiZwb3VuZDtcIixcIsKkXCI6XCImY3VycmVuO1wiLFwiwqVcIjpcIiZ5ZW47XCIsXCLCplwiOlwiJmJydmJhcjtcIixcIsKnXCI6XCImc2VjdDtcIixcIsKoXCI6XCImdW1sO1wiLFwiwqlcIjpcIiZjb3B5O1wiLFwiwqpcIjpcIiZvcmRmO1wiLFwiwqtcIjpcIiZsYXF1bztcIixcIsKsXCI6XCImbm90O1wiLFwiwq1cIjpcIiZzaHk7XCIsXCLCrlwiOlwiJnJlZztcIixcIsKvXCI6XCImbWFjcjtcIixcIsKwXCI6XCImZGVnO1wiLFwiwrFcIjpcIiZwbHVzbW47XCIsXCLCslwiOlwiJnN1cDI7XCIsXCLCs1wiOlwiJnN1cDM7XCIsXCLCtFwiOlwiJmFjdXRlO1wiLFwiwrVcIjpcIiZtaWNybztcIixcIsK2XCI6XCImcGFyYTtcIixcIsK3XCI6XCImbWlkZG90O1wiLFwiwrhcIjpcIiZjZWRpbDtcIixcIsK5XCI6XCImc3VwMTtcIixcIsK6XCI6XCImb3JkbTtcIixcIsK7XCI6XCImcmFxdW87XCIsXCLCvFwiOlwiJmZyYWMxNDtcIixcIsK9XCI6XCImZnJhYzEyO1wiLFwiwr5cIjpcIiZmcmFjMzQ7XCIsXCLCv1wiOlwiJmlxdWVzdDtcIixcIsOAXCI6XCImQWdyYXZlO1wiLFwiw4FcIjpcIiZBYWN1dGU7XCIsXCLDglwiOlwiJkFjaXJjO1wiLFwiw4NcIjpcIiZBdGlsZGU7XCIsXCLDhFwiOlwiJkF1bWw7XCIsXCLDhVwiOlwiJkFyaW5nO1wiLFwiw4ZcIjpcIiZBRWxpZztcIixcIsOHXCI6XCImQ2NlZGlsO1wiLFwiw4hcIjpcIiZFZ3JhdmU7XCIsXCLDiVwiOlwiJkVhY3V0ZTtcIixcIsOKXCI6XCImRWNpcmM7XCIsXCLDi1wiOlwiJkV1bWw7XCIsXCLDjFwiOlwiJklncmF2ZTtcIixcIsONXCI6XCImSWFjdXRlO1wiLFwiw45cIjpcIiZJY2lyYztcIixcIsOPXCI6XCImSXVtbDtcIixcIsOQXCI6XCImRVRIO1wiLFwiw5FcIjpcIiZOdGlsZGU7XCIsXCLDklwiOlwiJk9ncmF2ZTtcIixcIsOTXCI6XCImT2FjdXRlO1wiLFwiw5RcIjpcIiZPY2lyYztcIixcIsOVXCI6XCImT3RpbGRlO1wiLFwiw5ZcIjpcIiZPdW1sO1wiLFwiw5dcIjpcIiZ0aW1lcztcIixcIsOYXCI6XCImT3NsYXNoO1wiLFwiw5lcIjpcIiZVZ3JhdmU7XCIsXCLDmlwiOlwiJlVhY3V0ZTtcIixcIsObXCI6XCImVWNpcmM7XCIsXCLDnFwiOlwiJlV1bWw7XCIsXCLDnVwiOlwiJllhY3V0ZTtcIixcIsOeXCI6XCImVEhPUk47XCIsXCLDn1wiOlwiJnN6bGlnO1wiLFwiw6BcIjpcIiZhZ3JhdmU7XCIsXCLDoVwiOlwiJmFhY3V0ZTtcIixcIsOiXCI6XCImYWNpcmM7XCIsXCLDo1wiOlwiJmF0aWxkZTtcIixcIsOkXCI6XCImYXVtbDtcIixcIsOlXCI6XCImYXJpbmc7XCIsXCLDplwiOlwiJmFlbGlnO1wiLFwiw6dcIjpcIiZjY2VkaWw7XCIsXCLDqFwiOlwiJmVncmF2ZTtcIixcIsOpXCI6XCImZWFjdXRlO1wiLFwiw6pcIjpcIiZlY2lyYztcIixcIsOrXCI6XCImZXVtbDtcIixcIsOsXCI6XCImaWdyYXZlO1wiLFwiw61cIjpcIiZpYWN1dGU7XCIsXCLDrlwiOlwiJmljaXJjO1wiLFwiw69cIjpcIiZpdW1sO1wiLFwiw7BcIjpcIiZldGg7XCIsXCLDsVwiOlwiJm50aWxkZTtcIixcIsOyXCI6XCImb2dyYXZlO1wiLFwiw7NcIjpcIiZvYWN1dGU7XCIsXCLDtFwiOlwiJm9jaXJjO1wiLFwiw7VcIjpcIiZvdGlsZGU7XCIsXCLDtlwiOlwiJm91bWw7XCIsXCLDt1wiOlwiJmRpdmlkZTtcIixcIsO4XCI6XCImb3NsYXNoO1wiLFwiw7lcIjpcIiZ1Z3JhdmU7XCIsXCLDulwiOlwiJnVhY3V0ZTtcIixcIsO7XCI6XCImdWNpcmM7XCIsXCLDvFwiOlwiJnV1bWw7XCIsXCLDvVwiOlwiJnlhY3V0ZTtcIixcIsO+XCI6XCImdGhvcm47XCIsXCLDv1wiOlwiJnl1bWw7XCIsJ1wiJzpcIiZxdW90O1wiLFwiJlwiOlwiJmFtcDtcIixcIjxcIjpcIiZsdDtcIixcIj5cIjpcIiZndDtcIixcIsWSXCI6XCImT0VsaWc7XCIsXCLFk1wiOlwiJm9lbGlnO1wiLFwixaBcIjpcIiZTY2Fyb247XCIsXCLFoVwiOlwiJnNjYXJvbjtcIixcIsW4XCI6XCImWXVtbDtcIixcIsuGXCI6XCImY2lyYztcIixcIsucXCI6XCImdGlsZGU7XCIsXCLigIJcIjpcIiZlbnNwO1wiLFwi4oCDXCI6XCImZW1zcDtcIixcIuKAiVwiOlwiJnRoaW5zcDtcIixcIuKAjFwiOlwiJnp3bmo7XCIsXCLigI1cIjpcIiZ6d2o7XCIsXCLigI5cIjpcIiZscm07XCIsXCLigI9cIjpcIiZybG07XCIsXCLigJNcIjpcIiZuZGFzaDtcIixcIuKAlFwiOlwiJm1kYXNoO1wiLFwi4oCYXCI6XCImbHNxdW87XCIsXCLigJlcIjpcIiZyc3F1bztcIixcIuKAmlwiOlwiJnNicXVvO1wiLFwi4oCcXCI6XCImbGRxdW87XCIsXCLigJ1cIjpcIiZyZHF1bztcIixcIuKAnlwiOlwiJmJkcXVvO1wiLFwi4oCgXCI6XCImZGFnZ2VyO1wiLFwi4oChXCI6XCImRGFnZ2VyO1wiLFwi4oCwXCI6XCImcGVybWlsO1wiLFwi4oC5XCI6XCImbHNhcXVvO1wiLFwi4oC6XCI6XCImcnNhcXVvO1wiLFwi4oKsXCI6XCImZXVybztcIixcIsaSXCI6XCImZm5vZjtcIixcIs6RXCI6XCImQWxwaGE7XCIsXCLOklwiOlwiJkJldGE7XCIsXCLOk1wiOlwiJkdhbW1hO1wiLFwizpRcIjpcIiZEZWx0YTtcIixcIs6VXCI6XCImRXBzaWxvbjtcIixcIs6WXCI6XCImWmV0YTtcIixcIs6XXCI6XCImRXRhO1wiLFwizphcIjpcIiZUaGV0YTtcIixcIs6ZXCI6XCImSW90YTtcIixcIs6aXCI6XCImS2FwcGE7XCIsXCLOm1wiOlwiJkxhbWJkYTtcIixcIs6cXCI6XCImTXU7XCIsXCLOnVwiOlwiJk51O1wiLFwizp5cIjpcIiZYaTtcIixcIs6fXCI6XCImT21pY3JvbjtcIixcIs6gXCI6XCImUGk7XCIsXCLOoVwiOlwiJlJobztcIixcIs6jXCI6XCImU2lnbWE7XCIsXCLOpFwiOlwiJlRhdTtcIixcIs6lXCI6XCImVXBzaWxvbjtcIixcIs6mXCI6XCImUGhpO1wiLFwizqdcIjpcIiZDaGk7XCIsXCLOqFwiOlwiJlBzaTtcIixcIs6pXCI6XCImT21lZ2E7XCIsXCLOsVwiOlwiJmFscGhhO1wiLFwizrJcIjpcIiZiZXRhO1wiLFwizrNcIjpcIiZnYW1tYTtcIixcIs60XCI6XCImZGVsdGE7XCIsXCLOtVwiOlwiJmVwc2lsb247XCIsXCLOtlwiOlwiJnpldGE7XCIsXCLOt1wiOlwiJmV0YTtcIixcIs64XCI6XCImdGhldGE7XCIsXCLOuVwiOlwiJmlvdGE7XCIsXCLOulwiOlwiJmthcHBhO1wiLFwizrtcIjpcIiZsYW1iZGE7XCIsXCLOvFwiOlwiJm11O1wiLFwizr1cIjpcIiZudTtcIixcIs6+XCI6XCImeGk7XCIsXCLOv1wiOlwiJm9taWNyb247XCIsXCLPgFwiOlwiJnBpO1wiLFwiz4FcIjpcIiZyaG87XCIsXCLPglwiOlwiJnNpZ21hZjtcIixcIs+DXCI6XCImc2lnbWE7XCIsXCLPhFwiOlwiJnRhdTtcIixcIs+FXCI6XCImdXBzaWxvbjtcIixcIs+GXCI6XCImcGhpO1wiLFwiz4dcIjpcIiZjaGk7XCIsXCLPiFwiOlwiJnBzaTtcIixcIs+JXCI6XCImb21lZ2E7XCIsXCLPkVwiOlwiJnRoZXRhc3ltO1wiLFwiz5JcIjpcIiZ1cHNpaDtcIixcIs+WXCI6XCImcGl2O1wiLFwi4oCiXCI6XCImYnVsbDtcIixcIuKAplwiOlwiJmhlbGxpcDtcIixcIuKAslwiOlwiJnByaW1lO1wiLFwi4oCzXCI6XCImUHJpbWU7XCIsXCLigL5cIjpcIiZvbGluZTtcIixcIuKBhFwiOlwiJmZyYXNsO1wiLFwi4oSYXCI6XCImd2VpZXJwO1wiLFwi4oSRXCI6XCImaW1hZ2U7XCIsXCLihJxcIjpcIiZyZWFsO1wiLFwi4oSiXCI6XCImdHJhZGU7XCIsXCLihLVcIjpcIiZhbGVmc3ltO1wiLFwi4oaQXCI6XCImbGFycjtcIixcIuKGkVwiOlwiJnVhcnI7XCIsXCLihpJcIjpcIiZyYXJyO1wiLFwi4oaTXCI6XCImZGFycjtcIixcIuKGlFwiOlwiJmhhcnI7XCIsXCLihrVcIjpcIiZjcmFycjtcIixcIuKHkFwiOlwiJmxBcnI7XCIsXCLih5FcIjpcIiZ1QXJyO1wiLFwi4oeSXCI6XCImckFycjtcIixcIuKHk1wiOlwiJmRBcnI7XCIsXCLih5RcIjpcIiZoQXJyO1wiLFwi4oiAXCI6XCImZm9yYWxsO1wiLFwi4oiCXCI6XCImcGFydDtcIixcIuKIg1wiOlwiJmV4aXN0O1wiLFwi4oiFXCI6XCImZW1wdHk7XCIsXCLiiIdcIjpcIiZuYWJsYTtcIixcIuKIiFwiOlwiJmlzaW47XCIsXCLiiIlcIjpcIiZub3RpbjtcIixcIuKIi1wiOlwiJm5pO1wiLFwi4oiPXCI6XCImcHJvZDtcIixcIuKIkVwiOlwiJnN1bTtcIixcIuKIklwiOlwiJm1pbnVzO1wiLFwi4oiXXCI6XCImbG93YXN0O1wiLFwi4oiaXCI6XCImcmFkaWM7XCIsXCLiiJ1cIjpcIiZwcm9wO1wiLFwi4oieXCI6XCImaW5maW47XCIsXCLiiKBcIjpcIiZhbmc7XCIsXCLiiKdcIjpcIiZhbmQ7XCIsXCLiiKhcIjpcIiZvcjtcIixcIuKIqVwiOlwiJmNhcDtcIixcIuKIqlwiOlwiJmN1cDtcIixcIuKIq1wiOlwiJmludDtcIixcIuKItFwiOlwiJnRoZXJlNDtcIixcIuKIvFwiOlwiJnNpbTtcIixcIuKJhVwiOlwiJmNvbmc7XCIsXCLiiYhcIjpcIiZhc3ltcDtcIixcIuKJoFwiOlwiJm5lO1wiLFwi4omhXCI6XCImZXF1aXY7XCIsXCLiiaRcIjpcIiZsZTtcIixcIuKJpVwiOlwiJmdlO1wiLFwi4oqCXCI6XCImc3ViO1wiLFwi4oqDXCI6XCImc3VwO1wiLFwi4oqEXCI6XCImbnN1YjtcIixcIuKKhlwiOlwiJnN1YmU7XCIsXCLiiodcIjpcIiZzdXBlO1wiLFwi4oqVXCI6XCImb3BsdXM7XCIsXCLiipdcIjpcIiZvdGltZXM7XCIsXCLiiqVcIjpcIiZwZXJwO1wiLFwi4ouFXCI6XCImc2RvdDtcIixcIuKMiFwiOlwiJmxjZWlsO1wiLFwi4oyJXCI6XCImcmNlaWw7XCIsXCLijIpcIjpcIiZsZmxvb3I7XCIsXCLijItcIjpcIiZyZmxvb3I7XCIsXCLijKlcIjpcIiZsYW5nO1wiLFwi4oyqXCI6XCImcmFuZztcIixcIuKXilwiOlwiJmxvejtcIixcIuKZoFwiOlwiJnNwYWRlcztcIixcIuKZo1wiOlwiJmNsdWJzO1wiLFwi4pmlXCI6XCImaGVhcnRzO1wiLFwi4pmmXCI6XCImZGlhbXM7XCJ9fSxodG1sNTp7ZW50aXRpZXM6e1wiJkFFbGlnXCI6XCLDhlwiLFwiJkFFbGlnO1wiOlwiw4ZcIixcIiZBTVBcIjpcIiZcIixcIiZBTVA7XCI6XCImXCIsXCImQWFjdXRlXCI6XCLDgVwiLFwiJkFhY3V0ZTtcIjpcIsOBXCIsXCImQWJyZXZlO1wiOlwixIJcIixcIiZBY2lyY1wiOlwiw4JcIixcIiZBY2lyYztcIjpcIsOCXCIsXCImQWN5O1wiOlwi0JBcIixcIiZBZnI7XCI6XCLwnZSEXCIsXCImQWdyYXZlXCI6XCLDgFwiLFwiJkFncmF2ZTtcIjpcIsOAXCIsXCImQWxwaGE7XCI6XCLOkVwiLFwiJkFtYWNyO1wiOlwixIBcIixcIiZBbmQ7XCI6XCLiqZNcIixcIiZBb2dvbjtcIjpcIsSEXCIsXCImQW9wZjtcIjpcIvCdlLhcIixcIiZBcHBseUZ1bmN0aW9uO1wiOlwi4oGhXCIsXCImQXJpbmdcIjpcIsOFXCIsXCImQXJpbmc7XCI6XCLDhVwiLFwiJkFzY3I7XCI6XCLwnZKcXCIsXCImQXNzaWduO1wiOlwi4omUXCIsXCImQXRpbGRlXCI6XCLDg1wiLFwiJkF0aWxkZTtcIjpcIsODXCIsXCImQXVtbFwiOlwiw4RcIixcIiZBdW1sO1wiOlwiw4RcIixcIiZCYWNrc2xhc2g7XCI6XCLiiJZcIixcIiZCYXJ2O1wiOlwi4qunXCIsXCImQmFyd2VkO1wiOlwi4oyGXCIsXCImQmN5O1wiOlwi0JFcIixcIiZCZWNhdXNlO1wiOlwi4oi1XCIsXCImQmVybm91bGxpcztcIjpcIuKErFwiLFwiJkJldGE7XCI6XCLOklwiLFwiJkJmcjtcIjpcIvCdlIVcIixcIiZCb3BmO1wiOlwi8J2UuVwiLFwiJkJyZXZlO1wiOlwiy5hcIixcIiZCc2NyO1wiOlwi4oSsXCIsXCImQnVtcGVxO1wiOlwi4omOXCIsXCImQ0hjeTtcIjpcItCnXCIsXCImQ09QWVwiOlwiwqlcIixcIiZDT1BZO1wiOlwiwqlcIixcIiZDYWN1dGU7XCI6XCLEhlwiLFwiJkNhcDtcIjpcIuKLklwiLFwiJkNhcGl0YWxEaWZmZXJlbnRpYWxEO1wiOlwi4oWFXCIsXCImQ2F5bGV5cztcIjpcIuKErVwiLFwiJkNjYXJvbjtcIjpcIsSMXCIsXCImQ2NlZGlsXCI6XCLDh1wiLFwiJkNjZWRpbDtcIjpcIsOHXCIsXCImQ2NpcmM7XCI6XCLEiFwiLFwiJkNjb25pbnQ7XCI6XCLiiLBcIixcIiZDZG90O1wiOlwixIpcIixcIiZDZWRpbGxhO1wiOlwiwrhcIixcIiZDZW50ZXJEb3Q7XCI6XCLCt1wiLFwiJkNmcjtcIjpcIuKErVwiLFwiJkNoaTtcIjpcIs6nXCIsXCImQ2lyY2xlRG90O1wiOlwi4oqZXCIsXCImQ2lyY2xlTWludXM7XCI6XCLiipZcIixcIiZDaXJjbGVQbHVzO1wiOlwi4oqVXCIsXCImQ2lyY2xlVGltZXM7XCI6XCLiipdcIixcIiZDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCI6XCLiiLJcIixcIiZDbG9zZUN1cmx5RG91YmxlUXVvdGU7XCI6XCLigJ1cIixcIiZDbG9zZUN1cmx5UXVvdGU7XCI6XCLigJlcIixcIiZDb2xvbjtcIjpcIuKIt1wiLFwiJkNvbG9uZTtcIjpcIuKptFwiLFwiJkNvbmdydWVudDtcIjpcIuKJoVwiLFwiJkNvbmludDtcIjpcIuKIr1wiLFwiJkNvbnRvdXJJbnRlZ3JhbDtcIjpcIuKIrlwiLFwiJkNvcGY7XCI6XCLihIJcIixcIiZDb3Byb2R1Y3Q7XCI6XCLiiJBcIixcIiZDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsO1wiOlwi4oizXCIsXCImQ3Jvc3M7XCI6XCLiqK9cIixcIiZDc2NyO1wiOlwi8J2SnlwiLFwiJkN1cDtcIjpcIuKLk1wiLFwiJkN1cENhcDtcIjpcIuKJjVwiLFwiJkREO1wiOlwi4oWFXCIsXCImRERvdHJhaGQ7XCI6XCLipJFcIixcIiZESmN5O1wiOlwi0IJcIixcIiZEU2N5O1wiOlwi0IVcIixcIiZEWmN5O1wiOlwi0I9cIixcIiZEYWdnZXI7XCI6XCLigKFcIixcIiZEYXJyO1wiOlwi4oahXCIsXCImRGFzaHY7XCI6XCLiq6RcIixcIiZEY2Fyb247XCI6XCLEjlwiLFwiJkRjeTtcIjpcItCUXCIsXCImRGVsO1wiOlwi4oiHXCIsXCImRGVsdGE7XCI6XCLOlFwiLFwiJkRmcjtcIjpcIvCdlIdcIixcIiZEaWFjcml0aWNhbEFjdXRlO1wiOlwiwrRcIixcIiZEaWFjcml0aWNhbERvdDtcIjpcIsuZXCIsXCImRGlhY3JpdGljYWxEb3VibGVBY3V0ZTtcIjpcIsudXCIsXCImRGlhY3JpdGljYWxHcmF2ZTtcIjpcImBcIixcIiZEaWFjcml0aWNhbFRpbGRlO1wiOlwiy5xcIixcIiZEaWFtb25kO1wiOlwi4ouEXCIsXCImRGlmZmVyZW50aWFsRDtcIjpcIuKFhlwiLFwiJkRvcGY7XCI6XCLwnZS7XCIsXCImRG90O1wiOlwiwqhcIixcIiZEb3REb3Q7XCI6XCLig5xcIixcIiZEb3RFcXVhbDtcIjpcIuKJkFwiLFwiJkRvdWJsZUNvbnRvdXJJbnRlZ3JhbDtcIjpcIuKIr1wiLFwiJkRvdWJsZURvdDtcIjpcIsKoXCIsXCImRG91YmxlRG93bkFycm93O1wiOlwi4oeTXCIsXCImRG91YmxlTGVmdEFycm93O1wiOlwi4oeQXCIsXCImRG91YmxlTGVmdFJpZ2h0QXJyb3c7XCI6XCLih5RcIixcIiZEb3VibGVMZWZ0VGVlO1wiOlwi4qukXCIsXCImRG91YmxlTG9uZ0xlZnRBcnJvdztcIjpcIuKfuFwiLFwiJkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdztcIjpcIuKfulwiLFwiJkRvdWJsZUxvbmdSaWdodEFycm93O1wiOlwi4p+5XCIsXCImRG91YmxlUmlnaHRBcnJvdztcIjpcIuKHklwiLFwiJkRvdWJsZVJpZ2h0VGVlO1wiOlwi4oqoXCIsXCImRG91YmxlVXBBcnJvdztcIjpcIuKHkVwiLFwiJkRvdWJsZVVwRG93bkFycm93O1wiOlwi4oeVXCIsXCImRG91YmxlVmVydGljYWxCYXI7XCI6XCLiiKVcIixcIiZEb3duQXJyb3c7XCI6XCLihpNcIixcIiZEb3duQXJyb3dCYXI7XCI6XCLipJNcIixcIiZEb3duQXJyb3dVcEFycm93O1wiOlwi4oe1XCIsXCImRG93bkJyZXZlO1wiOlwizJFcIixcIiZEb3duTGVmdFJpZ2h0VmVjdG9yO1wiOlwi4qWQXCIsXCImRG93bkxlZnRUZWVWZWN0b3I7XCI6XCLipZ5cIixcIiZEb3duTGVmdFZlY3RvcjtcIjpcIuKGvVwiLFwiJkRvd25MZWZ0VmVjdG9yQmFyO1wiOlwi4qWWXCIsXCImRG93blJpZ2h0VGVlVmVjdG9yO1wiOlwi4qWfXCIsXCImRG93blJpZ2h0VmVjdG9yO1wiOlwi4oeBXCIsXCImRG93blJpZ2h0VmVjdG9yQmFyO1wiOlwi4qWXXCIsXCImRG93blRlZTtcIjpcIuKKpFwiLFwiJkRvd25UZWVBcnJvdztcIjpcIuKGp1wiLFwiJkRvd25hcnJvdztcIjpcIuKHk1wiLFwiJkRzY3I7XCI6XCLwnZKfXCIsXCImRHN0cm9rO1wiOlwixJBcIixcIiZFTkc7XCI6XCLFilwiLFwiJkVUSFwiOlwiw5BcIixcIiZFVEg7XCI6XCLDkFwiLFwiJkVhY3V0ZVwiOlwiw4lcIixcIiZFYWN1dGU7XCI6XCLDiVwiLFwiJkVjYXJvbjtcIjpcIsSaXCIsXCImRWNpcmNcIjpcIsOKXCIsXCImRWNpcmM7XCI6XCLDilwiLFwiJkVjeTtcIjpcItCtXCIsXCImRWRvdDtcIjpcIsSWXCIsXCImRWZyO1wiOlwi8J2UiFwiLFwiJkVncmF2ZVwiOlwiw4hcIixcIiZFZ3JhdmU7XCI6XCLDiFwiLFwiJkVsZW1lbnQ7XCI6XCLiiIhcIixcIiZFbWFjcjtcIjpcIsSSXCIsXCImRW1wdHlTbWFsbFNxdWFyZTtcIjpcIuKXu1wiLFwiJkVtcHR5VmVyeVNtYWxsU3F1YXJlO1wiOlwi4parXCIsXCImRW9nb247XCI6XCLEmFwiLFwiJkVvcGY7XCI6XCLwnZS8XCIsXCImRXBzaWxvbjtcIjpcIs6VXCIsXCImRXF1YWw7XCI6XCLiqbVcIixcIiZFcXVhbFRpbGRlO1wiOlwi4omCXCIsXCImRXF1aWxpYnJpdW07XCI6XCLih4xcIixcIiZFc2NyO1wiOlwi4oSwXCIsXCImRXNpbTtcIjpcIuKps1wiLFwiJkV0YTtcIjpcIs6XXCIsXCImRXVtbFwiOlwiw4tcIixcIiZFdW1sO1wiOlwiw4tcIixcIiZFeGlzdHM7XCI6XCLiiINcIixcIiZFeHBvbmVudGlhbEU7XCI6XCLihYdcIixcIiZGY3k7XCI6XCLQpFwiLFwiJkZmcjtcIjpcIvCdlIlcIixcIiZGaWxsZWRTbWFsbFNxdWFyZTtcIjpcIuKXvFwiLFwiJkZpbGxlZFZlcnlTbWFsbFNxdWFyZTtcIjpcIuKWqlwiLFwiJkZvcGY7XCI6XCLwnZS9XCIsXCImRm9yQWxsO1wiOlwi4oiAXCIsXCImRm91cmllcnRyZjtcIjpcIuKEsVwiLFwiJkZzY3I7XCI6XCLihLFcIixcIiZHSmN5O1wiOlwi0INcIixcIiZHVFwiOlwiPlwiLFwiJkdUO1wiOlwiPlwiLFwiJkdhbW1hO1wiOlwizpNcIixcIiZHYW1tYWQ7XCI6XCLPnFwiLFwiJkdicmV2ZTtcIjpcIsSeXCIsXCImR2NlZGlsO1wiOlwixKJcIixcIiZHY2lyYztcIjpcIsScXCIsXCImR2N5O1wiOlwi0JNcIixcIiZHZG90O1wiOlwixKBcIixcIiZHZnI7XCI6XCLwnZSKXCIsXCImR2c7XCI6XCLii5lcIixcIiZHb3BmO1wiOlwi8J2UvlwiLFwiJkdyZWF0ZXJFcXVhbDtcIjpcIuKJpVwiLFwiJkdyZWF0ZXJFcXVhbExlc3M7XCI6XCLii5tcIixcIiZHcmVhdGVyRnVsbEVxdWFsO1wiOlwi4omnXCIsXCImR3JlYXRlckdyZWF0ZXI7XCI6XCLiqqJcIixcIiZHcmVhdGVyTGVzcztcIjpcIuKJt1wiLFwiJkdyZWF0ZXJTbGFudEVxdWFsO1wiOlwi4qm+XCIsXCImR3JlYXRlclRpbGRlO1wiOlwi4omzXCIsXCImR3NjcjtcIjpcIvCdkqJcIixcIiZHdDtcIjpcIuKJq1wiLFwiJkhBUkRjeTtcIjpcItCqXCIsXCImSGFjZWs7XCI6XCLLh1wiLFwiJkhhdDtcIjpcIl5cIixcIiZIY2lyYztcIjpcIsSkXCIsXCImSGZyO1wiOlwi4oSMXCIsXCImSGlsYmVydFNwYWNlO1wiOlwi4oSLXCIsXCImSG9wZjtcIjpcIuKEjVwiLFwiJkhvcml6b250YWxMaW5lO1wiOlwi4pSAXCIsXCImSHNjcjtcIjpcIuKEi1wiLFwiJkhzdHJvaztcIjpcIsSmXCIsXCImSHVtcERvd25IdW1wO1wiOlwi4omOXCIsXCImSHVtcEVxdWFsO1wiOlwi4omPXCIsXCImSUVjeTtcIjpcItCVXCIsXCImSUpsaWc7XCI6XCLEslwiLFwiJklPY3k7XCI6XCLQgVwiLFwiJklhY3V0ZVwiOlwiw41cIixcIiZJYWN1dGU7XCI6XCLDjVwiLFwiJkljaXJjXCI6XCLDjlwiLFwiJkljaXJjO1wiOlwiw45cIixcIiZJY3k7XCI6XCLQmFwiLFwiJklkb3Q7XCI6XCLEsFwiLFwiJklmcjtcIjpcIuKEkVwiLFwiJklncmF2ZVwiOlwiw4xcIixcIiZJZ3JhdmU7XCI6XCLDjFwiLFwiJkltO1wiOlwi4oSRXCIsXCImSW1hY3I7XCI6XCLEqlwiLFwiJkltYWdpbmFyeUk7XCI6XCLihYhcIixcIiZJbXBsaWVzO1wiOlwi4oeSXCIsXCImSW50O1wiOlwi4oisXCIsXCImSW50ZWdyYWw7XCI6XCLiiKtcIixcIiZJbnRlcnNlY3Rpb247XCI6XCLii4JcIixcIiZJbnZpc2libGVDb21tYTtcIjpcIuKBo1wiLFwiJkludmlzaWJsZVRpbWVzO1wiOlwi4oGiXCIsXCImSW9nb247XCI6XCLErlwiLFwiJklvcGY7XCI6XCLwnZWAXCIsXCImSW90YTtcIjpcIs6ZXCIsXCImSXNjcjtcIjpcIuKEkFwiLFwiJkl0aWxkZTtcIjpcIsSoXCIsXCImSXVrY3k7XCI6XCLQhlwiLFwiJkl1bWxcIjpcIsOPXCIsXCImSXVtbDtcIjpcIsOPXCIsXCImSmNpcmM7XCI6XCLEtFwiLFwiJkpjeTtcIjpcItCZXCIsXCImSmZyO1wiOlwi8J2UjVwiLFwiJkpvcGY7XCI6XCLwnZWBXCIsXCImSnNjcjtcIjpcIvCdkqVcIixcIiZKc2VyY3k7XCI6XCLQiFwiLFwiJkp1a2N5O1wiOlwi0IRcIixcIiZLSGN5O1wiOlwi0KVcIixcIiZLSmN5O1wiOlwi0IxcIixcIiZLYXBwYTtcIjpcIs6aXCIsXCImS2NlZGlsO1wiOlwixLZcIixcIiZLY3k7XCI6XCLQmlwiLFwiJktmcjtcIjpcIvCdlI5cIixcIiZLb3BmO1wiOlwi8J2VglwiLFwiJktzY3I7XCI6XCLwnZKmXCIsXCImTEpjeTtcIjpcItCJXCIsXCImTFRcIjpcIjxcIixcIiZMVDtcIjpcIjxcIixcIiZMYWN1dGU7XCI6XCLEuVwiLFwiJkxhbWJkYTtcIjpcIs6bXCIsXCImTGFuZztcIjpcIuKfqlwiLFwiJkxhcGxhY2V0cmY7XCI6XCLihJJcIixcIiZMYXJyO1wiOlwi4oaeXCIsXCImTGNhcm9uO1wiOlwixL1cIixcIiZMY2VkaWw7XCI6XCLEu1wiLFwiJkxjeTtcIjpcItCbXCIsXCImTGVmdEFuZ2xlQnJhY2tldDtcIjpcIuKfqFwiLFwiJkxlZnRBcnJvdztcIjpcIuKGkFwiLFwiJkxlZnRBcnJvd0JhcjtcIjpcIuKHpFwiLFwiJkxlZnRBcnJvd1JpZ2h0QXJyb3c7XCI6XCLih4ZcIixcIiZMZWZ0Q2VpbGluZztcIjpcIuKMiFwiLFwiJkxlZnREb3VibGVCcmFja2V0O1wiOlwi4p+mXCIsXCImTGVmdERvd25UZWVWZWN0b3I7XCI6XCLipaFcIixcIiZMZWZ0RG93blZlY3RvcjtcIjpcIuKHg1wiLFwiJkxlZnREb3duVmVjdG9yQmFyO1wiOlwi4qWZXCIsXCImTGVmdEZsb29yO1wiOlwi4oyKXCIsXCImTGVmdFJpZ2h0QXJyb3c7XCI6XCLihpRcIixcIiZMZWZ0UmlnaHRWZWN0b3I7XCI6XCLipY5cIixcIiZMZWZ0VGVlO1wiOlwi4oqjXCIsXCImTGVmdFRlZUFycm93O1wiOlwi4oakXCIsXCImTGVmdFRlZVZlY3RvcjtcIjpcIuKlmlwiLFwiJkxlZnRUcmlhbmdsZTtcIjpcIuKKslwiLFwiJkxlZnRUcmlhbmdsZUJhcjtcIjpcIuKnj1wiLFwiJkxlZnRUcmlhbmdsZUVxdWFsO1wiOlwi4oq0XCIsXCImTGVmdFVwRG93blZlY3RvcjtcIjpcIuKlkVwiLFwiJkxlZnRVcFRlZVZlY3RvcjtcIjpcIuKloFwiLFwiJkxlZnRVcFZlY3RvcjtcIjpcIuKGv1wiLFwiJkxlZnRVcFZlY3RvckJhcjtcIjpcIuKlmFwiLFwiJkxlZnRWZWN0b3I7XCI6XCLihrxcIixcIiZMZWZ0VmVjdG9yQmFyO1wiOlwi4qWSXCIsXCImTGVmdGFycm93O1wiOlwi4oeQXCIsXCImTGVmdHJpZ2h0YXJyb3c7XCI6XCLih5RcIixcIiZMZXNzRXF1YWxHcmVhdGVyO1wiOlwi4ouaXCIsXCImTGVzc0Z1bGxFcXVhbDtcIjpcIuKJplwiLFwiJkxlc3NHcmVhdGVyO1wiOlwi4om2XCIsXCImTGVzc0xlc3M7XCI6XCLiqqFcIixcIiZMZXNzU2xhbnRFcXVhbDtcIjpcIuKpvVwiLFwiJkxlc3NUaWxkZTtcIjpcIuKJslwiLFwiJkxmcjtcIjpcIvCdlI9cIixcIiZMbDtcIjpcIuKLmFwiLFwiJkxsZWZ0YXJyb3c7XCI6XCLih5pcIixcIiZMbWlkb3Q7XCI6XCLEv1wiLFwiJkxvbmdMZWZ0QXJyb3c7XCI6XCLin7VcIixcIiZMb25nTGVmdFJpZ2h0QXJyb3c7XCI6XCLin7dcIixcIiZMb25nUmlnaHRBcnJvdztcIjpcIuKftlwiLFwiJkxvbmdsZWZ0YXJyb3c7XCI6XCLin7hcIixcIiZMb25nbGVmdHJpZ2h0YXJyb3c7XCI6XCLin7pcIixcIiZMb25ncmlnaHRhcnJvdztcIjpcIuKfuVwiLFwiJkxvcGY7XCI6XCLwnZWDXCIsXCImTG93ZXJMZWZ0QXJyb3c7XCI6XCLihplcIixcIiZMb3dlclJpZ2h0QXJyb3c7XCI6XCLihphcIixcIiZMc2NyO1wiOlwi4oSSXCIsXCImTHNoO1wiOlwi4oawXCIsXCImTHN0cm9rO1wiOlwixYFcIixcIiZMdDtcIjpcIuKJqlwiLFwiJk1hcDtcIjpcIuKkhVwiLFwiJk1jeTtcIjpcItCcXCIsXCImTWVkaXVtU3BhY2U7XCI6XCLigZ9cIixcIiZNZWxsaW50cmY7XCI6XCLihLNcIixcIiZNZnI7XCI6XCLwnZSQXCIsXCImTWludXNQbHVzO1wiOlwi4oiTXCIsXCImTW9wZjtcIjpcIvCdlYRcIixcIiZNc2NyO1wiOlwi4oSzXCIsXCImTXU7XCI6XCLOnFwiLFwiJk5KY3k7XCI6XCLQilwiLFwiJk5hY3V0ZTtcIjpcIsWDXCIsXCImTmNhcm9uO1wiOlwixYdcIixcIiZOY2VkaWw7XCI6XCLFhVwiLFwiJk5jeTtcIjpcItCdXCIsXCImTmVnYXRpdmVNZWRpdW1TcGFjZTtcIjpcIuKAi1wiLFwiJk5lZ2F0aXZlVGhpY2tTcGFjZTtcIjpcIuKAi1wiLFwiJk5lZ2F0aXZlVGhpblNwYWNlO1wiOlwi4oCLXCIsXCImTmVnYXRpdmVWZXJ5VGhpblNwYWNlO1wiOlwi4oCLXCIsXCImTmVzdGVkR3JlYXRlckdyZWF0ZXI7XCI6XCLiiatcIixcIiZOZXN0ZWRMZXNzTGVzcztcIjpcIuKJqlwiLFwiJk5ld0xpbmU7XCI6XCJcXG5cIixcIiZOZnI7XCI6XCLwnZSRXCIsXCImTm9CcmVhaztcIjpcIuKBoFwiLFwiJk5vbkJyZWFraW5nU3BhY2U7XCI6XCLCoFwiLFwiJk5vcGY7XCI6XCLihJVcIixcIiZOb3Q7XCI6XCLiq6xcIixcIiZOb3RDb25ncnVlbnQ7XCI6XCLiiaJcIixcIiZOb3RDdXBDYXA7XCI6XCLiia1cIixcIiZOb3REb3VibGVWZXJ0aWNhbEJhcjtcIjpcIuKIplwiLFwiJk5vdEVsZW1lbnQ7XCI6XCLiiIlcIixcIiZOb3RFcXVhbDtcIjpcIuKJoFwiLFwiJk5vdEVxdWFsVGlsZGU7XCI6XCLiiYLMuFwiLFwiJk5vdEV4aXN0cztcIjpcIuKIhFwiLFwiJk5vdEdyZWF0ZXI7XCI6XCLiia9cIixcIiZOb3RHcmVhdGVyRXF1YWw7XCI6XCLiibFcIixcIiZOb3RHcmVhdGVyRnVsbEVxdWFsO1wiOlwi4omnzLhcIixcIiZOb3RHcmVhdGVyR3JlYXRlcjtcIjpcIuKJq8y4XCIsXCImTm90R3JlYXRlckxlc3M7XCI6XCLiiblcIixcIiZOb3RHcmVhdGVyU2xhbnRFcXVhbDtcIjpcIuKpvsy4XCIsXCImTm90R3JlYXRlclRpbGRlO1wiOlwi4om1XCIsXCImTm90SHVtcERvd25IdW1wO1wiOlwi4omOzLhcIixcIiZOb3RIdW1wRXF1YWw7XCI6XCLiiY/MuFwiLFwiJk5vdExlZnRUcmlhbmdsZTtcIjpcIuKLqlwiLFwiJk5vdExlZnRUcmlhbmdsZUJhcjtcIjpcIuKnj8y4XCIsXCImTm90TGVmdFRyaWFuZ2xlRXF1YWw7XCI6XCLii6xcIixcIiZOb3RMZXNzO1wiOlwi4omuXCIsXCImTm90TGVzc0VxdWFsO1wiOlwi4omwXCIsXCImTm90TGVzc0dyZWF0ZXI7XCI6XCLiibhcIixcIiZOb3RMZXNzTGVzcztcIjpcIuKJqsy4XCIsXCImTm90TGVzc1NsYW50RXF1YWw7XCI6XCLiqb3MuFwiLFwiJk5vdExlc3NUaWxkZTtcIjpcIuKJtFwiLFwiJk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyO1wiOlwi4qqizLhcIixcIiZOb3ROZXN0ZWRMZXNzTGVzcztcIjpcIuKqocy4XCIsXCImTm90UHJlY2VkZXM7XCI6XCLiioBcIixcIiZOb3RQcmVjZWRlc0VxdWFsO1wiOlwi4qqvzLhcIixcIiZOb3RQcmVjZWRlc1NsYW50RXF1YWw7XCI6XCLii6BcIixcIiZOb3RSZXZlcnNlRWxlbWVudDtcIjpcIuKIjFwiLFwiJk5vdFJpZ2h0VHJpYW5nbGU7XCI6XCLii6tcIixcIiZOb3RSaWdodFRyaWFuZ2xlQmFyO1wiOlwi4qeQzLhcIixcIiZOb3RSaWdodFRyaWFuZ2xlRXF1YWw7XCI6XCLii61cIixcIiZOb3RTcXVhcmVTdWJzZXQ7XCI6XCLiio/MuFwiLFwiJk5vdFNxdWFyZVN1YnNldEVxdWFsO1wiOlwi4ouiXCIsXCImTm90U3F1YXJlU3VwZXJzZXQ7XCI6XCLiipDMuFwiLFwiJk5vdFNxdWFyZVN1cGVyc2V0RXF1YWw7XCI6XCLii6NcIixcIiZOb3RTdWJzZXQ7XCI6XCLiioLig5JcIixcIiZOb3RTdWJzZXRFcXVhbDtcIjpcIuKKiFwiLFwiJk5vdFN1Y2NlZWRzO1wiOlwi4oqBXCIsXCImTm90U3VjY2VlZHNFcXVhbDtcIjpcIuKqsMy4XCIsXCImTm90U3VjY2VlZHNTbGFudEVxdWFsO1wiOlwi4ouhXCIsXCImTm90U3VjY2VlZHNUaWxkZTtcIjpcIuKJv8y4XCIsXCImTm90U3VwZXJzZXQ7XCI6XCLiioPig5JcIixcIiZOb3RTdXBlcnNldEVxdWFsO1wiOlwi4oqJXCIsXCImTm90VGlsZGU7XCI6XCLiiYFcIixcIiZOb3RUaWxkZUVxdWFsO1wiOlwi4omEXCIsXCImTm90VGlsZGVGdWxsRXF1YWw7XCI6XCLiiYdcIixcIiZOb3RUaWxkZVRpbGRlO1wiOlwi4omJXCIsXCImTm90VmVydGljYWxCYXI7XCI6XCLiiKRcIixcIiZOc2NyO1wiOlwi8J2SqVwiLFwiJk50aWxkZVwiOlwiw5FcIixcIiZOdGlsZGU7XCI6XCLDkVwiLFwiJk51O1wiOlwizp1cIixcIiZPRWxpZztcIjpcIsWSXCIsXCImT2FjdXRlXCI6XCLDk1wiLFwiJk9hY3V0ZTtcIjpcIsOTXCIsXCImT2NpcmNcIjpcIsOUXCIsXCImT2NpcmM7XCI6XCLDlFwiLFwiJk9jeTtcIjpcItCeXCIsXCImT2RibGFjO1wiOlwixZBcIixcIiZPZnI7XCI6XCLwnZSSXCIsXCImT2dyYXZlXCI6XCLDklwiLFwiJk9ncmF2ZTtcIjpcIsOSXCIsXCImT21hY3I7XCI6XCLFjFwiLFwiJk9tZWdhO1wiOlwizqlcIixcIiZPbWljcm9uO1wiOlwizp9cIixcIiZPb3BmO1wiOlwi8J2VhlwiLFwiJk9wZW5DdXJseURvdWJsZVF1b3RlO1wiOlwi4oCcXCIsXCImT3BlbkN1cmx5UXVvdGU7XCI6XCLigJhcIixcIiZPcjtcIjpcIuKplFwiLFwiJk9zY3I7XCI6XCLwnZKqXCIsXCImT3NsYXNoXCI6XCLDmFwiLFwiJk9zbGFzaDtcIjpcIsOYXCIsXCImT3RpbGRlXCI6XCLDlVwiLFwiJk90aWxkZTtcIjpcIsOVXCIsXCImT3RpbWVzO1wiOlwi4qi3XCIsXCImT3VtbFwiOlwiw5ZcIixcIiZPdW1sO1wiOlwiw5ZcIixcIiZPdmVyQmFyO1wiOlwi4oC+XCIsXCImT3ZlckJyYWNlO1wiOlwi4o+eXCIsXCImT3ZlckJyYWNrZXQ7XCI6XCLijrRcIixcIiZPdmVyUGFyZW50aGVzaXM7XCI6XCLij5xcIixcIiZQYXJ0aWFsRDtcIjpcIuKIglwiLFwiJlBjeTtcIjpcItCfXCIsXCImUGZyO1wiOlwi8J2Uk1wiLFwiJlBoaTtcIjpcIs6mXCIsXCImUGk7XCI6XCLOoFwiLFwiJlBsdXNNaW51cztcIjpcIsKxXCIsXCImUG9pbmNhcmVwbGFuZTtcIjpcIuKEjFwiLFwiJlBvcGY7XCI6XCLihJlcIixcIiZQcjtcIjpcIuKqu1wiLFwiJlByZWNlZGVzO1wiOlwi4om6XCIsXCImUHJlY2VkZXNFcXVhbDtcIjpcIuKqr1wiLFwiJlByZWNlZGVzU2xhbnRFcXVhbDtcIjpcIuKJvFwiLFwiJlByZWNlZGVzVGlsZGU7XCI6XCLiib5cIixcIiZQcmltZTtcIjpcIuKAs1wiLFwiJlByb2R1Y3Q7XCI6XCLiiI9cIixcIiZQcm9wb3J0aW9uO1wiOlwi4oi3XCIsXCImUHJvcG9ydGlvbmFsO1wiOlwi4oidXCIsXCImUHNjcjtcIjpcIvCdkqtcIixcIiZQc2k7XCI6XCLOqFwiLFwiJlFVT1RcIjonXCInLFwiJlFVT1Q7XCI6J1wiJyxcIiZRZnI7XCI6XCLwnZSUXCIsXCImUW9wZjtcIjpcIuKEmlwiLFwiJlFzY3I7XCI6XCLwnZKsXCIsXCImUkJhcnI7XCI6XCLipJBcIixcIiZSRUdcIjpcIsKuXCIsXCImUkVHO1wiOlwiwq5cIixcIiZSYWN1dGU7XCI6XCLFlFwiLFwiJlJhbmc7XCI6XCLin6tcIixcIiZSYXJyO1wiOlwi4oagXCIsXCImUmFycnRsO1wiOlwi4qSWXCIsXCImUmNhcm9uO1wiOlwixZhcIixcIiZSY2VkaWw7XCI6XCLFllwiLFwiJlJjeTtcIjpcItCgXCIsXCImUmU7XCI6XCLihJxcIixcIiZSZXZlcnNlRWxlbWVudDtcIjpcIuKIi1wiLFwiJlJldmVyc2VFcXVpbGlicml1bTtcIjpcIuKHi1wiLFwiJlJldmVyc2VVcEVxdWlsaWJyaXVtO1wiOlwi4qWvXCIsXCImUmZyO1wiOlwi4oScXCIsXCImUmhvO1wiOlwizqFcIixcIiZSaWdodEFuZ2xlQnJhY2tldDtcIjpcIuKfqVwiLFwiJlJpZ2h0QXJyb3c7XCI6XCLihpJcIixcIiZSaWdodEFycm93QmFyO1wiOlwi4oelXCIsXCImUmlnaHRBcnJvd0xlZnRBcnJvdztcIjpcIuKHhFwiLFwiJlJpZ2h0Q2VpbGluZztcIjpcIuKMiVwiLFwiJlJpZ2h0RG91YmxlQnJhY2tldDtcIjpcIuKfp1wiLFwiJlJpZ2h0RG93blRlZVZlY3RvcjtcIjpcIuKlnVwiLFwiJlJpZ2h0RG93blZlY3RvcjtcIjpcIuKHglwiLFwiJlJpZ2h0RG93blZlY3RvckJhcjtcIjpcIuKllVwiLFwiJlJpZ2h0Rmxvb3I7XCI6XCLijItcIixcIiZSaWdodFRlZTtcIjpcIuKKolwiLFwiJlJpZ2h0VGVlQXJyb3c7XCI6XCLihqZcIixcIiZSaWdodFRlZVZlY3RvcjtcIjpcIuKlm1wiLFwiJlJpZ2h0VHJpYW5nbGU7XCI6XCLiirNcIixcIiZSaWdodFRyaWFuZ2xlQmFyO1wiOlwi4qeQXCIsXCImUmlnaHRUcmlhbmdsZUVxdWFsO1wiOlwi4oq1XCIsXCImUmlnaHRVcERvd25WZWN0b3I7XCI6XCLipY9cIixcIiZSaWdodFVwVGVlVmVjdG9yO1wiOlwi4qWcXCIsXCImUmlnaHRVcFZlY3RvcjtcIjpcIuKGvlwiLFwiJlJpZ2h0VXBWZWN0b3JCYXI7XCI6XCLipZRcIixcIiZSaWdodFZlY3RvcjtcIjpcIuKHgFwiLFwiJlJpZ2h0VmVjdG9yQmFyO1wiOlwi4qWTXCIsXCImUmlnaHRhcnJvdztcIjpcIuKHklwiLFwiJlJvcGY7XCI6XCLihJ1cIixcIiZSb3VuZEltcGxpZXM7XCI6XCLipbBcIixcIiZScmlnaHRhcnJvdztcIjpcIuKHm1wiLFwiJlJzY3I7XCI6XCLihJtcIixcIiZSc2g7XCI6XCLihrFcIixcIiZSdWxlRGVsYXllZDtcIjpcIuKntFwiLFwiJlNIQ0hjeTtcIjpcItCpXCIsXCImU0hjeTtcIjpcItCoXCIsXCImU09GVGN5O1wiOlwi0KxcIixcIiZTYWN1dGU7XCI6XCLFmlwiLFwiJlNjO1wiOlwi4qq8XCIsXCImU2Nhcm9uO1wiOlwixaBcIixcIiZTY2VkaWw7XCI6XCLFnlwiLFwiJlNjaXJjO1wiOlwixZxcIixcIiZTY3k7XCI6XCLQoVwiLFwiJlNmcjtcIjpcIvCdlJZcIixcIiZTaG9ydERvd25BcnJvdztcIjpcIuKGk1wiLFwiJlNob3J0TGVmdEFycm93O1wiOlwi4oaQXCIsXCImU2hvcnRSaWdodEFycm93O1wiOlwi4oaSXCIsXCImU2hvcnRVcEFycm93O1wiOlwi4oaRXCIsXCImU2lnbWE7XCI6XCLOo1wiLFwiJlNtYWxsQ2lyY2xlO1wiOlwi4oiYXCIsXCImU29wZjtcIjpcIvCdlYpcIixcIiZTcXJ0O1wiOlwi4oiaXCIsXCImU3F1YXJlO1wiOlwi4pahXCIsXCImU3F1YXJlSW50ZXJzZWN0aW9uO1wiOlwi4oqTXCIsXCImU3F1YXJlU3Vic2V0O1wiOlwi4oqPXCIsXCImU3F1YXJlU3Vic2V0RXF1YWw7XCI6XCLiipFcIixcIiZTcXVhcmVTdXBlcnNldDtcIjpcIuKKkFwiLFwiJlNxdWFyZVN1cGVyc2V0RXF1YWw7XCI6XCLiipJcIixcIiZTcXVhcmVVbmlvbjtcIjpcIuKKlFwiLFwiJlNzY3I7XCI6XCLwnZKuXCIsXCImU3RhcjtcIjpcIuKLhlwiLFwiJlN1YjtcIjpcIuKLkFwiLFwiJlN1YnNldDtcIjpcIuKLkFwiLFwiJlN1YnNldEVxdWFsO1wiOlwi4oqGXCIsXCImU3VjY2VlZHM7XCI6XCLiibtcIixcIiZTdWNjZWVkc0VxdWFsO1wiOlwi4qqwXCIsXCImU3VjY2VlZHNTbGFudEVxdWFsO1wiOlwi4om9XCIsXCImU3VjY2VlZHNUaWxkZTtcIjpcIuKJv1wiLFwiJlN1Y2hUaGF0O1wiOlwi4oiLXCIsXCImU3VtO1wiOlwi4oiRXCIsXCImU3VwO1wiOlwi4ouRXCIsXCImU3VwZXJzZXQ7XCI6XCLiioNcIixcIiZTdXBlcnNldEVxdWFsO1wiOlwi4oqHXCIsXCImU3Vwc2V0O1wiOlwi4ouRXCIsXCImVEhPUk5cIjpcIsOeXCIsXCImVEhPUk47XCI6XCLDnlwiLFwiJlRSQURFO1wiOlwi4oSiXCIsXCImVFNIY3k7XCI6XCLQi1wiLFwiJlRTY3k7XCI6XCLQplwiLFwiJlRhYjtcIjpcIlxcdFwiLFwiJlRhdTtcIjpcIs6kXCIsXCImVGNhcm9uO1wiOlwixaRcIixcIiZUY2VkaWw7XCI6XCLFolwiLFwiJlRjeTtcIjpcItCiXCIsXCImVGZyO1wiOlwi8J2Ul1wiLFwiJlRoZXJlZm9yZTtcIjpcIuKItFwiLFwiJlRoZXRhO1wiOlwizphcIixcIiZUaGlja1NwYWNlO1wiOlwi4oGf4oCKXCIsXCImVGhpblNwYWNlO1wiOlwi4oCJXCIsXCImVGlsZGU7XCI6XCLiiLxcIixcIiZUaWxkZUVxdWFsO1wiOlwi4omDXCIsXCImVGlsZGVGdWxsRXF1YWw7XCI6XCLiiYVcIixcIiZUaWxkZVRpbGRlO1wiOlwi4omIXCIsXCImVG9wZjtcIjpcIvCdlYtcIixcIiZUcmlwbGVEb3Q7XCI6XCLig5tcIixcIiZUc2NyO1wiOlwi8J2Sr1wiLFwiJlRzdHJvaztcIjpcIsWmXCIsXCImVWFjdXRlXCI6XCLDmlwiLFwiJlVhY3V0ZTtcIjpcIsOaXCIsXCImVWFycjtcIjpcIuKGn1wiLFwiJlVhcnJvY2lyO1wiOlwi4qWJXCIsXCImVWJyY3k7XCI6XCLQjlwiLFwiJlVicmV2ZTtcIjpcIsWsXCIsXCImVWNpcmNcIjpcIsObXCIsXCImVWNpcmM7XCI6XCLDm1wiLFwiJlVjeTtcIjpcItCjXCIsXCImVWRibGFjO1wiOlwixbBcIixcIiZVZnI7XCI6XCLwnZSYXCIsXCImVWdyYXZlXCI6XCLDmVwiLFwiJlVncmF2ZTtcIjpcIsOZXCIsXCImVW1hY3I7XCI6XCLFqlwiLFwiJlVuZGVyQmFyO1wiOlwiX1wiLFwiJlVuZGVyQnJhY2U7XCI6XCLij59cIixcIiZVbmRlckJyYWNrZXQ7XCI6XCLijrVcIixcIiZVbmRlclBhcmVudGhlc2lzO1wiOlwi4o+dXCIsXCImVW5pb247XCI6XCLii4NcIixcIiZVbmlvblBsdXM7XCI6XCLiio5cIixcIiZVb2dvbjtcIjpcIsWyXCIsXCImVW9wZjtcIjpcIvCdlYxcIixcIiZVcEFycm93O1wiOlwi4oaRXCIsXCImVXBBcnJvd0JhcjtcIjpcIuKkklwiLFwiJlVwQXJyb3dEb3duQXJyb3c7XCI6XCLih4VcIixcIiZVcERvd25BcnJvdztcIjpcIuKGlVwiLFwiJlVwRXF1aWxpYnJpdW07XCI6XCLipa5cIixcIiZVcFRlZTtcIjpcIuKKpVwiLFwiJlVwVGVlQXJyb3c7XCI6XCLihqVcIixcIiZVcGFycm93O1wiOlwi4oeRXCIsXCImVXBkb3duYXJyb3c7XCI6XCLih5VcIixcIiZVcHBlckxlZnRBcnJvdztcIjpcIuKGllwiLFwiJlVwcGVyUmlnaHRBcnJvdztcIjpcIuKGl1wiLFwiJlVwc2k7XCI6XCLPklwiLFwiJlVwc2lsb247XCI6XCLOpVwiLFwiJlVyaW5nO1wiOlwixa5cIixcIiZVc2NyO1wiOlwi8J2SsFwiLFwiJlV0aWxkZTtcIjpcIsWoXCIsXCImVXVtbFwiOlwiw5xcIixcIiZVdW1sO1wiOlwiw5xcIixcIiZWRGFzaDtcIjpcIuKKq1wiLFwiJlZiYXI7XCI6XCLiq6tcIixcIiZWY3k7XCI6XCLQklwiLFwiJlZkYXNoO1wiOlwi4oqpXCIsXCImVmRhc2hsO1wiOlwi4qumXCIsXCImVmVlO1wiOlwi4ouBXCIsXCImVmVyYmFyO1wiOlwi4oCWXCIsXCImVmVydDtcIjpcIuKAllwiLFwiJlZlcnRpY2FsQmFyO1wiOlwi4oijXCIsXCImVmVydGljYWxMaW5lO1wiOlwifFwiLFwiJlZlcnRpY2FsU2VwYXJhdG9yO1wiOlwi4p2YXCIsXCImVmVydGljYWxUaWxkZTtcIjpcIuKJgFwiLFwiJlZlcnlUaGluU3BhY2U7XCI6XCLigIpcIixcIiZWZnI7XCI6XCLwnZSZXCIsXCImVm9wZjtcIjpcIvCdlY1cIixcIiZWc2NyO1wiOlwi8J2SsVwiLFwiJlZ2ZGFzaDtcIjpcIuKKqlwiLFwiJldjaXJjO1wiOlwixbRcIixcIiZXZWRnZTtcIjpcIuKLgFwiLFwiJldmcjtcIjpcIvCdlJpcIixcIiZXb3BmO1wiOlwi8J2VjlwiLFwiJldzY3I7XCI6XCLwnZKyXCIsXCImWGZyO1wiOlwi8J2Um1wiLFwiJlhpO1wiOlwizp5cIixcIiZYb3BmO1wiOlwi8J2Vj1wiLFwiJlhzY3I7XCI6XCLwnZKzXCIsXCImWUFjeTtcIjpcItCvXCIsXCImWUljeTtcIjpcItCHXCIsXCImWVVjeTtcIjpcItCuXCIsXCImWWFjdXRlXCI6XCLDnVwiLFwiJllhY3V0ZTtcIjpcIsOdXCIsXCImWWNpcmM7XCI6XCLFtlwiLFwiJlljeTtcIjpcItCrXCIsXCImWWZyO1wiOlwi8J2UnFwiLFwiJllvcGY7XCI6XCLwnZWQXCIsXCImWXNjcjtcIjpcIvCdkrRcIixcIiZZdW1sO1wiOlwixbhcIixcIiZaSGN5O1wiOlwi0JZcIixcIiZaYWN1dGU7XCI6XCLFuVwiLFwiJlpjYXJvbjtcIjpcIsW9XCIsXCImWmN5O1wiOlwi0JdcIixcIiZaZG90O1wiOlwixbtcIixcIiZaZXJvV2lkdGhTcGFjZTtcIjpcIuKAi1wiLFwiJlpldGE7XCI6XCLOllwiLFwiJlpmcjtcIjpcIuKEqFwiLFwiJlpvcGY7XCI6XCLihKRcIixcIiZac2NyO1wiOlwi8J2StVwiLFwiJmFhY3V0ZVwiOlwiw6FcIixcIiZhYWN1dGU7XCI6XCLDoVwiLFwiJmFicmV2ZTtcIjpcIsSDXCIsXCImYWM7XCI6XCLiiL5cIixcIiZhY0U7XCI6XCLiiL7Ms1wiLFwiJmFjZDtcIjpcIuKIv1wiLFwiJmFjaXJjXCI6XCLDolwiLFwiJmFjaXJjO1wiOlwiw6JcIixcIiZhY3V0ZVwiOlwiwrRcIixcIiZhY3V0ZTtcIjpcIsK0XCIsXCImYWN5O1wiOlwi0LBcIixcIiZhZWxpZ1wiOlwiw6ZcIixcIiZhZWxpZztcIjpcIsOmXCIsXCImYWY7XCI6XCLigaFcIixcIiZhZnI7XCI6XCLwnZSeXCIsXCImYWdyYXZlXCI6XCLDoFwiLFwiJmFncmF2ZTtcIjpcIsOgXCIsXCImYWxlZnN5bTtcIjpcIuKEtVwiLFwiJmFsZXBoO1wiOlwi4oS1XCIsXCImYWxwaGE7XCI6XCLOsVwiLFwiJmFtYWNyO1wiOlwixIFcIixcIiZhbWFsZztcIjpcIuKov1wiLFwiJmFtcFwiOlwiJlwiLFwiJmFtcDtcIjpcIiZcIixcIiZhbmQ7XCI6XCLiiKdcIixcIiZhbmRhbmQ7XCI6XCLiqZVcIixcIiZhbmRkO1wiOlwi4qmcXCIsXCImYW5kc2xvcGU7XCI6XCLiqZhcIixcIiZhbmR2O1wiOlwi4qmaXCIsXCImYW5nO1wiOlwi4oigXCIsXCImYW5nZTtcIjpcIuKmpFwiLFwiJmFuZ2xlO1wiOlwi4oigXCIsXCImYW5nbXNkO1wiOlwi4oihXCIsXCImYW5nbXNkYWE7XCI6XCLipqhcIixcIiZhbmdtc2RhYjtcIjpcIuKmqVwiLFwiJmFuZ21zZGFjO1wiOlwi4qaqXCIsXCImYW5nbXNkYWQ7XCI6XCLipqtcIixcIiZhbmdtc2RhZTtcIjpcIuKmrFwiLFwiJmFuZ21zZGFmO1wiOlwi4qatXCIsXCImYW5nbXNkYWc7XCI6XCLipq5cIixcIiZhbmdtc2RhaDtcIjpcIuKmr1wiLFwiJmFuZ3J0O1wiOlwi4oifXCIsXCImYW5ncnR2YjtcIjpcIuKKvlwiLFwiJmFuZ3J0dmJkO1wiOlwi4qadXCIsXCImYW5nc3BoO1wiOlwi4oiiXCIsXCImYW5nc3Q7XCI6XCLDhVwiLFwiJmFuZ3phcnI7XCI6XCLijbxcIixcIiZhb2dvbjtcIjpcIsSFXCIsXCImYW9wZjtcIjpcIvCdlZJcIixcIiZhcDtcIjpcIuKJiFwiLFwiJmFwRTtcIjpcIuKpsFwiLFwiJmFwYWNpcjtcIjpcIuKpr1wiLFwiJmFwZTtcIjpcIuKJilwiLFwiJmFwaWQ7XCI6XCLiiYtcIixcIiZhcG9zO1wiOlwiJ1wiLFwiJmFwcHJveDtcIjpcIuKJiFwiLFwiJmFwcHJveGVxO1wiOlwi4omKXCIsXCImYXJpbmdcIjpcIsOlXCIsXCImYXJpbmc7XCI6XCLDpVwiLFwiJmFzY3I7XCI6XCLwnZK2XCIsXCImYXN0O1wiOlwiKlwiLFwiJmFzeW1wO1wiOlwi4omIXCIsXCImYXN5bXBlcTtcIjpcIuKJjVwiLFwiJmF0aWxkZVwiOlwiw6NcIixcIiZhdGlsZGU7XCI6XCLDo1wiLFwiJmF1bWxcIjpcIsOkXCIsXCImYXVtbDtcIjpcIsOkXCIsXCImYXdjb25pbnQ7XCI6XCLiiLNcIixcIiZhd2ludDtcIjpcIuKokVwiLFwiJmJOb3Q7XCI6XCLiq61cIixcIiZiYWNrY29uZztcIjpcIuKJjFwiLFwiJmJhY2tlcHNpbG9uO1wiOlwiz7ZcIixcIiZiYWNrcHJpbWU7XCI6XCLigLVcIixcIiZiYWNrc2ltO1wiOlwi4oi9XCIsXCImYmFja3NpbWVxO1wiOlwi4ouNXCIsXCImYmFydmVlO1wiOlwi4oq9XCIsXCImYmFyd2VkO1wiOlwi4oyFXCIsXCImYmFyd2VkZ2U7XCI6XCLijIVcIixcIiZiYnJrO1wiOlwi4o61XCIsXCImYmJya3Ricms7XCI6XCLijrZcIixcIiZiY29uZztcIjpcIuKJjFwiLFwiJmJjeTtcIjpcItCxXCIsXCImYmRxdW87XCI6XCLigJ5cIixcIiZiZWNhdXM7XCI6XCLiiLVcIixcIiZiZWNhdXNlO1wiOlwi4oi1XCIsXCImYmVtcHR5djtcIjpcIuKmsFwiLFwiJmJlcHNpO1wiOlwiz7ZcIixcIiZiZXJub3U7XCI6XCLihKxcIixcIiZiZXRhO1wiOlwizrJcIixcIiZiZXRoO1wiOlwi4oS2XCIsXCImYmV0d2VlbjtcIjpcIuKJrFwiLFwiJmJmcjtcIjpcIvCdlJ9cIixcIiZiaWdjYXA7XCI6XCLii4JcIixcIiZiaWdjaXJjO1wiOlwi4pevXCIsXCImYmlnY3VwO1wiOlwi4ouDXCIsXCImYmlnb2RvdDtcIjpcIuKogFwiLFwiJmJpZ29wbHVzO1wiOlwi4qiBXCIsXCImYmlnb3RpbWVzO1wiOlwi4qiCXCIsXCImYmlnc3FjdXA7XCI6XCLiqIZcIixcIiZiaWdzdGFyO1wiOlwi4piFXCIsXCImYmlndHJpYW5nbGVkb3duO1wiOlwi4pa9XCIsXCImYmlndHJpYW5nbGV1cDtcIjpcIuKWs1wiLFwiJmJpZ3VwbHVzO1wiOlwi4qiEXCIsXCImYmlndmVlO1wiOlwi4ouBXCIsXCImYmlnd2VkZ2U7XCI6XCLii4BcIixcIiZia2Fyb3c7XCI6XCLipI1cIixcIiZibGFja2xvemVuZ2U7XCI6XCLip6tcIixcIiZibGFja3NxdWFyZTtcIjpcIuKWqlwiLFwiJmJsYWNrdHJpYW5nbGU7XCI6XCLilrRcIixcIiZibGFja3RyaWFuZ2xlZG93bjtcIjpcIuKWvlwiLFwiJmJsYWNrdHJpYW5nbGVsZWZ0O1wiOlwi4peCXCIsXCImYmxhY2t0cmlhbmdsZXJpZ2h0O1wiOlwi4pa4XCIsXCImYmxhbms7XCI6XCLikKNcIixcIiZibGsxMjtcIjpcIuKWklwiLFwiJmJsazE0O1wiOlwi4paRXCIsXCImYmxrMzQ7XCI6XCLilpNcIixcIiZibG9jaztcIjpcIuKWiFwiLFwiJmJuZTtcIjpcIj3ig6VcIixcIiZibmVxdWl2O1wiOlwi4omh4oOlXCIsXCImYm5vdDtcIjpcIuKMkFwiLFwiJmJvcGY7XCI6XCLwnZWTXCIsXCImYm90O1wiOlwi4oqlXCIsXCImYm90dG9tO1wiOlwi4oqlXCIsXCImYm93dGllO1wiOlwi4ouIXCIsXCImYm94REw7XCI6XCLilZdcIixcIiZib3hEUjtcIjpcIuKVlFwiLFwiJmJveERsO1wiOlwi4pWWXCIsXCImYm94RHI7XCI6XCLilZNcIixcIiZib3hIO1wiOlwi4pWQXCIsXCImYm94SEQ7XCI6XCLilaZcIixcIiZib3hIVTtcIjpcIuKVqVwiLFwiJmJveEhkO1wiOlwi4pWkXCIsXCImYm94SHU7XCI6XCLiladcIixcIiZib3hVTDtcIjpcIuKVnVwiLFwiJmJveFVSO1wiOlwi4pWaXCIsXCImYm94VWw7XCI6XCLilZxcIixcIiZib3hVcjtcIjpcIuKVmVwiLFwiJmJveFY7XCI6XCLilZFcIixcIiZib3hWSDtcIjpcIuKVrFwiLFwiJmJveFZMO1wiOlwi4pWjXCIsXCImYm94VlI7XCI6XCLilaBcIixcIiZib3hWaDtcIjpcIuKVq1wiLFwiJmJveFZsO1wiOlwi4pWiXCIsXCImYm94VnI7XCI6XCLilZ9cIixcIiZib3hib3g7XCI6XCLip4lcIixcIiZib3hkTDtcIjpcIuKVlVwiLFwiJmJveGRSO1wiOlwi4pWSXCIsXCImYm94ZGw7XCI6XCLilJBcIixcIiZib3hkcjtcIjpcIuKUjFwiLFwiJmJveGg7XCI6XCLilIBcIixcIiZib3hoRDtcIjpcIuKVpVwiLFwiJmJveGhVO1wiOlwi4pWoXCIsXCImYm94aGQ7XCI6XCLilKxcIixcIiZib3hodTtcIjpcIuKUtFwiLFwiJmJveG1pbnVzO1wiOlwi4oqfXCIsXCImYm94cGx1cztcIjpcIuKKnlwiLFwiJmJveHRpbWVzO1wiOlwi4oqgXCIsXCImYm94dUw7XCI6XCLilZtcIixcIiZib3h1UjtcIjpcIuKVmFwiLFwiJmJveHVsO1wiOlwi4pSYXCIsXCImYm94dXI7XCI6XCLilJRcIixcIiZib3h2O1wiOlwi4pSCXCIsXCImYm94dkg7XCI6XCLilapcIixcIiZib3h2TDtcIjpcIuKVoVwiLFwiJmJveHZSO1wiOlwi4pWeXCIsXCImYm94dmg7XCI6XCLilLxcIixcIiZib3h2bDtcIjpcIuKUpFwiLFwiJmJveHZyO1wiOlwi4pScXCIsXCImYnByaW1lO1wiOlwi4oC1XCIsXCImYnJldmU7XCI6XCLLmFwiLFwiJmJydmJhclwiOlwiwqZcIixcIiZicnZiYXI7XCI6XCLCplwiLFwiJmJzY3I7XCI6XCLwnZK3XCIsXCImYnNlbWk7XCI6XCLigY9cIixcIiZic2ltO1wiOlwi4oi9XCIsXCImYnNpbWU7XCI6XCLii41cIixcIiZic29sO1wiOlwiXFxcXFwiLFwiJmJzb2xiO1wiOlwi4qeFXCIsXCImYnNvbGhzdWI7XCI6XCLin4hcIixcIiZidWxsO1wiOlwi4oCiXCIsXCImYnVsbGV0O1wiOlwi4oCiXCIsXCImYnVtcDtcIjpcIuKJjlwiLFwiJmJ1bXBFO1wiOlwi4qquXCIsXCImYnVtcGU7XCI6XCLiiY9cIixcIiZidW1wZXE7XCI6XCLiiY9cIixcIiZjYWN1dGU7XCI6XCLEh1wiLFwiJmNhcDtcIjpcIuKIqVwiLFwiJmNhcGFuZDtcIjpcIuKphFwiLFwiJmNhcGJyY3VwO1wiOlwi4qmJXCIsXCImY2FwY2FwO1wiOlwi4qmLXCIsXCImY2FwY3VwO1wiOlwi4qmHXCIsXCImY2FwZG90O1wiOlwi4qmAXCIsXCImY2FwcztcIjpcIuKIqe+4gFwiLFwiJmNhcmV0O1wiOlwi4oGBXCIsXCImY2Fyb247XCI6XCLLh1wiLFwiJmNjYXBzO1wiOlwi4qmNXCIsXCImY2Nhcm9uO1wiOlwixI1cIixcIiZjY2VkaWxcIjpcIsOnXCIsXCImY2NlZGlsO1wiOlwiw6dcIixcIiZjY2lyYztcIjpcIsSJXCIsXCImY2N1cHM7XCI6XCLiqYxcIixcIiZjY3Vwc3NtO1wiOlwi4qmQXCIsXCImY2RvdDtcIjpcIsSLXCIsXCImY2VkaWxcIjpcIsK4XCIsXCImY2VkaWw7XCI6XCLCuFwiLFwiJmNlbXB0eXY7XCI6XCLiprJcIixcIiZjZW50XCI6XCLColwiLFwiJmNlbnQ7XCI6XCLColwiLFwiJmNlbnRlcmRvdDtcIjpcIsK3XCIsXCImY2ZyO1wiOlwi8J2UoFwiLFwiJmNoY3k7XCI6XCLRh1wiLFwiJmNoZWNrO1wiOlwi4pyTXCIsXCImY2hlY2ttYXJrO1wiOlwi4pyTXCIsXCImY2hpO1wiOlwiz4dcIixcIiZjaXI7XCI6XCLil4tcIixcIiZjaXJFO1wiOlwi4qeDXCIsXCImY2lyYztcIjpcIsuGXCIsXCImY2lyY2VxO1wiOlwi4omXXCIsXCImY2lyY2xlYXJyb3dsZWZ0O1wiOlwi4oa6XCIsXCImY2lyY2xlYXJyb3dyaWdodDtcIjpcIuKGu1wiLFwiJmNpcmNsZWRSO1wiOlwiwq5cIixcIiZjaXJjbGVkUztcIjpcIuKTiFwiLFwiJmNpcmNsZWRhc3Q7XCI6XCLiiptcIixcIiZjaXJjbGVkY2lyYztcIjpcIuKKmlwiLFwiJmNpcmNsZWRkYXNoO1wiOlwi4oqdXCIsXCImY2lyZTtcIjpcIuKJl1wiLFwiJmNpcmZuaW50O1wiOlwi4qiQXCIsXCImY2lybWlkO1wiOlwi4quvXCIsXCImY2lyc2NpcjtcIjpcIuKnglwiLFwiJmNsdWJzO1wiOlwi4pmjXCIsXCImY2x1YnN1aXQ7XCI6XCLimaNcIixcIiZjb2xvbjtcIjpcIjpcIixcIiZjb2xvbmU7XCI6XCLiiZRcIixcIiZjb2xvbmVxO1wiOlwi4omUXCIsXCImY29tbWE7XCI6XCIsXCIsXCImY29tbWF0O1wiOlwiQFwiLFwiJmNvbXA7XCI6XCLiiIFcIixcIiZjb21wZm47XCI6XCLiiJhcIixcIiZjb21wbGVtZW50O1wiOlwi4oiBXCIsXCImY29tcGxleGVzO1wiOlwi4oSCXCIsXCImY29uZztcIjpcIuKJhVwiLFwiJmNvbmdkb3Q7XCI6XCLiqa1cIixcIiZjb25pbnQ7XCI6XCLiiK5cIixcIiZjb3BmO1wiOlwi8J2VlFwiLFwiJmNvcHJvZDtcIjpcIuKIkFwiLFwiJmNvcHlcIjpcIsKpXCIsXCImY29weTtcIjpcIsKpXCIsXCImY29weXNyO1wiOlwi4oSXXCIsXCImY3JhcnI7XCI6XCLihrVcIixcIiZjcm9zcztcIjpcIuKcl1wiLFwiJmNzY3I7XCI6XCLwnZK4XCIsXCImY3N1YjtcIjpcIuKrj1wiLFwiJmNzdWJlO1wiOlwi4quRXCIsXCImY3N1cDtcIjpcIuKrkFwiLFwiJmNzdXBlO1wiOlwi4quSXCIsXCImY3Rkb3Q7XCI6XCLii69cIixcIiZjdWRhcnJsO1wiOlwi4qS4XCIsXCImY3VkYXJycjtcIjpcIuKktVwiLFwiJmN1ZXByO1wiOlwi4oueXCIsXCImY3Vlc2M7XCI6XCLii59cIixcIiZjdWxhcnI7XCI6XCLihrZcIixcIiZjdWxhcnJwO1wiOlwi4qS9XCIsXCImY3VwO1wiOlwi4oiqXCIsXCImY3VwYnJjYXA7XCI6XCLiqYhcIixcIiZjdXBjYXA7XCI6XCLiqYZcIixcIiZjdXBjdXA7XCI6XCLiqYpcIixcIiZjdXBkb3Q7XCI6XCLiio1cIixcIiZjdXBvcjtcIjpcIuKphVwiLFwiJmN1cHM7XCI6XCLiiKrvuIBcIixcIiZjdXJhcnI7XCI6XCLihrdcIixcIiZjdXJhcnJtO1wiOlwi4qS8XCIsXCImY3VybHllcXByZWM7XCI6XCLii55cIixcIiZjdXJseWVxc3VjYztcIjpcIuKLn1wiLFwiJmN1cmx5dmVlO1wiOlwi4ouOXCIsXCImY3VybHl3ZWRnZTtcIjpcIuKLj1wiLFwiJmN1cnJlblwiOlwiwqRcIixcIiZjdXJyZW47XCI6XCLCpFwiLFwiJmN1cnZlYXJyb3dsZWZ0O1wiOlwi4oa2XCIsXCImY3VydmVhcnJvd3JpZ2h0O1wiOlwi4oa3XCIsXCImY3V2ZWU7XCI6XCLii45cIixcIiZjdXdlZDtcIjpcIuKLj1wiLFwiJmN3Y29uaW50O1wiOlwi4oiyXCIsXCImY3dpbnQ7XCI6XCLiiLFcIixcIiZjeWxjdHk7XCI6XCLijK1cIixcIiZkQXJyO1wiOlwi4oeTXCIsXCImZEhhcjtcIjpcIuKlpVwiLFwiJmRhZ2dlcjtcIjpcIuKAoFwiLFwiJmRhbGV0aDtcIjpcIuKEuFwiLFwiJmRhcnI7XCI6XCLihpNcIixcIiZkYXNoO1wiOlwi4oCQXCIsXCImZGFzaHY7XCI6XCLiiqNcIixcIiZkYmthcm93O1wiOlwi4qSPXCIsXCImZGJsYWM7XCI6XCLLnVwiLFwiJmRjYXJvbjtcIjpcIsSPXCIsXCImZGN5O1wiOlwi0LRcIixcIiZkZDtcIjpcIuKFhlwiLFwiJmRkYWdnZXI7XCI6XCLigKFcIixcIiZkZGFycjtcIjpcIuKHilwiLFwiJmRkb3RzZXE7XCI6XCLiqbdcIixcIiZkZWdcIjpcIsKwXCIsXCImZGVnO1wiOlwiwrBcIixcIiZkZWx0YTtcIjpcIs60XCIsXCImZGVtcHR5djtcIjpcIuKmsVwiLFwiJmRmaXNodDtcIjpcIuKlv1wiLFwiJmRmcjtcIjpcIvCdlKFcIixcIiZkaGFybDtcIjpcIuKHg1wiLFwiJmRoYXJyO1wiOlwi4oeCXCIsXCImZGlhbTtcIjpcIuKLhFwiLFwiJmRpYW1vbmQ7XCI6XCLii4RcIixcIiZkaWFtb25kc3VpdDtcIjpcIuKZplwiLFwiJmRpYW1zO1wiOlwi4pmmXCIsXCImZGllO1wiOlwiwqhcIixcIiZkaWdhbW1hO1wiOlwiz51cIixcIiZkaXNpbjtcIjpcIuKLslwiLFwiJmRpdjtcIjpcIsO3XCIsXCImZGl2aWRlXCI6XCLDt1wiLFwiJmRpdmlkZTtcIjpcIsO3XCIsXCImZGl2aWRlb250aW1lcztcIjpcIuKLh1wiLFwiJmRpdm9ueDtcIjpcIuKLh1wiLFwiJmRqY3k7XCI6XCLRklwiLFwiJmRsY29ybjtcIjpcIuKMnlwiLFwiJmRsY3JvcDtcIjpcIuKMjVwiLFwiJmRvbGxhcjtcIjpcIiRcIixcIiZkb3BmO1wiOlwi8J2VlVwiLFwiJmRvdDtcIjpcIsuZXCIsXCImZG90ZXE7XCI6XCLiiZBcIixcIiZkb3RlcWRvdDtcIjpcIuKJkVwiLFwiJmRvdG1pbnVzO1wiOlwi4oi4XCIsXCImZG90cGx1cztcIjpcIuKIlFwiLFwiJmRvdHNxdWFyZTtcIjpcIuKKoVwiLFwiJmRvdWJsZWJhcndlZGdlO1wiOlwi4oyGXCIsXCImZG93bmFycm93O1wiOlwi4oaTXCIsXCImZG93bmRvd25hcnJvd3M7XCI6XCLih4pcIixcIiZkb3duaGFycG9vbmxlZnQ7XCI6XCLih4NcIixcIiZkb3duaGFycG9vbnJpZ2h0O1wiOlwi4oeCXCIsXCImZHJia2Fyb3c7XCI6XCLipJBcIixcIiZkcmNvcm47XCI6XCLijJ9cIixcIiZkcmNyb3A7XCI6XCLijIxcIixcIiZkc2NyO1wiOlwi8J2SuVwiLFwiJmRzY3k7XCI6XCLRlVwiLFwiJmRzb2w7XCI6XCLip7ZcIixcIiZkc3Ryb2s7XCI6XCLEkVwiLFwiJmR0ZG90O1wiOlwi4ouxXCIsXCImZHRyaTtcIjpcIuKWv1wiLFwiJmR0cmlmO1wiOlwi4pa+XCIsXCImZHVhcnI7XCI6XCLih7VcIixcIiZkdWhhcjtcIjpcIuKlr1wiLFwiJmR3YW5nbGU7XCI6XCLipqZcIixcIiZkemN5O1wiOlwi0Z9cIixcIiZkemlncmFycjtcIjpcIuKfv1wiLFwiJmVERG90O1wiOlwi4qm3XCIsXCImZURvdDtcIjpcIuKJkVwiLFwiJmVhY3V0ZVwiOlwiw6lcIixcIiZlYWN1dGU7XCI6XCLDqVwiLFwiJmVhc3RlcjtcIjpcIuKprlwiLFwiJmVjYXJvbjtcIjpcIsSbXCIsXCImZWNpcjtcIjpcIuKJllwiLFwiJmVjaXJjXCI6XCLDqlwiLFwiJmVjaXJjO1wiOlwiw6pcIixcIiZlY29sb247XCI6XCLiiZVcIixcIiZlY3k7XCI6XCLRjVwiLFwiJmVkb3Q7XCI6XCLEl1wiLFwiJmVlO1wiOlwi4oWHXCIsXCImZWZEb3Q7XCI6XCLiiZJcIixcIiZlZnI7XCI6XCLwnZSiXCIsXCImZWc7XCI6XCLiqppcIixcIiZlZ3JhdmVcIjpcIsOoXCIsXCImZWdyYXZlO1wiOlwiw6hcIixcIiZlZ3M7XCI6XCLiqpZcIixcIiZlZ3Nkb3Q7XCI6XCLiqphcIixcIiZlbDtcIjpcIuKqmVwiLFwiJmVsaW50ZXJzO1wiOlwi4o+nXCIsXCImZWxsO1wiOlwi4oSTXCIsXCImZWxzO1wiOlwi4qqVXCIsXCImZWxzZG90O1wiOlwi4qqXXCIsXCImZW1hY3I7XCI6XCLEk1wiLFwiJmVtcHR5O1wiOlwi4oiFXCIsXCImZW1wdHlzZXQ7XCI6XCLiiIVcIixcIiZlbXB0eXY7XCI6XCLiiIVcIixcIiZlbXNwMTM7XCI6XCLigIRcIixcIiZlbXNwMTQ7XCI6XCLigIVcIixcIiZlbXNwO1wiOlwi4oCDXCIsXCImZW5nO1wiOlwixYtcIixcIiZlbnNwO1wiOlwi4oCCXCIsXCImZW9nb247XCI6XCLEmVwiLFwiJmVvcGY7XCI6XCLwnZWWXCIsXCImZXBhcjtcIjpcIuKLlVwiLFwiJmVwYXJzbDtcIjpcIuKno1wiLFwiJmVwbHVzO1wiOlwi4qmxXCIsXCImZXBzaTtcIjpcIs61XCIsXCImZXBzaWxvbjtcIjpcIs61XCIsXCImZXBzaXY7XCI6XCLPtVwiLFwiJmVxY2lyYztcIjpcIuKJllwiLFwiJmVxY29sb247XCI6XCLiiZVcIixcIiZlcXNpbTtcIjpcIuKJglwiLFwiJmVxc2xhbnRndHI7XCI6XCLiqpZcIixcIiZlcXNsYW50bGVzcztcIjpcIuKqlVwiLFwiJmVxdWFscztcIjpcIj1cIixcIiZlcXVlc3Q7XCI6XCLiiZ9cIixcIiZlcXVpdjtcIjpcIuKJoVwiLFwiJmVxdWl2REQ7XCI6XCLiqbhcIixcIiZlcXZwYXJzbDtcIjpcIuKnpVwiLFwiJmVyRG90O1wiOlwi4omTXCIsXCImZXJhcnI7XCI6XCLipbFcIixcIiZlc2NyO1wiOlwi4oSvXCIsXCImZXNkb3Q7XCI6XCLiiZBcIixcIiZlc2ltO1wiOlwi4omCXCIsXCImZXRhO1wiOlwizrdcIixcIiZldGhcIjpcIsOwXCIsXCImZXRoO1wiOlwiw7BcIixcIiZldW1sXCI6XCLDq1wiLFwiJmV1bWw7XCI6XCLDq1wiLFwiJmV1cm87XCI6XCLigqxcIixcIiZleGNsO1wiOlwiIVwiLFwiJmV4aXN0O1wiOlwi4oiDXCIsXCImZXhwZWN0YXRpb247XCI6XCLihLBcIixcIiZleHBvbmVudGlhbGU7XCI6XCLihYdcIixcIiZmYWxsaW5nZG90c2VxO1wiOlwi4omSXCIsXCImZmN5O1wiOlwi0YRcIixcIiZmZW1hbGU7XCI6XCLimYBcIixcIiZmZmlsaWc7XCI6XCLvrINcIixcIiZmZmxpZztcIjpcIu+sgFwiLFwiJmZmbGxpZztcIjpcIu+shFwiLFwiJmZmcjtcIjpcIvCdlKNcIixcIiZmaWxpZztcIjpcIu+sgVwiLFwiJmZqbGlnO1wiOlwiZmpcIixcIiZmbGF0O1wiOlwi4pmtXCIsXCImZmxsaWc7XCI6XCLvrIJcIixcIiZmbHRucztcIjpcIuKWsVwiLFwiJmZub2Y7XCI6XCLGklwiLFwiJmZvcGY7XCI6XCLwnZWXXCIsXCImZm9yYWxsO1wiOlwi4oiAXCIsXCImZm9yaztcIjpcIuKLlFwiLFwiJmZvcmt2O1wiOlwi4quZXCIsXCImZnBhcnRpbnQ7XCI6XCLiqI1cIixcIiZmcmFjMTJcIjpcIsK9XCIsXCImZnJhYzEyO1wiOlwiwr1cIixcIiZmcmFjMTM7XCI6XCLihZNcIixcIiZmcmFjMTRcIjpcIsK8XCIsXCImZnJhYzE0O1wiOlwiwrxcIixcIiZmcmFjMTU7XCI6XCLihZVcIixcIiZmcmFjMTY7XCI6XCLihZlcIixcIiZmcmFjMTg7XCI6XCLihZtcIixcIiZmcmFjMjM7XCI6XCLihZRcIixcIiZmcmFjMjU7XCI6XCLihZZcIixcIiZmcmFjMzRcIjpcIsK+XCIsXCImZnJhYzM0O1wiOlwiwr5cIixcIiZmcmFjMzU7XCI6XCLihZdcIixcIiZmcmFjMzg7XCI6XCLihZxcIixcIiZmcmFjNDU7XCI6XCLihZhcIixcIiZmcmFjNTY7XCI6XCLihZpcIixcIiZmcmFjNTg7XCI6XCLihZ1cIixcIiZmcmFjNzg7XCI6XCLihZ5cIixcIiZmcmFzbDtcIjpcIuKBhFwiLFwiJmZyb3duO1wiOlwi4oyiXCIsXCImZnNjcjtcIjpcIvCdkrtcIixcIiZnRTtcIjpcIuKJp1wiLFwiJmdFbDtcIjpcIuKqjFwiLFwiJmdhY3V0ZTtcIjpcIse1XCIsXCImZ2FtbWE7XCI6XCLOs1wiLFwiJmdhbW1hZDtcIjpcIs+dXCIsXCImZ2FwO1wiOlwi4qqGXCIsXCImZ2JyZXZlO1wiOlwixJ9cIixcIiZnY2lyYztcIjpcIsSdXCIsXCImZ2N5O1wiOlwi0LNcIixcIiZnZG90O1wiOlwixKFcIixcIiZnZTtcIjpcIuKJpVwiLFwiJmdlbDtcIjpcIuKLm1wiLFwiJmdlcTtcIjpcIuKJpVwiLFwiJmdlcXE7XCI6XCLiiadcIixcIiZnZXFzbGFudDtcIjpcIuKpvlwiLFwiJmdlcztcIjpcIuKpvlwiLFwiJmdlc2NjO1wiOlwi4qqpXCIsXCImZ2VzZG90O1wiOlwi4qqAXCIsXCImZ2VzZG90bztcIjpcIuKqglwiLFwiJmdlc2RvdG9sO1wiOlwi4qqEXCIsXCImZ2VzbDtcIjpcIuKLm++4gFwiLFwiJmdlc2xlcztcIjpcIuKqlFwiLFwiJmdmcjtcIjpcIvCdlKRcIixcIiZnZztcIjpcIuKJq1wiLFwiJmdnZztcIjpcIuKLmVwiLFwiJmdpbWVsO1wiOlwi4oS3XCIsXCImZ2pjeTtcIjpcItGTXCIsXCImZ2w7XCI6XCLiibdcIixcIiZnbEU7XCI6XCLiqpJcIixcIiZnbGE7XCI6XCLiqqVcIixcIiZnbGo7XCI6XCLiqqRcIixcIiZnbkU7XCI6XCLiialcIixcIiZnbmFwO1wiOlwi4qqKXCIsXCImZ25hcHByb3g7XCI6XCLiqopcIixcIiZnbmU7XCI6XCLiqohcIixcIiZnbmVxO1wiOlwi4qqIXCIsXCImZ25lcXE7XCI6XCLiialcIixcIiZnbnNpbTtcIjpcIuKLp1wiLFwiJmdvcGY7XCI6XCLwnZWYXCIsXCImZ3JhdmU7XCI6XCJgXCIsXCImZ3NjcjtcIjpcIuKEilwiLFwiJmdzaW07XCI6XCLiibNcIixcIiZnc2ltZTtcIjpcIuKqjlwiLFwiJmdzaW1sO1wiOlwi4qqQXCIsXCImZ3RcIjpcIj5cIixcIiZndDtcIjpcIj5cIixcIiZndGNjO1wiOlwi4qqnXCIsXCImZ3RjaXI7XCI6XCLiqbpcIixcIiZndGRvdDtcIjpcIuKLl1wiLFwiJmd0bFBhcjtcIjpcIuKmlVwiLFwiJmd0cXVlc3Q7XCI6XCLiqbxcIixcIiZndHJhcHByb3g7XCI6XCLiqoZcIixcIiZndHJhcnI7XCI6XCLipbhcIixcIiZndHJkb3Q7XCI6XCLii5dcIixcIiZndHJlcWxlc3M7XCI6XCLii5tcIixcIiZndHJlcXFsZXNzO1wiOlwi4qqMXCIsXCImZ3RybGVzcztcIjpcIuKJt1wiLFwiJmd0cnNpbTtcIjpcIuKJs1wiLFwiJmd2ZXJ0bmVxcTtcIjpcIuKJqe+4gFwiLFwiJmd2bkU7XCI6XCLiianvuIBcIixcIiZoQXJyO1wiOlwi4oeUXCIsXCImaGFpcnNwO1wiOlwi4oCKXCIsXCImaGFsZjtcIjpcIsK9XCIsXCImaGFtaWx0O1wiOlwi4oSLXCIsXCImaGFyZGN5O1wiOlwi0YpcIixcIiZoYXJyO1wiOlwi4oaUXCIsXCImaGFycmNpcjtcIjpcIuKliFwiLFwiJmhhcnJ3O1wiOlwi4oatXCIsXCImaGJhcjtcIjpcIuKEj1wiLFwiJmhjaXJjO1wiOlwixKVcIixcIiZoZWFydHM7XCI6XCLimaVcIixcIiZoZWFydHN1aXQ7XCI6XCLimaVcIixcIiZoZWxsaXA7XCI6XCLigKZcIixcIiZoZXJjb247XCI6XCLiirlcIixcIiZoZnI7XCI6XCLwnZSlXCIsXCImaGtzZWFyb3c7XCI6XCLipKVcIixcIiZoa3N3YXJvdztcIjpcIuKkplwiLFwiJmhvYXJyO1wiOlwi4oe/XCIsXCImaG9tdGh0O1wiOlwi4oi7XCIsXCImaG9va2xlZnRhcnJvdztcIjpcIuKGqVwiLFwiJmhvb2tyaWdodGFycm93O1wiOlwi4oaqXCIsXCImaG9wZjtcIjpcIvCdlZlcIixcIiZob3JiYXI7XCI6XCLigJVcIixcIiZoc2NyO1wiOlwi8J2SvVwiLFwiJmhzbGFzaDtcIjpcIuKEj1wiLFwiJmhzdHJvaztcIjpcIsSnXCIsXCImaHlidWxsO1wiOlwi4oGDXCIsXCImaHlwaGVuO1wiOlwi4oCQXCIsXCImaWFjdXRlXCI6XCLDrVwiLFwiJmlhY3V0ZTtcIjpcIsOtXCIsXCImaWM7XCI6XCLigaNcIixcIiZpY2lyY1wiOlwiw65cIixcIiZpY2lyYztcIjpcIsOuXCIsXCImaWN5O1wiOlwi0LhcIixcIiZpZWN5O1wiOlwi0LVcIixcIiZpZXhjbFwiOlwiwqFcIixcIiZpZXhjbDtcIjpcIsKhXCIsXCImaWZmO1wiOlwi4oeUXCIsXCImaWZyO1wiOlwi8J2UplwiLFwiJmlncmF2ZVwiOlwiw6xcIixcIiZpZ3JhdmU7XCI6XCLDrFwiLFwiJmlpO1wiOlwi4oWIXCIsXCImaWlpaW50O1wiOlwi4qiMXCIsXCImaWlpbnQ7XCI6XCLiiK1cIixcIiZpaW5maW47XCI6XCLip5xcIixcIiZpaW90YTtcIjpcIuKEqVwiLFwiJmlqbGlnO1wiOlwixLNcIixcIiZpbWFjcjtcIjpcIsSrXCIsXCImaW1hZ2U7XCI6XCLihJFcIixcIiZpbWFnbGluZTtcIjpcIuKEkFwiLFwiJmltYWdwYXJ0O1wiOlwi4oSRXCIsXCImaW1hdGg7XCI6XCLEsVwiLFwiJmltb2Y7XCI6XCLiirdcIixcIiZpbXBlZDtcIjpcIsa1XCIsXCImaW47XCI6XCLiiIhcIixcIiZpbmNhcmU7XCI6XCLihIVcIixcIiZpbmZpbjtcIjpcIuKInlwiLFwiJmluZmludGllO1wiOlwi4qedXCIsXCImaW5vZG90O1wiOlwixLFcIixcIiZpbnQ7XCI6XCLiiKtcIixcIiZpbnRjYWw7XCI6XCLiirpcIixcIiZpbnRlZ2VycztcIjpcIuKEpFwiLFwiJmludGVyY2FsO1wiOlwi4oq6XCIsXCImaW50bGFyaGs7XCI6XCLiqJdcIixcIiZpbnRwcm9kO1wiOlwi4qi8XCIsXCImaW9jeTtcIjpcItGRXCIsXCImaW9nb247XCI6XCLEr1wiLFwiJmlvcGY7XCI6XCLwnZWaXCIsXCImaW90YTtcIjpcIs65XCIsXCImaXByb2Q7XCI6XCLiqLxcIixcIiZpcXVlc3RcIjpcIsK/XCIsXCImaXF1ZXN0O1wiOlwiwr9cIixcIiZpc2NyO1wiOlwi8J2SvlwiLFwiJmlzaW47XCI6XCLiiIhcIixcIiZpc2luRTtcIjpcIuKLuVwiLFwiJmlzaW5kb3Q7XCI6XCLii7VcIixcIiZpc2lucztcIjpcIuKLtFwiLFwiJmlzaW5zdjtcIjpcIuKLs1wiLFwiJmlzaW52O1wiOlwi4oiIXCIsXCImaXQ7XCI6XCLigaJcIixcIiZpdGlsZGU7XCI6XCLEqVwiLFwiJml1a2N5O1wiOlwi0ZZcIixcIiZpdW1sXCI6XCLDr1wiLFwiJml1bWw7XCI6XCLDr1wiLFwiJmpjaXJjO1wiOlwixLVcIixcIiZqY3k7XCI6XCLQuVwiLFwiJmpmcjtcIjpcIvCdlKdcIixcIiZqbWF0aDtcIjpcIsi3XCIsXCImam9wZjtcIjpcIvCdlZtcIixcIiZqc2NyO1wiOlwi8J2Sv1wiLFwiJmpzZXJjeTtcIjpcItGYXCIsXCImanVrY3k7XCI6XCLRlFwiLFwiJmthcHBhO1wiOlwizrpcIixcIiZrYXBwYXY7XCI6XCLPsFwiLFwiJmtjZWRpbDtcIjpcIsS3XCIsXCIma2N5O1wiOlwi0LpcIixcIiZrZnI7XCI6XCLwnZSoXCIsXCIma2dyZWVuO1wiOlwixLhcIixcIiZraGN5O1wiOlwi0YVcIixcIiZramN5O1wiOlwi0ZxcIixcIiZrb3BmO1wiOlwi8J2VnFwiLFwiJmtzY3I7XCI6XCLwnZOAXCIsXCImbEFhcnI7XCI6XCLih5pcIixcIiZsQXJyO1wiOlwi4oeQXCIsXCImbEF0YWlsO1wiOlwi4qSbXCIsXCImbEJhcnI7XCI6XCLipI5cIixcIiZsRTtcIjpcIuKJplwiLFwiJmxFZztcIjpcIuKqi1wiLFwiJmxIYXI7XCI6XCLipaJcIixcIiZsYWN1dGU7XCI6XCLEulwiLFwiJmxhZW1wdHl2O1wiOlwi4qa0XCIsXCImbGFncmFuO1wiOlwi4oSSXCIsXCImbGFtYmRhO1wiOlwizrtcIixcIiZsYW5nO1wiOlwi4p+oXCIsXCImbGFuZ2Q7XCI6XCLippFcIixcIiZsYW5nbGU7XCI6XCLin6hcIixcIiZsYXA7XCI6XCLiqoVcIixcIiZsYXF1b1wiOlwiwqtcIixcIiZsYXF1bztcIjpcIsKrXCIsXCImbGFycjtcIjpcIuKGkFwiLFwiJmxhcnJiO1wiOlwi4oekXCIsXCImbGFycmJmcztcIjpcIuKkn1wiLFwiJmxhcnJmcztcIjpcIuKknVwiLFwiJmxhcnJoaztcIjpcIuKGqVwiLFwiJmxhcnJscDtcIjpcIuKGq1wiLFwiJmxhcnJwbDtcIjpcIuKkuVwiLFwiJmxhcnJzaW07XCI6XCLipbNcIixcIiZsYXJydGw7XCI6XCLihqJcIixcIiZsYXQ7XCI6XCLiqqtcIixcIiZsYXRhaWw7XCI6XCLipJlcIixcIiZsYXRlO1wiOlwi4qqtXCIsXCImbGF0ZXM7XCI6XCLiqq3vuIBcIixcIiZsYmFycjtcIjpcIuKkjFwiLFwiJmxiYnJrO1wiOlwi4p2yXCIsXCImbGJyYWNlO1wiOlwie1wiLFwiJmxicmFjaztcIjpcIltcIixcIiZsYnJrZTtcIjpcIuKmi1wiLFwiJmxicmtzbGQ7XCI6XCLipo9cIixcIiZsYnJrc2x1O1wiOlwi4qaNXCIsXCImbGNhcm9uO1wiOlwixL5cIixcIiZsY2VkaWw7XCI6XCLEvFwiLFwiJmxjZWlsO1wiOlwi4oyIXCIsXCImbGN1YjtcIjpcIntcIixcIiZsY3k7XCI6XCLQu1wiLFwiJmxkY2E7XCI6XCLipLZcIixcIiZsZHF1bztcIjpcIuKAnFwiLFwiJmxkcXVvcjtcIjpcIuKAnlwiLFwiJmxkcmRoYXI7XCI6XCLipadcIixcIiZsZHJ1c2hhcjtcIjpcIuKli1wiLFwiJmxkc2g7XCI6XCLihrJcIixcIiZsZTtcIjpcIuKJpFwiLFwiJmxlZnRhcnJvdztcIjpcIuKGkFwiLFwiJmxlZnRhcnJvd3RhaWw7XCI6XCLihqJcIixcIiZsZWZ0aGFycG9vbmRvd247XCI6XCLihr1cIixcIiZsZWZ0aGFycG9vbnVwO1wiOlwi4oa8XCIsXCImbGVmdGxlZnRhcnJvd3M7XCI6XCLih4dcIixcIiZsZWZ0cmlnaHRhcnJvdztcIjpcIuKGlFwiLFwiJmxlZnRyaWdodGFycm93cztcIjpcIuKHhlwiLFwiJmxlZnRyaWdodGhhcnBvb25zO1wiOlwi4oeLXCIsXCImbGVmdHJpZ2h0c3F1aWdhcnJvdztcIjpcIuKGrVwiLFwiJmxlZnR0aHJlZXRpbWVzO1wiOlwi4ouLXCIsXCImbGVnO1wiOlwi4ouaXCIsXCImbGVxO1wiOlwi4omkXCIsXCImbGVxcTtcIjpcIuKJplwiLFwiJmxlcXNsYW50O1wiOlwi4qm9XCIsXCImbGVzO1wiOlwi4qm9XCIsXCImbGVzY2M7XCI6XCLiqqhcIixcIiZsZXNkb3Q7XCI6XCLiqb9cIixcIiZsZXNkb3RvO1wiOlwi4qqBXCIsXCImbGVzZG90b3I7XCI6XCLiqoNcIixcIiZsZXNnO1wiOlwi4oua77iAXCIsXCImbGVzZ2VzO1wiOlwi4qqTXCIsXCImbGVzc2FwcHJveDtcIjpcIuKqhVwiLFwiJmxlc3Nkb3Q7XCI6XCLii5ZcIixcIiZsZXNzZXFndHI7XCI6XCLii5pcIixcIiZsZXNzZXFxZ3RyO1wiOlwi4qqLXCIsXCImbGVzc2d0cjtcIjpcIuKJtlwiLFwiJmxlc3NzaW07XCI6XCLiibJcIixcIiZsZmlzaHQ7XCI6XCLipbxcIixcIiZsZmxvb3I7XCI6XCLijIpcIixcIiZsZnI7XCI6XCLwnZSpXCIsXCImbGc7XCI6XCLiibZcIixcIiZsZ0U7XCI6XCLiqpFcIixcIiZsaGFyZDtcIjpcIuKGvVwiLFwiJmxoYXJ1O1wiOlwi4oa8XCIsXCImbGhhcnVsO1wiOlwi4qWqXCIsXCImbGhibGs7XCI6XCLiloRcIixcIiZsamN5O1wiOlwi0ZlcIixcIiZsbDtcIjpcIuKJqlwiLFwiJmxsYXJyO1wiOlwi4oeHXCIsXCImbGxjb3JuZXI7XCI6XCLijJ5cIixcIiZsbGhhcmQ7XCI6XCLipatcIixcIiZsbHRyaTtcIjpcIuKXulwiLFwiJmxtaWRvdDtcIjpcIsWAXCIsXCImbG1vdXN0O1wiOlwi4o6wXCIsXCImbG1vdXN0YWNoZTtcIjpcIuKOsFwiLFwiJmxuRTtcIjpcIuKJqFwiLFwiJmxuYXA7XCI6XCLiqolcIixcIiZsbmFwcHJveDtcIjpcIuKqiVwiLFwiJmxuZTtcIjpcIuKqh1wiLFwiJmxuZXE7XCI6XCLiqodcIixcIiZsbmVxcTtcIjpcIuKJqFwiLFwiJmxuc2ltO1wiOlwi4oumXCIsXCImbG9hbmc7XCI6XCLin6xcIixcIiZsb2FycjtcIjpcIuKHvVwiLFwiJmxvYnJrO1wiOlwi4p+mXCIsXCImbG9uZ2xlZnRhcnJvdztcIjpcIuKftVwiLFwiJmxvbmdsZWZ0cmlnaHRhcnJvdztcIjpcIuKft1wiLFwiJmxvbmdtYXBzdG87XCI6XCLin7xcIixcIiZsb25ncmlnaHRhcnJvdztcIjpcIuKftlwiLFwiJmxvb3BhcnJvd2xlZnQ7XCI6XCLihqtcIixcIiZsb29wYXJyb3dyaWdodDtcIjpcIuKGrFwiLFwiJmxvcGFyO1wiOlwi4qaFXCIsXCImbG9wZjtcIjpcIvCdlZ1cIixcIiZsb3BsdXM7XCI6XCLiqK1cIixcIiZsb3RpbWVzO1wiOlwi4qi0XCIsXCImbG93YXN0O1wiOlwi4oiXXCIsXCImbG93YmFyO1wiOlwiX1wiLFwiJmxvejtcIjpcIuKXilwiLFwiJmxvemVuZ2U7XCI6XCLil4pcIixcIiZsb3pmO1wiOlwi4qerXCIsXCImbHBhcjtcIjpcIihcIixcIiZscGFybHQ7XCI6XCLippNcIixcIiZscmFycjtcIjpcIuKHhlwiLFwiJmxyY29ybmVyO1wiOlwi4oyfXCIsXCImbHJoYXI7XCI6XCLih4tcIixcIiZscmhhcmQ7XCI6XCLipa1cIixcIiZscm07XCI6XCLigI5cIixcIiZscnRyaTtcIjpcIuKKv1wiLFwiJmxzYXF1bztcIjpcIuKAuVwiLFwiJmxzY3I7XCI6XCLwnZOBXCIsXCImbHNoO1wiOlwi4oawXCIsXCImbHNpbTtcIjpcIuKJslwiLFwiJmxzaW1lO1wiOlwi4qqNXCIsXCImbHNpbWc7XCI6XCLiqo9cIixcIiZsc3FiO1wiOlwiW1wiLFwiJmxzcXVvO1wiOlwi4oCYXCIsXCImbHNxdW9yO1wiOlwi4oCaXCIsXCImbHN0cm9rO1wiOlwixYJcIixcIiZsdFwiOlwiPFwiLFwiJmx0O1wiOlwiPFwiLFwiJmx0Y2M7XCI6XCLiqqZcIixcIiZsdGNpcjtcIjpcIuKpuVwiLFwiJmx0ZG90O1wiOlwi4ouWXCIsXCImbHRocmVlO1wiOlwi4ouLXCIsXCImbHRpbWVzO1wiOlwi4ouJXCIsXCImbHRsYXJyO1wiOlwi4qW2XCIsXCImbHRxdWVzdDtcIjpcIuKpu1wiLFwiJmx0clBhcjtcIjpcIuKmllwiLFwiJmx0cmk7XCI6XCLil4NcIixcIiZsdHJpZTtcIjpcIuKKtFwiLFwiJmx0cmlmO1wiOlwi4peCXCIsXCImbHVyZHNoYXI7XCI6XCLipYpcIixcIiZsdXJ1aGFyO1wiOlwi4qWmXCIsXCImbHZlcnRuZXFxO1wiOlwi4omo77iAXCIsXCImbHZuRTtcIjpcIuKJqO+4gFwiLFwiJm1ERG90O1wiOlwi4oi6XCIsXCImbWFjclwiOlwiwq9cIixcIiZtYWNyO1wiOlwiwq9cIixcIiZtYWxlO1wiOlwi4pmCXCIsXCImbWFsdDtcIjpcIuKcoFwiLFwiJm1hbHRlc2U7XCI6XCLinKBcIixcIiZtYXA7XCI6XCLihqZcIixcIiZtYXBzdG87XCI6XCLihqZcIixcIiZtYXBzdG9kb3duO1wiOlwi4oanXCIsXCImbWFwc3RvbGVmdDtcIjpcIuKGpFwiLFwiJm1hcHN0b3VwO1wiOlwi4oalXCIsXCImbWFya2VyO1wiOlwi4pauXCIsXCImbWNvbW1hO1wiOlwi4qipXCIsXCImbWN5O1wiOlwi0LxcIixcIiZtZGFzaDtcIjpcIuKAlFwiLFwiJm1lYXN1cmVkYW5nbGU7XCI6XCLiiKFcIixcIiZtZnI7XCI6XCLwnZSqXCIsXCImbWhvO1wiOlwi4oSnXCIsXCImbWljcm9cIjpcIsK1XCIsXCImbWljcm87XCI6XCLCtVwiLFwiJm1pZDtcIjpcIuKIo1wiLFwiJm1pZGFzdDtcIjpcIipcIixcIiZtaWRjaXI7XCI6XCLiq7BcIixcIiZtaWRkb3RcIjpcIsK3XCIsXCImbWlkZG90O1wiOlwiwrdcIixcIiZtaW51cztcIjpcIuKIklwiLFwiJm1pbnVzYjtcIjpcIuKKn1wiLFwiJm1pbnVzZDtcIjpcIuKIuFwiLFwiJm1pbnVzZHU7XCI6XCLiqKpcIixcIiZtbGNwO1wiOlwi4qubXCIsXCImbWxkcjtcIjpcIuKAplwiLFwiJm1ucGx1cztcIjpcIuKIk1wiLFwiJm1vZGVscztcIjpcIuKKp1wiLFwiJm1vcGY7XCI6XCLwnZWeXCIsXCImbXA7XCI6XCLiiJNcIixcIiZtc2NyO1wiOlwi8J2TglwiLFwiJm1zdHBvcztcIjpcIuKIvlwiLFwiJm11O1wiOlwizrxcIixcIiZtdWx0aW1hcDtcIjpcIuKKuFwiLFwiJm11bWFwO1wiOlwi4oq4XCIsXCImbkdnO1wiOlwi4ouZzLhcIixcIiZuR3Q7XCI6XCLiiavig5JcIixcIiZuR3R2O1wiOlwi4omrzLhcIixcIiZuTGVmdGFycm93O1wiOlwi4oeNXCIsXCImbkxlZnRyaWdodGFycm93O1wiOlwi4oeOXCIsXCImbkxsO1wiOlwi4ouYzLhcIixcIiZuTHQ7XCI6XCLiiarig5JcIixcIiZuTHR2O1wiOlwi4omqzLhcIixcIiZuUmlnaHRhcnJvdztcIjpcIuKHj1wiLFwiJm5WRGFzaDtcIjpcIuKKr1wiLFwiJm5WZGFzaDtcIjpcIuKKrlwiLFwiJm5hYmxhO1wiOlwi4oiHXCIsXCImbmFjdXRlO1wiOlwixYRcIixcIiZuYW5nO1wiOlwi4oig4oOSXCIsXCImbmFwO1wiOlwi4omJXCIsXCImbmFwRTtcIjpcIuKpsMy4XCIsXCImbmFwaWQ7XCI6XCLiiYvMuFwiLFwiJm5hcG9zO1wiOlwixYlcIixcIiZuYXBwcm94O1wiOlwi4omJXCIsXCImbmF0dXI7XCI6XCLima5cIixcIiZuYXR1cmFsO1wiOlwi4pmuXCIsXCImbmF0dXJhbHM7XCI6XCLihJVcIixcIiZuYnNwXCI6XCLCoFwiLFwiJm5ic3A7XCI6XCLCoFwiLFwiJm5idW1wO1wiOlwi4omOzLhcIixcIiZuYnVtcGU7XCI6XCLiiY/MuFwiLFwiJm5jYXA7XCI6XCLiqYNcIixcIiZuY2Fyb247XCI6XCLFiFwiLFwiJm5jZWRpbDtcIjpcIsWGXCIsXCImbmNvbmc7XCI6XCLiiYdcIixcIiZuY29uZ2RvdDtcIjpcIuKprcy4XCIsXCImbmN1cDtcIjpcIuKpglwiLFwiJm5jeTtcIjpcItC9XCIsXCImbmRhc2g7XCI6XCLigJNcIixcIiZuZTtcIjpcIuKJoFwiLFwiJm5lQXJyO1wiOlwi4oeXXCIsXCImbmVhcmhrO1wiOlwi4qSkXCIsXCImbmVhcnI7XCI6XCLihpdcIixcIiZuZWFycm93O1wiOlwi4oaXXCIsXCImbmVkb3Q7XCI6XCLiiZDMuFwiLFwiJm5lcXVpdjtcIjpcIuKJolwiLFwiJm5lc2VhcjtcIjpcIuKkqFwiLFwiJm5lc2ltO1wiOlwi4omCzLhcIixcIiZuZXhpc3Q7XCI6XCLiiIRcIixcIiZuZXhpc3RzO1wiOlwi4oiEXCIsXCImbmZyO1wiOlwi8J2Uq1wiLFwiJm5nRTtcIjpcIuKJp8y4XCIsXCImbmdlO1wiOlwi4omxXCIsXCImbmdlcTtcIjpcIuKJsVwiLFwiJm5nZXFxO1wiOlwi4omnzLhcIixcIiZuZ2Vxc2xhbnQ7XCI6XCLiqb7MuFwiLFwiJm5nZXM7XCI6XCLiqb7MuFwiLFwiJm5nc2ltO1wiOlwi4om1XCIsXCImbmd0O1wiOlwi4omvXCIsXCImbmd0cjtcIjpcIuKJr1wiLFwiJm5oQXJyO1wiOlwi4oeOXCIsXCImbmhhcnI7XCI6XCLihq5cIixcIiZuaHBhcjtcIjpcIuKrslwiLFwiJm5pO1wiOlwi4oiLXCIsXCImbmlzO1wiOlwi4ou8XCIsXCImbmlzZDtcIjpcIuKLulwiLFwiJm5pdjtcIjpcIuKIi1wiLFwiJm5qY3k7XCI6XCLRmlwiLFwiJm5sQXJyO1wiOlwi4oeNXCIsXCImbmxFO1wiOlwi4ommzLhcIixcIiZubGFycjtcIjpcIuKGmlwiLFwiJm5sZHI7XCI6XCLigKVcIixcIiZubGU7XCI6XCLiibBcIixcIiZubGVmdGFycm93O1wiOlwi4oaaXCIsXCImbmxlZnRyaWdodGFycm93O1wiOlwi4oauXCIsXCImbmxlcTtcIjpcIuKJsFwiLFwiJm5sZXFxO1wiOlwi4ommzLhcIixcIiZubGVxc2xhbnQ7XCI6XCLiqb3MuFwiLFwiJm5sZXM7XCI6XCLiqb3MuFwiLFwiJm5sZXNzO1wiOlwi4omuXCIsXCImbmxzaW07XCI6XCLiibRcIixcIiZubHQ7XCI6XCLiia5cIixcIiZubHRyaTtcIjpcIuKLqlwiLFwiJm5sdHJpZTtcIjpcIuKLrFwiLFwiJm5taWQ7XCI6XCLiiKRcIixcIiZub3BmO1wiOlwi8J2Vn1wiLFwiJm5vdFwiOlwiwqxcIixcIiZub3Q7XCI6XCLCrFwiLFwiJm5vdGluO1wiOlwi4oiJXCIsXCImbm90aW5FO1wiOlwi4ou5zLhcIixcIiZub3RpbmRvdDtcIjpcIuKLtcy4XCIsXCImbm90aW52YTtcIjpcIuKIiVwiLFwiJm5vdGludmI7XCI6XCLii7dcIixcIiZub3RpbnZjO1wiOlwi4ou2XCIsXCImbm90bmk7XCI6XCLiiIxcIixcIiZub3RuaXZhO1wiOlwi4oiMXCIsXCImbm90bml2YjtcIjpcIuKLvlwiLFwiJm5vdG5pdmM7XCI6XCLii71cIixcIiZucGFyO1wiOlwi4oimXCIsXCImbnBhcmFsbGVsO1wiOlwi4oimXCIsXCImbnBhcnNsO1wiOlwi4qu94oOlXCIsXCImbnBhcnQ7XCI6XCLiiILMuFwiLFwiJm5wb2xpbnQ7XCI6XCLiqJRcIixcIiZucHI7XCI6XCLiioBcIixcIiZucHJjdWU7XCI6XCLii6BcIixcIiZucHJlO1wiOlwi4qqvzLhcIixcIiZucHJlYztcIjpcIuKKgFwiLFwiJm5wcmVjZXE7XCI6XCLiqq/MuFwiLFwiJm5yQXJyO1wiOlwi4oePXCIsXCImbnJhcnI7XCI6XCLihptcIixcIiZucmFycmM7XCI6XCLipLPMuFwiLFwiJm5yYXJydztcIjpcIuKGncy4XCIsXCImbnJpZ2h0YXJyb3c7XCI6XCLihptcIixcIiZucnRyaTtcIjpcIuKLq1wiLFwiJm5ydHJpZTtcIjpcIuKLrVwiLFwiJm5zYztcIjpcIuKKgVwiLFwiJm5zY2N1ZTtcIjpcIuKLoVwiLFwiJm5zY2U7XCI6XCLiqrDMuFwiLFwiJm5zY3I7XCI6XCLwnZODXCIsXCImbnNob3J0bWlkO1wiOlwi4oikXCIsXCImbnNob3J0cGFyYWxsZWw7XCI6XCLiiKZcIixcIiZuc2ltO1wiOlwi4omBXCIsXCImbnNpbWU7XCI6XCLiiYRcIixcIiZuc2ltZXE7XCI6XCLiiYRcIixcIiZuc21pZDtcIjpcIuKIpFwiLFwiJm5zcGFyO1wiOlwi4oimXCIsXCImbnNxc3ViZTtcIjpcIuKLolwiLFwiJm5zcXN1cGU7XCI6XCLii6NcIixcIiZuc3ViO1wiOlwi4oqEXCIsXCImbnN1YkU7XCI6XCLiq4XMuFwiLFwiJm5zdWJlO1wiOlwi4oqIXCIsXCImbnN1YnNldDtcIjpcIuKKguKDklwiLFwiJm5zdWJzZXRlcTtcIjpcIuKKiFwiLFwiJm5zdWJzZXRlcXE7XCI6XCLiq4XMuFwiLFwiJm5zdWNjO1wiOlwi4oqBXCIsXCImbnN1Y2NlcTtcIjpcIuKqsMy4XCIsXCImbnN1cDtcIjpcIuKKhVwiLFwiJm5zdXBFO1wiOlwi4quGzLhcIixcIiZuc3VwZTtcIjpcIuKKiVwiLFwiJm5zdXBzZXQ7XCI6XCLiioPig5JcIixcIiZuc3Vwc2V0ZXE7XCI6XCLiiolcIixcIiZuc3Vwc2V0ZXFxO1wiOlwi4quGzLhcIixcIiZudGdsO1wiOlwi4om5XCIsXCImbnRpbGRlXCI6XCLDsVwiLFwiJm50aWxkZTtcIjpcIsOxXCIsXCImbnRsZztcIjpcIuKJuFwiLFwiJm50cmlhbmdsZWxlZnQ7XCI6XCLii6pcIixcIiZudHJpYW5nbGVsZWZ0ZXE7XCI6XCLii6xcIixcIiZudHJpYW5nbGVyaWdodDtcIjpcIuKLq1wiLFwiJm50cmlhbmdsZXJpZ2h0ZXE7XCI6XCLii61cIixcIiZudTtcIjpcIs69XCIsXCImbnVtO1wiOlwiI1wiLFwiJm51bWVybztcIjpcIuKEllwiLFwiJm51bXNwO1wiOlwi4oCHXCIsXCImbnZEYXNoO1wiOlwi4oqtXCIsXCImbnZIYXJyO1wiOlwi4qSEXCIsXCImbnZhcDtcIjpcIuKJjeKDklwiLFwiJm52ZGFzaDtcIjpcIuKKrFwiLFwiJm52Z2U7XCI6XCLiiaXig5JcIixcIiZudmd0O1wiOlwiPuKDklwiLFwiJm52aW5maW47XCI6XCLip55cIixcIiZudmxBcnI7XCI6XCLipIJcIixcIiZudmxlO1wiOlwi4omk4oOSXCIsXCImbnZsdDtcIjpcIjzig5JcIixcIiZudmx0cmllO1wiOlwi4oq04oOSXCIsXCImbnZyQXJyO1wiOlwi4qSDXCIsXCImbnZydHJpZTtcIjpcIuKKteKDklwiLFwiJm52c2ltO1wiOlwi4oi84oOSXCIsXCImbndBcnI7XCI6XCLih5ZcIixcIiZud2FyaGs7XCI6XCLipKNcIixcIiZud2FycjtcIjpcIuKGllwiLFwiJm53YXJyb3c7XCI6XCLihpZcIixcIiZud25lYXI7XCI6XCLipKdcIixcIiZvUztcIjpcIuKTiFwiLFwiJm9hY3V0ZVwiOlwiw7NcIixcIiZvYWN1dGU7XCI6XCLDs1wiLFwiJm9hc3Q7XCI6XCLiiptcIixcIiZvY2lyO1wiOlwi4oqaXCIsXCImb2NpcmNcIjpcIsO0XCIsXCImb2NpcmM7XCI6XCLDtFwiLFwiJm9jeTtcIjpcItC+XCIsXCImb2Rhc2g7XCI6XCLiip1cIixcIiZvZGJsYWM7XCI6XCLFkVwiLFwiJm9kaXY7XCI6XCLiqLhcIixcIiZvZG90O1wiOlwi4oqZXCIsXCImb2Rzb2xkO1wiOlwi4qa8XCIsXCImb2VsaWc7XCI6XCLFk1wiLFwiJm9mY2lyO1wiOlwi4qa/XCIsXCImb2ZyO1wiOlwi8J2UrFwiLFwiJm9nb247XCI6XCLLm1wiLFwiJm9ncmF2ZVwiOlwiw7JcIixcIiZvZ3JhdmU7XCI6XCLDslwiLFwiJm9ndDtcIjpcIuKngVwiLFwiJm9oYmFyO1wiOlwi4qa1XCIsXCImb2htO1wiOlwizqlcIixcIiZvaW50O1wiOlwi4oiuXCIsXCImb2xhcnI7XCI6XCLihrpcIixcIiZvbGNpcjtcIjpcIuKmvlwiLFwiJm9sY3Jvc3M7XCI6XCLiprtcIixcIiZvbGluZTtcIjpcIuKAvlwiLFwiJm9sdDtcIjpcIuKngFwiLFwiJm9tYWNyO1wiOlwixY1cIixcIiZvbWVnYTtcIjpcIs+JXCIsXCImb21pY3JvbjtcIjpcIs6/XCIsXCImb21pZDtcIjpcIuKmtlwiLFwiJm9taW51cztcIjpcIuKKllwiLFwiJm9vcGY7XCI6XCLwnZWgXCIsXCImb3BhcjtcIjpcIuKmt1wiLFwiJm9wZXJwO1wiOlwi4qa5XCIsXCImb3BsdXM7XCI6XCLiipVcIixcIiZvcjtcIjpcIuKIqFwiLFwiJm9yYXJyO1wiOlwi4oa7XCIsXCImb3JkO1wiOlwi4qmdXCIsXCImb3JkZXI7XCI6XCLihLRcIixcIiZvcmRlcm9mO1wiOlwi4oS0XCIsXCImb3JkZlwiOlwiwqpcIixcIiZvcmRmO1wiOlwiwqpcIixcIiZvcmRtXCI6XCLCulwiLFwiJm9yZG07XCI6XCLCulwiLFwiJm9yaWdvZjtcIjpcIuKKtlwiLFwiJm9yb3I7XCI6XCLiqZZcIixcIiZvcnNsb3BlO1wiOlwi4qmXXCIsXCImb3J2O1wiOlwi4qmbXCIsXCImb3NjcjtcIjpcIuKEtFwiLFwiJm9zbGFzaFwiOlwiw7hcIixcIiZvc2xhc2g7XCI6XCLDuFwiLFwiJm9zb2w7XCI6XCLiiphcIixcIiZvdGlsZGVcIjpcIsO1XCIsXCImb3RpbGRlO1wiOlwiw7VcIixcIiZvdGltZXM7XCI6XCLiipdcIixcIiZvdGltZXNhcztcIjpcIuKotlwiLFwiJm91bWxcIjpcIsO2XCIsXCImb3VtbDtcIjpcIsO2XCIsXCImb3ZiYXI7XCI6XCLijL1cIixcIiZwYXI7XCI6XCLiiKVcIixcIiZwYXJhXCI6XCLCtlwiLFwiJnBhcmE7XCI6XCLCtlwiLFwiJnBhcmFsbGVsO1wiOlwi4oilXCIsXCImcGFyc2ltO1wiOlwi4quzXCIsXCImcGFyc2w7XCI6XCLiq71cIixcIiZwYXJ0O1wiOlwi4oiCXCIsXCImcGN5O1wiOlwi0L9cIixcIiZwZXJjbnQ7XCI6XCIlXCIsXCImcGVyaW9kO1wiOlwiLlwiLFwiJnBlcm1pbDtcIjpcIuKAsFwiLFwiJnBlcnA7XCI6XCLiiqVcIixcIiZwZXJ0ZW5rO1wiOlwi4oCxXCIsXCImcGZyO1wiOlwi8J2UrVwiLFwiJnBoaTtcIjpcIs+GXCIsXCImcGhpdjtcIjpcIs+VXCIsXCImcGhtbWF0O1wiOlwi4oSzXCIsXCImcGhvbmU7XCI6XCLimI5cIixcIiZwaTtcIjpcIs+AXCIsXCImcGl0Y2hmb3JrO1wiOlwi4ouUXCIsXCImcGl2O1wiOlwiz5ZcIixcIiZwbGFuY2s7XCI6XCLihI9cIixcIiZwbGFuY2toO1wiOlwi4oSOXCIsXCImcGxhbmt2O1wiOlwi4oSPXCIsXCImcGx1cztcIjpcIitcIixcIiZwbHVzYWNpcjtcIjpcIuKoo1wiLFwiJnBsdXNiO1wiOlwi4oqeXCIsXCImcGx1c2NpcjtcIjpcIuKoolwiLFwiJnBsdXNkbztcIjpcIuKIlFwiLFwiJnBsdXNkdTtcIjpcIuKopVwiLFwiJnBsdXNlO1wiOlwi4qmyXCIsXCImcGx1c21uXCI6XCLCsVwiLFwiJnBsdXNtbjtcIjpcIsKxXCIsXCImcGx1c3NpbTtcIjpcIuKoplwiLFwiJnBsdXN0d287XCI6XCLiqKdcIixcIiZwbTtcIjpcIsKxXCIsXCImcG9pbnRpbnQ7XCI6XCLiqJVcIixcIiZwb3BmO1wiOlwi8J2VoVwiLFwiJnBvdW5kXCI6XCLCo1wiLFwiJnBvdW5kO1wiOlwiwqNcIixcIiZwcjtcIjpcIuKJulwiLFwiJnByRTtcIjpcIuKqs1wiLFwiJnByYXA7XCI6XCLiqrdcIixcIiZwcmN1ZTtcIjpcIuKJvFwiLFwiJnByZTtcIjpcIuKqr1wiLFwiJnByZWM7XCI6XCLiibpcIixcIiZwcmVjYXBwcm94O1wiOlwi4qq3XCIsXCImcHJlY2N1cmx5ZXE7XCI6XCLiibxcIixcIiZwcmVjZXE7XCI6XCLiqq9cIixcIiZwcmVjbmFwcHJveDtcIjpcIuKquVwiLFwiJnByZWNuZXFxO1wiOlwi4qq1XCIsXCImcHJlY25zaW07XCI6XCLii6hcIixcIiZwcmVjc2ltO1wiOlwi4om+XCIsXCImcHJpbWU7XCI6XCLigLJcIixcIiZwcmltZXM7XCI6XCLihJlcIixcIiZwcm5FO1wiOlwi4qq1XCIsXCImcHJuYXA7XCI6XCLiqrlcIixcIiZwcm5zaW07XCI6XCLii6hcIixcIiZwcm9kO1wiOlwi4oiPXCIsXCImcHJvZmFsYXI7XCI6XCLijK5cIixcIiZwcm9mbGluZTtcIjpcIuKMklwiLFwiJnByb2ZzdXJmO1wiOlwi4oyTXCIsXCImcHJvcDtcIjpcIuKInVwiLFwiJnByb3B0bztcIjpcIuKInVwiLFwiJnByc2ltO1wiOlwi4om+XCIsXCImcHJ1cmVsO1wiOlwi4oqwXCIsXCImcHNjcjtcIjpcIvCdk4VcIixcIiZwc2k7XCI6XCLPiFwiLFwiJnB1bmNzcDtcIjpcIuKAiFwiLFwiJnFmcjtcIjpcIvCdlK5cIixcIiZxaW50O1wiOlwi4qiMXCIsXCImcW9wZjtcIjpcIvCdlaJcIixcIiZxcHJpbWU7XCI6XCLigZdcIixcIiZxc2NyO1wiOlwi8J2ThlwiLFwiJnF1YXRlcm5pb25zO1wiOlwi4oSNXCIsXCImcXVhdGludDtcIjpcIuKollwiLFwiJnF1ZXN0O1wiOlwiP1wiLFwiJnF1ZXN0ZXE7XCI6XCLiiZ9cIixcIiZxdW90XCI6J1wiJyxcIiZxdW90O1wiOidcIicsXCImckFhcnI7XCI6XCLih5tcIixcIiZyQXJyO1wiOlwi4oeSXCIsXCImckF0YWlsO1wiOlwi4qScXCIsXCImckJhcnI7XCI6XCLipI9cIixcIiZySGFyO1wiOlwi4qWkXCIsXCImcmFjZTtcIjpcIuKIvcyxXCIsXCImcmFjdXRlO1wiOlwixZVcIixcIiZyYWRpYztcIjpcIuKImlwiLFwiJnJhZW1wdHl2O1wiOlwi4qazXCIsXCImcmFuZztcIjpcIuKfqVwiLFwiJnJhbmdkO1wiOlwi4qaSXCIsXCImcmFuZ2U7XCI6XCLipqVcIixcIiZyYW5nbGU7XCI6XCLin6lcIixcIiZyYXF1b1wiOlwiwrtcIixcIiZyYXF1bztcIjpcIsK7XCIsXCImcmFycjtcIjpcIuKGklwiLFwiJnJhcnJhcDtcIjpcIuKltVwiLFwiJnJhcnJiO1wiOlwi4oelXCIsXCImcmFycmJmcztcIjpcIuKkoFwiLFwiJnJhcnJjO1wiOlwi4qSzXCIsXCImcmFycmZzO1wiOlwi4qSeXCIsXCImcmFycmhrO1wiOlwi4oaqXCIsXCImcmFycmxwO1wiOlwi4oasXCIsXCImcmFycnBsO1wiOlwi4qWFXCIsXCImcmFycnNpbTtcIjpcIuKltFwiLFwiJnJhcnJ0bDtcIjpcIuKGo1wiLFwiJnJhcnJ3O1wiOlwi4oadXCIsXCImcmF0YWlsO1wiOlwi4qSaXCIsXCImcmF0aW87XCI6XCLiiLZcIixcIiZyYXRpb25hbHM7XCI6XCLihJpcIixcIiZyYmFycjtcIjpcIuKkjVwiLFwiJnJiYnJrO1wiOlwi4p2zXCIsXCImcmJyYWNlO1wiOlwifVwiLFwiJnJicmFjaztcIjpcIl1cIixcIiZyYnJrZTtcIjpcIuKmjFwiLFwiJnJicmtzbGQ7XCI6XCLipo5cIixcIiZyYnJrc2x1O1wiOlwi4qaQXCIsXCImcmNhcm9uO1wiOlwixZlcIixcIiZyY2VkaWw7XCI6XCLFl1wiLFwiJnJjZWlsO1wiOlwi4oyJXCIsXCImcmN1YjtcIjpcIn1cIixcIiZyY3k7XCI6XCLRgFwiLFwiJnJkY2E7XCI6XCLipLdcIixcIiZyZGxkaGFyO1wiOlwi4qWpXCIsXCImcmRxdW87XCI6XCLigJ1cIixcIiZyZHF1b3I7XCI6XCLigJ1cIixcIiZyZHNoO1wiOlwi4oazXCIsXCImcmVhbDtcIjpcIuKEnFwiLFwiJnJlYWxpbmU7XCI6XCLihJtcIixcIiZyZWFscGFydDtcIjpcIuKEnFwiLFwiJnJlYWxzO1wiOlwi4oSdXCIsXCImcmVjdDtcIjpcIuKWrVwiLFwiJnJlZ1wiOlwiwq5cIixcIiZyZWc7XCI6XCLCrlwiLFwiJnJmaXNodDtcIjpcIuKlvVwiLFwiJnJmbG9vcjtcIjpcIuKMi1wiLFwiJnJmcjtcIjpcIvCdlK9cIixcIiZyaGFyZDtcIjpcIuKHgVwiLFwiJnJoYXJ1O1wiOlwi4oeAXCIsXCImcmhhcnVsO1wiOlwi4qWsXCIsXCImcmhvO1wiOlwiz4FcIixcIiZyaG92O1wiOlwiz7FcIixcIiZyaWdodGFycm93O1wiOlwi4oaSXCIsXCImcmlnaHRhcnJvd3RhaWw7XCI6XCLihqNcIixcIiZyaWdodGhhcnBvb25kb3duO1wiOlwi4oeBXCIsXCImcmlnaHRoYXJwb29udXA7XCI6XCLih4BcIixcIiZyaWdodGxlZnRhcnJvd3M7XCI6XCLih4RcIixcIiZyaWdodGxlZnRoYXJwb29ucztcIjpcIuKHjFwiLFwiJnJpZ2h0cmlnaHRhcnJvd3M7XCI6XCLih4lcIixcIiZyaWdodHNxdWlnYXJyb3c7XCI6XCLihp1cIixcIiZyaWdodHRocmVldGltZXM7XCI6XCLii4xcIixcIiZyaW5nO1wiOlwiy5pcIixcIiZyaXNpbmdkb3RzZXE7XCI6XCLiiZNcIixcIiZybGFycjtcIjpcIuKHhFwiLFwiJnJsaGFyO1wiOlwi4oeMXCIsXCImcmxtO1wiOlwi4oCPXCIsXCImcm1vdXN0O1wiOlwi4o6xXCIsXCImcm1vdXN0YWNoZTtcIjpcIuKOsVwiLFwiJnJubWlkO1wiOlwi4quuXCIsXCImcm9hbmc7XCI6XCLin61cIixcIiZyb2FycjtcIjpcIuKHvlwiLFwiJnJvYnJrO1wiOlwi4p+nXCIsXCImcm9wYXI7XCI6XCLipoZcIixcIiZyb3BmO1wiOlwi8J2Vo1wiLFwiJnJvcGx1cztcIjpcIuKorlwiLFwiJnJvdGltZXM7XCI6XCLiqLVcIixcIiZycGFyO1wiOlwiKVwiLFwiJnJwYXJndDtcIjpcIuKmlFwiLFwiJnJwcG9saW50O1wiOlwi4qiSXCIsXCImcnJhcnI7XCI6XCLih4lcIixcIiZyc2FxdW87XCI6XCLigLpcIixcIiZyc2NyO1wiOlwi8J2Th1wiLFwiJnJzaDtcIjpcIuKGsVwiLFwiJnJzcWI7XCI6XCJdXCIsXCImcnNxdW87XCI6XCLigJlcIixcIiZyc3F1b3I7XCI6XCLigJlcIixcIiZydGhyZWU7XCI6XCLii4xcIixcIiZydGltZXM7XCI6XCLii4pcIixcIiZydHJpO1wiOlwi4pa5XCIsXCImcnRyaWU7XCI6XCLiirVcIixcIiZydHJpZjtcIjpcIuKWuFwiLFwiJnJ0cmlsdHJpO1wiOlwi4qeOXCIsXCImcnVsdWhhcjtcIjpcIuKlqFwiLFwiJnJ4O1wiOlwi4oSeXCIsXCImc2FjdXRlO1wiOlwixZtcIixcIiZzYnF1bztcIjpcIuKAmlwiLFwiJnNjO1wiOlwi4om7XCIsXCImc2NFO1wiOlwi4qq0XCIsXCImc2NhcDtcIjpcIuKquFwiLFwiJnNjYXJvbjtcIjpcIsWhXCIsXCImc2NjdWU7XCI6XCLiib1cIixcIiZzY2U7XCI6XCLiqrBcIixcIiZzY2VkaWw7XCI6XCLFn1wiLFwiJnNjaXJjO1wiOlwixZ1cIixcIiZzY25FO1wiOlwi4qq2XCIsXCImc2NuYXA7XCI6XCLiqrpcIixcIiZzY25zaW07XCI6XCLii6lcIixcIiZzY3BvbGludDtcIjpcIuKok1wiLFwiJnNjc2ltO1wiOlwi4om/XCIsXCImc2N5O1wiOlwi0YFcIixcIiZzZG90O1wiOlwi4ouFXCIsXCImc2RvdGI7XCI6XCLiiqFcIixcIiZzZG90ZTtcIjpcIuKpplwiLFwiJnNlQXJyO1wiOlwi4oeYXCIsXCImc2VhcmhrO1wiOlwi4qSlXCIsXCImc2VhcnI7XCI6XCLihphcIixcIiZzZWFycm93O1wiOlwi4oaYXCIsXCImc2VjdFwiOlwiwqdcIixcIiZzZWN0O1wiOlwiwqdcIixcIiZzZW1pO1wiOlwiO1wiLFwiJnNlc3dhcjtcIjpcIuKkqVwiLFwiJnNldG1pbnVzO1wiOlwi4oiWXCIsXCImc2V0bW47XCI6XCLiiJZcIixcIiZzZXh0O1wiOlwi4py2XCIsXCImc2ZyO1wiOlwi8J2UsFwiLFwiJnNmcm93bjtcIjpcIuKMolwiLFwiJnNoYXJwO1wiOlwi4pmvXCIsXCImc2hjaGN5O1wiOlwi0YlcIixcIiZzaGN5O1wiOlwi0YhcIixcIiZzaG9ydG1pZDtcIjpcIuKIo1wiLFwiJnNob3J0cGFyYWxsZWw7XCI6XCLiiKVcIixcIiZzaHlcIjpcIsKtXCIsXCImc2h5O1wiOlwiwq1cIixcIiZzaWdtYTtcIjpcIs+DXCIsXCImc2lnbWFmO1wiOlwiz4JcIixcIiZzaWdtYXY7XCI6XCLPglwiLFwiJnNpbTtcIjpcIuKIvFwiLFwiJnNpbWRvdDtcIjpcIuKpqlwiLFwiJnNpbWU7XCI6XCLiiYNcIixcIiZzaW1lcTtcIjpcIuKJg1wiLFwiJnNpbWc7XCI6XCLiqp5cIixcIiZzaW1nRTtcIjpcIuKqoFwiLFwiJnNpbWw7XCI6XCLiqp1cIixcIiZzaW1sRTtcIjpcIuKqn1wiLFwiJnNpbW5lO1wiOlwi4omGXCIsXCImc2ltcGx1cztcIjpcIuKopFwiLFwiJnNpbXJhcnI7XCI6XCLipbJcIixcIiZzbGFycjtcIjpcIuKGkFwiLFwiJnNtYWxsc2V0bWludXM7XCI6XCLiiJZcIixcIiZzbWFzaHA7XCI6XCLiqLNcIixcIiZzbWVwYXJzbDtcIjpcIuKnpFwiLFwiJnNtaWQ7XCI6XCLiiKNcIixcIiZzbWlsZTtcIjpcIuKMo1wiLFwiJnNtdDtcIjpcIuKqqlwiLFwiJnNtdGU7XCI6XCLiqqxcIixcIiZzbXRlcztcIjpcIuKqrO+4gFwiLFwiJnNvZnRjeTtcIjpcItGMXCIsXCImc29sO1wiOlwiL1wiLFwiJnNvbGI7XCI6XCLip4RcIixcIiZzb2xiYXI7XCI6XCLijL9cIixcIiZzb3BmO1wiOlwi8J2VpFwiLFwiJnNwYWRlcztcIjpcIuKZoFwiLFwiJnNwYWRlc3VpdDtcIjpcIuKZoFwiLFwiJnNwYXI7XCI6XCLiiKVcIixcIiZzcWNhcDtcIjpcIuKKk1wiLFwiJnNxY2FwcztcIjpcIuKKk++4gFwiLFwiJnNxY3VwO1wiOlwi4oqUXCIsXCImc3FjdXBzO1wiOlwi4oqU77iAXCIsXCImc3FzdWI7XCI6XCLiio9cIixcIiZzcXN1YmU7XCI6XCLiipFcIixcIiZzcXN1YnNldDtcIjpcIuKKj1wiLFwiJnNxc3Vic2V0ZXE7XCI6XCLiipFcIixcIiZzcXN1cDtcIjpcIuKKkFwiLFwiJnNxc3VwZTtcIjpcIuKKklwiLFwiJnNxc3Vwc2V0O1wiOlwi4oqQXCIsXCImc3FzdXBzZXRlcTtcIjpcIuKKklwiLFwiJnNxdTtcIjpcIuKWoVwiLFwiJnNxdWFyZTtcIjpcIuKWoVwiLFwiJnNxdWFyZjtcIjpcIuKWqlwiLFwiJnNxdWY7XCI6XCLilqpcIixcIiZzcmFycjtcIjpcIuKGklwiLFwiJnNzY3I7XCI6XCLwnZOIXCIsXCImc3NldG1uO1wiOlwi4oiWXCIsXCImc3NtaWxlO1wiOlwi4oyjXCIsXCImc3N0YXJmO1wiOlwi4ouGXCIsXCImc3RhcjtcIjpcIuKYhlwiLFwiJnN0YXJmO1wiOlwi4piFXCIsXCImc3RyYWlnaHRlcHNpbG9uO1wiOlwiz7VcIixcIiZzdHJhaWdodHBoaTtcIjpcIs+VXCIsXCImc3RybnM7XCI6XCLCr1wiLFwiJnN1YjtcIjpcIuKKglwiLFwiJnN1YkU7XCI6XCLiq4VcIixcIiZzdWJkb3Q7XCI6XCLiqr1cIixcIiZzdWJlO1wiOlwi4oqGXCIsXCImc3ViZWRvdDtcIjpcIuKrg1wiLFwiJnN1Ym11bHQ7XCI6XCLiq4FcIixcIiZzdWJuRTtcIjpcIuKri1wiLFwiJnN1Ym5lO1wiOlwi4oqKXCIsXCImc3VicGx1cztcIjpcIuKqv1wiLFwiJnN1YnJhcnI7XCI6XCLipblcIixcIiZzdWJzZXQ7XCI6XCLiioJcIixcIiZzdWJzZXRlcTtcIjpcIuKKhlwiLFwiJnN1YnNldGVxcTtcIjpcIuKrhVwiLFwiJnN1YnNldG5lcTtcIjpcIuKKilwiLFwiJnN1YnNldG5lcXE7XCI6XCLiq4tcIixcIiZzdWJzaW07XCI6XCLiq4dcIixcIiZzdWJzdWI7XCI6XCLiq5VcIixcIiZzdWJzdXA7XCI6XCLiq5NcIixcIiZzdWNjO1wiOlwi4om7XCIsXCImc3VjY2FwcHJveDtcIjpcIuKquFwiLFwiJnN1Y2NjdXJseWVxO1wiOlwi4om9XCIsXCImc3VjY2VxO1wiOlwi4qqwXCIsXCImc3VjY25hcHByb3g7XCI6XCLiqrpcIixcIiZzdWNjbmVxcTtcIjpcIuKqtlwiLFwiJnN1Y2Nuc2ltO1wiOlwi4oupXCIsXCImc3VjY3NpbTtcIjpcIuKJv1wiLFwiJnN1bTtcIjpcIuKIkVwiLFwiJnN1bmc7XCI6XCLimapcIixcIiZzdXAxXCI6XCLCuVwiLFwiJnN1cDE7XCI6XCLCuVwiLFwiJnN1cDJcIjpcIsKyXCIsXCImc3VwMjtcIjpcIsKyXCIsXCImc3VwM1wiOlwiwrNcIixcIiZzdXAzO1wiOlwiwrNcIixcIiZzdXA7XCI6XCLiioNcIixcIiZzdXBFO1wiOlwi4quGXCIsXCImc3VwZG90O1wiOlwi4qq+XCIsXCImc3VwZHN1YjtcIjpcIuKrmFwiLFwiJnN1cGU7XCI6XCLiiodcIixcIiZzdXBlZG90O1wiOlwi4quEXCIsXCImc3VwaHNvbDtcIjpcIuKfiVwiLFwiJnN1cGhzdWI7XCI6XCLiq5dcIixcIiZzdXBsYXJyO1wiOlwi4qW7XCIsXCImc3VwbXVsdDtcIjpcIuKrglwiLFwiJnN1cG5FO1wiOlwi4quMXCIsXCImc3VwbmU7XCI6XCLiiotcIixcIiZzdXBwbHVzO1wiOlwi4quAXCIsXCImc3Vwc2V0O1wiOlwi4oqDXCIsXCImc3Vwc2V0ZXE7XCI6XCLiiodcIixcIiZzdXBzZXRlcXE7XCI6XCLiq4ZcIixcIiZzdXBzZXRuZXE7XCI6XCLiiotcIixcIiZzdXBzZXRuZXFxO1wiOlwi4quMXCIsXCImc3Vwc2ltO1wiOlwi4quIXCIsXCImc3Vwc3ViO1wiOlwi4quUXCIsXCImc3Vwc3VwO1wiOlwi4quWXCIsXCImc3dBcnI7XCI6XCLih5lcIixcIiZzd2FyaGs7XCI6XCLipKZcIixcIiZzd2FycjtcIjpcIuKGmVwiLFwiJnN3YXJyb3c7XCI6XCLihplcIixcIiZzd253YXI7XCI6XCLipKpcIixcIiZzemxpZ1wiOlwiw59cIixcIiZzemxpZztcIjpcIsOfXCIsXCImdGFyZ2V0O1wiOlwi4oyWXCIsXCImdGF1O1wiOlwiz4RcIixcIiZ0YnJrO1wiOlwi4o60XCIsXCImdGNhcm9uO1wiOlwixaVcIixcIiZ0Y2VkaWw7XCI6XCLFo1wiLFwiJnRjeTtcIjpcItGCXCIsXCImdGRvdDtcIjpcIuKDm1wiLFwiJnRlbHJlYztcIjpcIuKMlVwiLFwiJnRmcjtcIjpcIvCdlLFcIixcIiZ0aGVyZTQ7XCI6XCLiiLRcIixcIiZ0aGVyZWZvcmU7XCI6XCLiiLRcIixcIiZ0aGV0YTtcIjpcIs64XCIsXCImdGhldGFzeW07XCI6XCLPkVwiLFwiJnRoZXRhdjtcIjpcIs+RXCIsXCImdGhpY2thcHByb3g7XCI6XCLiiYhcIixcIiZ0aGlja3NpbTtcIjpcIuKIvFwiLFwiJnRoaW5zcDtcIjpcIuKAiVwiLFwiJnRoa2FwO1wiOlwi4omIXCIsXCImdGhrc2ltO1wiOlwi4oi8XCIsXCImdGhvcm5cIjpcIsO+XCIsXCImdGhvcm47XCI6XCLDvlwiLFwiJnRpbGRlO1wiOlwiy5xcIixcIiZ0aW1lc1wiOlwiw5dcIixcIiZ0aW1lcztcIjpcIsOXXCIsXCImdGltZXNiO1wiOlwi4oqgXCIsXCImdGltZXNiYXI7XCI6XCLiqLFcIixcIiZ0aW1lc2Q7XCI6XCLiqLBcIixcIiZ0aW50O1wiOlwi4oitXCIsXCImdG9lYTtcIjpcIuKkqFwiLFwiJnRvcDtcIjpcIuKKpFwiLFwiJnRvcGJvdDtcIjpcIuKMtlwiLFwiJnRvcGNpcjtcIjpcIuKrsVwiLFwiJnRvcGY7XCI6XCLwnZWlXCIsXCImdG9wZm9yaztcIjpcIuKrmlwiLFwiJnRvc2E7XCI6XCLipKlcIixcIiZ0cHJpbWU7XCI6XCLigLRcIixcIiZ0cmFkZTtcIjpcIuKEolwiLFwiJnRyaWFuZ2xlO1wiOlwi4pa1XCIsXCImdHJpYW5nbGVkb3duO1wiOlwi4pa/XCIsXCImdHJpYW5nbGVsZWZ0O1wiOlwi4peDXCIsXCImdHJpYW5nbGVsZWZ0ZXE7XCI6XCLiirRcIixcIiZ0cmlhbmdsZXE7XCI6XCLiiZxcIixcIiZ0cmlhbmdsZXJpZ2h0O1wiOlwi4pa5XCIsXCImdHJpYW5nbGVyaWdodGVxO1wiOlwi4oq1XCIsXCImdHJpZG90O1wiOlwi4pesXCIsXCImdHJpZTtcIjpcIuKJnFwiLFwiJnRyaW1pbnVzO1wiOlwi4qi6XCIsXCImdHJpcGx1cztcIjpcIuKouVwiLFwiJnRyaXNiO1wiOlwi4qeNXCIsXCImdHJpdGltZTtcIjpcIuKou1wiLFwiJnRycGV6aXVtO1wiOlwi4o+iXCIsXCImdHNjcjtcIjpcIvCdk4lcIixcIiZ0c2N5O1wiOlwi0YZcIixcIiZ0c2hjeTtcIjpcItGbXCIsXCImdHN0cm9rO1wiOlwixadcIixcIiZ0d2l4dDtcIjpcIuKJrFwiLFwiJnR3b2hlYWRsZWZ0YXJyb3c7XCI6XCLihp5cIixcIiZ0d29oZWFkcmlnaHRhcnJvdztcIjpcIuKGoFwiLFwiJnVBcnI7XCI6XCLih5FcIixcIiZ1SGFyO1wiOlwi4qWjXCIsXCImdWFjdXRlXCI6XCLDulwiLFwiJnVhY3V0ZTtcIjpcIsO6XCIsXCImdWFycjtcIjpcIuKGkVwiLFwiJnVicmN5O1wiOlwi0Z5cIixcIiZ1YnJldmU7XCI6XCLFrVwiLFwiJnVjaXJjXCI6XCLDu1wiLFwiJnVjaXJjO1wiOlwiw7tcIixcIiZ1Y3k7XCI6XCLRg1wiLFwiJnVkYXJyO1wiOlwi4oeFXCIsXCImdWRibGFjO1wiOlwixbFcIixcIiZ1ZGhhcjtcIjpcIuKlrlwiLFwiJnVmaXNodDtcIjpcIuKlvlwiLFwiJnVmcjtcIjpcIvCdlLJcIixcIiZ1Z3JhdmVcIjpcIsO5XCIsXCImdWdyYXZlO1wiOlwiw7lcIixcIiZ1aGFybDtcIjpcIuKGv1wiLFwiJnVoYXJyO1wiOlwi4oa+XCIsXCImdWhibGs7XCI6XCLiloBcIixcIiZ1bGNvcm47XCI6XCLijJxcIixcIiZ1bGNvcm5lcjtcIjpcIuKMnFwiLFwiJnVsY3JvcDtcIjpcIuKMj1wiLFwiJnVsdHJpO1wiOlwi4pe4XCIsXCImdW1hY3I7XCI6XCLFq1wiLFwiJnVtbFwiOlwiwqhcIixcIiZ1bWw7XCI6XCLCqFwiLFwiJnVvZ29uO1wiOlwixbNcIixcIiZ1b3BmO1wiOlwi8J2VplwiLFwiJnVwYXJyb3c7XCI6XCLihpFcIixcIiZ1cGRvd25hcnJvdztcIjpcIuKGlVwiLFwiJnVwaGFycG9vbmxlZnQ7XCI6XCLihr9cIixcIiZ1cGhhcnBvb25yaWdodDtcIjpcIuKGvlwiLFwiJnVwbHVzO1wiOlwi4oqOXCIsXCImdXBzaTtcIjpcIs+FXCIsXCImdXBzaWg7XCI6XCLPklwiLFwiJnVwc2lsb247XCI6XCLPhVwiLFwiJnVwdXBhcnJvd3M7XCI6XCLih4hcIixcIiZ1cmNvcm47XCI6XCLijJ1cIixcIiZ1cmNvcm5lcjtcIjpcIuKMnVwiLFwiJnVyY3JvcDtcIjpcIuKMjlwiLFwiJnVyaW5nO1wiOlwixa9cIixcIiZ1cnRyaTtcIjpcIuKXuVwiLFwiJnVzY3I7XCI6XCLwnZOKXCIsXCImdXRkb3Q7XCI6XCLii7BcIixcIiZ1dGlsZGU7XCI6XCLFqVwiLFwiJnV0cmk7XCI6XCLilrVcIixcIiZ1dHJpZjtcIjpcIuKWtFwiLFwiJnV1YXJyO1wiOlwi4oeIXCIsXCImdXVtbFwiOlwiw7xcIixcIiZ1dW1sO1wiOlwiw7xcIixcIiZ1d2FuZ2xlO1wiOlwi4qanXCIsXCImdkFycjtcIjpcIuKHlVwiLFwiJnZCYXI7XCI6XCLiq6hcIixcIiZ2QmFydjtcIjpcIuKrqVwiLFwiJnZEYXNoO1wiOlwi4oqoXCIsXCImdmFuZ3J0O1wiOlwi4qacXCIsXCImdmFyZXBzaWxvbjtcIjpcIs+1XCIsXCImdmFya2FwcGE7XCI6XCLPsFwiLFwiJnZhcm5vdGhpbmc7XCI6XCLiiIVcIixcIiZ2YXJwaGk7XCI6XCLPlVwiLFwiJnZhcnBpO1wiOlwiz5ZcIixcIiZ2YXJwcm9wdG87XCI6XCLiiJ1cIixcIiZ2YXJyO1wiOlwi4oaVXCIsXCImdmFycmhvO1wiOlwiz7FcIixcIiZ2YXJzaWdtYTtcIjpcIs+CXCIsXCImdmFyc3Vic2V0bmVxO1wiOlwi4oqK77iAXCIsXCImdmFyc3Vic2V0bmVxcTtcIjpcIuKri++4gFwiLFwiJnZhcnN1cHNldG5lcTtcIjpcIuKKi++4gFwiLFwiJnZhcnN1cHNldG5lcXE7XCI6XCLiq4zvuIBcIixcIiZ2YXJ0aGV0YTtcIjpcIs+RXCIsXCImdmFydHJpYW5nbGVsZWZ0O1wiOlwi4oqyXCIsXCImdmFydHJpYW5nbGVyaWdodDtcIjpcIuKKs1wiLFwiJnZjeTtcIjpcItCyXCIsXCImdmRhc2g7XCI6XCLiiqJcIixcIiZ2ZWU7XCI6XCLiiKhcIixcIiZ2ZWViYXI7XCI6XCLiirtcIixcIiZ2ZWVlcTtcIjpcIuKJmlwiLFwiJnZlbGxpcDtcIjpcIuKLrlwiLFwiJnZlcmJhcjtcIjpcInxcIixcIiZ2ZXJ0O1wiOlwifFwiLFwiJnZmcjtcIjpcIvCdlLNcIixcIiZ2bHRyaTtcIjpcIuKKslwiLFwiJnZuc3ViO1wiOlwi4oqC4oOSXCIsXCImdm5zdXA7XCI6XCLiioPig5JcIixcIiZ2b3BmO1wiOlwi8J2Vp1wiLFwiJnZwcm9wO1wiOlwi4oidXCIsXCImdnJ0cmk7XCI6XCLiirNcIixcIiZ2c2NyO1wiOlwi8J2Ti1wiLFwiJnZzdWJuRTtcIjpcIuKri++4gFwiLFwiJnZzdWJuZTtcIjpcIuKKiu+4gFwiLFwiJnZzdXBuRTtcIjpcIuKrjO+4gFwiLFwiJnZzdXBuZTtcIjpcIuKKi++4gFwiLFwiJnZ6aWd6YWc7XCI6XCLipppcIixcIiZ3Y2lyYztcIjpcIsW1XCIsXCImd2VkYmFyO1wiOlwi4qmfXCIsXCImd2VkZ2U7XCI6XCLiiKdcIixcIiZ3ZWRnZXE7XCI6XCLiiZlcIixcIiZ3ZWllcnA7XCI6XCLihJhcIixcIiZ3ZnI7XCI6XCLwnZS0XCIsXCImd29wZjtcIjpcIvCdlahcIixcIiZ3cDtcIjpcIuKEmFwiLFwiJndyO1wiOlwi4omAXCIsXCImd3JlYXRoO1wiOlwi4omAXCIsXCImd3NjcjtcIjpcIvCdk4xcIixcIiZ4Y2FwO1wiOlwi4ouCXCIsXCImeGNpcmM7XCI6XCLil69cIixcIiZ4Y3VwO1wiOlwi4ouDXCIsXCImeGR0cmk7XCI6XCLilr1cIixcIiZ4ZnI7XCI6XCLwnZS1XCIsXCImeGhBcnI7XCI6XCLin7pcIixcIiZ4aGFycjtcIjpcIuKft1wiLFwiJnhpO1wiOlwizr5cIixcIiZ4bEFycjtcIjpcIuKfuFwiLFwiJnhsYXJyO1wiOlwi4p+1XCIsXCImeG1hcDtcIjpcIuKfvFwiLFwiJnhuaXM7XCI6XCLii7tcIixcIiZ4b2RvdDtcIjpcIuKogFwiLFwiJnhvcGY7XCI6XCLwnZWpXCIsXCImeG9wbHVzO1wiOlwi4qiBXCIsXCImeG90aW1lO1wiOlwi4qiCXCIsXCImeHJBcnI7XCI6XCLin7lcIixcIiZ4cmFycjtcIjpcIuKftlwiLFwiJnhzY3I7XCI6XCLwnZONXCIsXCImeHNxY3VwO1wiOlwi4qiGXCIsXCImeHVwbHVzO1wiOlwi4qiEXCIsXCImeHV0cmk7XCI6XCLilrNcIixcIiZ4dmVlO1wiOlwi4ouBXCIsXCImeHdlZGdlO1wiOlwi4ouAXCIsXCImeWFjdXRlXCI6XCLDvVwiLFwiJnlhY3V0ZTtcIjpcIsO9XCIsXCImeWFjeTtcIjpcItGPXCIsXCImeWNpcmM7XCI6XCLFt1wiLFwiJnljeTtcIjpcItGLXCIsXCImeWVuXCI6XCLCpVwiLFwiJnllbjtcIjpcIsKlXCIsXCImeWZyO1wiOlwi8J2UtlwiLFwiJnlpY3k7XCI6XCLRl1wiLFwiJnlvcGY7XCI6XCLwnZWqXCIsXCImeXNjcjtcIjpcIvCdk45cIixcIiZ5dWN5O1wiOlwi0Y5cIixcIiZ5dW1sXCI6XCLDv1wiLFwiJnl1bWw7XCI6XCLDv1wiLFwiJnphY3V0ZTtcIjpcIsW6XCIsXCImemNhcm9uO1wiOlwixb5cIixcIiZ6Y3k7XCI6XCLQt1wiLFwiJnpkb3Q7XCI6XCLFvFwiLFwiJnplZXRyZjtcIjpcIuKEqFwiLFwiJnpldGE7XCI6XCLOtlwiLFwiJnpmcjtcIjpcIvCdlLdcIixcIiZ6aGN5O1wiOlwi0LZcIixcIiZ6aWdyYXJyO1wiOlwi4oedXCIsXCImem9wZjtcIjpcIvCdlatcIixcIiZ6c2NyO1wiOlwi8J2Tj1wiLFwiJnp3ajtcIjpcIuKAjVwiLFwiJnp3bmo7XCI6XCLigIxcIn0sY2hhcmFjdGVyczp7XCLDhlwiOlwiJkFFbGlnO1wiLFwiJlwiOlwiJmFtcDtcIixcIsOBXCI6XCImQWFjdXRlO1wiLFwixIJcIjpcIiZBYnJldmU7XCIsXCLDglwiOlwiJkFjaXJjO1wiLFwi0JBcIjpcIiZBY3k7XCIsXCLwnZSEXCI6XCImQWZyO1wiLFwiw4BcIjpcIiZBZ3JhdmU7XCIsXCLOkVwiOlwiJkFscGhhO1wiLFwixIBcIjpcIiZBbWFjcjtcIixcIuKpk1wiOlwiJkFuZDtcIixcIsSEXCI6XCImQW9nb247XCIsXCLwnZS4XCI6XCImQW9wZjtcIixcIuKBoVwiOlwiJmFmO1wiLFwiw4VcIjpcIiZhbmdzdDtcIixcIvCdkpxcIjpcIiZBc2NyO1wiLFwi4omUXCI6XCImY29sb25lcTtcIixcIsODXCI6XCImQXRpbGRlO1wiLFwiw4RcIjpcIiZBdW1sO1wiLFwi4oiWXCI6XCImc3NldG1uO1wiLFwi4qunXCI6XCImQmFydjtcIixcIuKMhlwiOlwiJmRvdWJsZWJhcndlZGdlO1wiLFwi0JFcIjpcIiZCY3k7XCIsXCLiiLVcIjpcIiZiZWNhdXNlO1wiLFwi4oSsXCI6XCImYmVybm91O1wiLFwizpJcIjpcIiZCZXRhO1wiLFwi8J2UhVwiOlwiJkJmcjtcIixcIvCdlLlcIjpcIiZCb3BmO1wiLFwiy5hcIjpcIiZicmV2ZTtcIixcIuKJjlwiOlwiJmJ1bXA7XCIsXCLQp1wiOlwiJkNIY3k7XCIsXCLCqVwiOlwiJmNvcHk7XCIsXCLEhlwiOlwiJkNhY3V0ZTtcIixcIuKLklwiOlwiJkNhcDtcIixcIuKFhVwiOlwiJkREO1wiLFwi4oStXCI6XCImQ2ZyO1wiLFwixIxcIjpcIiZDY2Fyb247XCIsXCLDh1wiOlwiJkNjZWRpbDtcIixcIsSIXCI6XCImQ2NpcmM7XCIsXCLiiLBcIjpcIiZDY29uaW50O1wiLFwixIpcIjpcIiZDZG90O1wiLFwiwrhcIjpcIiZjZWRpbDtcIixcIsK3XCI6XCImbWlkZG90O1wiLFwizqdcIjpcIiZDaGk7XCIsXCLiiplcIjpcIiZvZG90O1wiLFwi4oqWXCI6XCImb21pbnVzO1wiLFwi4oqVXCI6XCImb3BsdXM7XCIsXCLiipdcIjpcIiZvdGltZXM7XCIsXCLiiLJcIjpcIiZjd2NvbmludDtcIixcIuKAnVwiOlwiJnJkcXVvcjtcIixcIuKAmVwiOlwiJnJzcXVvcjtcIixcIuKIt1wiOlwiJlByb3BvcnRpb247XCIsXCLiqbRcIjpcIiZDb2xvbmU7XCIsXCLiiaFcIjpcIiZlcXVpdjtcIixcIuKIr1wiOlwiJkRvdWJsZUNvbnRvdXJJbnRlZ3JhbDtcIixcIuKIrlwiOlwiJm9pbnQ7XCIsXCLihIJcIjpcIiZjb21wbGV4ZXM7XCIsXCLiiJBcIjpcIiZjb3Byb2Q7XCIsXCLiiLNcIjpcIiZhd2NvbmludDtcIixcIuKor1wiOlwiJkNyb3NzO1wiLFwi8J2SnlwiOlwiJkNzY3I7XCIsXCLii5NcIjpcIiZDdXA7XCIsXCLiiY1cIjpcIiZhc3ltcGVxO1wiLFwi4qSRXCI6XCImRERvdHJhaGQ7XCIsXCLQglwiOlwiJkRKY3k7XCIsXCLQhVwiOlwiJkRTY3k7XCIsXCLQj1wiOlwiJkRaY3k7XCIsXCLigKFcIjpcIiZkZGFnZ2VyO1wiLFwi4oahXCI6XCImRGFycjtcIixcIuKrpFwiOlwiJkRvdWJsZUxlZnRUZWU7XCIsXCLEjlwiOlwiJkRjYXJvbjtcIixcItCUXCI6XCImRGN5O1wiLFwi4oiHXCI6XCImbmFibGE7XCIsXCLOlFwiOlwiJkRlbHRhO1wiLFwi8J2Uh1wiOlwiJkRmcjtcIixcIsK0XCI6XCImYWN1dGU7XCIsXCLLmVwiOlwiJmRvdDtcIixcIsudXCI6XCImZGJsYWM7XCIsXCJgXCI6XCImZ3JhdmU7XCIsXCLLnFwiOlwiJnRpbGRlO1wiLFwi4ouEXCI6XCImZGlhbW9uZDtcIixcIuKFhlwiOlwiJmRkO1wiLFwi8J2Uu1wiOlwiJkRvcGY7XCIsXCLCqFwiOlwiJnVtbDtcIixcIuKDnFwiOlwiJkRvdERvdDtcIixcIuKJkFwiOlwiJmVzZG90O1wiLFwi4oeTXCI6XCImZEFycjtcIixcIuKHkFwiOlwiJmxBcnI7XCIsXCLih5RcIjpcIiZpZmY7XCIsXCLin7hcIjpcIiZ4bEFycjtcIixcIuKfulwiOlwiJnhoQXJyO1wiLFwi4p+5XCI6XCImeHJBcnI7XCIsXCLih5JcIjpcIiZyQXJyO1wiLFwi4oqoXCI6XCImdkRhc2g7XCIsXCLih5FcIjpcIiZ1QXJyO1wiLFwi4oeVXCI6XCImdkFycjtcIixcIuKIpVwiOlwiJnNwYXI7XCIsXCLihpNcIjpcIiZkb3duYXJyb3c7XCIsXCLipJNcIjpcIiZEb3duQXJyb3dCYXI7XCIsXCLih7VcIjpcIiZkdWFycjtcIixcIsyRXCI6XCImRG93bkJyZXZlO1wiLFwi4qWQXCI6XCImRG93bkxlZnRSaWdodFZlY3RvcjtcIixcIuKlnlwiOlwiJkRvd25MZWZ0VGVlVmVjdG9yO1wiLFwi4oa9XCI6XCImbGhhcmQ7XCIsXCLipZZcIjpcIiZEb3duTGVmdFZlY3RvckJhcjtcIixcIuKln1wiOlwiJkRvd25SaWdodFRlZVZlY3RvcjtcIixcIuKHgVwiOlwiJnJpZ2h0aGFycG9vbmRvd247XCIsXCLipZdcIjpcIiZEb3duUmlnaHRWZWN0b3JCYXI7XCIsXCLiiqRcIjpcIiZ0b3A7XCIsXCLihqdcIjpcIiZtYXBzdG9kb3duO1wiLFwi8J2Sn1wiOlwiJkRzY3I7XCIsXCLEkFwiOlwiJkRzdHJvaztcIixcIsWKXCI6XCImRU5HO1wiLFwiw5BcIjpcIiZFVEg7XCIsXCLDiVwiOlwiJkVhY3V0ZTtcIixcIsSaXCI6XCImRWNhcm9uO1wiLFwiw4pcIjpcIiZFY2lyYztcIixcItCtXCI6XCImRWN5O1wiLFwixJZcIjpcIiZFZG90O1wiLFwi8J2UiFwiOlwiJkVmcjtcIixcIsOIXCI6XCImRWdyYXZlO1wiLFwi4oiIXCI6XCImaXNpbnY7XCIsXCLEklwiOlwiJkVtYWNyO1wiLFwi4pe7XCI6XCImRW1wdHlTbWFsbFNxdWFyZTtcIixcIuKWq1wiOlwiJkVtcHR5VmVyeVNtYWxsU3F1YXJlO1wiLFwixJhcIjpcIiZFb2dvbjtcIixcIvCdlLxcIjpcIiZFb3BmO1wiLFwizpVcIjpcIiZFcHNpbG9uO1wiLFwi4qm1XCI6XCImRXF1YWw7XCIsXCLiiYJcIjpcIiZlc2ltO1wiLFwi4oeMXCI6XCImcmxoYXI7XCIsXCLihLBcIjpcIiZleHBlY3RhdGlvbjtcIixcIuKps1wiOlwiJkVzaW07XCIsXCLOl1wiOlwiJkV0YTtcIixcIsOLXCI6XCImRXVtbDtcIixcIuKIg1wiOlwiJmV4aXN0O1wiLFwi4oWHXCI6XCImZXhwb25lbnRpYWxlO1wiLFwi0KRcIjpcIiZGY3k7XCIsXCLwnZSJXCI6XCImRmZyO1wiLFwi4pe8XCI6XCImRmlsbGVkU21hbGxTcXVhcmU7XCIsXCLilqpcIjpcIiZzcXVmO1wiLFwi8J2UvVwiOlwiJkZvcGY7XCIsXCLiiIBcIjpcIiZmb3JhbGw7XCIsXCLihLFcIjpcIiZGc2NyO1wiLFwi0INcIjpcIiZHSmN5O1wiLFwiPlwiOlwiJmd0O1wiLFwizpNcIjpcIiZHYW1tYTtcIixcIs+cXCI6XCImR2FtbWFkO1wiLFwixJ5cIjpcIiZHYnJldmU7XCIsXCLEolwiOlwiJkdjZWRpbDtcIixcIsScXCI6XCImR2NpcmM7XCIsXCLQk1wiOlwiJkdjeTtcIixcIsSgXCI6XCImR2RvdDtcIixcIvCdlIpcIjpcIiZHZnI7XCIsXCLii5lcIjpcIiZnZ2c7XCIsXCLwnZS+XCI6XCImR29wZjtcIixcIuKJpVwiOlwiJmdlcTtcIixcIuKLm1wiOlwiJmd0cmVxbGVzcztcIixcIuKJp1wiOlwiJmdlcXE7XCIsXCLiqqJcIjpcIiZHcmVhdGVyR3JlYXRlcjtcIixcIuKJt1wiOlwiJmd0cmxlc3M7XCIsXCLiqb5cIjpcIiZnZXM7XCIsXCLiibNcIjpcIiZndHJzaW07XCIsXCLwnZKiXCI6XCImR3NjcjtcIixcIuKJq1wiOlwiJmdnO1wiLFwi0KpcIjpcIiZIQVJEY3k7XCIsXCLLh1wiOlwiJmNhcm9uO1wiLFwiXlwiOlwiJkhhdDtcIixcIsSkXCI6XCImSGNpcmM7XCIsXCLihIxcIjpcIiZQb2luY2FyZXBsYW5lO1wiLFwi4oSLXCI6XCImaGFtaWx0O1wiLFwi4oSNXCI6XCImcXVhdGVybmlvbnM7XCIsXCLilIBcIjpcIiZib3hoO1wiLFwixKZcIjpcIiZIc3Ryb2s7XCIsXCLiiY9cIjpcIiZidW1wZXE7XCIsXCLQlVwiOlwiJklFY3k7XCIsXCLEslwiOlwiJklKbGlnO1wiLFwi0IFcIjpcIiZJT2N5O1wiLFwiw41cIjpcIiZJYWN1dGU7XCIsXCLDjlwiOlwiJkljaXJjO1wiLFwi0JhcIjpcIiZJY3k7XCIsXCLEsFwiOlwiJklkb3Q7XCIsXCLihJFcIjpcIiZpbWFncGFydDtcIixcIsOMXCI6XCImSWdyYXZlO1wiLFwixKpcIjpcIiZJbWFjcjtcIixcIuKFiFwiOlwiJmlpO1wiLFwi4oisXCI6XCImSW50O1wiLFwi4oirXCI6XCImaW50O1wiLFwi4ouCXCI6XCImeGNhcDtcIixcIuKBo1wiOlwiJmljO1wiLFwi4oGiXCI6XCImaXQ7XCIsXCLErlwiOlwiJklvZ29uO1wiLFwi8J2VgFwiOlwiJklvcGY7XCIsXCLOmVwiOlwiJklvdGE7XCIsXCLihJBcIjpcIiZpbWFnbGluZTtcIixcIsSoXCI6XCImSXRpbGRlO1wiLFwi0IZcIjpcIiZJdWtjeTtcIixcIsOPXCI6XCImSXVtbDtcIixcIsS0XCI6XCImSmNpcmM7XCIsXCLQmVwiOlwiJkpjeTtcIixcIvCdlI1cIjpcIiZKZnI7XCIsXCLwnZWBXCI6XCImSm9wZjtcIixcIvCdkqVcIjpcIiZKc2NyO1wiLFwi0IhcIjpcIiZKc2VyY3k7XCIsXCLQhFwiOlwiJkp1a2N5O1wiLFwi0KVcIjpcIiZLSGN5O1wiLFwi0IxcIjpcIiZLSmN5O1wiLFwizppcIjpcIiZLYXBwYTtcIixcIsS2XCI6XCImS2NlZGlsO1wiLFwi0JpcIjpcIiZLY3k7XCIsXCLwnZSOXCI6XCImS2ZyO1wiLFwi8J2VglwiOlwiJktvcGY7XCIsXCLwnZKmXCI6XCImS3NjcjtcIixcItCJXCI6XCImTEpjeTtcIixcIjxcIjpcIiZsdDtcIixcIsS5XCI6XCImTGFjdXRlO1wiLFwizptcIjpcIiZMYW1iZGE7XCIsXCLin6pcIjpcIiZMYW5nO1wiLFwi4oSSXCI6XCImbGFncmFuO1wiLFwi4oaeXCI6XCImdHdvaGVhZGxlZnRhcnJvdztcIixcIsS9XCI6XCImTGNhcm9uO1wiLFwixLtcIjpcIiZMY2VkaWw7XCIsXCLQm1wiOlwiJkxjeTtcIixcIuKfqFwiOlwiJmxhbmdsZTtcIixcIuKGkFwiOlwiJnNsYXJyO1wiLFwi4oekXCI6XCImbGFycmI7XCIsXCLih4ZcIjpcIiZscmFycjtcIixcIuKMiFwiOlwiJmxjZWlsO1wiLFwi4p+mXCI6XCImbG9icms7XCIsXCLipaFcIjpcIiZMZWZ0RG93blRlZVZlY3RvcjtcIixcIuKHg1wiOlwiJmRvd25oYXJwb29ubGVmdDtcIixcIuKlmVwiOlwiJkxlZnREb3duVmVjdG9yQmFyO1wiLFwi4oyKXCI6XCImbGZsb29yO1wiLFwi4oaUXCI6XCImbGVmdHJpZ2h0YXJyb3c7XCIsXCLipY5cIjpcIiZMZWZ0UmlnaHRWZWN0b3I7XCIsXCLiiqNcIjpcIiZkYXNodjtcIixcIuKGpFwiOlwiJm1hcHN0b2xlZnQ7XCIsXCLipZpcIjpcIiZMZWZ0VGVlVmVjdG9yO1wiLFwi4oqyXCI6XCImdmx0cmk7XCIsXCLip49cIjpcIiZMZWZ0VHJpYW5nbGVCYXI7XCIsXCLiirRcIjpcIiZ0cmlhbmdsZWxlZnRlcTtcIixcIuKlkVwiOlwiJkxlZnRVcERvd25WZWN0b3I7XCIsXCLipaBcIjpcIiZMZWZ0VXBUZWVWZWN0b3I7XCIsXCLihr9cIjpcIiZ1cGhhcnBvb25sZWZ0O1wiLFwi4qWYXCI6XCImTGVmdFVwVmVjdG9yQmFyO1wiLFwi4oa8XCI6XCImbGhhcnU7XCIsXCLipZJcIjpcIiZMZWZ0VmVjdG9yQmFyO1wiLFwi4ouaXCI6XCImbGVzc2VxZ3RyO1wiLFwi4ommXCI6XCImbGVxcTtcIixcIuKJtlwiOlwiJmxnO1wiLFwi4qqhXCI6XCImTGVzc0xlc3M7XCIsXCLiqb1cIjpcIiZsZXM7XCIsXCLiibJcIjpcIiZsc2ltO1wiLFwi8J2Uj1wiOlwiJkxmcjtcIixcIuKLmFwiOlwiJkxsO1wiLFwi4oeaXCI6XCImbEFhcnI7XCIsXCLEv1wiOlwiJkxtaWRvdDtcIixcIuKftVwiOlwiJnhsYXJyO1wiLFwi4p+3XCI6XCImeGhhcnI7XCIsXCLin7ZcIjpcIiZ4cmFycjtcIixcIvCdlYNcIjpcIiZMb3BmO1wiLFwi4oaZXCI6XCImc3dhcnJvdztcIixcIuKGmFwiOlwiJnNlYXJyb3c7XCIsXCLihrBcIjpcIiZsc2g7XCIsXCLFgVwiOlwiJkxzdHJvaztcIixcIuKJqlwiOlwiJmxsO1wiLFwi4qSFXCI6XCImTWFwO1wiLFwi0JxcIjpcIiZNY3k7XCIsXCLigZ9cIjpcIiZNZWRpdW1TcGFjZTtcIixcIuKEs1wiOlwiJnBobW1hdDtcIixcIvCdlJBcIjpcIiZNZnI7XCIsXCLiiJNcIjpcIiZtcDtcIixcIvCdlYRcIjpcIiZNb3BmO1wiLFwizpxcIjpcIiZNdTtcIixcItCKXCI6XCImTkpjeTtcIixcIsWDXCI6XCImTmFjdXRlO1wiLFwixYdcIjpcIiZOY2Fyb247XCIsXCLFhVwiOlwiJk5jZWRpbDtcIixcItCdXCI6XCImTmN5O1wiLFwi4oCLXCI6XCImWmVyb1dpZHRoU3BhY2U7XCIsXCJcXG5cIjpcIiZOZXdMaW5lO1wiLFwi8J2UkVwiOlwiJk5mcjtcIixcIuKBoFwiOlwiJk5vQnJlYWs7XCIsXCLCoFwiOlwiJm5ic3A7XCIsXCLihJVcIjpcIiZuYXR1cmFscztcIixcIuKrrFwiOlwiJk5vdDtcIixcIuKJolwiOlwiJm5lcXVpdjtcIixcIuKJrVwiOlwiJk5vdEN1cENhcDtcIixcIuKIplwiOlwiJm5zcGFyO1wiLFwi4oiJXCI6XCImbm90aW52YTtcIixcIuKJoFwiOlwiJm5lO1wiLFwi4omCzLhcIjpcIiZuZXNpbTtcIixcIuKIhFwiOlwiJm5leGlzdHM7XCIsXCLiia9cIjpcIiZuZ3RyO1wiLFwi4omxXCI6XCImbmdlcTtcIixcIuKJp8y4XCI6XCImbmdlcXE7XCIsXCLiiavMuFwiOlwiJm5HdHY7XCIsXCLiiblcIjpcIiZudGdsO1wiLFwi4qm+zLhcIjpcIiZuZ2VzO1wiLFwi4om1XCI6XCImbmdzaW07XCIsXCLiiY7MuFwiOlwiJm5idW1wO1wiLFwi4omPzLhcIjpcIiZuYnVtcGU7XCIsXCLii6pcIjpcIiZudHJpYW5nbGVsZWZ0O1wiLFwi4qePzLhcIjpcIiZOb3RMZWZ0VHJpYW5nbGVCYXI7XCIsXCLii6xcIjpcIiZudHJpYW5nbGVsZWZ0ZXE7XCIsXCLiia5cIjpcIiZubHQ7XCIsXCLiibBcIjpcIiZubGVxO1wiLFwi4om4XCI6XCImbnRsZztcIixcIuKJqsy4XCI6XCImbkx0djtcIixcIuKpvcy4XCI6XCImbmxlcztcIixcIuKJtFwiOlwiJm5sc2ltO1wiLFwi4qqizLhcIjpcIiZOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjtcIixcIuKqocy4XCI6XCImTm90TmVzdGVkTGVzc0xlc3M7XCIsXCLiioBcIjpcIiZucHJlYztcIixcIuKqr8y4XCI6XCImbnByZWNlcTtcIixcIuKLoFwiOlwiJm5wcmN1ZTtcIixcIuKIjFwiOlwiJm5vdG5pdmE7XCIsXCLii6tcIjpcIiZudHJpYW5nbGVyaWdodDtcIixcIuKnkMy4XCI6XCImTm90UmlnaHRUcmlhbmdsZUJhcjtcIixcIuKLrVwiOlwiJm50cmlhbmdsZXJpZ2h0ZXE7XCIsXCLiio/MuFwiOlwiJk5vdFNxdWFyZVN1YnNldDtcIixcIuKLolwiOlwiJm5zcXN1YmU7XCIsXCLiipDMuFwiOlwiJk5vdFNxdWFyZVN1cGVyc2V0O1wiLFwi4oujXCI6XCImbnNxc3VwZTtcIixcIuKKguKDklwiOlwiJnZuc3ViO1wiLFwi4oqIXCI6XCImbnN1YnNldGVxO1wiLFwi4oqBXCI6XCImbnN1Y2M7XCIsXCLiqrDMuFwiOlwiJm5zdWNjZXE7XCIsXCLii6FcIjpcIiZuc2NjdWU7XCIsXCLiib/MuFwiOlwiJk5vdFN1Y2NlZWRzVGlsZGU7XCIsXCLiioPig5JcIjpcIiZ2bnN1cDtcIixcIuKKiVwiOlwiJm5zdXBzZXRlcTtcIixcIuKJgVwiOlwiJm5zaW07XCIsXCLiiYRcIjpcIiZuc2ltZXE7XCIsXCLiiYdcIjpcIiZuY29uZztcIixcIuKJiVwiOlwiJm5hcHByb3g7XCIsXCLiiKRcIjpcIiZuc21pZDtcIixcIvCdkqlcIjpcIiZOc2NyO1wiLFwiw5FcIjpcIiZOdGlsZGU7XCIsXCLOnVwiOlwiJk51O1wiLFwixZJcIjpcIiZPRWxpZztcIixcIsOTXCI6XCImT2FjdXRlO1wiLFwiw5RcIjpcIiZPY2lyYztcIixcItCeXCI6XCImT2N5O1wiLFwixZBcIjpcIiZPZGJsYWM7XCIsXCLwnZSSXCI6XCImT2ZyO1wiLFwiw5JcIjpcIiZPZ3JhdmU7XCIsXCLFjFwiOlwiJk9tYWNyO1wiLFwizqlcIjpcIiZvaG07XCIsXCLOn1wiOlwiJk9taWNyb247XCIsXCLwnZWGXCI6XCImT29wZjtcIixcIuKAnFwiOlwiJmxkcXVvO1wiLFwi4oCYXCI6XCImbHNxdW87XCIsXCLiqZRcIjpcIiZPcjtcIixcIvCdkqpcIjpcIiZPc2NyO1wiLFwiw5hcIjpcIiZPc2xhc2g7XCIsXCLDlVwiOlwiJk90aWxkZTtcIixcIuKot1wiOlwiJk90aW1lcztcIixcIsOWXCI6XCImT3VtbDtcIixcIuKAvlwiOlwiJm9saW5lO1wiLFwi4o+eXCI6XCImT3ZlckJyYWNlO1wiLFwi4o60XCI6XCImdGJyaztcIixcIuKPnFwiOlwiJk92ZXJQYXJlbnRoZXNpcztcIixcIuKIglwiOlwiJnBhcnQ7XCIsXCLQn1wiOlwiJlBjeTtcIixcIvCdlJNcIjpcIiZQZnI7XCIsXCLOplwiOlwiJlBoaTtcIixcIs6gXCI6XCImUGk7XCIsXCLCsVwiOlwiJnBtO1wiLFwi4oSZXCI6XCImcHJpbWVzO1wiLFwi4qq7XCI6XCImUHI7XCIsXCLiibpcIjpcIiZwcmVjO1wiLFwi4qqvXCI6XCImcHJlY2VxO1wiLFwi4om8XCI6XCImcHJlY2N1cmx5ZXE7XCIsXCLiib5cIjpcIiZwcnNpbTtcIixcIuKAs1wiOlwiJlByaW1lO1wiLFwi4oiPXCI6XCImcHJvZDtcIixcIuKInVwiOlwiJnZwcm9wO1wiLFwi8J2Sq1wiOlwiJlBzY3I7XCIsXCLOqFwiOlwiJlBzaTtcIiwnXCInOlwiJnF1b3Q7XCIsXCLwnZSUXCI6XCImUWZyO1wiLFwi4oSaXCI6XCImcmF0aW9uYWxzO1wiLFwi8J2SrFwiOlwiJlFzY3I7XCIsXCLipJBcIjpcIiZkcmJrYXJvdztcIixcIsKuXCI6XCImcmVnO1wiLFwixZRcIjpcIiZSYWN1dGU7XCIsXCLin6tcIjpcIiZSYW5nO1wiLFwi4oagXCI6XCImdHdvaGVhZHJpZ2h0YXJyb3c7XCIsXCLipJZcIjpcIiZSYXJydGw7XCIsXCLFmFwiOlwiJlJjYXJvbjtcIixcIsWWXCI6XCImUmNlZGlsO1wiLFwi0KBcIjpcIiZSY3k7XCIsXCLihJxcIjpcIiZyZWFscGFydDtcIixcIuKIi1wiOlwiJm5pdjtcIixcIuKHi1wiOlwiJmxyaGFyO1wiLFwi4qWvXCI6XCImZHVoYXI7XCIsXCLOoVwiOlwiJlJobztcIixcIuKfqVwiOlwiJnJhbmdsZTtcIixcIuKGklwiOlwiJnNyYXJyO1wiLFwi4oelXCI6XCImcmFycmI7XCIsXCLih4RcIjpcIiZybGFycjtcIixcIuKMiVwiOlwiJnJjZWlsO1wiLFwi4p+nXCI6XCImcm9icms7XCIsXCLipZ1cIjpcIiZSaWdodERvd25UZWVWZWN0b3I7XCIsXCLih4JcIjpcIiZkb3duaGFycG9vbnJpZ2h0O1wiLFwi4qWVXCI6XCImUmlnaHREb3duVmVjdG9yQmFyO1wiLFwi4oyLXCI6XCImcmZsb29yO1wiLFwi4oqiXCI6XCImdmRhc2g7XCIsXCLihqZcIjpcIiZtYXBzdG87XCIsXCLipZtcIjpcIiZSaWdodFRlZVZlY3RvcjtcIixcIuKKs1wiOlwiJnZydHJpO1wiLFwi4qeQXCI6XCImUmlnaHRUcmlhbmdsZUJhcjtcIixcIuKKtVwiOlwiJnRyaWFuZ2xlcmlnaHRlcTtcIixcIuKlj1wiOlwiJlJpZ2h0VXBEb3duVmVjdG9yO1wiLFwi4qWcXCI6XCImUmlnaHRVcFRlZVZlY3RvcjtcIixcIuKGvlwiOlwiJnVwaGFycG9vbnJpZ2h0O1wiLFwi4qWUXCI6XCImUmlnaHRVcFZlY3RvckJhcjtcIixcIuKHgFwiOlwiJnJpZ2h0aGFycG9vbnVwO1wiLFwi4qWTXCI6XCImUmlnaHRWZWN0b3JCYXI7XCIsXCLihJ1cIjpcIiZyZWFscztcIixcIuKlsFwiOlwiJlJvdW5kSW1wbGllcztcIixcIuKHm1wiOlwiJnJBYXJyO1wiLFwi4oSbXCI6XCImcmVhbGluZTtcIixcIuKGsVwiOlwiJnJzaDtcIixcIuKntFwiOlwiJlJ1bGVEZWxheWVkO1wiLFwi0KlcIjpcIiZTSENIY3k7XCIsXCLQqFwiOlwiJlNIY3k7XCIsXCLQrFwiOlwiJlNPRlRjeTtcIixcIsWaXCI6XCImU2FjdXRlO1wiLFwi4qq8XCI6XCImU2M7XCIsXCLFoFwiOlwiJlNjYXJvbjtcIixcIsWeXCI6XCImU2NlZGlsO1wiLFwixZxcIjpcIiZTY2lyYztcIixcItChXCI6XCImU2N5O1wiLFwi8J2UllwiOlwiJlNmcjtcIixcIuKGkVwiOlwiJnVwYXJyb3c7XCIsXCLOo1wiOlwiJlNpZ21hO1wiLFwi4oiYXCI6XCImY29tcGZuO1wiLFwi8J2VilwiOlwiJlNvcGY7XCIsXCLiiJpcIjpcIiZyYWRpYztcIixcIuKWoVwiOlwiJnNxdWFyZTtcIixcIuKKk1wiOlwiJnNxY2FwO1wiLFwi4oqPXCI6XCImc3FzdWJzZXQ7XCIsXCLiipFcIjpcIiZzcXN1YnNldGVxO1wiLFwi4oqQXCI6XCImc3FzdXBzZXQ7XCIsXCLiipJcIjpcIiZzcXN1cHNldGVxO1wiLFwi4oqUXCI6XCImc3FjdXA7XCIsXCLwnZKuXCI6XCImU3NjcjtcIixcIuKLhlwiOlwiJnNzdGFyZjtcIixcIuKLkFwiOlwiJlN1YnNldDtcIixcIuKKhlwiOlwiJnN1YnNldGVxO1wiLFwi4om7XCI6XCImc3VjYztcIixcIuKqsFwiOlwiJnN1Y2NlcTtcIixcIuKJvVwiOlwiJnN1Y2NjdXJseWVxO1wiLFwi4om/XCI6XCImc3VjY3NpbTtcIixcIuKIkVwiOlwiJnN1bTtcIixcIuKLkVwiOlwiJlN1cHNldDtcIixcIuKKg1wiOlwiJnN1cHNldDtcIixcIuKKh1wiOlwiJnN1cHNldGVxO1wiLFwiw55cIjpcIiZUSE9STjtcIixcIuKEolwiOlwiJnRyYWRlO1wiLFwi0ItcIjpcIiZUU0hjeTtcIixcItCmXCI6XCImVFNjeTtcIixcIlxcdFwiOlwiJlRhYjtcIixcIs6kXCI6XCImVGF1O1wiLFwixaRcIjpcIiZUY2Fyb247XCIsXCLFolwiOlwiJlRjZWRpbDtcIixcItCiXCI6XCImVGN5O1wiLFwi8J2Ul1wiOlwiJlRmcjtcIixcIuKItFwiOlwiJnRoZXJlZm9yZTtcIixcIs6YXCI6XCImVGhldGE7XCIsXCLigZ/igIpcIjpcIiZUaGlja1NwYWNlO1wiLFwi4oCJXCI6XCImdGhpbnNwO1wiLFwi4oi8XCI6XCImdGhrc2ltO1wiLFwi4omDXCI6XCImc2ltZXE7XCIsXCLiiYVcIjpcIiZjb25nO1wiLFwi4omIXCI6XCImdGhrYXA7XCIsXCLwnZWLXCI6XCImVG9wZjtcIixcIuKDm1wiOlwiJnRkb3Q7XCIsXCLwnZKvXCI6XCImVHNjcjtcIixcIsWmXCI6XCImVHN0cm9rO1wiLFwiw5pcIjpcIiZVYWN1dGU7XCIsXCLihp9cIjpcIiZVYXJyO1wiLFwi4qWJXCI6XCImVWFycm9jaXI7XCIsXCLQjlwiOlwiJlVicmN5O1wiLFwixaxcIjpcIiZVYnJldmU7XCIsXCLDm1wiOlwiJlVjaXJjO1wiLFwi0KNcIjpcIiZVY3k7XCIsXCLFsFwiOlwiJlVkYmxhYztcIixcIvCdlJhcIjpcIiZVZnI7XCIsXCLDmVwiOlwiJlVncmF2ZTtcIixcIsWqXCI6XCImVW1hY3I7XCIsXzpcIiZsb3diYXI7XCIsXCLij59cIjpcIiZVbmRlckJyYWNlO1wiLFwi4o61XCI6XCImYmJyaztcIixcIuKPnVwiOlwiJlVuZGVyUGFyZW50aGVzaXM7XCIsXCLii4NcIjpcIiZ4Y3VwO1wiLFwi4oqOXCI6XCImdXBsdXM7XCIsXCLFslwiOlwiJlVvZ29uO1wiLFwi8J2VjFwiOlwiJlVvcGY7XCIsXCLipJJcIjpcIiZVcEFycm93QmFyO1wiLFwi4oeFXCI6XCImdWRhcnI7XCIsXCLihpVcIjpcIiZ2YXJyO1wiLFwi4qWuXCI6XCImdWRoYXI7XCIsXCLiiqVcIjpcIiZwZXJwO1wiLFwi4oalXCI6XCImbWFwc3RvdXA7XCIsXCLihpZcIjpcIiZud2Fycm93O1wiLFwi4oaXXCI6XCImbmVhcnJvdztcIixcIs+SXCI6XCImdXBzaWg7XCIsXCLOpVwiOlwiJlVwc2lsb247XCIsXCLFrlwiOlwiJlVyaW5nO1wiLFwi8J2SsFwiOlwiJlVzY3I7XCIsXCLFqFwiOlwiJlV0aWxkZTtcIixcIsOcXCI6XCImVXVtbDtcIixcIuKKq1wiOlwiJlZEYXNoO1wiLFwi4qurXCI6XCImVmJhcjtcIixcItCSXCI6XCImVmN5O1wiLFwi4oqpXCI6XCImVmRhc2g7XCIsXCLiq6ZcIjpcIiZWZGFzaGw7XCIsXCLii4FcIjpcIiZ4dmVlO1wiLFwi4oCWXCI6XCImVmVydDtcIixcIuKIo1wiOlwiJnNtaWQ7XCIsXCJ8XCI6XCImdmVydDtcIixcIuKdmFwiOlwiJlZlcnRpY2FsU2VwYXJhdG9yO1wiLFwi4omAXCI6XCImd3JlYXRoO1wiLFwi4oCKXCI6XCImaGFpcnNwO1wiLFwi8J2UmVwiOlwiJlZmcjtcIixcIvCdlY1cIjpcIiZWb3BmO1wiLFwi8J2SsVwiOlwiJlZzY3I7XCIsXCLiiqpcIjpcIiZWdmRhc2g7XCIsXCLFtFwiOlwiJldjaXJjO1wiLFwi4ouAXCI6XCImeHdlZGdlO1wiLFwi8J2UmlwiOlwiJldmcjtcIixcIvCdlY5cIjpcIiZXb3BmO1wiLFwi8J2SslwiOlwiJldzY3I7XCIsXCLwnZSbXCI6XCImWGZyO1wiLFwizp5cIjpcIiZYaTtcIixcIvCdlY9cIjpcIiZYb3BmO1wiLFwi8J2Ss1wiOlwiJlhzY3I7XCIsXCLQr1wiOlwiJllBY3k7XCIsXCLQh1wiOlwiJllJY3k7XCIsXCLQrlwiOlwiJllVY3k7XCIsXCLDnVwiOlwiJllhY3V0ZTtcIixcIsW2XCI6XCImWWNpcmM7XCIsXCLQq1wiOlwiJlljeTtcIixcIvCdlJxcIjpcIiZZZnI7XCIsXCLwnZWQXCI6XCImWW9wZjtcIixcIvCdkrRcIjpcIiZZc2NyO1wiLFwixbhcIjpcIiZZdW1sO1wiLFwi0JZcIjpcIiZaSGN5O1wiLFwixblcIjpcIiZaYWN1dGU7XCIsXCLFvVwiOlwiJlpjYXJvbjtcIixcItCXXCI6XCImWmN5O1wiLFwixbtcIjpcIiZaZG90O1wiLFwizpZcIjpcIiZaZXRhO1wiLFwi4oSoXCI6XCImemVldHJmO1wiLFwi4oSkXCI6XCImaW50ZWdlcnM7XCIsXCLwnZK1XCI6XCImWnNjcjtcIixcIsOhXCI6XCImYWFjdXRlO1wiLFwixINcIjpcIiZhYnJldmU7XCIsXCLiiL5cIjpcIiZtc3Rwb3M7XCIsXCLiiL7Ms1wiOlwiJmFjRTtcIixcIuKIv1wiOlwiJmFjZDtcIixcIsOiXCI6XCImYWNpcmM7XCIsXCLQsFwiOlwiJmFjeTtcIixcIsOmXCI6XCImYWVsaWc7XCIsXCLwnZSeXCI6XCImYWZyO1wiLFwiw6BcIjpcIiZhZ3JhdmU7XCIsXCLihLVcIjpcIiZhbGVwaDtcIixcIs6xXCI6XCImYWxwaGE7XCIsXCLEgVwiOlwiJmFtYWNyO1wiLFwi4qi/XCI6XCImYW1hbGc7XCIsXCLiiKdcIjpcIiZ3ZWRnZTtcIixcIuKplVwiOlwiJmFuZGFuZDtcIixcIuKpnFwiOlwiJmFuZGQ7XCIsXCLiqZhcIjpcIiZhbmRzbG9wZTtcIixcIuKpmlwiOlwiJmFuZHY7XCIsXCLiiKBcIjpcIiZhbmdsZTtcIixcIuKmpFwiOlwiJmFuZ2U7XCIsXCLiiKFcIjpcIiZtZWFzdXJlZGFuZ2xlO1wiLFwi4qaoXCI6XCImYW5nbXNkYWE7XCIsXCLipqlcIjpcIiZhbmdtc2RhYjtcIixcIuKmqlwiOlwiJmFuZ21zZGFjO1wiLFwi4qarXCI6XCImYW5nbXNkYWQ7XCIsXCLipqxcIjpcIiZhbmdtc2RhZTtcIixcIuKmrVwiOlwiJmFuZ21zZGFmO1wiLFwi4qauXCI6XCImYW5nbXNkYWc7XCIsXCLipq9cIjpcIiZhbmdtc2RhaDtcIixcIuKIn1wiOlwiJmFuZ3J0O1wiLFwi4oq+XCI6XCImYW5ncnR2YjtcIixcIuKmnVwiOlwiJmFuZ3J0dmJkO1wiLFwi4oiiXCI6XCImYW5nc3BoO1wiLFwi4o28XCI6XCImYW5nemFycjtcIixcIsSFXCI6XCImYW9nb247XCIsXCLwnZWSXCI6XCImYW9wZjtcIixcIuKpsFwiOlwiJmFwRTtcIixcIuKpr1wiOlwiJmFwYWNpcjtcIixcIuKJilwiOlwiJmFwcHJveGVxO1wiLFwi4omLXCI6XCImYXBpZDtcIixcIidcIjpcIiZhcG9zO1wiLFwiw6VcIjpcIiZhcmluZztcIixcIvCdkrZcIjpcIiZhc2NyO1wiLFwiKlwiOlwiJm1pZGFzdDtcIixcIsOjXCI6XCImYXRpbGRlO1wiLFwiw6RcIjpcIiZhdW1sO1wiLFwi4qiRXCI6XCImYXdpbnQ7XCIsXCLiq61cIjpcIiZiTm90O1wiLFwi4omMXCI6XCImYmNvbmc7XCIsXCLPtlwiOlwiJmJlcHNpO1wiLFwi4oC1XCI6XCImYnByaW1lO1wiLFwi4oi9XCI6XCImYnNpbTtcIixcIuKLjVwiOlwiJmJzaW1lO1wiLFwi4oq9XCI6XCImYmFydmVlO1wiLFwi4oyFXCI6XCImYmFyd2VkZ2U7XCIsXCLijrZcIjpcIiZiYnJrdGJyaztcIixcItCxXCI6XCImYmN5O1wiLFwi4oCeXCI6XCImbGRxdW9yO1wiLFwi4qawXCI6XCImYmVtcHR5djtcIixcIs6yXCI6XCImYmV0YTtcIixcIuKEtlwiOlwiJmJldGg7XCIsXCLiiaxcIjpcIiZ0d2l4dDtcIixcIvCdlJ9cIjpcIiZiZnI7XCIsXCLil69cIjpcIiZ4Y2lyYztcIixcIuKogFwiOlwiJnhvZG90O1wiLFwi4qiBXCI6XCImeG9wbHVzO1wiLFwi4qiCXCI6XCImeG90aW1lO1wiLFwi4qiGXCI6XCImeHNxY3VwO1wiLFwi4piFXCI6XCImc3RhcmY7XCIsXCLilr1cIjpcIiZ4ZHRyaTtcIixcIuKWs1wiOlwiJnh1dHJpO1wiLFwi4qiEXCI6XCImeHVwbHVzO1wiLFwi4qSNXCI6XCImcmJhcnI7XCIsXCLip6tcIjpcIiZsb3pmO1wiLFwi4pa0XCI6XCImdXRyaWY7XCIsXCLilr5cIjpcIiZkdHJpZjtcIixcIuKXglwiOlwiJmx0cmlmO1wiLFwi4pa4XCI6XCImcnRyaWY7XCIsXCLikKNcIjpcIiZibGFuaztcIixcIuKWklwiOlwiJmJsazEyO1wiLFwi4paRXCI6XCImYmxrMTQ7XCIsXCLilpNcIjpcIiZibGszNDtcIixcIuKWiFwiOlwiJmJsb2NrO1wiLFwiPeKDpVwiOlwiJmJuZTtcIixcIuKJoeKDpVwiOlwiJmJuZXF1aXY7XCIsXCLijJBcIjpcIiZibm90O1wiLFwi8J2Vk1wiOlwiJmJvcGY7XCIsXCLii4hcIjpcIiZib3d0aWU7XCIsXCLilZdcIjpcIiZib3hETDtcIixcIuKVlFwiOlwiJmJveERSO1wiLFwi4pWWXCI6XCImYm94RGw7XCIsXCLilZNcIjpcIiZib3hEcjtcIixcIuKVkFwiOlwiJmJveEg7XCIsXCLilaZcIjpcIiZib3hIRDtcIixcIuKVqVwiOlwiJmJveEhVO1wiLFwi4pWkXCI6XCImYm94SGQ7XCIsXCLiladcIjpcIiZib3hIdTtcIixcIuKVnVwiOlwiJmJveFVMO1wiLFwi4pWaXCI6XCImYm94VVI7XCIsXCLilZxcIjpcIiZib3hVbDtcIixcIuKVmVwiOlwiJmJveFVyO1wiLFwi4pWRXCI6XCImYm94VjtcIixcIuKVrFwiOlwiJmJveFZIO1wiLFwi4pWjXCI6XCImYm94Vkw7XCIsXCLilaBcIjpcIiZib3hWUjtcIixcIuKVq1wiOlwiJmJveFZoO1wiLFwi4pWiXCI6XCImYm94Vmw7XCIsXCLilZ9cIjpcIiZib3hWcjtcIixcIuKniVwiOlwiJmJveGJveDtcIixcIuKVlVwiOlwiJmJveGRMO1wiLFwi4pWSXCI6XCImYm94ZFI7XCIsXCLilJBcIjpcIiZib3hkbDtcIixcIuKUjFwiOlwiJmJveGRyO1wiLFwi4pWlXCI6XCImYm94aEQ7XCIsXCLilahcIjpcIiZib3hoVTtcIixcIuKUrFwiOlwiJmJveGhkO1wiLFwi4pS0XCI6XCImYm94aHU7XCIsXCLiip9cIjpcIiZtaW51c2I7XCIsXCLiip5cIjpcIiZwbHVzYjtcIixcIuKKoFwiOlwiJnRpbWVzYjtcIixcIuKVm1wiOlwiJmJveHVMO1wiLFwi4pWYXCI6XCImYm94dVI7XCIsXCLilJhcIjpcIiZib3h1bDtcIixcIuKUlFwiOlwiJmJveHVyO1wiLFwi4pSCXCI6XCImYm94djtcIixcIuKVqlwiOlwiJmJveHZIO1wiLFwi4pWhXCI6XCImYm94dkw7XCIsXCLilZ5cIjpcIiZib3h2UjtcIixcIuKUvFwiOlwiJmJveHZoO1wiLFwi4pSkXCI6XCImYm94dmw7XCIsXCLilJxcIjpcIiZib3h2cjtcIixcIsKmXCI6XCImYnJ2YmFyO1wiLFwi8J2St1wiOlwiJmJzY3I7XCIsXCLigY9cIjpcIiZic2VtaTtcIixcIlxcXFxcIjpcIiZic29sO1wiLFwi4qeFXCI6XCImYnNvbGI7XCIsXCLin4hcIjpcIiZic29saHN1YjtcIixcIuKAolwiOlwiJmJ1bGxldDtcIixcIuKqrlwiOlwiJmJ1bXBFO1wiLFwixIdcIjpcIiZjYWN1dGU7XCIsXCLiiKlcIjpcIiZjYXA7XCIsXCLiqYRcIjpcIiZjYXBhbmQ7XCIsXCLiqYlcIjpcIiZjYXBicmN1cDtcIixcIuKpi1wiOlwiJmNhcGNhcDtcIixcIuKph1wiOlwiJmNhcGN1cDtcIixcIuKpgFwiOlwiJmNhcGRvdDtcIixcIuKIqe+4gFwiOlwiJmNhcHM7XCIsXCLigYFcIjpcIiZjYXJldDtcIixcIuKpjVwiOlwiJmNjYXBzO1wiLFwixI1cIjpcIiZjY2Fyb247XCIsXCLDp1wiOlwiJmNjZWRpbDtcIixcIsSJXCI6XCImY2NpcmM7XCIsXCLiqYxcIjpcIiZjY3VwcztcIixcIuKpkFwiOlwiJmNjdXBzc207XCIsXCLEi1wiOlwiJmNkb3Q7XCIsXCLiprJcIjpcIiZjZW1wdHl2O1wiLFwiwqJcIjpcIiZjZW50O1wiLFwi8J2UoFwiOlwiJmNmcjtcIixcItGHXCI6XCImY2hjeTtcIixcIuKck1wiOlwiJmNoZWNrbWFyaztcIixcIs+HXCI6XCImY2hpO1wiLFwi4peLXCI6XCImY2lyO1wiLFwi4qeDXCI6XCImY2lyRTtcIixcIsuGXCI6XCImY2lyYztcIixcIuKJl1wiOlwiJmNpcmU7XCIsXCLihrpcIjpcIiZvbGFycjtcIixcIuKGu1wiOlwiJm9yYXJyO1wiLFwi4pOIXCI6XCImb1M7XCIsXCLiiptcIjpcIiZvYXN0O1wiLFwi4oqaXCI6XCImb2NpcjtcIixcIuKKnVwiOlwiJm9kYXNoO1wiLFwi4qiQXCI6XCImY2lyZm5pbnQ7XCIsXCLiq69cIjpcIiZjaXJtaWQ7XCIsXCLip4JcIjpcIiZjaXJzY2lyO1wiLFwi4pmjXCI6XCImY2x1YnN1aXQ7XCIsXCI6XCI6XCImY29sb247XCIsXCIsXCI6XCImY29tbWE7XCIsXCJAXCI6XCImY29tbWF0O1wiLFwi4oiBXCI6XCImY29tcGxlbWVudDtcIixcIuKprVwiOlwiJmNvbmdkb3Q7XCIsXCLwnZWUXCI6XCImY29wZjtcIixcIuKEl1wiOlwiJmNvcHlzcjtcIixcIuKGtVwiOlwiJmNyYXJyO1wiLFwi4pyXXCI6XCImY3Jvc3M7XCIsXCLwnZK4XCI6XCImY3NjcjtcIixcIuKrj1wiOlwiJmNzdWI7XCIsXCLiq5FcIjpcIiZjc3ViZTtcIixcIuKrkFwiOlwiJmNzdXA7XCIsXCLiq5JcIjpcIiZjc3VwZTtcIixcIuKLr1wiOlwiJmN0ZG90O1wiLFwi4qS4XCI6XCImY3VkYXJybDtcIixcIuKktVwiOlwiJmN1ZGFycnI7XCIsXCLii55cIjpcIiZjdXJseWVxcHJlYztcIixcIuKLn1wiOlwiJmN1cmx5ZXFzdWNjO1wiLFwi4oa2XCI6XCImY3VydmVhcnJvd2xlZnQ7XCIsXCLipL1cIjpcIiZjdWxhcnJwO1wiLFwi4oiqXCI6XCImY3VwO1wiLFwi4qmIXCI6XCImY3VwYnJjYXA7XCIsXCLiqYZcIjpcIiZjdXBjYXA7XCIsXCLiqYpcIjpcIiZjdXBjdXA7XCIsXCLiio1cIjpcIiZjdXBkb3Q7XCIsXCLiqYVcIjpcIiZjdXBvcjtcIixcIuKIqu+4gFwiOlwiJmN1cHM7XCIsXCLihrdcIjpcIiZjdXJ2ZWFycm93cmlnaHQ7XCIsXCLipLxcIjpcIiZjdXJhcnJtO1wiLFwi4ouOXCI6XCImY3V2ZWU7XCIsXCLii49cIjpcIiZjdXdlZDtcIixcIsKkXCI6XCImY3VycmVuO1wiLFwi4oixXCI6XCImY3dpbnQ7XCIsXCLijK1cIjpcIiZjeWxjdHk7XCIsXCLipaVcIjpcIiZkSGFyO1wiLFwi4oCgXCI6XCImZGFnZ2VyO1wiLFwi4oS4XCI6XCImZGFsZXRoO1wiLFwi4oCQXCI6XCImaHlwaGVuO1wiLFwi4qSPXCI6XCImckJhcnI7XCIsXCLEj1wiOlwiJmRjYXJvbjtcIixcItC0XCI6XCImZGN5O1wiLFwi4oeKXCI6XCImZG93bmRvd25hcnJvd3M7XCIsXCLiqbdcIjpcIiZlRERvdDtcIixcIsKwXCI6XCImZGVnO1wiLFwizrRcIjpcIiZkZWx0YTtcIixcIuKmsVwiOlwiJmRlbXB0eXY7XCIsXCLipb9cIjpcIiZkZmlzaHQ7XCIsXCLwnZShXCI6XCImZGZyO1wiLFwi4pmmXCI6XCImZGlhbXM7XCIsXCLPnVwiOlwiJmdhbW1hZDtcIixcIuKLslwiOlwiJmRpc2luO1wiLFwiw7dcIjpcIiZkaXZpZGU7XCIsXCLii4dcIjpcIiZkaXZvbng7XCIsXCLRklwiOlwiJmRqY3k7XCIsXCLijJ5cIjpcIiZsbGNvcm5lcjtcIixcIuKMjVwiOlwiJmRsY3JvcDtcIiwkOlwiJmRvbGxhcjtcIixcIvCdlZVcIjpcIiZkb3BmO1wiLFwi4omRXCI6XCImZURvdDtcIixcIuKIuFwiOlwiJm1pbnVzZDtcIixcIuKIlFwiOlwiJnBsdXNkbztcIixcIuKKoVwiOlwiJnNkb3RiO1wiLFwi4oyfXCI6XCImbHJjb3JuZXI7XCIsXCLijIxcIjpcIiZkcmNyb3A7XCIsXCLwnZK5XCI6XCImZHNjcjtcIixcItGVXCI6XCImZHNjeTtcIixcIuKntlwiOlwiJmRzb2w7XCIsXCLEkVwiOlwiJmRzdHJvaztcIixcIuKLsVwiOlwiJmR0ZG90O1wiLFwi4pa/XCI6XCImdHJpYW5nbGVkb3duO1wiLFwi4qamXCI6XCImZHdhbmdsZTtcIixcItGfXCI6XCImZHpjeTtcIixcIuKfv1wiOlwiJmR6aWdyYXJyO1wiLFwiw6lcIjpcIiZlYWN1dGU7XCIsXCLiqa5cIjpcIiZlYXN0ZXI7XCIsXCLEm1wiOlwiJmVjYXJvbjtcIixcIuKJllwiOlwiJmVxY2lyYztcIixcIsOqXCI6XCImZWNpcmM7XCIsXCLiiZVcIjpcIiZlcWNvbG9uO1wiLFwi0Y1cIjpcIiZlY3k7XCIsXCLEl1wiOlwiJmVkb3Q7XCIsXCLiiZJcIjpcIiZmYWxsaW5nZG90c2VxO1wiLFwi8J2UolwiOlwiJmVmcjtcIixcIuKqmlwiOlwiJmVnO1wiLFwiw6hcIjpcIiZlZ3JhdmU7XCIsXCLiqpZcIjpcIiZlcXNsYW50Z3RyO1wiLFwi4qqYXCI6XCImZWdzZG90O1wiLFwi4qqZXCI6XCImZWw7XCIsXCLij6dcIjpcIiZlbGludGVycztcIixcIuKEk1wiOlwiJmVsbDtcIixcIuKqlVwiOlwiJmVxc2xhbnRsZXNzO1wiLFwi4qqXXCI6XCImZWxzZG90O1wiLFwixJNcIjpcIiZlbWFjcjtcIixcIuKIhVwiOlwiJnZhcm5vdGhpbmc7XCIsXCLigIRcIjpcIiZlbXNwMTM7XCIsXCLigIVcIjpcIiZlbXNwMTQ7XCIsXCLigINcIjpcIiZlbXNwO1wiLFwixYtcIjpcIiZlbmc7XCIsXCLigIJcIjpcIiZlbnNwO1wiLFwixJlcIjpcIiZlb2dvbjtcIixcIvCdlZZcIjpcIiZlb3BmO1wiLFwi4ouVXCI6XCImZXBhcjtcIixcIuKno1wiOlwiJmVwYXJzbDtcIixcIuKpsVwiOlwiJmVwbHVzO1wiLFwizrVcIjpcIiZlcHNpbG9uO1wiLFwiz7VcIjpcIiZ2YXJlcHNpbG9uO1wiLFwiPVwiOlwiJmVxdWFscztcIixcIuKJn1wiOlwiJnF1ZXN0ZXE7XCIsXCLiqbhcIjpcIiZlcXVpdkREO1wiLFwi4qelXCI6XCImZXF2cGFyc2w7XCIsXCLiiZNcIjpcIiZyaXNpbmdkb3RzZXE7XCIsXCLipbFcIjpcIiZlcmFycjtcIixcIuKEr1wiOlwiJmVzY3I7XCIsXCLOt1wiOlwiJmV0YTtcIixcIsOwXCI6XCImZXRoO1wiLFwiw6tcIjpcIiZldW1sO1wiLFwi4oKsXCI6XCImZXVybztcIixcIiFcIjpcIiZleGNsO1wiLFwi0YRcIjpcIiZmY3k7XCIsXCLimYBcIjpcIiZmZW1hbGU7XCIsXCLvrINcIjpcIiZmZmlsaWc7XCIsXCLvrIBcIjpcIiZmZmxpZztcIixcIu+shFwiOlwiJmZmbGxpZztcIixcIvCdlKNcIjpcIiZmZnI7XCIsXCLvrIFcIjpcIiZmaWxpZztcIixmajpcIiZmamxpZztcIixcIuKZrVwiOlwiJmZsYXQ7XCIsXCLvrIJcIjpcIiZmbGxpZztcIixcIuKWsVwiOlwiJmZsdG5zO1wiLFwixpJcIjpcIiZmbm9mO1wiLFwi8J2Vl1wiOlwiJmZvcGY7XCIsXCLii5RcIjpcIiZwaXRjaGZvcms7XCIsXCLiq5lcIjpcIiZmb3JrdjtcIixcIuKojVwiOlwiJmZwYXJ0aW50O1wiLFwiwr1cIjpcIiZoYWxmO1wiLFwi4oWTXCI6XCImZnJhYzEzO1wiLFwiwrxcIjpcIiZmcmFjMTQ7XCIsXCLihZVcIjpcIiZmcmFjMTU7XCIsXCLihZlcIjpcIiZmcmFjMTY7XCIsXCLihZtcIjpcIiZmcmFjMTg7XCIsXCLihZRcIjpcIiZmcmFjMjM7XCIsXCLihZZcIjpcIiZmcmFjMjU7XCIsXCLCvlwiOlwiJmZyYWMzNDtcIixcIuKFl1wiOlwiJmZyYWMzNTtcIixcIuKFnFwiOlwiJmZyYWMzODtcIixcIuKFmFwiOlwiJmZyYWM0NTtcIixcIuKFmlwiOlwiJmZyYWM1NjtcIixcIuKFnVwiOlwiJmZyYWM1ODtcIixcIuKFnlwiOlwiJmZyYWM3ODtcIixcIuKBhFwiOlwiJmZyYXNsO1wiLFwi4oyiXCI6XCImc2Zyb3duO1wiLFwi8J2Su1wiOlwiJmZzY3I7XCIsXCLiqoxcIjpcIiZndHJlcXFsZXNzO1wiLFwix7VcIjpcIiZnYWN1dGU7XCIsXCLOs1wiOlwiJmdhbW1hO1wiLFwi4qqGXCI6XCImZ3RyYXBwcm94O1wiLFwixJ9cIjpcIiZnYnJldmU7XCIsXCLEnVwiOlwiJmdjaXJjO1wiLFwi0LNcIjpcIiZnY3k7XCIsXCLEoVwiOlwiJmdkb3Q7XCIsXCLiqqlcIjpcIiZnZXNjYztcIixcIuKqgFwiOlwiJmdlc2RvdDtcIixcIuKqglwiOlwiJmdlc2RvdG87XCIsXCLiqoRcIjpcIiZnZXNkb3RvbDtcIixcIuKLm++4gFwiOlwiJmdlc2w7XCIsXCLiqpRcIjpcIiZnZXNsZXM7XCIsXCLwnZSkXCI6XCImZ2ZyO1wiLFwi4oS3XCI6XCImZ2ltZWw7XCIsXCLRk1wiOlwiJmdqY3k7XCIsXCLiqpJcIjpcIiZnbEU7XCIsXCLiqqVcIjpcIiZnbGE7XCIsXCLiqqRcIjpcIiZnbGo7XCIsXCLiialcIjpcIiZnbmVxcTtcIixcIuKqilwiOlwiJmduYXBwcm94O1wiLFwi4qqIXCI6XCImZ25lcTtcIixcIuKLp1wiOlwiJmduc2ltO1wiLFwi8J2VmFwiOlwiJmdvcGY7XCIsXCLihIpcIjpcIiZnc2NyO1wiLFwi4qqOXCI6XCImZ3NpbWU7XCIsXCLiqpBcIjpcIiZnc2ltbDtcIixcIuKqp1wiOlwiJmd0Y2M7XCIsXCLiqbpcIjpcIiZndGNpcjtcIixcIuKLl1wiOlwiJmd0cmRvdDtcIixcIuKmlVwiOlwiJmd0bFBhcjtcIixcIuKpvFwiOlwiJmd0cXVlc3Q7XCIsXCLipbhcIjpcIiZndHJhcnI7XCIsXCLiianvuIBcIjpcIiZndm5FO1wiLFwi0YpcIjpcIiZoYXJkY3k7XCIsXCLipYhcIjpcIiZoYXJyY2lyO1wiLFwi4oatXCI6XCImbGVmdHJpZ2h0c3F1aWdhcnJvdztcIixcIuKEj1wiOlwiJnBsYW5rdjtcIixcIsSlXCI6XCImaGNpcmM7XCIsXCLimaVcIjpcIiZoZWFydHN1aXQ7XCIsXCLigKZcIjpcIiZtbGRyO1wiLFwi4oq5XCI6XCImaGVyY29uO1wiLFwi8J2UpVwiOlwiJmhmcjtcIixcIuKkpVwiOlwiJnNlYXJoaztcIixcIuKkplwiOlwiJnN3YXJoaztcIixcIuKHv1wiOlwiJmhvYXJyO1wiLFwi4oi7XCI6XCImaG9tdGh0O1wiLFwi4oapXCI6XCImbGFycmhrO1wiLFwi4oaqXCI6XCImcmFycmhrO1wiLFwi8J2VmVwiOlwiJmhvcGY7XCIsXCLigJVcIjpcIiZob3JiYXI7XCIsXCLwnZK9XCI6XCImaHNjcjtcIixcIsSnXCI6XCImaHN0cm9rO1wiLFwi4oGDXCI6XCImaHlidWxsO1wiLFwiw61cIjpcIiZpYWN1dGU7XCIsXCLDrlwiOlwiJmljaXJjO1wiLFwi0LhcIjpcIiZpY3k7XCIsXCLQtVwiOlwiJmllY3k7XCIsXCLCoVwiOlwiJmlleGNsO1wiLFwi8J2UplwiOlwiJmlmcjtcIixcIsOsXCI6XCImaWdyYXZlO1wiLFwi4qiMXCI6XCImcWludDtcIixcIuKIrVwiOlwiJnRpbnQ7XCIsXCLip5xcIjpcIiZpaW5maW47XCIsXCLihKlcIjpcIiZpaW90YTtcIixcIsSzXCI6XCImaWpsaWc7XCIsXCLEq1wiOlwiJmltYWNyO1wiLFwixLFcIjpcIiZpbm9kb3Q7XCIsXCLiirdcIjpcIiZpbW9mO1wiLFwixrVcIjpcIiZpbXBlZDtcIixcIuKEhVwiOlwiJmluY2FyZTtcIixcIuKInlwiOlwiJmluZmluO1wiLFwi4qedXCI6XCImaW5maW50aWU7XCIsXCLiirpcIjpcIiZpbnRlcmNhbDtcIixcIuKol1wiOlwiJmludGxhcmhrO1wiLFwi4qi8XCI6XCImaXByb2Q7XCIsXCLRkVwiOlwiJmlvY3k7XCIsXCLEr1wiOlwiJmlvZ29uO1wiLFwi8J2VmlwiOlwiJmlvcGY7XCIsXCLOuVwiOlwiJmlvdGE7XCIsXCLCv1wiOlwiJmlxdWVzdDtcIixcIvCdkr5cIjpcIiZpc2NyO1wiLFwi4ou5XCI6XCImaXNpbkU7XCIsXCLii7VcIjpcIiZpc2luZG90O1wiLFwi4ou0XCI6XCImaXNpbnM7XCIsXCLii7NcIjpcIiZpc2luc3Y7XCIsXCLEqVwiOlwiJml0aWxkZTtcIixcItGWXCI6XCImaXVrY3k7XCIsXCLDr1wiOlwiJml1bWw7XCIsXCLEtVwiOlwiJmpjaXJjO1wiLFwi0LlcIjpcIiZqY3k7XCIsXCLwnZSnXCI6XCImamZyO1wiLFwiyLdcIjpcIiZqbWF0aDtcIixcIvCdlZtcIjpcIiZqb3BmO1wiLFwi8J2Sv1wiOlwiJmpzY3I7XCIsXCLRmFwiOlwiJmpzZXJjeTtcIixcItGUXCI6XCImanVrY3k7XCIsXCLOulwiOlwiJmthcHBhO1wiLFwiz7BcIjpcIiZ2YXJrYXBwYTtcIixcIsS3XCI6XCIma2NlZGlsO1wiLFwi0LpcIjpcIiZrY3k7XCIsXCLwnZSoXCI6XCIma2ZyO1wiLFwixLhcIjpcIiZrZ3JlZW47XCIsXCLRhVwiOlwiJmtoY3k7XCIsXCLRnFwiOlwiJmtqY3k7XCIsXCLwnZWcXCI6XCIma29wZjtcIixcIvCdk4BcIjpcIiZrc2NyO1wiLFwi4qSbXCI6XCImbEF0YWlsO1wiLFwi4qSOXCI6XCImbEJhcnI7XCIsXCLiqotcIjpcIiZsZXNzZXFxZ3RyO1wiLFwi4qWiXCI6XCImbEhhcjtcIixcIsS6XCI6XCImbGFjdXRlO1wiLFwi4qa0XCI6XCImbGFlbXB0eXY7XCIsXCLOu1wiOlwiJmxhbWJkYTtcIixcIuKmkVwiOlwiJmxhbmdkO1wiLFwi4qqFXCI6XCImbGVzc2FwcHJveDtcIixcIsKrXCI6XCImbGFxdW87XCIsXCLipJ9cIjpcIiZsYXJyYmZzO1wiLFwi4qSdXCI6XCImbGFycmZzO1wiLFwi4oarXCI6XCImbG9vcGFycm93bGVmdDtcIixcIuKkuVwiOlwiJmxhcnJwbDtcIixcIuKls1wiOlwiJmxhcnJzaW07XCIsXCLihqJcIjpcIiZsZWZ0YXJyb3d0YWlsO1wiLFwi4qqrXCI6XCImbGF0O1wiLFwi4qSZXCI6XCImbGF0YWlsO1wiLFwi4qqtXCI6XCImbGF0ZTtcIixcIuKqre+4gFwiOlwiJmxhdGVzO1wiLFwi4qSMXCI6XCImbGJhcnI7XCIsXCLinbJcIjpcIiZsYmJyaztcIixcIntcIjpcIiZsY3ViO1wiLFwiW1wiOlwiJmxzcWI7XCIsXCLipotcIjpcIiZsYnJrZTtcIixcIuKmj1wiOlwiJmxicmtzbGQ7XCIsXCLipo1cIjpcIiZsYnJrc2x1O1wiLFwixL5cIjpcIiZsY2Fyb247XCIsXCLEvFwiOlwiJmxjZWRpbDtcIixcItC7XCI6XCImbGN5O1wiLFwi4qS2XCI6XCImbGRjYTtcIixcIuKlp1wiOlwiJmxkcmRoYXI7XCIsXCLipYtcIjpcIiZsZHJ1c2hhcjtcIixcIuKGslwiOlwiJmxkc2g7XCIsXCLiiaRcIjpcIiZsZXE7XCIsXCLih4dcIjpcIiZsbGFycjtcIixcIuKLi1wiOlwiJmx0aHJlZTtcIixcIuKqqFwiOlwiJmxlc2NjO1wiLFwi4qm/XCI6XCImbGVzZG90O1wiLFwi4qqBXCI6XCImbGVzZG90bztcIixcIuKqg1wiOlwiJmxlc2RvdG9yO1wiLFwi4oua77iAXCI6XCImbGVzZztcIixcIuKqk1wiOlwiJmxlc2dlcztcIixcIuKLllwiOlwiJmx0ZG90O1wiLFwi4qW8XCI6XCImbGZpc2h0O1wiLFwi8J2UqVwiOlwiJmxmcjtcIixcIuKqkVwiOlwiJmxnRTtcIixcIuKlqlwiOlwiJmxoYXJ1bDtcIixcIuKWhFwiOlwiJmxoYmxrO1wiLFwi0ZlcIjpcIiZsamN5O1wiLFwi4qWrXCI6XCImbGxoYXJkO1wiLFwi4pe6XCI6XCImbGx0cmk7XCIsXCLFgFwiOlwiJmxtaWRvdDtcIixcIuKOsFwiOlwiJmxtb3VzdGFjaGU7XCIsXCLiiahcIjpcIiZsbmVxcTtcIixcIuKqiVwiOlwiJmxuYXBwcm94O1wiLFwi4qqHXCI6XCImbG5lcTtcIixcIuKLplwiOlwiJmxuc2ltO1wiLFwi4p+sXCI6XCImbG9hbmc7XCIsXCLih71cIjpcIiZsb2FycjtcIixcIuKfvFwiOlwiJnhtYXA7XCIsXCLihqxcIjpcIiZyYXJybHA7XCIsXCLipoVcIjpcIiZsb3BhcjtcIixcIvCdlZ1cIjpcIiZsb3BmO1wiLFwi4qitXCI6XCImbG9wbHVzO1wiLFwi4qi0XCI6XCImbG90aW1lcztcIixcIuKIl1wiOlwiJmxvd2FzdDtcIixcIuKXilwiOlwiJmxvemVuZ2U7XCIsXCIoXCI6XCImbHBhcjtcIixcIuKmk1wiOlwiJmxwYXJsdDtcIixcIuKlrVwiOlwiJmxyaGFyZDtcIixcIuKAjlwiOlwiJmxybTtcIixcIuKKv1wiOlwiJmxydHJpO1wiLFwi4oC5XCI6XCImbHNhcXVvO1wiLFwi8J2TgVwiOlwiJmxzY3I7XCIsXCLiqo1cIjpcIiZsc2ltZTtcIixcIuKqj1wiOlwiJmxzaW1nO1wiLFwi4oCaXCI6XCImc2JxdW87XCIsXCLFglwiOlwiJmxzdHJvaztcIixcIuKqplwiOlwiJmx0Y2M7XCIsXCLiqblcIjpcIiZsdGNpcjtcIixcIuKLiVwiOlwiJmx0aW1lcztcIixcIuKltlwiOlwiJmx0bGFycjtcIixcIuKpu1wiOlwiJmx0cXVlc3Q7XCIsXCLippZcIjpcIiZsdHJQYXI7XCIsXCLil4NcIjpcIiZ0cmlhbmdsZWxlZnQ7XCIsXCLipYpcIjpcIiZsdXJkc2hhcjtcIixcIuKlplwiOlwiJmx1cnVoYXI7XCIsXCLiiajvuIBcIjpcIiZsdm5FO1wiLFwi4oi6XCI6XCImbUREb3Q7XCIsXCLCr1wiOlwiJnN0cm5zO1wiLFwi4pmCXCI6XCImbWFsZTtcIixcIuKcoFwiOlwiJm1hbHRlc2U7XCIsXCLilq5cIjpcIiZtYXJrZXI7XCIsXCLiqKlcIjpcIiZtY29tbWE7XCIsXCLQvFwiOlwiJm1jeTtcIixcIuKAlFwiOlwiJm1kYXNoO1wiLFwi8J2UqlwiOlwiJm1mcjtcIixcIuKEp1wiOlwiJm1obztcIixcIsK1XCI6XCImbWljcm87XCIsXCLiq7BcIjpcIiZtaWRjaXI7XCIsXCLiiJJcIjpcIiZtaW51cztcIixcIuKoqlwiOlwiJm1pbnVzZHU7XCIsXCLiq5tcIjpcIiZtbGNwO1wiLFwi4oqnXCI6XCImbW9kZWxzO1wiLFwi8J2VnlwiOlwiJm1vcGY7XCIsXCLwnZOCXCI6XCImbXNjcjtcIixcIs68XCI6XCImbXU7XCIsXCLiirhcIjpcIiZtdW1hcDtcIixcIuKLmcy4XCI6XCImbkdnO1wiLFwi4omr4oOSXCI6XCImbkd0O1wiLFwi4oeNXCI6XCImbmxBcnI7XCIsXCLih45cIjpcIiZuaEFycjtcIixcIuKLmMy4XCI6XCImbkxsO1wiLFwi4omq4oOSXCI6XCImbkx0O1wiLFwi4oePXCI6XCImbnJBcnI7XCIsXCLiiq9cIjpcIiZuVkRhc2g7XCIsXCLiiq5cIjpcIiZuVmRhc2g7XCIsXCLFhFwiOlwiJm5hY3V0ZTtcIixcIuKIoOKDklwiOlwiJm5hbmc7XCIsXCLiqbDMuFwiOlwiJm5hcEU7XCIsXCLiiYvMuFwiOlwiJm5hcGlkO1wiLFwixYlcIjpcIiZuYXBvcztcIixcIuKZrlwiOlwiJm5hdHVyYWw7XCIsXCLiqYNcIjpcIiZuY2FwO1wiLFwixYhcIjpcIiZuY2Fyb247XCIsXCLFhlwiOlwiJm5jZWRpbDtcIixcIuKprcy4XCI6XCImbmNvbmdkb3Q7XCIsXCLiqYJcIjpcIiZuY3VwO1wiLFwi0L1cIjpcIiZuY3k7XCIsXCLigJNcIjpcIiZuZGFzaDtcIixcIuKHl1wiOlwiJm5lQXJyO1wiLFwi4qSkXCI6XCImbmVhcmhrO1wiLFwi4omQzLhcIjpcIiZuZWRvdDtcIixcIuKkqFwiOlwiJnRvZWE7XCIsXCLwnZSrXCI6XCImbmZyO1wiLFwi4oauXCI6XCImbmxlZnRyaWdodGFycm93O1wiLFwi4quyXCI6XCImbmhwYXI7XCIsXCLii7xcIjpcIiZuaXM7XCIsXCLii7pcIjpcIiZuaXNkO1wiLFwi0ZpcIjpcIiZuamN5O1wiLFwi4ommzLhcIjpcIiZubGVxcTtcIixcIuKGmlwiOlwiJm5sZWZ0YXJyb3c7XCIsXCLigKVcIjpcIiZubGRyO1wiLFwi8J2Vn1wiOlwiJm5vcGY7XCIsXCLCrFwiOlwiJm5vdDtcIixcIuKLucy4XCI6XCImbm90aW5FO1wiLFwi4ou1zLhcIjpcIiZub3RpbmRvdDtcIixcIuKLt1wiOlwiJm5vdGludmI7XCIsXCLii7ZcIjpcIiZub3RpbnZjO1wiLFwi4ou+XCI6XCImbm90bml2YjtcIixcIuKLvVwiOlwiJm5vdG5pdmM7XCIsXCLiq73ig6VcIjpcIiZucGFyc2w7XCIsXCLiiILMuFwiOlwiJm5wYXJ0O1wiLFwi4qiUXCI6XCImbnBvbGludDtcIixcIuKGm1wiOlwiJm5yaWdodGFycm93O1wiLFwi4qSzzLhcIjpcIiZucmFycmM7XCIsXCLihp3MuFwiOlwiJm5yYXJydztcIixcIvCdk4NcIjpcIiZuc2NyO1wiLFwi4oqEXCI6XCImbnN1YjtcIixcIuKrhcy4XCI6XCImbnN1YnNldGVxcTtcIixcIuKKhVwiOlwiJm5zdXA7XCIsXCLiq4bMuFwiOlwiJm5zdXBzZXRlcXE7XCIsXCLDsVwiOlwiJm50aWxkZTtcIixcIs69XCI6XCImbnU7XCIsXCIjXCI6XCImbnVtO1wiLFwi4oSWXCI6XCImbnVtZXJvO1wiLFwi4oCHXCI6XCImbnVtc3A7XCIsXCLiiq1cIjpcIiZudkRhc2g7XCIsXCLipIRcIjpcIiZudkhhcnI7XCIsXCLiiY3ig5JcIjpcIiZudmFwO1wiLFwi4oqsXCI6XCImbnZkYXNoO1wiLFwi4oml4oOSXCI6XCImbnZnZTtcIixcIj7ig5JcIjpcIiZudmd0O1wiLFwi4qeeXCI6XCImbnZpbmZpbjtcIixcIuKkglwiOlwiJm52bEFycjtcIixcIuKJpOKDklwiOlwiJm52bGU7XCIsXCI84oOSXCI6XCImbnZsdDtcIixcIuKKtOKDklwiOlwiJm52bHRyaWU7XCIsXCLipINcIjpcIiZudnJBcnI7XCIsXCLiirXig5JcIjpcIiZudnJ0cmllO1wiLFwi4oi84oOSXCI6XCImbnZzaW07XCIsXCLih5ZcIjpcIiZud0FycjtcIixcIuKko1wiOlwiJm53YXJoaztcIixcIuKkp1wiOlwiJm53bmVhcjtcIixcIsOzXCI6XCImb2FjdXRlO1wiLFwiw7RcIjpcIiZvY2lyYztcIixcItC+XCI6XCImb2N5O1wiLFwixZFcIjpcIiZvZGJsYWM7XCIsXCLiqLhcIjpcIiZvZGl2O1wiLFwi4qa8XCI6XCImb2Rzb2xkO1wiLFwixZNcIjpcIiZvZWxpZztcIixcIuKmv1wiOlwiJm9mY2lyO1wiLFwi8J2UrFwiOlwiJm9mcjtcIixcIsubXCI6XCImb2dvbjtcIixcIsOyXCI6XCImb2dyYXZlO1wiLFwi4qeBXCI6XCImb2d0O1wiLFwi4qa1XCI6XCImb2hiYXI7XCIsXCLipr5cIjpcIiZvbGNpcjtcIixcIuKmu1wiOlwiJm9sY3Jvc3M7XCIsXCLip4BcIjpcIiZvbHQ7XCIsXCLFjVwiOlwiJm9tYWNyO1wiLFwiz4lcIjpcIiZvbWVnYTtcIixcIs6/XCI6XCImb21pY3JvbjtcIixcIuKmtlwiOlwiJm9taWQ7XCIsXCLwnZWgXCI6XCImb29wZjtcIixcIuKmt1wiOlwiJm9wYXI7XCIsXCLiprlcIjpcIiZvcGVycDtcIixcIuKIqFwiOlwiJnZlZTtcIixcIuKpnVwiOlwiJm9yZDtcIixcIuKEtFwiOlwiJm9zY3I7XCIsXCLCqlwiOlwiJm9yZGY7XCIsXCLCulwiOlwiJm9yZG07XCIsXCLiirZcIjpcIiZvcmlnb2Y7XCIsXCLiqZZcIjpcIiZvcm9yO1wiLFwi4qmXXCI6XCImb3JzbG9wZTtcIixcIuKpm1wiOlwiJm9ydjtcIixcIsO4XCI6XCImb3NsYXNoO1wiLFwi4oqYXCI6XCImb3NvbDtcIixcIsO1XCI6XCImb3RpbGRlO1wiLFwi4qi2XCI6XCImb3RpbWVzYXM7XCIsXCLDtlwiOlwiJm91bWw7XCIsXCLijL1cIjpcIiZvdmJhcjtcIixcIsK2XCI6XCImcGFyYTtcIixcIuKrs1wiOlwiJnBhcnNpbTtcIixcIuKrvVwiOlwiJnBhcnNsO1wiLFwi0L9cIjpcIiZwY3k7XCIsXCIlXCI6XCImcGVyY250O1wiLFwiLlwiOlwiJnBlcmlvZDtcIixcIuKAsFwiOlwiJnBlcm1pbDtcIixcIuKAsVwiOlwiJnBlcnRlbms7XCIsXCLwnZStXCI6XCImcGZyO1wiLFwiz4ZcIjpcIiZwaGk7XCIsXCLPlVwiOlwiJnZhcnBoaTtcIixcIuKYjlwiOlwiJnBob25lO1wiLFwiz4BcIjpcIiZwaTtcIixcIs+WXCI6XCImdmFycGk7XCIsXCLihI5cIjpcIiZwbGFuY2toO1wiLFwiK1wiOlwiJnBsdXM7XCIsXCLiqKNcIjpcIiZwbHVzYWNpcjtcIixcIuKoolwiOlwiJnBsdXNjaXI7XCIsXCLiqKVcIjpcIiZwbHVzZHU7XCIsXCLiqbJcIjpcIiZwbHVzZTtcIixcIuKoplwiOlwiJnBsdXNzaW07XCIsXCLiqKdcIjpcIiZwbHVzdHdvO1wiLFwi4qiVXCI6XCImcG9pbnRpbnQ7XCIsXCLwnZWhXCI6XCImcG9wZjtcIixcIsKjXCI6XCImcG91bmQ7XCIsXCLiqrNcIjpcIiZwckU7XCIsXCLiqrdcIjpcIiZwcmVjYXBwcm94O1wiLFwi4qq5XCI6XCImcHJuYXA7XCIsXCLiqrVcIjpcIiZwcm5FO1wiLFwi4ouoXCI6XCImcHJuc2ltO1wiLFwi4oCyXCI6XCImcHJpbWU7XCIsXCLijK5cIjpcIiZwcm9mYWxhcjtcIixcIuKMklwiOlwiJnByb2ZsaW5lO1wiLFwi4oyTXCI6XCImcHJvZnN1cmY7XCIsXCLiirBcIjpcIiZwcnVyZWw7XCIsXCLwnZOFXCI6XCImcHNjcjtcIixcIs+IXCI6XCImcHNpO1wiLFwi4oCIXCI6XCImcHVuY3NwO1wiLFwi8J2UrlwiOlwiJnFmcjtcIixcIvCdlaJcIjpcIiZxb3BmO1wiLFwi4oGXXCI6XCImcXByaW1lO1wiLFwi8J2ThlwiOlwiJnFzY3I7XCIsXCLiqJZcIjpcIiZxdWF0aW50O1wiLFwiP1wiOlwiJnF1ZXN0O1wiLFwi4qScXCI6XCImckF0YWlsO1wiLFwi4qWkXCI6XCImckhhcjtcIixcIuKIvcyxXCI6XCImcmFjZTtcIixcIsWVXCI6XCImcmFjdXRlO1wiLFwi4qazXCI6XCImcmFlbXB0eXY7XCIsXCLippJcIjpcIiZyYW5nZDtcIixcIuKmpVwiOlwiJnJhbmdlO1wiLFwiwrtcIjpcIiZyYXF1bztcIixcIuKltVwiOlwiJnJhcnJhcDtcIixcIuKkoFwiOlwiJnJhcnJiZnM7XCIsXCLipLNcIjpcIiZyYXJyYztcIixcIuKknlwiOlwiJnJhcnJmcztcIixcIuKlhVwiOlwiJnJhcnJwbDtcIixcIuKltFwiOlwiJnJhcnJzaW07XCIsXCLihqNcIjpcIiZyaWdodGFycm93dGFpbDtcIixcIuKGnVwiOlwiJnJpZ2h0c3F1aWdhcnJvdztcIixcIuKkmlwiOlwiJnJhdGFpbDtcIixcIuKItlwiOlwiJnJhdGlvO1wiLFwi4p2zXCI6XCImcmJicms7XCIsXCJ9XCI6XCImcmN1YjtcIixcIl1cIjpcIiZyc3FiO1wiLFwi4qaMXCI6XCImcmJya2U7XCIsXCLipo5cIjpcIiZyYnJrc2xkO1wiLFwi4qaQXCI6XCImcmJya3NsdTtcIixcIsWZXCI6XCImcmNhcm9uO1wiLFwixZdcIjpcIiZyY2VkaWw7XCIsXCLRgFwiOlwiJnJjeTtcIixcIuKkt1wiOlwiJnJkY2E7XCIsXCLipalcIjpcIiZyZGxkaGFyO1wiLFwi4oazXCI6XCImcmRzaDtcIixcIuKWrVwiOlwiJnJlY3Q7XCIsXCLipb1cIjpcIiZyZmlzaHQ7XCIsXCLwnZSvXCI6XCImcmZyO1wiLFwi4qWsXCI6XCImcmhhcnVsO1wiLFwiz4FcIjpcIiZyaG87XCIsXCLPsVwiOlwiJnZhcnJobztcIixcIuKHiVwiOlwiJnJyYXJyO1wiLFwi4ouMXCI6XCImcnRocmVlO1wiLFwiy5pcIjpcIiZyaW5nO1wiLFwi4oCPXCI6XCImcmxtO1wiLFwi4o6xXCI6XCImcm1vdXN0YWNoZTtcIixcIuKrrlwiOlwiJnJubWlkO1wiLFwi4p+tXCI6XCImcm9hbmc7XCIsXCLih75cIjpcIiZyb2FycjtcIixcIuKmhlwiOlwiJnJvcGFyO1wiLFwi8J2Vo1wiOlwiJnJvcGY7XCIsXCLiqK5cIjpcIiZyb3BsdXM7XCIsXCLiqLVcIjpcIiZyb3RpbWVzO1wiLFwiKVwiOlwiJnJwYXI7XCIsXCLippRcIjpcIiZycGFyZ3Q7XCIsXCLiqJJcIjpcIiZycHBvbGludDtcIixcIuKAulwiOlwiJnJzYXF1bztcIixcIvCdk4dcIjpcIiZyc2NyO1wiLFwi4ouKXCI6XCImcnRpbWVzO1wiLFwi4pa5XCI6XCImdHJpYW5nbGVyaWdodDtcIixcIuKnjlwiOlwiJnJ0cmlsdHJpO1wiLFwi4qWoXCI6XCImcnVsdWhhcjtcIixcIuKEnlwiOlwiJnJ4O1wiLFwixZtcIjpcIiZzYWN1dGU7XCIsXCLiqrRcIjpcIiZzY0U7XCIsXCLiqrhcIjpcIiZzdWNjYXBwcm94O1wiLFwixaFcIjpcIiZzY2Fyb247XCIsXCLFn1wiOlwiJnNjZWRpbDtcIixcIsWdXCI6XCImc2NpcmM7XCIsXCLiqrZcIjpcIiZzdWNjbmVxcTtcIixcIuKqulwiOlwiJnN1Y2NuYXBwcm94O1wiLFwi4oupXCI6XCImc3VjY25zaW07XCIsXCLiqJNcIjpcIiZzY3BvbGludDtcIixcItGBXCI6XCImc2N5O1wiLFwi4ouFXCI6XCImc2RvdDtcIixcIuKpplwiOlwiJnNkb3RlO1wiLFwi4oeYXCI6XCImc2VBcnI7XCIsXCLCp1wiOlwiJnNlY3Q7XCIsXCI7XCI6XCImc2VtaTtcIixcIuKkqVwiOlwiJnRvc2E7XCIsXCLinLZcIjpcIiZzZXh0O1wiLFwi8J2UsFwiOlwiJnNmcjtcIixcIuKZr1wiOlwiJnNoYXJwO1wiLFwi0YlcIjpcIiZzaGNoY3k7XCIsXCLRiFwiOlwiJnNoY3k7XCIsXCLCrVwiOlwiJnNoeTtcIixcIs+DXCI6XCImc2lnbWE7XCIsXCLPglwiOlwiJnZhcnNpZ21hO1wiLFwi4qmqXCI6XCImc2ltZG90O1wiLFwi4qqeXCI6XCImc2ltZztcIixcIuKqoFwiOlwiJnNpbWdFO1wiLFwi4qqdXCI6XCImc2ltbDtcIixcIuKqn1wiOlwiJnNpbWxFO1wiLFwi4omGXCI6XCImc2ltbmU7XCIsXCLiqKRcIjpcIiZzaW1wbHVzO1wiLFwi4qWyXCI6XCImc2ltcmFycjtcIixcIuKos1wiOlwiJnNtYXNocDtcIixcIuKnpFwiOlwiJnNtZXBhcnNsO1wiLFwi4oyjXCI6XCImc3NtaWxlO1wiLFwi4qqqXCI6XCImc210O1wiLFwi4qqsXCI6XCImc210ZTtcIixcIuKqrO+4gFwiOlwiJnNtdGVzO1wiLFwi0YxcIjpcIiZzb2Z0Y3k7XCIsXCIvXCI6XCImc29sO1wiLFwi4qeEXCI6XCImc29sYjtcIixcIuKMv1wiOlwiJnNvbGJhcjtcIixcIvCdlaRcIjpcIiZzb3BmO1wiLFwi4pmgXCI6XCImc3BhZGVzdWl0O1wiLFwi4oqT77iAXCI6XCImc3FjYXBzO1wiLFwi4oqU77iAXCI6XCImc3FjdXBzO1wiLFwi8J2TiFwiOlwiJnNzY3I7XCIsXCLimIZcIjpcIiZzdGFyO1wiLFwi4oqCXCI6XCImc3Vic2V0O1wiLFwi4quFXCI6XCImc3Vic2V0ZXFxO1wiLFwi4qq9XCI6XCImc3ViZG90O1wiLFwi4quDXCI6XCImc3ViZWRvdDtcIixcIuKrgVwiOlwiJnN1Ym11bHQ7XCIsXCLiq4tcIjpcIiZzdWJzZXRuZXFxO1wiLFwi4oqKXCI6XCImc3Vic2V0bmVxO1wiLFwi4qq/XCI6XCImc3VicGx1cztcIixcIuKluVwiOlwiJnN1YnJhcnI7XCIsXCLiq4dcIjpcIiZzdWJzaW07XCIsXCLiq5VcIjpcIiZzdWJzdWI7XCIsXCLiq5NcIjpcIiZzdWJzdXA7XCIsXCLimapcIjpcIiZzdW5nO1wiLFwiwrlcIjpcIiZzdXAxO1wiLFwiwrJcIjpcIiZzdXAyO1wiLFwiwrNcIjpcIiZzdXAzO1wiLFwi4quGXCI6XCImc3Vwc2V0ZXFxO1wiLFwi4qq+XCI6XCImc3VwZG90O1wiLFwi4quYXCI6XCImc3VwZHN1YjtcIixcIuKrhFwiOlwiJnN1cGVkb3Q7XCIsXCLin4lcIjpcIiZzdXBoc29sO1wiLFwi4quXXCI6XCImc3VwaHN1YjtcIixcIuKlu1wiOlwiJnN1cGxhcnI7XCIsXCLiq4JcIjpcIiZzdXBtdWx0O1wiLFwi4quMXCI6XCImc3Vwc2V0bmVxcTtcIixcIuKKi1wiOlwiJnN1cHNldG5lcTtcIixcIuKrgFwiOlwiJnN1cHBsdXM7XCIsXCLiq4hcIjpcIiZzdXBzaW07XCIsXCLiq5RcIjpcIiZzdXBzdWI7XCIsXCLiq5ZcIjpcIiZzdXBzdXA7XCIsXCLih5lcIjpcIiZzd0FycjtcIixcIuKkqlwiOlwiJnN3bndhcjtcIixcIsOfXCI6XCImc3psaWc7XCIsXCLijJZcIjpcIiZ0YXJnZXQ7XCIsXCLPhFwiOlwiJnRhdTtcIixcIsWlXCI6XCImdGNhcm9uO1wiLFwixaNcIjpcIiZ0Y2VkaWw7XCIsXCLRglwiOlwiJnRjeTtcIixcIuKMlVwiOlwiJnRlbHJlYztcIixcIvCdlLFcIjpcIiZ0ZnI7XCIsXCLOuFwiOlwiJnRoZXRhO1wiLFwiz5FcIjpcIiZ2YXJ0aGV0YTtcIixcIsO+XCI6XCImdGhvcm47XCIsXCLDl1wiOlwiJnRpbWVzO1wiLFwi4qixXCI6XCImdGltZXNiYXI7XCIsXCLiqLBcIjpcIiZ0aW1lc2Q7XCIsXCLijLZcIjpcIiZ0b3Bib3Q7XCIsXCLiq7FcIjpcIiZ0b3BjaXI7XCIsXCLwnZWlXCI6XCImdG9wZjtcIixcIuKrmlwiOlwiJnRvcGZvcms7XCIsXCLigLRcIjpcIiZ0cHJpbWU7XCIsXCLilrVcIjpcIiZ1dHJpO1wiLFwi4omcXCI6XCImdHJpZTtcIixcIuKXrFwiOlwiJnRyaWRvdDtcIixcIuKoulwiOlwiJnRyaW1pbnVzO1wiLFwi4qi5XCI6XCImdHJpcGx1cztcIixcIuKnjVwiOlwiJnRyaXNiO1wiLFwi4qi7XCI6XCImdHJpdGltZTtcIixcIuKPolwiOlwiJnRycGV6aXVtO1wiLFwi8J2TiVwiOlwiJnRzY3I7XCIsXCLRhlwiOlwiJnRzY3k7XCIsXCLRm1wiOlwiJnRzaGN5O1wiLFwixadcIjpcIiZ0c3Ryb2s7XCIsXCLipaNcIjpcIiZ1SGFyO1wiLFwiw7pcIjpcIiZ1YWN1dGU7XCIsXCLRnlwiOlwiJnVicmN5O1wiLFwixa1cIjpcIiZ1YnJldmU7XCIsXCLDu1wiOlwiJnVjaXJjO1wiLFwi0YNcIjpcIiZ1Y3k7XCIsXCLFsVwiOlwiJnVkYmxhYztcIixcIuKlvlwiOlwiJnVmaXNodDtcIixcIvCdlLJcIjpcIiZ1ZnI7XCIsXCLDuVwiOlwiJnVncmF2ZTtcIixcIuKWgFwiOlwiJnVoYmxrO1wiLFwi4oycXCI6XCImdWxjb3JuZXI7XCIsXCLijI9cIjpcIiZ1bGNyb3A7XCIsXCLil7hcIjpcIiZ1bHRyaTtcIixcIsWrXCI6XCImdW1hY3I7XCIsXCLFs1wiOlwiJnVvZ29uO1wiLFwi8J2VplwiOlwiJnVvcGY7XCIsXCLPhVwiOlwiJnVwc2lsb247XCIsXCLih4hcIjpcIiZ1dWFycjtcIixcIuKMnVwiOlwiJnVyY29ybmVyO1wiLFwi4oyOXCI6XCImdXJjcm9wO1wiLFwixa9cIjpcIiZ1cmluZztcIixcIuKXuVwiOlwiJnVydHJpO1wiLFwi8J2TilwiOlwiJnVzY3I7XCIsXCLii7BcIjpcIiZ1dGRvdDtcIixcIsWpXCI6XCImdXRpbGRlO1wiLFwiw7xcIjpcIiZ1dW1sO1wiLFwi4qanXCI6XCImdXdhbmdsZTtcIixcIuKrqFwiOlwiJnZCYXI7XCIsXCLiq6lcIjpcIiZ2QmFydjtcIixcIuKmnFwiOlwiJnZhbmdydDtcIixcIuKKiu+4gFwiOlwiJnZzdWJuZTtcIixcIuKri++4gFwiOlwiJnZzdWJuRTtcIixcIuKKi++4gFwiOlwiJnZzdXBuZTtcIixcIuKrjO+4gFwiOlwiJnZzdXBuRTtcIixcItCyXCI6XCImdmN5O1wiLFwi4oq7XCI6XCImdmVlYmFyO1wiLFwi4omaXCI6XCImdmVlZXE7XCIsXCLii65cIjpcIiZ2ZWxsaXA7XCIsXCLwnZSzXCI6XCImdmZyO1wiLFwi8J2Vp1wiOlwiJnZvcGY7XCIsXCLwnZOLXCI6XCImdnNjcjtcIixcIuKmmlwiOlwiJnZ6aWd6YWc7XCIsXCLFtVwiOlwiJndjaXJjO1wiLFwi4qmfXCI6XCImd2VkYmFyO1wiLFwi4omZXCI6XCImd2VkZ2VxO1wiLFwi4oSYXCI6XCImd3A7XCIsXCLwnZS0XCI6XCImd2ZyO1wiLFwi8J2VqFwiOlwiJndvcGY7XCIsXCLwnZOMXCI6XCImd3NjcjtcIixcIvCdlLVcIjpcIiZ4ZnI7XCIsXCLOvlwiOlwiJnhpO1wiLFwi4ou7XCI6XCImeG5pcztcIixcIvCdlalcIjpcIiZ4b3BmO1wiLFwi8J2TjVwiOlwiJnhzY3I7XCIsXCLDvVwiOlwiJnlhY3V0ZTtcIixcItGPXCI6XCImeWFjeTtcIixcIsW3XCI6XCImeWNpcmM7XCIsXCLRi1wiOlwiJnljeTtcIixcIsKlXCI6XCImeWVuO1wiLFwi8J2UtlwiOlwiJnlmcjtcIixcItGXXCI6XCImeWljeTtcIixcIvCdlapcIjpcIiZ5b3BmO1wiLFwi8J2TjlwiOlwiJnlzY3I7XCIsXCLRjlwiOlwiJnl1Y3k7XCIsXCLDv1wiOlwiJnl1bWw7XCIsXCLFulwiOlwiJnphY3V0ZTtcIixcIsW+XCI6XCImemNhcm9uO1wiLFwi0LdcIjpcIiZ6Y3k7XCIsXCLFvFwiOlwiJnpkb3Q7XCIsXCLOtlwiOlwiJnpldGE7XCIsXCLwnZS3XCI6XCImemZyO1wiLFwi0LZcIjpcIiZ6aGN5O1wiLFwi4oedXCI6XCImemlncmFycjtcIixcIvCdlatcIjpcIiZ6b3BmO1wiLFwi8J2Tj1wiOlwiJnpzY3I7XCIsXCLigI1cIjpcIiZ6d2o7XCIsXCLigIxcIjpcIiZ6d25qO1wifX19OyIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0cy5udW1lcmljVW5pY29kZU1hcD17MDo2NTUzMywxMjg6ODM2NCwxMzA6ODIxOCwxMzE6NDAyLDEzMjo4MjIyLDEzMzo4MjMwLDEzNDo4MjI0LDEzNTo4MjI1LDEzNjo3MTAsMTM3OjgyNDAsMTM4OjM1MiwxMzk6ODI0OSwxNDA6MzM4LDE0MjozODEsMTQ1OjgyMTYsMTQ2OjgyMTcsMTQ3OjgyMjAsMTQ4OjgyMjEsMTQ5OjgyMjYsMTUwOjgyMTEsMTUxOjgyMTIsMTUyOjczMiwxNTM6ODQ4MiwxNTQ6MzUzLDE1NTo4MjUwLDE1NjozMzksMTU4OjM4MiwxNTk6Mzc2fTsiLCJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2V4cG9ydHMuZnJvbUNvZGVQb2ludD1TdHJpbmcuZnJvbUNvZGVQb2ludHx8ZnVuY3Rpb24oYXN0cmFsQ29kZVBvaW50KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLmZsb29yKChhc3RyYWxDb2RlUG9pbnQtNjU1MzYpLzEwMjQpKzU1Mjk2LChhc3RyYWxDb2RlUG9pbnQtNjU1MzYpJTEwMjQrNTYzMjApfTtleHBvcnRzLmdldENvZGVQb2ludD1TdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0P2Z1bmN0aW9uKGlucHV0LHBvc2l0aW9uKXtyZXR1cm4gaW5wdXQuY29kZVBvaW50QXQocG9zaXRpb24pfTpmdW5jdGlvbihpbnB1dCxwb3NpdGlvbil7cmV0dXJuKGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24pLTU1Mjk2KSoxMDI0K2lucHV0LmNoYXJDb2RlQXQocG9zaXRpb24rMSktNTYzMjArNjU1MzZ9O2V4cG9ydHMuaGlnaFN1cnJvZ2F0ZUZyb209NTUyOTY7ZXhwb3J0cy5oaWdoU3Vycm9nYXRlVG89NTYzMTk7IiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBjcmVhdGVCYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEZ1bmN0aW9uO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBjYXN0RnVuY3Rpb24gPSByZXF1aXJlKCcuL19jYXN0RnVuY3Rpb24nKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGNhc3RGdW5jdGlvbihpdGVyYXRlZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjIxJztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbicsXG4gICAgICBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gJ0ludmFsaWQgYHZhcmlhYmxlYCBvcHRpb24gcGFzc2VkIGludG8gYF8udGVtcGxhdGVgJztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG4gIHZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG4gIHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgdmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgICAgV1JBUF9SRUFSR19GTEFHID0gMjU2LFxuICAgICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyLFxuICAgICAgTEFaWV9XSElMRV9GTEFHID0gMztcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgICBOQU4gPSAwIC8gMDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcbiAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbiAgdmFyIHdyYXBGbGFncyA9IFtcbiAgICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICAgIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxuICAgIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICAgIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gICAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxuICAgIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxuICBdO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG4gIHZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHZhbGlkYXRlIHRoZSBgdmFsaWRhdGVgIG9wdGlvbiBpbiBgXy50ZW1wbGF0ZWAgdmFyaWFibGUuXG4gICAqXG4gICAqIEZvcmJpZHMgY2hhcmFjdGVycyB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBjaGFuZ2UgdGhlIG1lYW5pbmcgb2YgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50IGRlZmluaXRpb246XG4gICAqIC0gXCIoKSxcIiAobW9kaWZpY2F0aW9uIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMpXG4gICAqIC0gXCI9XCIgKGRlZmF1bHQgdmFsdWUpXG4gICAqIC0gXCJbXXt9XCIgKGRlc3RydWN0dXJpbmcgb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAgICogLSBcIi9cIiAoYmVnaW5uaW5nIG9mIGEgY29tbWVudClcbiAgICogLSB3aGl0ZXNwYWNlXG4gICAqL1xuICB2YXIgcmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMgPSAvWygpPSx7fVxcW1xcXVxcL1xcc10vO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWFwJywgJ01hdGgnLCAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAqIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNZWFuKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICAgIDogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXG4gICAqL1xuICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICsrcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgdmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICB2YXIgZGF0YSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubGFzdEluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ICsgMTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgdW5lc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxVbmVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgICArK3Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAxLjEuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0ID09IG51bGwgPyByb290IDogXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSk7XG5cbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuICAgIHZhciBjb3JlSnNEYXRhID0gY29udGV4dFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gICAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgICAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sLFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxuICAgICAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltSXRlcmF0b3IgPSBTeW1ib2wgPyBTeW1ib2wuaXRlcmF0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0oKSk7XG5cbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBjdHhOb3cgPSBEYXRlICYmIERhdGUubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUubm93LFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVKb2luID0gYXJyYXlQcm90by5qb2luLFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdyxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgICAgbmF0aXZlUmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgJ0RhdGFWaWV3JyksXG4gICAgICAgIE1hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnTWFwJyksXG4gICAgICAgIFByb21pc2UgPSBnZXROYXRpdmUoY29udGV4dCwgJ1Byb21pc2UnKSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xuICAgIHZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgICAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICAgICAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGNoYWluIHNlcXVlbmNlIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX19pbmRleF9fID0gMDtcbiAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICAgICAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsb2Rhc2g7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcbiAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCAoIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG4gICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGFkZFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBhbGlhcyBwdXNoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlU2l6ZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICAgICAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc2tpcCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBEZWVwIGNsb25lXG4gICAgICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XG4gICAgICB9XG4gICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgICAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgICAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICAgICAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gICAgICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc1RvYCB3aGljaCBhY2NlcHRzIGBwcm9wc2AgdG8gY2hlY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF0sXG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHx8ICFwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kZWxheWAgYW5kIGBfLmRlZmVyYCB3aGljaCBhY2NlcHRzIGBhcmdzYFxuICAgICAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICAgICAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGFycmF5W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAgICAgKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvclJpZ2h0ID0gY3JlYXRlQmFzZUZvcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25SaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICAgICAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgICAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR3QodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5SYW5nZWAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gbnVtYmVyID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiBudW1iZXIgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmludGVyc2VjdGlvbmAsIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnRlcnNlY3Rpb24oYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluY2x1ZGVzID0gY29tcGFyYXRvciA/IGFycmF5SW5jbHVkZXNXaXRoIDogYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcbiAgICAgICAgICBtYXhMZW5ndGggPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICAgICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XG4gICAgICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9ICFjb21wYXJhdG9yICYmIChpdGVyYXRlZSB8fCAobGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwKSlcbiAgICAgICAgICA/IG5ldyBTZXRDYWNoZShvdGhJbmRleCAmJiBhcnJheSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFycmF5ID0gYXJyYXlzWzBdO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoIShzZWVuXG4gICAgICAgICAgICAgID8gY2FjaGVIYXMoc2VlbiwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmICghKGNhY2hlXG4gICAgICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZlcnRgIGFuZCBgXy5pbnZlcnRCeWAgd2hpY2ggaW52ZXJ0c1xuICAgICAqIGBvYmplY3RgIHdpdGggdmFsdWVzIHRyYW5zZm9ybWVkIGJ5IGBpdGVyYXRlZWAgYW5kIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgaXRlcmF0ZWUodmFsdWUpLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZva2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIG1ldGhvZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHZhciBmdW5jID0gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJyYXlCdWZmZXJgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJyYXlCdWZmZXJUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNEYXRlYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICAgICAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICAgICAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgICAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICAgIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTHQodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubnRoYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VOdGgoYXJyYXksIG4pIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBpc0luZGV4KG4sIGxlbmd0aCkgPyBhcnJheVtuXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpZGVudGl0eV07XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQWxsQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICAgKiBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgc2VlbiA9IGFycmF5O1xuXG4gICAgICBpZiAoYXJyYXkgPT09IHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBjb3B5QXJyYXkodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpKSA+IC0xKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChzZWVuLCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICAgICAqIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVwZWF0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIGlmICghc3RyaW5nIHx8IG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVTaXplYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4pIHtcbiAgICAgIHZhciBhcnJheSA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhgIHdoaWNoXG4gICAgICogcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyBsb3cgOiBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuXG4gICAgICAgICAgaWYgKGNvbXB1dGVkICE9PSBudWxsICYmICFpc1N5bWJvbChjb21wdXRlZCkgJiZcbiAgICAgICAgICAgICAgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhCeWAgYW5kIGBfLnNvcnRlZExhc3RJbmRleEJ5YFxuICAgICAqIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZVxuICAgICAqIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgIHZhciB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcbiAgICAgICAgICB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZCxcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSByZXRIaWdoZXN0IHx8IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzTnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNTeW1ib2wpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRVbmlxYCBhbmQgYF8uc29ydGVkVW5pcUJ5YCB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICB2YXIgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvTnVtYmVyYCB3aGljaCBkb2Vzbid0IGVuc3VyZSBjb3JyZWN0XG4gICAgICogY29udmVyc2lvbnMgb2YgYmluYXJ5LCBoZXhhZGVjaW1hbCwgb3Igb2N0YWwgc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRyb3BXaGlsZWAgYW5kIGBfLnRha2VXaGlsZWBcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmXG4gICAgICAgIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG5cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaW5kZXhdLFxuICAgICAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChvdGhJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQsIDEpLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGBiYXNlUmVzdGAgYWxpYXMgd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggYGlkZW50aXR5YCBieSBtb2R1bGVcbiAgICAgKiByZXBsYWNlbWVudCBwbHVnaW5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgY2FzdFJlc3QgPSBiYXNlUmVzdDtcblxuICAgIC8qKlxuICAgICAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgICAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cbiAgICAgKi9cbiAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gcm9vdC5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgICAqXG4gICAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gICAgICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gZW5hYmxlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBsZW5ndGggLT0gaG9sZGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcblxuICAgICAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBjaGFycyA9IGNoYXJzID09PSB1bmRlZmluZWQgPyAnICcgOiBiYXNlVG9TdHJpbmcoY2hhcnMpO1xuXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICBpZiAoY2hhcnNMZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgIGlmIChwcmVjaXNpb24gJiYgbmF0aXZlSXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHdpdGggZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgaXNzdWVzLlxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bmMocGFpclswXSArICdlJyArICgrcGFpclsxXSArIHByZWNpc2lvbikpO1xuXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgcmV0dXJuICsocGFpclswXSArICdlJyArICgrcGFpclsxXSAtIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XG4gICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKGZ1bmMubmFtZSArICcnKSxcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgdmFyIG9iamVjdCA9IGhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLCAncGxhY2Vob2xkZXInKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaXRlcmF0ZWVcIiBmdW5jdGlvbi4gSWYgYF8uaXRlcmF0ZWVgIGlzIGN1c3RvbWl6ZWQsXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cbiAgICAgKiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCB0aGUgY2hvc2VuIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaXRlcmF0ZWUgfHwgaXRlcmF0ZWU7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGl0ZXJhdGVlID8gYmFzZUl0ZXJhdGVlIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICAgICAgOiBkYXRhLm1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbiAgICBpZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgICAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB3cmFwcGVyIGRldGFpbHMgZnJvbSB0aGUgYHNvdXJjZWAgYm9keSBjb21tZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXcmFwRGV0YWlscyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICAgICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgd3JhcHBlciBgZGV0YWlsc2AgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIGBzb3VyY2VgIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XG4gICAgICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShyZVdyYXBDb21tZW50LCAne1xcbi8qIFt3cmFwcGVkIHdpdGggJyArIGRldGFpbHMgKyAnXSAqL1xcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGF6aWFibGUoZnVuYykge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIG90aGVyICE9ICdmdW5jdGlvbicgfHwgIShmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGlzIGNhcGFibGUgb2YgYmVpbmcgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2thYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICAgICAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICAgICAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICAgICAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXG4gICAgICogZXhlY3V0ZWQgaW1wb3J0YW50LCBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlXG4gICAgICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAgICAgKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSkgJiYgKHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9BUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gICAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxuICAgICAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICAgICAqIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BzZXRUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vc2V0VGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBzZXRUaW1lb3V0ID0gY3R4U2V0VGltZW91dCB8fCBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICAgICAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyh3cmFwcGVyLCBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIHVwZGF0ZVdyYXBEZXRhaWxzKGdldFdyYXBEZXRhaWxzKHNvdXJjZSksIGJpdG1hc2spKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gICAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gICAgICogbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICB2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBhcnJheWAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcbiAgICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVB1c2goaXNBcnJheShhcnJheSkgPyBjb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxCeWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDgsIDEwXSwgJyonLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCAnKicsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcbiAgICAgICAgICA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMClcbiAgICAgICAgICA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbiBgYXJyYXlgIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksIGRlcHRoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIGZyb20ga2V5LXZhbHVlIGBwYWlyc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl1dKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGZpcnN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaGVhZChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjFdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGlmIChpdGVyYXRlZSA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlc1xuICAgICAqIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgZWxlbWVudHMgaW4gYGFycmF5YCBpbnRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScsJ10gVGhlIGVsZW1lbnQgc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGpvaW5lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uam9pbihbJ2EnLCAnYicsICdjJ10sICd+Jyk7XG4gICAgICogLy8gPT4gJ2F+Yn5jJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpvaW4oYXJyYXksIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyAnJyA6IG5hdGl2ZUpvaW4uY2FsbChhcnJheSwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KVxuICAgICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgLTIpO1xuICAgICAqIC8vID0+ICdjJztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGgoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VOdGgoYXJyYXksIHRvSW50ZWdlcihuKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucmVtb3ZlYFxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsKGFycmF5LCBbJ2EnLCAnYyddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGwoYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VCeWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAzIH0sIHsgJ3gnOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsQnkoYXJyYXksIFt7ICd4JzogMSB9LCB7ICd4JzogMyB9XSwgJ3gnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDUsICd5JzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LCB2YWx1ZXMsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIGBpbmRleGVzYCBhbmQgcmV0dXJucyBhblxuICAgICAqIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqIHZhciBwdWxsZWQgPSBfLnB1bGxBdChhcnJheSwgWzEsIDNdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhwdWxsZWQpO1xuICAgICAqIC8vID0+IFsnYicsICdkJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBhcnJheU1hcChpbmRleGVzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gaXNJbmRleChpbmRleCwgbGVuZ3RoKSA/ICtpbmRleCA6IGluZGV4O1xuICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyBgYXJyYXlgIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gYXJyYXkgOiBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgICAqIFtgQXJyYXkjc2xpY2VgXShodHRwczovL21kbi5pby9BcnJheS9zbGljZSkgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkTGFzdEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICBpZiAoZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcShbMSwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFpbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyXG4gICAgICogaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaXFXaXRoKG9iamVjdHMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgcmVncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB1bmRlZmluZWQsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMiwgMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcbiAgICAgKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyXG4gICAgICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy53aXRob3V0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgeG9yID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWRcbiAgICAgKiBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZVxuICAgICAqIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMiwgMy40XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy54b3JCeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICAgICAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBPYmplY3RgIGV4Y2VwdCB0aGF0IGl0IHN1cHBvcnRzIHByb3BlcnR5IHBhdGhzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdERlZXAoWydhLmJbMF0uYycsICdhLmJbMV0uZCddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogW3sgJ2MnOiAxIH0sIHsgJ2QnOiAyIH1dIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdERlZXAocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYmFzZVNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICBncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIGEgKyBiICsgYztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaXRlcmF0ZWUgPSB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC4gVGhlIHJlc3VsdCBvZiBzdWNoIHNlcXVlbmNlcyBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF9cbiAgICAgKiAgIC5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgICAgcmV0dXJuIG8udXNlciArICcgaXMgJyArIG8uYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0b1xuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICAvLyBNdXRhdGUgaW5wdXQgYXJyYXkuXG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInBhc3MgdGhydVwiIHZhbHVlcyByZXBsYWNpbmcgaW50ZXJtZWRpYXRlXG4gICAgICogcmVzdWx0cyBpbiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLmF0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGF0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8ob2JqZWN0KS5hdChbJ2FbMF0uYi5jJywgJ2FbMV0nXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBsZW5ndGggPyBwYXRoc1swXSA6IDAsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XG5cbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcbiAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcbiAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBvbiBhIHdyYXBwZWQgb2JqZWN0IGZvbGxvd2luZyB0aGVcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxuICAgICAqXG4gICAgICogQG5hbWUgbmV4dFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyTmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xuXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBsYW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xuICAgICAqIHZhciBvdGhlciA9IHdyYXBwZWQucGxhbnQoWzMsIDRdKTtcbiAgICAgKlxuICAgICAqIG90aGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcbiAgICAgICAgY2xvbmUuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICsrcmVzdWx0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gICAgICogW2V2ZXJ5dGhpbmcgaXMgdHJ1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFjdW91c190cnV0aCkgb2ZcbiAgICAgKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIENvbWJpbmluZyBzZXZlcmFsIHByZWRpY2F0ZXMgdXNpbmcgYF8ub3ZlckV2ZXJ5YCBvciBgXy5vdmVyU29tZWAuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8ub3ZlclNvbWUoW3sgJ2FnZSc6IDM2IH0sIFsnYWdlJywgNDBdXSkpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZWVwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVlcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAgICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAgICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIGBjb2xsZWN0aW9uYC4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAgICAgKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsIHJldHVybmluZ1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXG4gICAgICogZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBlYWNoIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIHZhciBpbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoby5jb2RlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIga2V5QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAgICAgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAgICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gICAgICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAgICAgKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICAgICAqIGFuZCBgc29ydEJ5YFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0sIDApO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8uZmlsdGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBgbmAgcmFuZG9tIGVsZW1lbnRzIGF0IHVuaXF1ZSBrZXlzIGZyb20gYGNvbGxlY3Rpb25gIHVwIHRvIHRoZVxuICAgICAqIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAgICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiAzMCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGN0eE5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLFxuICAgICAqIGlnbm9yaW5nIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBuO1xuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0FSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kKSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcbiAgICAgKiBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXG4gICAgICogbWV0aG9kcyB0aGF0IG1heSBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LiBTZWVcbiAgICAgKiBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ3VzZXInOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZEtleSA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmRLZXkpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXG4gICAgICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICAgICAqIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBgZnVuY2BcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcbiAgICAgKiBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICAgKiBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsYXN0QXJncyxcbiAgICAgICAgICBsYXN0VGhpcyxcbiAgICAgICAgICBtYXhXYWl0LFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB0aW1lcklkLFxuICAgICAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZ1xuICAgICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgWzIsIDAsIDFdKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSBmbGF0UmVzdChmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZSBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZVxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmdzW3N0YXJ0XSxcbiAgICAgICAgICAgIG90aGVyQXJncyA9IGNhc3RTbGljZShhcmdzLCAwLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKG90aGVyQXJncywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAgICAgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAgICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgYXJndW1lbnQsIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLnVuYXJ5KHBhcnNlSW50KSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuYXJ5KGZ1bmMpIHtcbiAgICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XG4gICAgICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGB3cmFwcGVyYC4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZS4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gICAgICpcbiAgICAgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gICAgICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgdW5kZWZpbmVkLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIGZpdmVcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKHNyY1ZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHdlYWtNYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzYWZlIGludGVnZXIuIEEgc2FmZSBpbnRlZ2VyIGNhbiBiZSBjb21wYXJlZCBhbmRcbiAgICAgKiByZXByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDkwMDcxOTkyNTQ3NDA5OTFcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgOiAodmFsdWUgPT09IDAgPyB2YWx1ZSA6IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICogLy8gPT4gJy0wJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8uYXQob2JqZWN0LCBbJ2FbMF0uYi5jJywgJ2FbMV0nXSk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIGF0ID0gZmxhdFJlc3QoYmFzZUF0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gICAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdjJywgJ2InLCB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JJbmAgbG9ncyAnYScsICdiJywgdGhlbiAnYycuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgfVxuICAgIH0sIGdldEl0ZXJhdGVlKTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiBbMSwgMiwgMywgNF0gfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0pO1xuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxuICAgICAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gICAgICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgIH1cbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxuICAgICAqIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcj0wXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gdXBwZXI7XG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvd2VyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB1cHBlciA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSB0b0Zpbml0ZSh1cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA+IHVwcGVyKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdXBwZXI7XG4gICAgICAgIHVwcGVyID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gICAgICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAgICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBsZW5ndGgpO1xuXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAgICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAgICAgKiBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICAgICAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICovXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArXG4gICAgICAgIHN0cmluZyArXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoc3RyaW5nICsgY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSlcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykgKyBzdHJpbmcpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhXG4gICAgICogaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGVcbiAgICAgKiBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuMikgb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVRyaW1TdGFydCwgJycpLCByYWRpeCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHN0cmluZ2Agd2l0aCBgcmVwbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjcmVwbGFjZWBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9yZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwbGFjZSgnSGkgRnJlZCcsICdGcmVkJywgJ0Jhcm5leScpO1xuICAgICAqIC8vID0+ICdIaSBCYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZSgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPCAzID8gc3RyaW5nIDogc3RyaW5nLnJlcGxhY2UoYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1GT08tQkFSLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHVwcGVyRmlyc3Qod29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICAgICAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICAgICAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICAgICAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cbiAgICAgKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgICAgIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXG4gICAgICAvLyBhbmQgZXNjYXBlIHRoZSBjb21tZW50LCB0aHVzIGluamVjdGluZyBjb2RlIHRoYXQgZ2V0cyBldmFsZWQuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgICAgICAgID8gKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1xccy9nLCAnICcpXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBhIGZvcmJpZGRlbiBjaGFyYWN0ZXIgd2FzIGZvdW5kIGluIGB2YXJpYWJsZWAsIHRvIHByZXZlbnRcbiAgICAgIC8vIHBvdGVudGlhbCBjb21tYW5kIGluamVjdGlvbiBhdHRhY2tzLlxuICAgICAgZWxzZSBpZiAocmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMudGVzdCh2YXJpYWJsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VUcmltKHN0cmluZyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksIF8ubWF0Y2hlcyh7ICdhJzogNCB9KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxuICAgICAqIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdCB0byBgc3JjVmFsdWVgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZVxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3RcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChvYmplY3RzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCAxKSwgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyRXZlcnkoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbnkqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIG1hdGNoZXNGdW5jID0gXy5vdmVyU29tZShbeyAnYSc6IDEgfSwgeyAnYSc6IDIgfV0pXG4gICAgICogdmFyIG1hdGNoZXNQcm9wZXJ0eUZ1bmMgPSBfLm92ZXJTb21lKFtbJ2EnLCAxXSwgWydhJywgMl1dKVxuICAgICAqL1xuICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgtNCk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAgICogLy8gPT4gW1tdLCBbXV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAgICAgKlxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlKTtcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxuICAgICAgICAgIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUgKyAnJztcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywga2V5KSkge1xuICAgICAgICAgIHJlYWxOYW1lc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVhbE5hbWVzW2tleV0ucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xuICAgICAgJ25hbWUnOiAnd3JhcHBlcicsXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGxhenkgYWxpYXNlcy5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuXG4gICAgaWYgKHN5bUl0ZXJhdG9yKSB7XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxuICBlbHNlIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzLlxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKlxuICBlc2xpbnQtZGlzYWJsZVxuICBuby1jb25zb2xlLFxuICBmdW5jLW5hbWVzXG4qL1xudmFyIG5vcm1hbGl6ZVVybCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS11cmxcIik7XG5cbnZhciBzcmNCeU1vZHVsZUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBub0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiO1xudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcblxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIHRpbWUpIHtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gZnVuY3Rpb25DYWxsKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb25DYWxsLCB0aW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRVcmwobW9kdWxlSWQpIHtcbiAgdmFyIHNyYyA9IHNyY0J5TW9kdWxlSWRbbW9kdWxlSWRdO1xuXG4gIGlmICghc3JjKSB7XG4gICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICAgIHNyYyA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuICAgICAgdmFyIGxhc3RTY3JpcHRUYWcgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChsYXN0U2NyaXB0VGFnKSB7XG4gICAgICAgIHNyYyA9IGxhc3RTY3JpcHRUYWcuc3JjO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNyY0J5TW9kdWxlSWRbbW9kdWxlSWRdID0gc3JjO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlTWFwKSB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzcGxpdFJlc3VsdCA9IHNyYy5zcGxpdCgvKFteXFxcXC9dKylcXC5qcyQvKTtcbiAgICB2YXIgZmlsZW5hbWUgPSBzcGxpdFJlc3VsdCAmJiBzcGxpdFJlc3VsdFsxXTtcblxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHJldHVybiBbc3JjLnJlcGxhY2UoXCIuanNcIiwgXCIuY3NzXCIpXTtcbiAgICB9XG5cbiAgICBpZiAoIWZpbGVNYXApIHtcbiAgICAgIHJldHVybiBbc3JjLnJlcGxhY2UoXCIuanNcIiwgXCIuY3NzXCIpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZU1hcC5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uIChtYXBSdWxlKSB7XG4gICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdChmaWxlbmFtZSwgXCJcXFxcLmpzJFwiKSwgXCJnXCIpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVybChzcmMucmVwbGFjZShyZWcsIFwiXCIuY29uY2F0KG1hcFJ1bGUucmVwbGFjZSgve2ZpbGVOYW1lfS9nLCBmaWxlbmFtZSksIFwiLmNzc1wiKSkpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDc3MoZWwsIHVybCkge1xuICBpZiAoIXVybCkge1xuICAgIGlmICghZWwuaHJlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cblxuICAgIHVybCA9IGVsLmhyZWYuc3BsaXQoXCI/XCIpWzBdO1xuICB9XG5cbiAgaWYgKCFpc1VybFJlcXVlc3QodXJsKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbC5pc0xvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBXZSBzZWVtIHRvIGJlIGFib3V0IHRvIHJlcGxhY2UgYSBjc3MgbGluayB0aGF0IGhhc24ndCBsb2FkZWQgeWV0LlxuICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNoYW5naW5nIHRoZSBzYW1lIGZpbGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF1cmwgfHwgISh1cmwuaW5kZXhPZihcIi5jc3NcIikgPiAtMSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cblxuICBlbC52aXNpdGVkID0gdHJ1ZTtcbiAgdmFyIG5ld0VsID0gZWwuY2xvbmVOb2RlKCk7XG4gIG5ld0VsLmlzTG9hZGVkID0gZmFsc2U7XG4gIG5ld0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobmV3RWwuaXNMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXdFbC5pc0xvYWRlZCA9IHRydWU7XG4gICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gIH0pO1xuICBuZXdFbC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChuZXdFbC5pc0xvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5ld0VsLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfSk7XG4gIG5ld0VsLmhyZWYgPSBcIlwiLmNvbmNhdCh1cmwsIFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7XG5cbiAgaWYgKGVsLm5leHRTaWJsaW5nKSB7XG4gICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3RWwsIGVsLm5leHRTaWJsaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG5ld0VsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWxvYWRVcmwoaHJlZiwgc3JjKSB7XG4gIHZhciByZXQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXG4gIGhyZWYgPSBub3JtYWxpemVVcmwoaHJlZiwge1xuICAgIHN0cmlwV1dXOiBmYWxzZVxuICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuXG4gIHNyYy5zb21lKGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoaHJlZi5pbmRleE9mKHNyYykgPiAtMSkge1xuICAgICAgcmV0ID0gdXJsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHJlbG9hZFN0eWxlKHNyYykge1xuICBpZiAoIXNyYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO1xuICB2YXIgbG9hZGVkID0gZmFsc2U7XG4gIGZvckVhY2guY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKCFlbC5ocmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHVybCA9IGdldFJlbG9hZFVybChlbC5ocmVmLCBzcmMpO1xuXG4gICAgaWYgKCFpc1VybFJlcXVlc3QodXJsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbC52aXNpdGVkID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHVybCkge1xuICAgICAgdXBkYXRlQ3NzKGVsLCB1cmwpO1xuICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbG9hZGVkO1xufVxuXG5mdW5jdGlvbiByZWxvYWRBbGwoKSB7XG4gIHZhciBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO1xuICBmb3JFYWNoLmNhbGwoZWxlbWVudHMsIGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC52aXNpdGVkID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlQ3NzKGVsKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzVXJsUmVxdWVzdCh1cmwpIHtcbiAgLy8gQW4gVVJMIGlzIG5vdCBhbiByZXF1ZXN0IGlmXG4gIC8vIEl0IGlzIG5vdCBodHRwIG9yIGh0dHBzXG4gIGlmICghL15bYS16QS1aXVthLXpBLVpcXGQrXFwtLl0qOi8udGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBvcHRpb25zKSB7XG4gIGlmIChub0RvY3VtZW50KSB7XG4gICAgY29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7XG4gICAgcmV0dXJuIG5vb3A7XG4gIH1cblxuICB2YXIgZ2V0U2NyaXB0U3JjID0gZ2V0Q3VycmVudFNjcmlwdFVybChtb2R1bGVJZCk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBzcmMgPSBnZXRTY3JpcHRTcmMob3B0aW9ucy5maWxlbmFtZSk7XG4gICAgdmFyIHJlbG9hZGVkID0gcmVsb2FkU3R5bGUoc3JjKTtcblxuICAgIGlmIChvcHRpb25zLmxvY2Fscykge1xuICAgICAgY29uc29sZS5sb2coXCJbSE1SXSBEZXRlY3RlZCBsb2NhbCBjc3MgbW9kdWxlcy4gUmVsb2FkIGFsbCBjc3NcIik7XG4gICAgICByZWxvYWRBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVsb2FkZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW0hNUl0gY3NzIHJlbG9hZCAlc1wiLCBzcmMuam9pbihcIiBcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO1xuICAgICAgcmVsb2FkQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlYm91bmNlKHVwZGF0ZSwgNTApO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVybChwYXRoQ29tcG9uZW50cykge1xuICByZXR1cm4gcGF0aENvbXBvbmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgaXRlbSkge1xuICAgIHN3aXRjaCAoaXRlbSkge1xuICAgICAgY2FzZSBcIi4uXCI6XG4gICAgICAgIGFjY3VtdWxhdG9yLnBvcCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFjY3VtdWxhdG9yLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9LCBbXSkuam9pbihcIi9cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybFN0cmluZykge1xuICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcudHJpbSgpO1xuXG4gIGlmICgvXmRhdGE6L2kudGVzdCh1cmxTdHJpbmcpKSB7XG4gICAgcmV0dXJuIHVybFN0cmluZztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHVybFN0cmluZy5pbmRleE9mKFwiLy9cIikgIT09IC0xID8gdXJsU3RyaW5nLnNwbGl0KFwiLy9cIilbMF0gKyBcIi8vXCIgOiBcIlwiO1xuICB2YXIgY29tcG9uZW50cyA9IHVybFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAocHJvdG9jb2wsIFwiaVwiKSwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICB2YXIgaG9zdCA9IGNvbXBvbmVudHNbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLywgXCJcIik7XG4gIGNvbXBvbmVudHNbMF0gPSBcIlwiO1xuICB2YXIgcGF0aCA9IG5vcm1hbGl6ZVVybChjb21wb25lbnRzKTtcbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGg7XG59OyIsIi8vIGNoZWNrIGRvY3VtZW50IGZpcnN0IHNvIGl0IGRvZXNuJ3QgZXJyb3IgaW4gbm9kZS5qc1xudmFyIHN0eWxlID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXG4gID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpLnN0eWxlXG4gIDoge31cblxudmFyIHByZWZpeGVzID0gWydPJywgJ21zJywgJ01veicsICdXZWJraXQnXVxudmFyIHVwcGVyID0gLyhbQS1aXSkvZ1xudmFyIG1lbW8gPSB7fVxuXG4vKipcbiAqIHByZWZpeCBga2V5YFxuICpcbiAqICAgcHJlZml4KCd0cmFuc2Zvcm0nKSAvLyA9PiBXZWJraXRUcmFuc2Zvcm1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBwcmVmaXgoa2V5KXtcbiAgLy8gQ2FtZWwgY2FzZVxuICBrZXkgPSBrZXkucmVwbGFjZSgvLShbYS16XSkvZywgZnVuY3Rpb24oXywgY2hhcil7XG4gICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKVxuICB9KVxuXG4gIC8vIFdpdGhvdXQgcHJlZml4XG4gIGlmIChzdHlsZVtrZXldICE9PSB1bmRlZmluZWQpIHJldHVybiBrZXlcblxuICAvLyBXaXRoIHByZWZpeFxuICB2YXIgS2V5ID0ga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpXG4gIHZhciBpID0gcHJlZml4ZXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgbmFtZSA9IHByZWZpeGVzW2ldICsgS2V5XG4gICAgaWYgKHN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBuYW1lXG4gIH1cblxuICByZXR1cm4ga2V5XG59XG5cbi8qKlxuICogTWVtb2l6ZWQgdmVyc2lvbiBvZiBgcHJlZml4YFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHByZWZpeE1lbW96aWVkKGtleSl7XG4gIHJldHVybiBrZXkgaW4gbWVtb1xuICAgID8gbWVtb1trZXldXG4gICAgOiBtZW1vW2tleV0gPSBwcmVmaXgoa2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRhc2hlZCBwcmVmaXhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBwcmVmaXhEYXNoZWQoa2V5KXtcbiAga2V5ID0gcHJlZml4KGtleSlcbiAgaWYgKHVwcGVyLnRlc3Qoa2V5KSkge1xuICAgIGtleSA9ICctJyArIGtleS5yZXBsYWNlKHVwcGVyLCAnLSQxJylcbiAgICB1cHBlci5sYXN0SW5kZXggPSAwXG4gIH1cbiAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlZml4TWVtb3ppZWRcbm1vZHVsZS5leHBvcnRzLmRhc2ggPSBwcmVmaXhEYXNoZWRcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuLi91dGlscy9sb2cuanNcIjtcblxudmFyIFdlYlNvY2tldENsaWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdlYlNvY2tldENsaWVudCh1cmwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViU29ja2V0Q2xpZW50KTtcblxuICAgIHRoaXMuY2xpZW50ID0gbmV3IFdlYlNvY2tldCh1cmwpO1xuXG4gICAgdGhpcy5jbGllbnQub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFdlYlNvY2tldENsaWVudCwgW3tcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbihmKSB7XG4gICAgICB0aGlzLmNsaWVudC5vbm9wZW4gPSBmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xvc2UoZikge1xuICAgICAgdGhpcy5jbGllbnQub25jbG9zZSA9IGY7XG4gICAgfSAvLyBjYWxsIGYgd2l0aCB0aGUgbWVzc2FnZSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZXNzYWdlKGYpIHtcbiAgICAgIHRoaXMuY2xpZW50Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGYoZS5kYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYlNvY2tldENsaWVudDtcbn0oKTtcblxuZXhwb3J0IHsgV2ViU29ja2V0Q2xpZW50IGFzIGRlZmF1bHQgfTsiLCIvKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5LCBfX3dlYnBhY2tfaGFzaF9fICovXG5pbXBvcnQgd2VicGFja0hvdExvZyBmcm9tIFwid2VicGFjay9ob3QvbG9nLmpzXCI7XG5pbXBvcnQgc3RyaXBBbnNpIGZyb20gXCIuL21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qc1wiO1xuaW1wb3J0IHBhcnNlVVJMIGZyb20gXCIuL3V0aWxzL3BhcnNlVVJMLmpzXCI7XG5pbXBvcnQgc29ja2V0IGZyb20gXCIuL3NvY2tldC5qc1wiO1xuaW1wb3J0IHsgc2hvdywgaGlkZSB9IGZyb20gXCIuL292ZXJsYXkuanNcIjtcbmltcG9ydCB7IGxvZywgc2V0TG9nTGV2ZWwgfSBmcm9tIFwiLi91dGlscy9sb2cuanNcIjtcbmltcG9ydCBzZW5kTWVzc2FnZSBmcm9tIFwiLi91dGlscy9zZW5kTWVzc2FnZS5qc1wiO1xuaW1wb3J0IHJlbG9hZEFwcCBmcm9tIFwiLi91dGlscy9yZWxvYWRBcHAuanNcIjtcbmltcG9ydCBjcmVhdGVTb2NrZXRVUkwgZnJvbSBcIi4vdXRpbHMvY3JlYXRlU29ja2V0VVJMLmpzXCI7XG52YXIgc3RhdHVzID0ge1xuICBpc1VubG9hZGluZzogZmFsc2UsXG4gIC8vIFRPRE8gV29ya2Fyb3VuZCBmb3Igd2VicGFjayB2NCwgYF9fd2VicGFja19oYXNoX19gIGlzIG5vdCByZXBsYWNlZCB3aXRob3V0IEhvdE1vZHVsZVJlcGxhY2VtZW50XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgY3VycmVudEhhc2g6IHR5cGVvZiBfX3dlYnBhY2tfaGFzaF9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX2hhc2hfXyA6IFwiXCJcbn07IC8vIGNvbnNvbGUubG9nKF9fd2VicGFja19oYXNoX18pO1xuXG52YXIgb3B0aW9ucyA9IHtcbiAgaG90OiBmYWxzZSxcbiAgbGl2ZVJlbG9hZDogZmFsc2UsXG4gIHByb2dyZXNzOiBmYWxzZSxcbiAgb3ZlcmxheTogZmFsc2Vcbn07XG52YXIgcGFyc2VkUmVzb3VyY2VRdWVyeSA9IHBhcnNlVVJMKF9fcmVzb3VyY2VRdWVyeSk7XG5cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LmhvdCA9PT0gXCJ0cnVlXCIpIHtcbiAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICBsb2cuaW5mbyhcIkhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC5cIik7XG59XG5cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5W1wibGl2ZS1yZWxvYWRcIl0gPT09IFwidHJ1ZVwiKSB7XG4gIG9wdGlvbnMubGl2ZVJlbG9hZCA9IHRydWU7XG4gIGxvZy5pbmZvKFwiTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC5cIik7XG59XG5cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LmxvZ2dpbmcpIHtcbiAgb3B0aW9ucy5sb2dnaW5nID0gcGFyc2VkUmVzb3VyY2VRdWVyeS5sb2dnaW5nO1xufVxuXG5mdW5jdGlvbiBzZXRBbGxMb2dMZXZlbChsZXZlbCkge1xuICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBITVIgbG9nZ2VyIG9wZXJhdGUgc2VwYXJhdGVseSBmcm9tIGRldiBzZXJ2ZXIgbG9nZ2VyXG4gIHdlYnBhY2tIb3RMb2cuc2V0TG9nTGV2ZWwobGV2ZWwgPT09IFwidmVyYm9zZVwiIHx8IGxldmVsID09PSBcImxvZ1wiID8gXCJpbmZvXCIgOiBsZXZlbCk7XG4gIHNldExvZ0xldmVsKGxldmVsKTtcbn1cblxuaWYgKG9wdGlvbnMubG9nZ2luZykge1xuICBzZXRBbGxMb2dMZXZlbChvcHRpb25zLmxvZ2dpbmcpO1xufVxuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICBzdGF0dXMuaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG52YXIgb25Tb2NrZXRNZXNzYWdlID0ge1xuICBob3Q6IGZ1bmN0aW9uIGhvdCgpIHtcbiAgICBpZiAocGFyc2VkUmVzb3VyY2VRdWVyeS5ob3QgPT09IFwiZmFsc2VcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaG90ID0gdHJ1ZTtcbiAgICBsb2cuaW5mbyhcIkhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC5cIik7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgaWYgKHBhcnNlZFJlc291cmNlUXVlcnlbXCJsaXZlLXJlbG9hZFwiXSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbyhcIkxpdmUgUmVsb2FkaW5nIGVuYWJsZWQuXCIpO1xuICB9LFxuICBpbnZhbGlkOiBmdW5jdGlvbiBpbnZhbGlkKCkge1xuICAgIGxvZy5pbmZvKFwiQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uXCIpOyAvLyBGaXhlcyAjMTA0Mi4gb3ZlcmxheSBkb2Vzbid0IGNsZWFyIGlmIGVycm9ycyBhcmUgZml4ZWQgYnV0IHdhcm5pbmdzIHJlbWFpbi5cblxuICAgIGlmIChvcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZShcIkludmFsaWRcIik7XG4gIH0sXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBzdGF0dXMucHJldmlvdXNIYXNoID0gc3RhdHVzLmN1cnJlbnRIYXNoO1xuICAgIHN0YXR1cy5jdXJyZW50SGFzaCA9IF9oYXNoO1xuICB9LFxuICBsb2dnaW5nOiBzZXRBbGxMb2dMZXZlbCxcbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zLm92ZXJsYXkgPSB2YWx1ZTtcbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xuICAgIG9wdGlvbnMucHJvZ3Jlc3MgPSBfcHJvZ3Jlc3M7XG4gIH0sXG4gIFwicHJvZ3Jlc3MtdXBkYXRlXCI6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcbiAgICBpZiAob3B0aW9ucy5wcm9ncmVzcykge1xuICAgICAgbG9nLmluZm8oXCJcIi5jb25jYXQoZGF0YS5wbHVnaW5OYW1lID8gXCJbXCIuY29uY2F0KGRhdGEucGx1Z2luTmFtZSwgXCJdIFwiKSA6IFwiXCIpLmNvbmNhdChkYXRhLnBlcmNlbnQsIFwiJSAtIFwiKS5jb25jYXQoZGF0YS5tc2csIFwiLlwiKSk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoXCJQcm9ncmVzc1wiLCBkYXRhKTtcbiAgfSxcbiAgXCJzdGlsbC1va1wiOiBmdW5jdGlvbiBzdGlsbE9rKCkge1xuICAgIGxvZy5pbmZvKFwiTm90aGluZyBjaGFuZ2VkLlwiKTtcblxuICAgIGlmIChvcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZShcIlN0aWxsT2tcIik7XG4gIH0sXG4gIG9rOiBmdW5jdGlvbiBvaygpIHtcbiAgICBzZW5kTWVzc2FnZShcIk9rXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgaGlkZSgpO1xuICAgIH1cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICAvLyBUT0RPOiByZW1vdmUgaW4gdjUgaW4gZmF2b3Igb2YgJ3N0YXRpYy1jaGFuZ2VkJ1xuICBcImNvbnRlbnQtY2hhbmdlZFwiOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZChmaWxlKSB7XG4gICAgbG9nLmluZm8oXCJcIi5jb25jYXQoZmlsZSA/IFwiXFxcIlwiLmNvbmNhdChmaWxlLCBcIlxcXCJcIikgOiBcIkNvbnRlbnRcIiwgXCIgZnJvbSBzdGF0aWMgZGlyZWN0b3J5IHdhcyBjaGFuZ2VkLiBSZWxvYWRpbmcuLi5cIikpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIFwic3RhdGljLWNoYW5nZWRcIjogZnVuY3Rpb24gc3RhdGljQ2hhbmdlZChmaWxlKSB7XG4gICAgbG9nLmluZm8oXCJcIi5jb25jYXQoZmlsZSA/IFwiXFxcIlwiLmNvbmNhdChmaWxlLCBcIlxcXCJcIikgOiBcIkNvbnRlbnRcIiwgXCIgZnJvbSBzdGF0aWMgZGlyZWN0b3J5IHdhcyBjaGFuZ2VkLiBSZWxvYWRpbmcuLi5cIikpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybihcIldhcm5pbmdzIHdoaWxlIGNvbXBpbGluZy5cIik7XG5cbiAgICB2YXIgc3RyaXBwZWRXYXJuaW5ncyA9IF93YXJuaW5ncy5tYXAoZnVuY3Rpb24gKHdhcm5pbmcpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2kod2FybmluZy5tZXNzYWdlID8gd2FybmluZy5tZXNzYWdlIDogd2FybmluZyk7XG4gICAgfSk7XG5cbiAgICBzZW5kTWVzc2FnZShcIldhcm5pbmdzXCIsIHN0cmlwcGVkV2FybmluZ3MpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZFdhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cud2FybihzdHJpcHBlZFdhcm5pbmdzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZFNob3dPdmVybGF5Rm9yV2FybmluZ3MgPSB0eXBlb2Ygb3B0aW9ucy5vdmVybGF5ID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMub3ZlcmxheSA6IG9wdGlvbnMub3ZlcmxheSAmJiBvcHRpb25zLm92ZXJsYXkud2FybmluZ3M7XG5cbiAgICBpZiAobmVlZFNob3dPdmVybGF5Rm9yV2FybmluZ3MpIHtcbiAgICAgIHNob3coX3dhcm5pbmdzLCBcIndhcm5pbmdzXCIpO1xuICAgIH1cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKFwiRXJyb3JzIHdoaWxlIGNvbXBpbGluZy4gUmVsb2FkIHByZXZlbnRlZC5cIik7XG5cbiAgICB2YXIgc3RyaXBwZWRFcnJvcnMgPSBfZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2koZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcik7XG4gICAgfSk7XG5cbiAgICBzZW5kTWVzc2FnZShcIkVycm9yc1wiLCBzdHJpcHBlZEVycm9ycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xuICAgIH1cblxuICAgIHZhciBuZWVkU2hvd092ZXJsYXlGb3JFcnJvcnMgPSB0eXBlb2Ygb3B0aW9ucy5vdmVybGF5ID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMub3ZlcmxheSA6IG9wdGlvbnMub3ZlcmxheSAmJiBvcHRpb25zLm92ZXJsYXkuZXJyb3JzO1xuXG4gICAgaWYgKG5lZWRTaG93T3ZlcmxheUZvckVycm9ycykge1xuICAgICAgc2hvdyhfZXJyb3JzLCBcImVycm9yc1wiKTtcbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGxvZy5pbmZvKFwiRGlzY29ubmVjdGVkIVwiKTtcblxuICAgIGlmIChvcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZShcIkNsb3NlXCIpO1xuICB9XG59O1xudmFyIHNvY2tldFVSTCA9IGNyZWF0ZVNvY2tldFVSTChwYXJzZWRSZXNvdXJjZVF1ZXJ5KTtcbnNvY2tldChzb2NrZXRVUkwsIG9uU29ja2V0TWVzc2FnZSk7IiwiLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9jbGllbnQtc3JjL21vZHVsZXMvbG9nZ2VyL1N5bmNCYWlsSG9va0Zha2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jbGllbnQtc3JjL21vZHVsZXMvbG9nZ2VyL1N5bmNCYWlsSG9va0Zha2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblxuLyoqXG4gKiBDbGllbnQgc3R1YiBmb3IgdGFwYWJsZSBTeW5jQmFpbEhvb2tcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNsaWVudFRhcGFibGVTeW5jQmFpbEhvb2soKSB7XG4gIHJldHVybiB7XG4gICAgY2FsbDogZnVuY3Rpb24gY2FsbCgpIHt9XG4gIH07XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL0xvZ2dlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL0xvZ2dlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG4vKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7IHJldHVybiBpOyB9KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyWyh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxudmFyIExvZ1R5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgZXJyb3I6IFwiZXJyb3JcIixcbiAgLy8gbWVzc2FnZSwgYyBzdHlsZSBhcmd1bWVudHNcbiAgd2FybjogXCJ3YXJuXCIsXG4gIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gIGluZm86IFwiaW5mb1wiLFxuICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuICBsb2c6IFwibG9nXCIsXG4gIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gIGRlYnVnOiBcImRlYnVnXCIsXG4gIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gIHRyYWNlOiBcInRyYWNlXCIsXG4gIC8vIG5vIGFyZ3VtZW50c1xuICBncm91cDogXCJncm91cFwiLFxuICAvLyBbbGFiZWxdXG4gIGdyb3VwQ29sbGFwc2VkOiBcImdyb3VwQ29sbGFwc2VkXCIsXG4gIC8vIFtsYWJlbF1cbiAgZ3JvdXBFbmQ6IFwiZ3JvdXBFbmRcIixcbiAgLy8gW2xhYmVsXVxuICBwcm9maWxlOiBcInByb2ZpbGVcIixcbiAgLy8gW3Byb2ZpbGVOYW1lXVxuICBwcm9maWxlRW5kOiBcInByb2ZpbGVFbmRcIixcbiAgLy8gW3Byb2ZpbGVOYW1lXVxuICB0aW1lOiBcInRpbWVcIixcbiAgLy8gbmFtZSwgdGltZSBhcyBbc2Vjb25kcywgbmFub3NlY29uZHNdXG4gIGNsZWFyOiBcImNsZWFyXCIsXG4gIC8vIG5vIGFyZ3VtZW50c1xuICBzdGF0dXM6IFwic3RhdHVzXCIgLy8gbWVzc2FnZSwgYXJndW1lbnRzXG5cbn0pO1xuZXhwb3J0cy5Mb2dUeXBlID0gTG9nVHlwZTtcbi8qKiBAdHlwZWRlZiB7dHlwZW9mIExvZ1R5cGVba2V5b2YgdHlwZW9mIExvZ1R5cGVdfSBMb2dUeXBlRW51bSAqL1xuXG52YXIgTE9HX1NZTUJPTCA9ICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pKFwid2VicGFjayBsb2dnZXIgcmF3IGxvZyBtZXRob2RcIik7XG52YXIgVElNRVJTX1NZTUJPTCA9ICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pKFwid2VicGFjayBsb2dnZXIgdGltZXNcIik7XG52YXIgVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MID0gKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkoXCJ3ZWJwYWNrIGxvZ2dlciBhZ2dyZWdhdGVkIHRpbWVzXCIpO1xuXG52YXIgV2VicGFja0xvZ2dlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKExvZ1R5cGVFbnVtLCBhbnlbXT0pOiB2b2lkfSBsb2cgbG9nIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nIHwgZnVuY3Rpb24oKTogc3RyaW5nKTogV2VicGFja0xvZ2dlcn0gZ2V0Q2hpbGRMb2dnZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGNoaWxkIGxvZ2dlclxuICAgKi9cbiAgZnVuY3Rpb24gV2VicGFja0xvZ2dlcihsb2csIGdldENoaWxkTG9nZ2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYnBhY2tMb2dnZXIpO1xuXG4gICAgdGhpc1tMT0dfU1lNQk9MXSA9IGxvZztcbiAgICB0aGlzLmdldENoaWxkTG9nZ2VyID0gZ2V0Q2hpbGRMb2dnZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2VicGFja0xvZ2dlciwgW3tcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmVycm9yLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2FyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLndhcm4sIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuaW5mbywgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2coKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUubG9nLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVidWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZGVidWcsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc3NlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0KGFzc2VydGlvbikge1xuICAgICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42ID4gMSA/IF9sZW42IC0gMSA6IDApLCBfa2V5NiA9IDE7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgICBhcmdzW19rZXk2IC0gMV0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmVycm9yLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUudHJhY2UsIFtcIlRyYWNlXCJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuY2xlYXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhdHVzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnN0YXR1cywgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleThdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmdyb3VwLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JvdXBDb2xsYXBzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXBDb2xsYXBzZWQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OV0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZ3JvdXBDb2xsYXBzZWQsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncm91cEVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cEVuZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEwKSwgX2tleTEwID0gMDsgX2tleTEwIDwgX2xlbjEwOyBfa2V5MTArKykge1xuICAgICAgICBhcmdzW19rZXkxMF0gPSBhcmd1bWVudHNbX2tleTEwXTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmdyb3VwRW5kLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvZmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9maWxlKGxhYmVsKSB7XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUucHJvZmlsZSwgW2xhYmVsXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2ZpbGVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvZmlsZUVuZChsYWJlbCkge1xuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnByb2ZpbGVFbmQsIFtsYWJlbF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWUobGFiZWwpIHtcbiAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0gPSB0aGlzW1RJTUVSU19TWU1CT0xdIHx8IG5ldyBNYXAoKTtcbiAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0uc2V0KGxhYmVsLCBwcm9jZXNzLmhydGltZSgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lTG9nKGxhYmVsKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXNbVElNRVJTX1NZTUJPTF0gJiYgdGhpc1tUSU1FUlNfU1lNQk9MXS5nZXQobGFiZWwpO1xuXG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbCAnXCIuY29uY2F0KGxhYmVsLCBcIicgZm9yIFdlYnBhY2tMb2dnZXIudGltZUxvZygpXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZShwcmV2KTtcbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS50aW1lLCBbbGFiZWxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGltZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXNbVElNRVJTX1NZTUJPTF0gJiYgdGhpc1tUSU1FUlNfU1lNQk9MXS5nZXQobGFiZWwpO1xuXG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbCAnXCIuY29uY2F0KGxhYmVsLCBcIicgZm9yIFdlYnBhY2tMb2dnZXIudGltZUVuZCgpXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZShwcmV2KTtcbiAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0uZGVsZXRlKGxhYmVsKTtcbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS50aW1lLCBbbGFiZWxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGltZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUFnZ3JlZ2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lQWdncmVnYXRlKGxhYmVsKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXNbVElNRVJTX1NZTUJPTF0gJiYgdGhpc1tUSU1FUlNfU1lNQk9MXS5nZXQobGFiZWwpO1xuXG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbCAnXCIuY29uY2F0KGxhYmVsLCBcIicgZm9yIFdlYnBhY2tMb2dnZXIudGltZUFnZ3JlZ2F0ZSgpXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZShwcmV2KTtcbiAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0uZGVsZXRlKGxhYmVsKTtcbiAgICAgIHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSB8fCBuZXcgTWFwKCk7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXS5nZXQobGFiZWwpO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aW1lWzFdICsgY3VycmVudFsxXSA+IDFlOSkge1xuICAgICAgICAgIHRpbWVbMF0gKz0gY3VycmVudFswXSArIDE7XG4gICAgICAgICAgdGltZVsxXSA9IHRpbWVbMV0gLSAxZTkgKyBjdXJyZW50WzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVbMF0gKz0gY3VycmVudFswXTtcbiAgICAgICAgICB0aW1lWzFdICs9IGN1cnJlbnRbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdLnNldChsYWJlbCwgdGltZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVBZ2dyZWdhdGVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZUFnZ3JlZ2F0ZUVuZChsYWJlbCkge1xuICAgICAgaWYgKHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICB2YXIgdGltZSA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXS5nZXQobGFiZWwpO1xuICAgICAgaWYgKHRpbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnRpbWUsIFtsYWJlbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aW1lKSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJwYWNrTG9nZ2VyO1xufSgpO1xuXG5leHBvcnRzLkxvZ2dlciA9IFdlYnBhY2tMb2dnZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvY3JlYXRlQ29uc29sZUxvZ2dlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9jcmVhdGVDb25zb2xlTG9nZ2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7IHJldHVybiBpOyB9KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyWyh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vTG9nZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9Mb2dnZXIuanNcIiksXG4gICAgTG9nVHlwZSA9IF9yZXF1aXJlLkxvZ1R5cGU7XG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2RlY2xhcmF0aW9ucy9XZWJwYWNrT3B0aW9uc1wiKS5GaWx0ZXJJdGVtVHlwZXN9IEZpbHRlckl0ZW1UeXBlcyAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2RlY2xhcmF0aW9ucy9XZWJwYWNrT3B0aW9uc1wiKS5GaWx0ZXJUeXBlc30gRmlsdGVyVHlwZXMgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL0xvZ2dlclwiKS5Mb2dUeXBlRW51bX0gTG9nVHlwZUVudW0gKi9cblxuLyoqIEB0eXBlZGVmIHtmdW5jdGlvbihzdHJpbmcpOiBib29sZWFufSBGaWx0ZXJGdW5jdGlvbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExvZ2dlckNvbnNvbGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gY2xlYXJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gdHJhY2VcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBpbmZvXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gbG9nXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gd2FyblxuICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGVycm9yXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IGRlYnVnXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IGdyb3VwXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IGdyb3VwQ29sbGFwc2VkXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IGdyb3VwRW5kXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IHN0YXR1c1xuICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBwcm9maWxlXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IHByb2ZpbGVFbmRcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gbG9nVGltZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTG9nZ2VyT3B0aW9uc1xuICogQHByb3BlcnR5IHtmYWxzZXx0cnVlfFwibm9uZVwifFwiZXJyb3JcInxcIndhcm5cInxcImluZm9cInxcImxvZ1wifFwidmVyYm9zZVwifSBsZXZlbCBsb2dsZXZlbFxuICogQHByb3BlcnR5IHtGaWx0ZXJUeXBlc3xib29sZWFufSBkZWJ1ZyBmaWx0ZXIgZm9yIGRlYnVnIGxvZ2dpbmdcbiAqIEBwcm9wZXJ0eSB7TG9nZ2VyQ29uc29sZX0gY29uc29sZSB0aGUgY29uc29sZSB0byBsb2cgdG9cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmlsdGVySXRlbVR5cGVzfSBpdGVtIGFuIGlucHV0IGl0ZW1cbiAqIEByZXR1cm5zIHtGaWx0ZXJGdW5jdGlvbn0gZmlsdGVyIGZ1bmN0aW9uXG4gKi9cblxuXG52YXIgZmlsdGVyVG9GdW5jdGlvbiA9IGZ1bmN0aW9uIGZpbHRlclRvRnVuY3Rpb24oaXRlbSkge1xuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cChcIltcXFxcXFxcXC9dXCIuY29uY2F0KGl0ZW0ucmVwbGFjZSggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgL1stW1xcXXt9KCkqKz8uXFxcXF4kfF0vZywgXCJcXFxcJCZcIiksIFwiKFtcXFxcXFxcXC9dfCR8IXxcXFxcPylcIikpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoaWRlbnQpIHtcbiAgICAgIHJldHVybiByZWdFeHAudGVzdChpZGVudCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBpdGVtLnRlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaWRlbnQpIHtcbiAgICAgIHJldHVybiBpdGVtLnRlc3QoaWRlbnQpO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpdGVtID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5cblxudmFyIExvZ0xldmVsID0ge1xuICBub25lOiA2LFxuICBmYWxzZTogNixcbiAgZXJyb3I6IDUsXG4gIHdhcm46IDQsXG4gIGluZm86IDMsXG4gIGxvZzogMixcbiAgdHJ1ZTogMixcbiAgdmVyYm9zZTogMVxufTtcbi8qKlxuICogQHBhcmFtIHtMb2dnZXJPcHRpb25zfSBvcHRpb25zIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBMb2dUeXBlRW51bSwgYW55W10pOiB2b2lkfSBsb2dnaW5nIGZ1bmN0aW9uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgX3JlZiRsZXZlbCA9IF9yZWYubGV2ZWwsXG4gICAgICBsZXZlbCA9IF9yZWYkbGV2ZWwgPT09IHZvaWQgMCA/IFwiaW5mb1wiIDogX3JlZiRsZXZlbCxcbiAgICAgIF9yZWYkZGVidWcgPSBfcmVmLmRlYnVnLFxuICAgICAgZGVidWcgPSBfcmVmJGRlYnVnID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGVidWcsXG4gICAgICBjb25zb2xlID0gX3JlZi5jb25zb2xlO1xuICB2YXIgZGVidWdGaWx0ZXJzID0gdHlwZW9mIGRlYnVnID09PSBcImJvb2xlYW5cIiA/IFtmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XSA6XG4gIC8qKiBAdHlwZSB7RmlsdGVySXRlbVR5cGVzW119ICovXG4gIFtdLmNvbmNhdChkZWJ1ZykubWFwKGZpbHRlclRvRnVuY3Rpb24pO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICB2YXIgbG9nbGV2ZWwgPSBMb2dMZXZlbFtcIlwiLmNvbmNhdChsZXZlbCldIHx8IDA7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBsb2dnZXJcbiAgICogQHBhcmFtIHtMb2dUeXBlRW51bX0gdHlwZSB0eXBlIG9mIHRoZSBsb2cgZW50cnlcbiAgICogQHBhcmFtIHthbnlbXX0gYXJncyBhcmd1bWVudHMgb2YgdGhlIGxvZyBlbnRyeVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cbiAgdmFyIGxvZ2dlciA9IGZ1bmN0aW9uIGxvZ2dlcihuYW1lLCB0eXBlLCBhcmdzKSB7XG4gICAgdmFyIGxhYmVsZWRBcmdzID0gZnVuY3Rpb24gbGFiZWxlZEFyZ3MoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIltcIi5jb25jYXQobmFtZSwgXCJdIFwiKS5jb25jYXQoYXJnc1swXSldLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYXJncy5zbGljZSgxKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXCJbXCIuY29uY2F0KG5hbWUsIFwiXVwiKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlYnVnID0gZGVidWdGaWx0ZXJzLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIExvZ1R5cGUuZGVidWc6XG4gICAgICAgIGlmICghZGVidWcpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5kZWJ1ZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGNvbnNvbGUuZGVidWcuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5sb2c6XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5pbmZvOlxuICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwuaW5mbykgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS53YXJuOlxuICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwud2FybikgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5lcnJvcjpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmVycm9yKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS50cmFjZTpcbiAgICAgICAgaWYgKCFkZWJ1ZykgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExvZ1R5cGUuZ3JvdXBDb2xsYXBzZWQ6XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjtcblxuICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwudmVyYm9zZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZC5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgICAgY2FzZSBMb2dUeXBlLmdyb3VwOlxuICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwubG9nKSByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuZ3JvdXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICBjb25zb2xlLmdyb3VwLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExvZ1R5cGUuZ3JvdXBFbmQ6XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5ncm91cEVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExvZ1R5cGUudGltZTpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjtcbiAgICAgICAgICB2YXIgbXMgPSBhcmdzWzFdICogMTAwMCArIGFyZ3NbMl0gLyAxMDAwMDAwO1xuICAgICAgICAgIHZhciBtc2cgPSBcIltcIi5jb25jYXQobmFtZSwgXCJdIFwiKS5jb25jYXQoYXJnc1swXSwgXCI6IFwiKS5jb25jYXQobXMsIFwiIG1zXCIpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmxvZ1RpbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2dUaW1lKG1zZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBMb2dUeXBlLnByb2ZpbGU6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnByb2ZpbGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICBjb25zb2xlLnByb2ZpbGUuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExvZ1R5cGUucHJvZmlsZUVuZDpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUucHJvZmlsZUVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGNvbnNvbGUucHJvZmlsZUVuZC5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5jbGVhcjpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmNsZWFyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgY29uc29sZS5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5zdGF0dXM6XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5pbmZvKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnN0YXR1cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLnN0YXR1cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLnN0YXR1cy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIExvZ1R5cGUgXCIuY29uY2F0KHR5cGUpKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxvZ2dlcjtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvcnVudGltZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBTeW5jQmFpbEhvb2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0YXBhYmxlL2xpYi9TeW5jQmFpbEhvb2sgKi8gXCIuL2NsaWVudC1zcmMvbW9kdWxlcy9sb2dnZXIvU3luY0JhaWxIb29rRmFrZS5qc1wiKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Mb2dnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL0xvZ2dlci5qc1wiKSxcbiAgICBMb2dnZXIgPSBfcmVxdWlyZS5Mb2dnZXI7XG5cbnZhciBjcmVhdGVDb25zb2xlTG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVDb25zb2xlTG9nZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9jcmVhdGVDb25zb2xlTG9nZ2VyLmpzXCIpO1xuLyoqIEB0eXBlIHtjcmVhdGVDb25zb2xlTG9nZ2VyLkxvZ2dlck9wdGlvbnN9ICovXG5cblxudmFyIGN1cnJlbnREZWZhdWx0TG9nZ2VyT3B0aW9ucyA9IHtcbiAgbGV2ZWw6IFwiaW5mb1wiLFxuICBkZWJ1ZzogZmFsc2UsXG4gIGNvbnNvbGU6IGNvbnNvbGVcbn07XG52YXIgY3VycmVudERlZmF1bHRMb2dnZXIgPSBjcmVhdGVDb25zb2xlTG9nZ2VyKGN1cnJlbnREZWZhdWx0TG9nZ2VyT3B0aW9ucyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGxvZ2dlclxuICogQHJldHVybnMge0xvZ2dlcn0gYSBsb2dnZXJcbiAqL1xuXG5leHBvcnRzLmdldExvZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuZXcgTG9nZ2VyKGZ1bmN0aW9uICh0eXBlLCBhcmdzKSB7XG4gICAgaWYgKGV4cG9ydHMuaG9va3MubG9nLmNhbGwobmFtZSwgdHlwZSwgYXJncykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudERlZmF1bHRMb2dnZXIobmFtZSwgdHlwZSwgYXJncyk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoY2hpbGROYW1lKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZ2V0TG9nZ2VyKFwiXCIuY29uY2F0KG5hbWUsIFwiL1wiKS5jb25jYXQoY2hpbGROYW1lKSk7XG4gIH0pO1xufTtcbi8qKlxuICogQHBhcmFtIHtjcmVhdGVDb25zb2xlTG9nZ2VyLkxvZ2dlck9wdGlvbnN9IG9wdGlvbnMgbmV3IG9wdGlvbnMsIG1lcmdlIHdpdGggb2xkIG9wdGlvbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cblxuZXhwb3J0cy5jb25maWd1cmVEZWZhdWx0TG9nZ2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgX2V4dGVuZHMoY3VycmVudERlZmF1bHRMb2dnZXJPcHRpb25zLCBvcHRpb25zKTtcblxuICBjdXJyZW50RGVmYXVsdExvZ2dlciA9IGNyZWF0ZUNvbnNvbGVMb2dnZXIoY3VycmVudERlZmF1bHRMb2dnZXJPcHRpb25zKTtcbn07XG5cbmV4cG9ydHMuaG9va3MgPSB7XG4gIGxvZzogbmV3IFN5bmNCYWlsSG9vayhbXCJvcmlnaW5cIiwgXCJ0eXBlXCIsIFwiYXJnc1wiXSlcbn07XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH1cbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaXNvbGF0ZWQgYWdhaW5zdCBvdGhlciBtb2R1bGVzIGluIHRoZSBjaHVuay5cbiFmdW5jdGlvbigpIHtcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY2xpZW50LXNyYy9tb2R1bGVzL2xvZ2dlci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCBkZWZhdWx0IGV4cG9ydCBmcm9tIG5hbWVkIG1vZHVsZSAqLyB3ZWJwYWNrX2xpYl9sb2dnaW5nX3J1bnRpbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXzsgfVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgd2VicGFja19saWJfbG9nZ2luZ19ydW50aW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB3ZWJwYWNrL2xpYi9sb2dnaW5nL3J1bnRpbWUuanMgKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL3J1bnRpbWUuanNcIik7XG5cbn0oKTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fID0gZXhwb3J0cztcbmZvcih2YXIgaSBpbiBfX3dlYnBhY2tfZXhwb3J0c19fKSBfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fW2ldID0gX193ZWJwYWNrX2V4cG9ydHNfX1tpXTtcbmlmKF9fd2VicGFja19leHBvcnRzX18uX19lc01vZHVsZSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRfdGFyZ2V0X18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gfSkoKVxuOyIsIi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBzdHJpcEFuc2k7IH1cbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGFuc2lfcmVnZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGFuc2ktcmVnZXggKi8gXCIuL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzXCIpO1xuXG5mdW5jdGlvbiBzdHJpcEFuc2koc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIGBzdHJpbmdgLCBnb3QgYFwiLmNvbmNhdCh0eXBlb2Ygc3RyaW5nLCBcImBcIikpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKCgwLGFuc2lfcmVnZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pKCksICcnKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGFuc2lSZWdleDsgfVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG5mdW5jdGlvbiBhbnNpUmVnZXgoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYkb25seUZpcnN0ID0gX3JlZi5vbmx5Rmlyc3QsXG4gICAgICBvbmx5Rmlyc3QgPSBfcmVmJG9ubHlGaXJzdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJG9ubHlGaXJzdDtcblxuICB2YXIgcGF0dGVybiA9IFtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNylcIiwgJyg/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnRxcnk9Pjx+XSkpJ10uam9pbignfCcpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBvbmx5Rmlyc3QgPyB1bmRlZmluZWQgOiAnZycpO1xufVxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4hZnVuY3Rpb24oKSB7XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jbGllbnQtc3JjL21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHN0cmlwX2Fuc2lfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHN0cmlwLWFuc2kgKi8gXCIuL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzXCIpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHN0cmlwX2Fuc2lfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xufSgpO1xudmFyIF9fd2VicGFja19leHBvcnRfdGFyZ2V0X18gPSBleHBvcnRzO1xuZm9yKHZhciBpIGluIF9fd2VicGFja19leHBvcnRzX18pIF9fd2VicGFja19leHBvcnRfdGFyZ2V0X19baV0gPSBfX3dlYnBhY2tfZXhwb3J0c19fW2ldO1xuaWYoX193ZWJwYWNrX2V4cG9ydHNfXy5fX2VzTW9kdWxlKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyB9KSgpXG47IiwiLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5pbXBvcnQgYW5zaUhUTUwgZnJvbSBcImFuc2ktaHRtbC1jb21tdW5pdHlcIjtcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCJodG1sLWVudGl0aWVzXCI7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogW1widHJhbnNwYXJlbnRcIiwgXCJ0cmFuc3BhcmVudFwiXSxcbiAgYmxhY2s6IFwiMTgxODE4XCIsXG4gIHJlZDogXCJFMzYwNDlcIixcbiAgZ3JlZW46IFwiQjNDQjc0XCIsXG4gIHllbGxvdzogXCJGRkQwODBcIixcbiAgYmx1ZTogXCI3Q0FGQzJcIixcbiAgbWFnZW50YTogXCI3RkFDQ0FcIixcbiAgY3lhbjogXCJDM0MyRUZcIixcbiAgbGlnaHRncmV5OiBcIkVCRTdFM1wiLFxuICBkYXJrZ3JleTogXCI2RDc4OTFcIlxufTtcbnZhciBpZnJhbWVDb250YWluZXJFbGVtZW50O1xudmFyIGNvbnRhaW5lckVsZW1lbnQ7XG52YXIgb25Mb2FkUXVldWUgPSBbXTtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoKSB7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LmlkID0gXCJ3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXlcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zcmMgPSBcImFib3V0OmJsYW5rXCI7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuc3R5bGUubGVmdCA9IDA7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuc3R5bGUudG9wID0gMDtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5yaWdodCA9IDA7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuc3R5bGUuYm90dG9tID0gMDtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTAwdndcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIjEwMHZoXCI7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuc3R5bGUuYm9yZGVyID0gXCJub25lXCI7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcblxuICBpZnJhbWVDb250YWluZXJFbGVtZW50Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb250YWluZXJFbGVtZW50ID0gaWZyYW1lQ29udGFpbmVyRWxlbWVudC5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXJFbGVtZW50LmlkID0gXCJ3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXktZGl2XCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUubGVmdCA9IDA7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS50b3AgPSAwO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUucmlnaHQgPSAwO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUuYm90dG9tID0gMDtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDB2d1wiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCIxMDB2aFwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDAsIDAsIDAsIDAuODUpXCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5jb2xvciA9IFwiI0U4RThFOFwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUuZm9udEZhbWlseSA9IFwiTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2VcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmZvbnRTaXplID0gXCJsYXJnZVwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFwiMnJlbVwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUubGluZUhlaWdodCA9IFwiMS4yXCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gXCJwcmUtd3JhcFwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImF1dG9cIjtcbiAgICB2YXIgaGVhZGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGhlYWRlckVsZW1lbnQuaW5uZXJUZXh0ID0gXCJDb21waWxlZCB3aXRoIHByb2JsZW1zOlwiO1xuICAgIHZhciBjbG9zZUJ1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5pbm5lclRleHQgPSBcIlhcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuc3R5bGUuYm9yZGVyID0gXCJub25lXCI7XG4gICAgY2xvc2VCdXR0b25FbGVtZW50LnN0eWxlLmZvbnRTaXplID0gXCIyMHB4XCI7XG4gICAgY2xvc2VCdXR0b25FbGVtZW50LnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuc3R5bGUuY29sb3IgPSBcIndoaXRlXCI7XG4gICAgY2xvc2VCdXR0b25FbGVtZW50LnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9IFwicmlnaHRcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuc3R5bGUuc3R5bGVGbG9hdCA9IFwicmlnaHRcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9KTtcbiAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGhlYWRlckVsZW1lbnQpO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b25FbGVtZW50KTtcbiAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuY29udGVudERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyRWxlbWVudCk7XG4gICAgb25Mb2FkUXVldWUuZm9yRWFjaChmdW5jdGlvbiAob25Mb2FkKSB7XG4gICAgICBvbkxvYWQoY29udGFpbmVyRWxlbWVudCk7XG4gICAgfSk7XG4gICAgb25Mb2FkUXVldWUgPSBbXTtcbiAgICBpZnJhbWVDb250YWluZXJFbGVtZW50Lm9ubG9hZCA9IG51bGw7XG4gIH07XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWVDb250YWluZXJFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheUV4aXN0cyhjYWxsYmFjaykge1xuICBpZiAoY29udGFpbmVyRWxlbWVudCkge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgY2FsbGJhY2soY29udGFpbmVyRWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb25Mb2FkUXVldWUucHVzaChjYWxsYmFjayk7XG5cbiAgaWYgKGlmcmFtZUNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjcmVhdGVDb250YWluZXIoKTtcbn0gLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cblxuXG5mdW5jdGlvbiBoaWRlKCkge1xuICBpZiAoIWlmcmFtZUNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ2xlYW4gdXAgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlLlxuXG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWVDb250YWluZXJFbGVtZW50KTtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudCA9IG51bGw7XG4gIGNvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xufSAvLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cblxuXG5mdW5jdGlvbiBzaG93KG1lc3NhZ2VzLCB0eXBlKSB7XG4gIGVuc3VyZU92ZXJsYXlFeGlzdHMoZnVuY3Rpb24gKCkge1xuICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBlbnRyeUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdmFyIHR5cGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0eXBlRWxlbWVudC5pbm5lclRleHQgPSB0eXBlID09PSBcIndhcm5pbmdzXCIgPyBcIldhcm5pbmc6XCIgOiBcIkVycm9yOlwiO1xuICAgICAgdHlwZUVsZW1lbnQuc3R5bGUuY29sb3IgPSBcIiNcIi5jb25jYXQoY29sb3JzLnJlZCk7IC8vIE1ha2UgaXQgbG9vayBzaW1pbGFyIHRvIG91ciB0ZXJtaW5hbC5cblxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2UubWVzc2FnZSB8fCBtZXNzYWdlc1swXTtcbiAgICAgIHZhciB0ZXh0ID0gYW5zaUhUTUwoZW5jb2RlKGVycm9yTWVzc2FnZSkpO1xuICAgICAgdmFyIG1lc3NhZ2VUZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBtZXNzYWdlVGV4dE5vZGUuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgIGVudHJ5RWxlbWVudC5hcHBlbmRDaGlsZCh0eXBlRWxlbWVudCk7XG4gICAgICBlbnRyeUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIGVudHJ5RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKG1lc3NhZ2VUZXh0Tm9kZSk7XG4gICAgICBlbnRyeUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIGVudHJ5RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChlbnRyeUVsZW1lbnQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgc2hvdywgaGlkZSB9OyIsIi8qIGdsb2JhbCBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAqL1xuaW1wb3J0IFdlYlNvY2tldENsaWVudCBmcm9tIFwiLi9jbGllbnRzL1dlYlNvY2tldENsaWVudC5qc1wiOyAvLyB0aGlzIFdlYnNvY2tldENsaWVudCBpcyBoZXJlIGFzIGEgZGVmYXVsdCBmYWxsYmFjaywgaW4gY2FzZSB0aGUgY2xpZW50IGlzIG5vdCBpbmplY3RlZFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cblxudmFyIENsaWVudCA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2UsIG5vLW5lc3RlZC10ZXJuYXJ5XG50eXBlb2YgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gIT09IFwidW5kZWZpbmVkXCIgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG50eXBlb2YgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18uZGVmYXVsdCAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fLmRlZmF1bHQgOiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyA6IFdlYlNvY2tldENsaWVudDtcbi8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5cbnZhciByZXRyaWVzID0gMDtcbnZhciBjbGllbnQgPSBudWxsO1xuXG52YXIgc29ja2V0ID0gZnVuY3Rpb24gaW5pdFNvY2tldCh1cmwsIGhhbmRsZXJzKSB7XG4gIGNsaWVudCA9IG5ldyBDbGllbnQodXJsKTtcbiAgY2xpZW50Lm9uT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gIH0pO1xuICBjbGllbnQub25DbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IDApIHtcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XG4gICAgfSAvLyBUcnkgdG8gcmVjb25uZWN0LlxuXG5cbiAgICBjbGllbnQgPSBudWxsOyAvLyBBZnRlciAxMCByZXRyaWVzIHN0b3AgdHJ5aW5nLCB0byBwcmV2ZW50IGxvZ3NwYW0uXG5cbiAgICBpZiAocmV0cmllcyA8PSAxMCkge1xuICAgICAgLy8gRXhwb25lbnRpYWxseSBpbmNyZWFzZSB0aW1lb3V0IHRvIHJlY29ubmVjdC5cbiAgICAgIC8vIFJlc3BlY3RmdWxseSBjb3BpZWQgZnJvbSB0aGUgcGFja2FnZSBgZ290YC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnMsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgdmFyIHJldHJ5SW5NcyA9IDEwMDAgKiBNYXRoLnBvdygyLCByZXRyaWVzKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICByZXRyaWVzICs9IDE7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc29ja2V0KHVybCwgaGFuZGxlcnMpO1xuICAgICAgfSwgcmV0cnlJbk1zKTtcbiAgICB9XG4gIH0pO1xuICBjbGllbnQub25NZXNzYWdlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgaWYgKGhhbmRsZXJzW21lc3NhZ2UudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21lc3NhZ2UudHlwZV0obWVzc2FnZS5kYXRhKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc29ja2V0OyIsImltcG9ydCB1cmwgZnJvbSBcInVybFwiOyAvLyBXZSBoYW5kbGUgbGVnYWN5IEFQSSB0aGF0IGlzIE5vZGUuanMgc3BlY2lmaWMsIGFuZCBhIG5ld2VyIEFQSSB0aGF0IGltcGxlbWVudHMgdGhlIHNhbWUgV0hBVFdHIFVSTCBTdGFuZGFyZCB1c2VkIGJ5IHdlYiBicm93c2Vyc1xuLy8gUGxlYXNlIGxvb2sgYXQgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS91cmwuaHRtbCN1cmxfdXJsX3N0cmluZ3NfYW5kX3VybF9vYmplY3RzXG5cbmZ1bmN0aW9uIGNyZWF0ZVNvY2tldFVSTChwYXJzZWRVUkwpIHtcbiAgdmFyIGhvc3RuYW1lID0gcGFyc2VkVVJMLmhvc3RuYW1lOyAvLyBOb2RlLmpzIG1vZHVsZSBwYXJzZXMgaXQgYXMgYDo6YFxuICAvLyBgbmV3IFVSTCh1cmxTdHJpbmcsIFtiYXNlVVJMc3RyaW5nXSlgIHBhcnNlcyBpdCBhcyAnWzo6XSdcblxuICB2YXIgaXNJbkFkZHJBbnkgPSBob3N0bmFtZSA9PT0gXCIwLjAuMC4wXCIgfHwgaG9zdG5hbWUgPT09IFwiOjpcIiB8fCBob3N0bmFtZSA9PT0gXCJbOjpdXCI7IC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG5cbiAgaWYgKGlzSW5BZGRyQW55ICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgJiYgc2VsZi5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKFwiaHR0cFwiKSA9PT0gMCkge1xuICAgIGhvc3RuYW1lID0gc2VsZi5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgfVxuXG4gIHZhciBzb2NrZXRVUkxQcm90b2NvbCA9IHBhcnNlZFVSTC5wcm90b2NvbCB8fCBzZWxmLmxvY2F0aW9uLnByb3RvY29sOyAvLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYiBzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWIgc29ja2V0cy5cblxuICBpZiAoc29ja2V0VVJMUHJvdG9jb2wgPT09IFwiYXV0bzpcIiB8fCBob3N0bmFtZSAmJiBpc0luQWRkckFueSAmJiBzZWxmLmxvY2F0aW9uLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgc29ja2V0VVJMUHJvdG9jb2wgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sO1xuICB9XG5cbiAgc29ja2V0VVJMUHJvdG9jb2wgPSBzb2NrZXRVUkxQcm90b2NvbC5yZXBsYWNlKC9eKD86aHR0cHwuKy1leHRlbnNpb258ZmlsZSkvaSwgXCJ3c1wiKTtcbiAgdmFyIHNvY2tldFVSTEF1dGggPSBcIlwiOyAvLyBgbmV3IFVSTCh1cmxTdHJpbmcsIFtiYXNlVVJMc3RyaW5nXSlgIGRvZXNuJ3QgaGF2ZSBgYXV0aGAgcHJvcGVydHlcbiAgLy8gUGFyc2UgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgaW4gY2FzZSB3ZSBuZWVkIHRoZW1cblxuICBpZiAocGFyc2VkVVJMLnVzZXJuYW1lKSB7XG4gICAgc29ja2V0VVJMQXV0aCA9IHBhcnNlZFVSTC51c2VybmFtZTsgLy8gU2luY2UgSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvbiBkb2VzIG5vdCBhbGxvdyBlbXB0eSB1c2VybmFtZSxcbiAgICAvLyB3ZSBvbmx5IGluY2x1ZGUgcGFzc3dvcmQgaWYgdGhlIHVzZXJuYW1lIGlzIG5vdCBlbXB0eS5cblxuICAgIGlmIChwYXJzZWRVUkwucGFzc3dvcmQpIHtcbiAgICAgIC8vIFJlc3VsdDogPHVzZXJuYW1lPjo8cGFzc3dvcmQ+XG4gICAgICBzb2NrZXRVUkxBdXRoID0gc29ja2V0VVJMQXV0aC5jb25jYXQoXCI6XCIsIHBhcnNlZFVSTC5wYXNzd29yZCk7XG4gICAgfVxuICB9IC8vIEluIGNhc2UgdGhlIGhvc3QgaXMgYSByYXcgSVB2NiBhZGRyZXNzLCBpdCBjYW4gYmUgZW5jbG9zZWQgaW5cbiAgLy8gdGhlIGJyYWNrZXRzIGFzIHRoZSBicmFja2V0cyBhcmUgbmVlZGVkIGluIHRoZSBmaW5hbCBVUkwgc3RyaW5nLlxuICAvLyBOZWVkIHRvIHJlbW92ZSB0aG9zZSBhcyB1cmwuZm9ybWF0IGJsaW5kbHkgYWRkcyBpdHMgb3duIHNldCBvZiBicmFja2V0c1xuICAvLyBpZiB0aGUgaG9zdCBzdHJpbmcgY29udGFpbnMgY29sb25zLiBUaGF0IHdvdWxkIGxlYWQgdG8gbm9uLXdvcmtpbmdcbiAgLy8gZG91YmxlIGJyYWNrZXRzIChlLmcuIFtbOjpdXSkgaG9zdFxuICAvL1xuICAvLyBBbGwgb2YgdGhlc2Ugd2ViIHNvY2tldCB1cmwgcGFyYW1zIGFyZSBvcHRpb25hbGx5IHBhc3NlZCBpbiB0aHJvdWdoIHJlc291cmNlUXVlcnksXG4gIC8vIHNvIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IGlmIHRoZXkgYXJlIG5vdCBwcm92aWRlZFxuXG5cbiAgdmFyIHNvY2tldFVSTEhvc3RuYW1lID0gKGhvc3RuYW1lIHx8IHNlbGYubG9jYXRpb24uaG9zdG5hbWUgfHwgXCJsb2NhbGhvc3RcIikucmVwbGFjZSgvXlxcWyguKilcXF0kLywgXCIkMVwiKTtcbiAgdmFyIHNvY2tldFVSTFBvcnQgPSBwYXJzZWRVUkwucG9ydDtcblxuICBpZiAoIXNvY2tldFVSTFBvcnQgfHwgc29ja2V0VVJMUG9ydCA9PT0gXCIwXCIpIHtcbiAgICBzb2NrZXRVUkxQb3J0ID0gc2VsZi5sb2NhdGlvbi5wb3J0O1xuICB9IC8vIElmIHBhdGggaXMgcHJvdmlkZWQgaXQnbGwgYmUgcGFzc2VkIGluIHZpYSB0aGUgcmVzb3VyY2VRdWVyeSBhcyBhXG4gIC8vIHF1ZXJ5IHBhcmFtIHNvIGl0IGhhcyB0byBiZSBwYXJzZWQgb3V0IG9mIHRoZSBxdWVyeXN0cmluZyBpbiBvcmRlciBmb3IgdGhlXG4gIC8vIGNsaWVudCB0byBvcGVuIHRoZSBzb2NrZXQgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG5cblxuICB2YXIgc29ja2V0VVJMUGF0aG5hbWUgPSBcIi93c1wiO1xuXG4gIGlmIChwYXJzZWRVUkwucGF0aG5hbWUgJiYgIXBhcnNlZFVSTC5mcm9tQ3VycmVudFNjcmlwdCkge1xuICAgIHNvY2tldFVSTFBhdGhuYW1lID0gcGFyc2VkVVJMLnBhdGhuYW1lO1xuICB9XG5cbiAgcmV0dXJuIHVybC5mb3JtYXQoe1xuICAgIHByb3RvY29sOiBzb2NrZXRVUkxQcm90b2NvbCxcbiAgICBhdXRoOiBzb2NrZXRVUkxBdXRoLFxuICAgIGhvc3RuYW1lOiBzb2NrZXRVUkxIb3N0bmFtZSxcbiAgICBwb3J0OiBzb2NrZXRVUkxQb3J0LFxuICAgIHBhdGhuYW1lOiBzb2NrZXRVUkxQYXRobmFtZSxcbiAgICBzbGFzaGVzOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTb2NrZXRVUkw7IiwiZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgfSAvLyBGYWxsYmFjayB0byBnZXR0aW5nIGFsbCBzY3JpcHRzIHJ1bm5pbmcgaW4gdGhlIGRvY3VtZW50LlxuXG5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIHNjcmlwdEVsZW1lbnRzV2l0aFNyYyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChzY3JpcHRFbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gIH0pO1xuXG4gIGlmIChzY3JpcHRFbGVtZW50c1dpdGhTcmMubGVuZ3RoID4gMCkge1xuICAgIHZhciBjdXJyZW50U2NyaXB0ID0gc2NyaXB0RWxlbWVudHNXaXRoU3JjW3NjcmlwdEVsZW1lbnRzV2l0aFNyYy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gIH0gLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cblxuXG4gIHRocm93IG5ldyBFcnJvcihcIlt3ZWJwYWNrLWRldi1zZXJ2ZXJdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLlwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiLCJpbXBvcnQgbG9nZ2VyIGZyb20gXCIuLi9tb2R1bGVzL2xvZ2dlci9pbmRleC5qc1wiO1xudmFyIG5hbWUgPSBcIndlYnBhY2stZGV2LXNlcnZlclwiOyAvLyBkZWZhdWx0IGxldmVsIGlzIHNldCBvbiB0aGUgY2xpZW50IHNpZGUsIHNvIGl0IGRvZXMgbm90IG5lZWRcbi8vIHRvIGJlIHNldCBieSB0aGUgQ0xJIG9yIEFQSVxuXG52YXIgZGVmYXVsdExldmVsID0gXCJpbmZvXCI7XG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIGxvZ2dlci5jb25maWd1cmVEZWZhdWx0TG9nZ2VyKHtcbiAgICBsZXZlbDogbGV2ZWxcbiAgfSk7XG59XG5cbnNldExvZ0xldmVsKGRlZmF1bHRMZXZlbCk7XG52YXIgbG9nID0gbG9nZ2VyLmdldExvZ2dlcihuYW1lKTtcbmV4cG9ydCB7IGxvZywgc2V0TG9nTGV2ZWwgfTsiLCJpbXBvcnQgdXJsIGZyb20gXCJ1cmxcIjtcbmltcG9ydCBnZXRDdXJyZW50U2NyaXB0U291cmNlIGZyb20gXCIuL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UuanNcIjtcblxuZnVuY3Rpb24gcGFyc2VVUkwocmVzb3VyY2VRdWVyeSkge1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcmVzb3VyY2VRdWVyeSA9PT0gXCJzdHJpbmdcIiAmJiByZXNvdXJjZVF1ZXJ5ICE9PSBcIlwiKSB7XG4gICAgdmFyIHNlYXJjaFBhcmFtcyA9IHJlc291cmNlUXVlcnkuc3Vic3RyKDEpLnNwbGl0KFwiJlwiKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VhcmNoUGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFpciA9IHNlYXJjaFBhcmFtc1tpXS5zcGxpdChcIj1cIik7XG4gICAgICBvcHRpb25zW3BhaXJbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBFbHNlLCBnZXQgdGhlIHVybCBmcm9tIHRoZSA8c2NyaXB0PiB0aGlzIGZpbGUgd2FzIGNhbGxlZCB3aXRoLlxuICAgIHZhciBzY3JpcHRTb3VyY2UgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7XG5cbiAgICBpZiAoc2NyaXB0U291cmNlKSB7XG4gICAgICB2YXIgc2NyaXB0U291cmNlVVJMO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGUgcGxhY2Vob2xkZXIgYGJhc2VVUkxgIHdpdGggYHdpbmRvdy5sb2NhdGlvbi5ocmVmYCxcbiAgICAgICAgLy8gaXMgdG8gYWxsb3cgcGFyc2luZyBvZiBwYXRoLXJlbGF0aXZlIG9yIHByb3RvY29sLXJlbGF0aXZlIFVSTHMsXG4gICAgICAgIC8vIGFuZCB3aWxsIGhhdmUgbm8gZWZmZWN0IGlmIGBzY3JpcHRTb3VyY2VgIGlzIGEgZnVsbHkgdmFsaWQgVVJMLlxuICAgICAgICBzY3JpcHRTb3VyY2VVUkwgPSBuZXcgVVJMKHNjcmlwdFNvdXJjZSwgc2VsZi5sb2NhdGlvbi5ocmVmKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gVVJMIHBhcnNpbmcgZmFpbGVkLCBkbyBub3RoaW5nLlxuICAgICAgICAvLyBXZSB3aWxsIHN0aWxsIHByb2NlZWQgdG8gc2VlIGlmIHdlIGNhbiByZWNvdmVyIHVzaW5nIGByZXNvdXJjZVF1ZXJ5YFxuICAgICAgfVxuXG4gICAgICBpZiAoc2NyaXB0U291cmNlVVJMKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzY3JpcHRTb3VyY2VVUkw7XG4gICAgICAgIG9wdGlvbnMuZnJvbUN1cnJlbnRTY3JpcHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gdXJsLnBhcnNlKHNlbGYubG9jYXRpb24uaHJlZiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBvcHRpb25zLmZyb21DdXJyZW50U2NyaXB0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2VVUkw7IiwiLyogZ2xvYmFsIF9fd2VicGFja19oYXNoX18gKi9cbmltcG9ydCBob3RFbWl0dGVyIGZyb20gXCJ3ZWJwYWNrL2hvdC9lbWl0dGVyLmpzXCI7XG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi9sb2cuanNcIjtcblxuZnVuY3Rpb24gcmVsb2FkQXBwKF9yZWYsIHN0YXR1cykge1xuICB2YXIgaG90ID0gX3JlZi5ob3QsXG4gICAgICBsaXZlUmVsb2FkID0gX3JlZi5saXZlUmVsb2FkO1xuXG4gIGlmIChzdGF0dXMuaXNVbmxvYWRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudEhhc2ggPSBzdGF0dXMuY3VycmVudEhhc2gsXG4gICAgICBwcmV2aW91c0hhc2ggPSBzdGF0dXMucHJldmlvdXNIYXNoO1xuICB2YXIgaXNJbml0aWFsID0gY3VycmVudEhhc2guaW5kZXhPZihwcmV2aW91c0hhc2gpID49IDA7XG5cbiAgaWYgKGlzSW5pdGlhbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIGxvZy5pbmZvKFwiQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLlwiKTtcbiAgICByb290V2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHNlbGYubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbGxvd1RvSG90ID0gc2VhcmNoLmluZGV4T2YoXCJ3ZWJwYWNrLWRldi1zZXJ2ZXItaG90PWZhbHNlXCIpID09PSAtMTtcbiAgdmFyIGFsbG93VG9MaXZlUmVsb2FkID0gc2VhcmNoLmluZGV4T2YoXCJ3ZWJwYWNrLWRldi1zZXJ2ZXItbGl2ZS1yZWxvYWQ9ZmFsc2VcIikgPT09IC0xO1xuXG4gIGlmIChob3QgJiYgYWxsb3dUb0hvdCkge1xuICAgIGxvZy5pbmZvKFwiQXBwIGhvdCB1cGRhdGUuLi5cIik7XG4gICAgaG90RW1pdHRlci5lbWl0KFwid2VicGFja0hvdFVwZGF0ZVwiLCBzdGF0dXMuY3VycmVudEhhc2gpO1xuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYud2luZG93KSB7XG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZShcIndlYnBhY2tIb3RVcGRhdGVcIi5jb25jYXQoc3RhdHVzLmN1cnJlbnRIYXNoKSwgXCIqXCIpO1xuICAgIH1cbiAgfSAvLyBhbGxvdyByZWZyZXNoaW5nIHRoZSBwYWdlIG9ubHkgaWYgbGl2ZVJlbG9hZCBpc24ndCBkaXNhYmxlZFxuICBlbHNlIGlmIChsaXZlUmVsb2FkICYmIGFsbG93VG9MaXZlUmVsb2FkKSB7XG4gICAgdmFyIHJvb3RXaW5kb3cgPSBzZWxmOyAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcblxuICAgIHZhciBpbnRlcnZhbElkID0gc2VsZi5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocm9vdFdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gXCJhYm91dDpcIikge1xuICAgICAgICAvLyByZWxvYWQgaW1tZWRpYXRlbHkgaWYgcHJvdG9jb2wgaXMgdmFsaWRcbiAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290V2luZG93ID0gcm9vdFdpbmRvdy5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVsb2FkQXBwOyIsIi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnkgV29ya2VyR2xvYmFsU2NvcGUgKi9cbi8vIFNlbmQgbWVzc2FnZXMgdG8gdGhlIG91dHNpZGUsIHNvIHBsdWdpbnMgY2FuIGNvbnN1bWUgaXQuXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09IFwidW5kZWZpbmVkXCIgfHwgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ3ZWJwYWNrXCIuY29uY2F0KHR5cGUpLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sIFwiKlwiKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzZW5kTXNnOyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vKiBnbG9iYWxzIF9fd2VicGFja19oYXNoX18gKi9cbmlmIChtb2R1bGUuaG90KSB7XG5cdHZhciBsYXN0SGFzaDtcblx0dmFyIHVwVG9EYXRlID0gZnVuY3Rpb24gdXBUb0RhdGUoKSB7XG5cdFx0cmV0dXJuIGxhc3RIYXNoLmluZGV4T2YoX193ZWJwYWNrX2hhc2hfXykgPj0gMDtcblx0fTtcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcblx0dmFyIGNoZWNrID0gZnVuY3Rpb24gY2hlY2soKSB7XG5cdFx0bW9kdWxlLmhvdFxuXHRcdFx0LmNoZWNrKHRydWUpXG5cdFx0XHQudGhlbihmdW5jdGlvbiAodXBkYXRlZE1vZHVsZXMpIHtcblx0XHRcdFx0aWYgKCF1cGRhdGVkTW9kdWxlcykge1xuXHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBDYW5ub3QgZmluZCB1cGRhdGUuIE5lZWQgdG8gZG8gYSBmdWxsIHJlbG9hZCFcIik7XG5cdFx0XHRcdFx0bG9nKFxuXHRcdFx0XHRcdFx0XCJ3YXJuaW5nXCIsXG5cdFx0XHRcdFx0XHRcIltITVJdIChQcm9iYWJseSBiZWNhdXNlIG9mIHJlc3RhcnRpbmcgdGhlIHdlYnBhY2stZGV2LXNlcnZlcilcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdXBUb0RhdGUoKSkge1xuXHRcdFx0XHRcdGNoZWNrKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXF1aXJlKFwiLi9sb2ctYXBwbHktcmVzdWx0XCIpKHVwZGF0ZWRNb2R1bGVzLCB1cGRhdGVkTW9kdWxlcyk7XG5cblx0XHRcdFx0aWYgKHVwVG9EYXRlKCkpIHtcblx0XHRcdFx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gQXBwIGlzIHVwIHRvIGRhdGUuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0dmFyIHN0YXR1cyA9IG1vZHVsZS5ob3Quc3RhdHVzKCk7XG5cdFx0XHRcdGlmIChbXCJhYm9ydFwiLCBcImZhaWxcIl0uaW5kZXhPZihzdGF0dXMpID49IDApIHtcblx0XHRcdFx0XHRsb2coXG5cdFx0XHRcdFx0XHRcIndhcm5pbmdcIixcblx0XHRcdFx0XHRcdFwiW0hNUl0gQ2Fubm90IGFwcGx5IHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gXCIgKyBsb2cuZm9ybWF0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBVcGRhdGUgZmFpbGVkOiBcIiArIGxvZy5mb3JtYXRFcnJvcihlcnIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH07XG5cdHZhciBob3RFbWl0dGVyID0gcmVxdWlyZShcIi4vZW1pdHRlclwiKTtcblx0aG90RW1pdHRlci5vbihcIndlYnBhY2tIb3RVcGRhdGVcIiwgZnVuY3Rpb24gKGN1cnJlbnRIYXNoKSB7XG5cdFx0bGFzdEhhc2ggPSBjdXJyZW50SGFzaDtcblx0XHRpZiAoIXVwVG9EYXRlKCkgJiYgbW9kdWxlLmhvdC5zdGF0dXMoKSA9PT0gXCJpZGxlXCIpIHtcblx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSBDaGVja2luZyBmb3IgdXBkYXRlcyBvbiB0aGUgc2VydmVyLi4uXCIpO1xuXHRcdFx0Y2hlY2soKTtcblx0XHR9XG5cdH0pO1xuXHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gV2FpdGluZyBmb3IgdXBkYXRlIHNpZ25hbCBmcm9tIFdEUy4uLlwiKTtcbn0gZWxzZSB7XG5cdHRocm93IG5ldyBFcnJvcihcIltITVJdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgaXMgZGlzYWJsZWQuXCIpO1xufVxuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cGRhdGVkTW9kdWxlcywgcmVuZXdlZE1vZHVsZXMpIHtcblx0dmFyIHVuYWNjZXB0ZWRNb2R1bGVzID0gdXBkYXRlZE1vZHVsZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdHJldHVybiByZW5ld2VkTW9kdWxlcyAmJiByZW5ld2VkTW9kdWxlcy5pbmRleE9mKG1vZHVsZUlkKSA8IDA7XG5cdH0pO1xuXHR2YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xuXG5cdGlmICh1bmFjY2VwdGVkTW9kdWxlcy5sZW5ndGggPiAwKSB7XG5cdFx0bG9nKFxuXHRcdFx0XCJ3YXJuaW5nXCIsXG5cdFx0XHRcIltITVJdIFRoZSBmb2xsb3dpbmcgbW9kdWxlcyBjb3VsZG4ndCBiZSBob3QgdXBkYXRlZDogKFRoZXkgd291bGQgbmVlZCBhIGZ1bGwgcmVsb2FkISlcIlxuXHRcdCk7XG5cdFx0dW5hY2NlcHRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICghcmVuZXdlZE1vZHVsZXMgfHwgcmVuZXdlZE1vZHVsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdIE5vdGhpbmcgaG90IHVwZGF0ZWQuXCIpO1xuXHR9IGVsc2Uge1xuXHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSBVcGRhdGVkIG1vZHVsZXM6XCIpO1xuXHRcdHJlbmV3ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1vZHVsZUlkID09PSBcInN0cmluZ1wiICYmIG1vZHVsZUlkLmluZGV4T2YoXCIhXCIpICE9PSAtMSkge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBtb2R1bGVJZC5zcGxpdChcIiFcIik7XG5cdFx0XHRcdGxvZy5ncm91cENvbGxhcHNlZChcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIHBhcnRzLnBvcCgpKTtcblx0XHRcdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xuXHRcdFx0XHRsb2cuZ3JvdXBFbmQoXCJpbmZvXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHZhciBudW1iZXJJZHMgPSByZW5ld2VkTW9kdWxlcy5ldmVyeShmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdHJldHVybiB0eXBlb2YgbW9kdWxlSWQgPT09IFwibnVtYmVyXCI7XG5cdFx0fSk7XG5cdFx0aWYgKG51bWJlcklkcylcblx0XHRcdGxvZyhcblx0XHRcdFx0XCJpbmZvXCIsXG5cdFx0XHRcdCdbSE1SXSBDb25zaWRlciB1c2luZyB0aGUgb3B0aW1pemF0aW9uLm1vZHVsZUlkczogXCJuYW1lZFwiIGZvciBtb2R1bGUgbmFtZXMuJ1xuXHRcdFx0KTtcblx0fVxufTtcbiIsInZhciBsb2dMZXZlbCA9IFwiaW5mb1wiO1xuXG5mdW5jdGlvbiBkdW1teSgpIHt9XG5cbmZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbCkge1xuXHR2YXIgc2hvdWxkTG9nID1cblx0XHQobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcblx0cmV0dXJuIHNob3VsZExvZztcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChsZXZlbCwgbXNnKSB7XG5cdFx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRcdGxvZ0ZuKG1zZyk7XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnKSB7XG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0aWYgKGxldmVsID09PSBcImluZm9cIikge1xuXHRcdFx0Y29uc29sZS5sb2cobXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ0dyb3VwKGdyb3VwQ29sbGFwc2VkKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XG5cbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG5cdGxvZ0xldmVsID0gbGV2ZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0dmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcblx0dmFyIHN0YWNrID0gZXJyLnN0YWNrO1xuXHRpZiAoIXN0YWNrKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdH0gZWxzZSBpZiAoc3RhY2suaW5kZXhPZihtZXNzYWdlKSA8IDApIHtcblx0XHRyZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gc3RhY2s7XG5cdH1cbn07XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNjM0NjAyNjg5NTQ3XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9ob21lL2x1Y2Fzc2lsdmEvYmFja3VwL3Byb2pldG9zL2VuZHVyYW5jZS9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCJcIixcImxvY2Fsc1wiOmZhbHNlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIG1vZHVsZS5ob3QuYWNjZXB0KHVuZGVmaW5lZCwgY3NzUmVsb2FkKTtcbiAgICB9XG4gICIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoY2FjaGVkTW9kdWxlLmVycm9yICE9PSB1bmRlZmluZWQpIHRocm93IGNhY2hlZE1vZHVsZS5lcnJvcjtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0dHJ5IHtcblx0XHR2YXIgZXhlY09wdGlvbnMgPSB7IGlkOiBtb2R1bGVJZCwgbW9kdWxlOiBtb2R1bGUsIGZhY3Rvcnk6IF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLCByZXF1aXJlOiBfX3dlYnBhY2tfcmVxdWlyZV9fIH07XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikgeyBoYW5kbGVyKGV4ZWNPcHRpb25zKTsgfSk7XG5cdFx0bW9kdWxlID0gZXhlY09wdGlvbnMubW9kdWxlO1xuXHRcdGV4ZWNPcHRpb25zLmZhY3RvcnkuY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgZXhlY09wdGlvbnMucmVxdWlyZSk7XG5cdH0gY2F0Y2goZSkge1xuXHRcdG1vZHVsZS5lcnJvciA9IGU7XG5cdFx0dGhyb3cgZTtcblx0fVxuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbl9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgZXhlY3V0aW9uIGludGVyY2VwdG9yXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBbXTtcblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmh1ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5oKCkgKyBcIi5ob3QtdXBkYXRlLmpzXCI7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFsbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18ubWluaUNzc0YgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiXCIgKyBjaHVua0lkICsgXCIuY3NzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1yRiA9ICgpID0+IChcIm1haW4uXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNvblwiKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSAoKSA9PiAoXCJhYTJhY2Q1NDFhNjNkNjA0ZDAzNFwiKSIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsInZhciBpblByb2dyZXNzID0ge307XG52YXIgZGF0YVdlYnBhY2tQcmVmaXggPSBcImZsb2VtYTpcIjtcbi8vIGxvYWRTY3JpcHQgZnVuY3Rpb24gdG8gbG9hZCBhIHNjcmlwdCB2aWEgc2NyaXB0IHRhZ1xuX193ZWJwYWNrX3JlcXVpcmVfXy5sID0gKHVybCwgZG9uZSwga2V5LCBjaHVua0lkKSA9PiB7XG5cdGlmKGluUHJvZ3Jlc3NbdXJsXSkgeyBpblByb2dyZXNzW3VybF0ucHVzaChkb25lKTsgcmV0dXJuOyB9XG5cdHZhciBzY3JpcHQsIG5lZWRBdHRhY2g7XG5cdGlmKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHMgPSBzY3JpcHRzW2ldO1xuXHRcdFx0aWYocy5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgPT0gdXJsIHx8IHMuZ2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIpID09IGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KSB7IHNjcmlwdCA9IHM7IGJyZWFrOyB9XG5cdFx0fVxuXHR9XG5cdGlmKCFzY3JpcHQpIHtcblx0XHRuZWVkQXR0YWNoID0gdHJ1ZTtcblx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ3V0Zi04Jztcblx0XHRzY3JpcHQudGltZW91dCA9IDEyMDtcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIF9fd2VicGFja19yZXF1aXJlX18ubmMpO1xuXHRcdH1cblx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIsIGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KTtcblx0XHRzY3JpcHQuc3JjID0gdXJsO1xuXHR9XG5cdGluUHJvZ3Jlc3NbdXJsXSA9IFtkb25lXTtcblx0dmFyIG9uU2NyaXB0Q29tcGxldGUgPSAocHJldiwgZXZlbnQpID0+IHtcblx0XHQvLyBhdm9pZCBtZW0gbGVha3MgaW4gSUUuXG5cdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0dmFyIGRvbmVGbnMgPSBpblByb2dyZXNzW3VybF07XG5cdFx0ZGVsZXRlIGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRzY3JpcHQucGFyZW50Tm9kZSAmJiBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdGRvbmVGbnMgJiYgZG9uZUZucy5mb3JFYWNoKChmbikgPT4gKGZuKGV2ZW50KSkpO1xuXHRcdGlmKHByZXYpIHJldHVybiBwcmV2KGV2ZW50KTtcblx0fVxuXHQ7XG5cdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgdW5kZWZpbmVkLCB7IHR5cGU6ICd0aW1lb3V0JywgdGFyZ2V0OiBzY3JpcHQgfSksIDEyMDAwMCk7XG5cdHNjcmlwdC5vbmVycm9yID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmVycm9yKTtcblx0c2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25sb2FkKTtcblx0bmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG59OyIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJ2YXIgY3VycmVudE1vZHVsZURhdGEgPSB7fTtcbnZhciBpbnN0YWxsZWRNb2R1bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jO1xuXG4vLyBtb2R1bGUgYW5kIHJlcXVpcmUgY3JlYXRpb25cbnZhciBjdXJyZW50Q2hpbGRNb2R1bGU7XG52YXIgY3VycmVudFBhcmVudHMgPSBbXTtcblxuLy8gc3RhdHVzXG52YXIgcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzID0gW107XG52YXIgY3VycmVudFN0YXR1cyA9IFwiaWRsZVwiO1xuXG4vLyB3aGlsZSBkb3dubG9hZGluZ1xudmFyIGJsb2NraW5nUHJvbWlzZXM7XG5cbi8vIFRoZSB1cGRhdGUgaW5mb1xudmFyIGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzO1xudmFyIHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckQgPSBjdXJyZW50TW9kdWxlRGF0YTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5pLnB1c2goZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0dmFyIG1vZHVsZSA9IG9wdGlvbnMubW9kdWxlO1xuXHR2YXIgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUob3B0aW9ucy5yZXF1aXJlLCBvcHRpb25zLmlkKTtcblx0bW9kdWxlLmhvdCA9IGNyZWF0ZU1vZHVsZUhvdE9iamVjdChvcHRpb25zLmlkLCBtb2R1bGUpO1xuXHRtb2R1bGUucGFyZW50cyA9IGN1cnJlbnRQYXJlbnRzO1xuXHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0Y3VycmVudFBhcmVudHMgPSBbXTtcblx0b3B0aW9ucy5yZXF1aXJlID0gcmVxdWlyZTtcbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18uaG1ySSA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVSZXF1aXJlKHJlcXVpcmUsIG1vZHVsZUlkKSB7XG5cdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuXHRpZiAoIW1lKSByZXR1cm4gcmVxdWlyZTtcblx0dmFyIGZuID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0XHRpZiAobWUuaG90LmFjdGl2ZSkge1xuXHRcdFx0aWYgKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0pIHtcblx0XHRcdFx0dmFyIHBhcmVudHMgPSBpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHM7XG5cdFx0XHRcdGlmIChwYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpID09PSAtMSkge1xuXHRcdFx0XHRcdHBhcmVudHMucHVzaChtb2R1bGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcblx0XHRcdFx0Y3VycmVudENoaWxkTW9kdWxlID0gcmVxdWVzdDtcblx0XHRcdH1cblx0XHRcdGlmIChtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpID09PSAtMSkge1xuXHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICtcblx0XHRcdFx0XHRyZXF1ZXN0ICtcblx0XHRcdFx0XHRcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgK1xuXHRcdFx0XHRcdG1vZHVsZUlkXG5cdFx0XHQpO1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcXVpcmUocmVxdWVzdCk7XG5cdH07XG5cdHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiByZXF1aXJlW25hbWVdO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHJlcXVpcmVbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXHRmb3IgKHZhciBuYW1lIGluIHJlcXVpcmUpIHtcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlcXVpcmUsIG5hbWUpICYmIG5hbWUgIT09IFwiZVwiKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIG5hbWUsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcihuYW1lKSk7XG5cdFx0fVxuXHR9XG5cdGZuLmUgPSBmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdHJldHVybiB0cmFja0Jsb2NraW5nUHJvbWlzZShyZXF1aXJlLmUoY2h1bmtJZCkpO1xuXHR9O1xuXHRyZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUhvdE9iamVjdChtb2R1bGVJZCwgbWUpIHtcblx0dmFyIF9tYWluID0gY3VycmVudENoaWxkTW9kdWxlICE9PSBtb2R1bGVJZDtcblx0dmFyIGhvdCA9IHtcblx0XHQvLyBwcml2YXRlIHN0dWZmXG5cdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcblx0XHRfYWNjZXB0ZWRFcnJvckhhbmRsZXJzOiB7fSxcblx0XHRfZGVjbGluZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxuXHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxuXHRcdF9zZWxmSW52YWxpZGF0ZWQ6IGZhbHNlLFxuXHRcdF9kaXNwb3NlSGFuZGxlcnM6IFtdLFxuXHRcdF9tYWluOiBfbWFpbixcblx0XHRfcmVxdWlyZVNlbGY6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGN1cnJlbnRQYXJlbnRzID0gbWUucGFyZW50cy5zbGljZSgpO1xuXHRcdFx0Y3VycmVudENoaWxkTW9kdWxlID0gX21haW4gPyB1bmRlZmluZWQgOiBtb2R1bGVJZDtcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xuXHRcdH0sXG5cblx0XHQvLyBNb2R1bGUgQVBJXG5cdFx0YWN0aXZlOiB0cnVlLFxuXHRcdGFjY2VwdDogZnVuY3Rpb24gKGRlcCwgY2FsbGJhY2ssIGVycm9ySGFuZGxlcikge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpIGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIiAmJiBkZXAgIT09IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBbaV1dID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcF0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0aG90Ll9hY2NlcHRlZEVycm9ySGFuZGxlcnNbZGVwXSA9IGVycm9ySGFuZGxlcjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlY2xpbmU6IGZ1bmN0aW9uIChkZXApIHtcblx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIiAmJiBkZXAgIT09IG51bGwpXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XG5cdFx0XHRlbHNlIGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwXSA9IHRydWU7XG5cdFx0fSxcblx0XHRkaXNwb3NlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuXHRcdH0sXG5cdFx0YWRkRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaWR4ID0gaG90Ll9kaXNwb3NlSGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XG5cdFx0XHRpZiAoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdH0sXG5cdFx0aW52YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fc2VsZkludmFsaWRhdGVkID0gdHJ1ZTtcblx0XHRcdHN3aXRjaCAoY3VycmVudFN0YXR1cykge1xuXHRcdFx0XHRjYXNlIFwiaWRsZVwiOlxuXHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0c2V0U3RhdHVzKFwicmVhZHlcIik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJyZWFkeVwiOlxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtcklba2V5XShcblx0XHRcdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwicHJlcGFyZVwiOlxuXHRcdFx0XHRjYXNlIFwiY2hlY2tcIjpcblx0XHRcdFx0Y2FzZSBcImRpc3Bvc2VcIjpcblx0XHRcdFx0Y2FzZSBcImFwcGx5XCI6XG5cdFx0XHRcdFx0KHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyB8fCBbXSkucHVzaChcblx0XHRcdFx0XHRcdG1vZHVsZUlkXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBpZ25vcmUgcmVxdWVzdHMgaW4gZXJyb3Igc3RhdGVzXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIE1hbmFnZW1lbnQgQVBJXG5cdFx0Y2hlY2s6IGhvdENoZWNrLFxuXHRcdGFwcGx5OiBob3RBcHBseSxcblx0XHRzdGF0dXM6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRpZiAoIWwpIHJldHVybiBjdXJyZW50U3RhdHVzO1xuXHRcdFx0cmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG5cdFx0fSxcblx0XHRhZGRTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbiAobCkge1xuXHRcdFx0cmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG5cdFx0fSxcblx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbiAobCkge1xuXHRcdFx0dmFyIGlkeCA9IHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xuXHRcdFx0aWYgKGlkeCA+PSAwKSByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblxuXHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxuXHRcdGRhdGE6IGN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxuXHR9O1xuXHRjdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XG5cdHJldHVybiBob3Q7XG59XG5cbmZ1bmN0aW9uIHNldFN0YXR1cyhuZXdTdGF0dXMpIHtcblx0Y3VycmVudFN0YXR1cyA9IG5ld1N0YXR1cztcblx0dmFyIHJlc3VsdHMgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5sZW5ndGg7IGkrKylcblx0XHRyZXN1bHRzW2ldID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzW2ldLmNhbGwobnVsbCwgbmV3U3RhdHVzKTtcblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cyk7XG59XG5cbmZ1bmN0aW9uIHRyYWNrQmxvY2tpbmdQcm9taXNlKHByb21pc2UpIHtcblx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRzZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuXHRcdFx0YmxvY2tpbmdQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuXHRcdFx0d2FpdEZvckJsb2NraW5nUHJvbWlzZXMoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicmVhZHlcIik7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdGNhc2UgXCJwcmVwYXJlXCI6XG5cdFx0XHRibG9ja2luZ1Byb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cbn1cblxuZnVuY3Rpb24gd2FpdEZvckJsb2NraW5nUHJvbWlzZXMoZm4pIHtcblx0aWYgKGJsb2NraW5nUHJvbWlzZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZm4oKTtcblx0dmFyIGJsb2NrZXIgPSBibG9ja2luZ1Byb21pc2VzO1xuXHRibG9ja2luZ1Byb21pc2VzID0gW107XG5cdHJldHVybiBQcm9taXNlLmFsbChibG9ja2VyKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gd2FpdEZvckJsb2NraW5nUHJvbWlzZXMoZm4pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gaG90Q2hlY2soYXBwbHlPblVwZGF0ZSkge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJpZGxlXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcblx0fVxuXHRyZXR1cm4gc2V0U3RhdHVzKFwiY2hlY2tcIilcblx0XHQudGhlbihfX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHVwZGF0ZSkge1xuXHRcdFx0aWYgKCF1cGRhdGUpIHtcblx0XHRcdFx0cmV0dXJuIHNldFN0YXR1cyhhcHBseUludmFsaWRhdGVkTW9kdWxlcygpID8gXCJyZWFkeVwiIDogXCJpZGxlXCIpLnRoZW4oXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicHJlcGFyZVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHVwZGF0ZWRNb2R1bGVzID0gW107XG5cdFx0XHRcdGJsb2NraW5nUHJvbWlzZXMgPSBbXTtcblx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSBbXTtcblxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJDKS5yZWR1Y2UoZnVuY3Rpb24gKFxuXHRcdFx0XHRcdFx0cHJvbWlzZXMsXG5cdFx0XHRcdFx0XHRrZXlcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1yQ1trZXldKFxuXHRcdFx0XHRcdFx0XHR1cGRhdGUuYyxcblx0XHRcdFx0XHRcdFx0dXBkYXRlLnIsXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZS5tLFxuXHRcdFx0XHRcdFx0XHRwcm9taXNlcyxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMsXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZWRNb2R1bGVzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb21pc2VzO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0W10pXG5cdFx0XHRcdCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdhaXRGb3JCbG9ja2luZ1Byb21pc2VzKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGlmIChhcHBseU9uVXBkYXRlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbnRlcm5hbEFwcGx5KGFwcGx5T25VcGRhdGUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNldFN0YXR1cyhcInJlYWR5XCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB1cGRhdGVkTW9kdWxlcztcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG59XG5cbmZ1bmN0aW9uIGhvdEFwcGx5KG9wdGlvbnMpIHtcblx0aWYgKGN1cnJlbnRTdGF0dXMgIT09IFwicmVhZHlcIikge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1c1wiKTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxBcHBseShvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCk7XG5cblx0dmFyIHJlc3VsdHMgPSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHRyZXR1cm4gaGFuZGxlcihvcHRpb25zKTtcblx0fSk7XG5cdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gdW5kZWZpbmVkO1xuXG5cdHZhciBlcnJvcnMgPSByZXN1bHRzXG5cdFx0Lm1hcChmdW5jdGlvbiAocikge1xuXHRcdFx0cmV0dXJuIHIuZXJyb3I7XG5cdFx0fSlcblx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuXHRcdHJldHVybiBzZXRTdGF0dXMoXCJhYm9ydFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IGVycm9yc1swXTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxuXHR2YXIgZGlzcG9zZVByb21pc2UgPSBzZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xuXG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5kaXNwb3NlKSByZXN1bHQuZGlzcG9zZSgpO1xuXHR9KTtcblxuXHQvLyBOb3cgaW4gXCJhcHBseVwiIHBoYXNlXG5cdHZhciBhcHBseVByb21pc2UgPSBzZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuXHR2YXIgZXJyb3I7XG5cdHZhciByZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcblx0fTtcblxuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5hcHBseSkge1xuXHRcdFx0dmFyIG1vZHVsZXMgPSByZXN1bHQuYXBwbHkocmVwb3J0RXJyb3IpO1xuXHRcdFx0aWYgKG1vZHVsZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gobW9kdWxlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChbZGlzcG9zZVByb21pc2UsIGFwcGx5UHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwiZmFpbFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChsaXN0KSB7XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRcdGlmIChsaXN0LmluZGV4T2YobW9kdWxlSWQpIDwgMCkgbGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldFN0YXR1cyhcImlkbGVcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSB7XG5cdGlmIChxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcblx0XHRpZiAoIWN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzKSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHVuZGVmaW5lZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHNjcmlwdFVybCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5zcmNcblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwidmFyIGNyZWF0ZVN0eWxlc2hlZXQgPSAoY2h1bmtJZCwgZnVsbGhyZWYsIHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHR2YXIgbGlua1RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGxpbmtUYWcucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdGxpbmtUYWcudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0dmFyIG9uTGlua0NvbXBsZXRlID0gKGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzLlxuXHRcdGxpbmtUYWcub25lcnJvciA9IGxpbmtUYWcub25sb2FkID0gbnVsbDtcblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnKSB7XG5cdFx0XHRyZXNvbHZlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHR2YXIgcmVhbEhyZWYgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LmhyZWYgfHwgZnVsbGhyZWY7XG5cdFx0XHR2YXIgZXJyID0gbmV3IEVycm9yKFwiTG9hZGluZyBDU1MgY2h1bmsgXCIgKyBjaHVua0lkICsgXCIgZmFpbGVkLlxcbihcIiArIHJlYWxIcmVmICsgXCIpXCIpO1xuXHRcdFx0ZXJyLmNvZGUgPSBcIkNTU19DSFVOS19MT0FEX0ZBSUxFRFwiO1xuXHRcdFx0ZXJyLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRlcnIucmVxdWVzdCA9IHJlYWxIcmVmO1xuXHRcdFx0bGlua1RhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmtUYWcpXG5cdFx0XHRyZWplY3QoZXJyKTtcblx0XHR9XG5cdH1cblx0bGlua1RhZy5vbmVycm9yID0gbGlua1RhZy5vbmxvYWQgPSBvbkxpbmtDb21wbGV0ZTtcblx0bGlua1RhZy5ocmVmID0gZnVsbGhyZWY7XG5cblx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rVGFnKTtcblx0cmV0dXJuIGxpbmtUYWc7XG59O1xudmFyIGZpbmRTdHlsZXNoZWV0ID0gKGhyZWYsIGZ1bGxocmVmKSA9PiB7XG5cdHZhciBleGlzdGluZ0xpbmtUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgZXhpc3RpbmdMaW5rVGFncy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB0YWcgPSBleGlzdGluZ0xpbmtUYWdzW2ldO1xuXHRcdHZhciBkYXRhSHJlZiA9IHRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIikgfHwgdGFnLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdFx0aWYodGFnLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgJiYgKGRhdGFIcmVmID09PSBocmVmIHx8IGRhdGFIcmVmID09PSBmdWxsaHJlZikpIHJldHVybiB0YWc7XG5cdH1cblx0dmFyIGV4aXN0aW5nU3R5bGVUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHlsZVwiKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGV4aXN0aW5nU3R5bGVUYWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHRhZyA9IGV4aXN0aW5nU3R5bGVUYWdzW2ldO1xuXHRcdHZhciBkYXRhSHJlZiA9IHRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIik7XG5cdFx0aWYoZGF0YUhyZWYgPT09IGhyZWYgfHwgZGF0YUhyZWYgPT09IGZ1bGxocmVmKSByZXR1cm4gdGFnO1xuXHR9XG59O1xudmFyIGxvYWRTdHlsZXNoZWV0ID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHR2YXIgaHJlZiA9IF9fd2VicGFja19yZXF1aXJlX18ubWluaUNzc0YoY2h1bmtJZCk7XG5cdFx0dmFyIGZ1bGxocmVmID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgaHJlZjtcblx0XHRpZihmaW5kU3R5bGVzaGVldChocmVmLCBmdWxsaHJlZikpIHJldHVybiByZXNvbHZlKCk7XG5cdFx0Y3JlYXRlU3R5bGVzaGVldChjaHVua0lkLCBmdWxsaHJlZiwgcmVzb2x2ZSwgcmVqZWN0KTtcblx0fSk7XG59XG4vLyBubyBjaHVuayBsb2FkaW5nXG5cbnZhciBvbGRUYWdzID0gW107XG52YXIgbmV3VGFncyA9IFtdO1xudmFyIGFwcGx5SGFuZGxlciA9IChvcHRpb25zKSA9PiB7XG5cdHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IHtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgb2xkVGFncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG9sZFRhZyA9IG9sZFRhZ3NbaV07XG5cdFx0XHRpZihvbGRUYWcucGFyZW50Tm9kZSkgb2xkVGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2xkVGFnKTtcblx0XHR9XG5cdFx0b2xkVGFncy5sZW5ndGggPSAwO1xuXHR9LCBhcHBseTogKCkgPT4ge1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBuZXdUYWdzLmxlbmd0aDsgaSsrKSBuZXdUYWdzW2ldLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXHRcdG5ld1RhZ3MubGVuZ3RoID0gMDtcblx0fSB9O1xufVxuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJDLm1pbmlDc3MgPSAoY2h1bmtJZHMsIHJlbW92ZWRDaHVua3MsIHJlbW92ZWRNb2R1bGVzLCBwcm9taXNlcywgYXBwbHlIYW5kbGVycywgdXBkYXRlZE1vZHVsZXNMaXN0KSA9PiB7XG5cdGFwcGx5SGFuZGxlcnMucHVzaChhcHBseUhhbmRsZXIpO1xuXHRjaHVua0lkcy5mb3JFYWNoKChjaHVua0lkKSA9PiB7XG5cdFx0dmFyIGhyZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm1pbmlDc3NGKGNodW5rSWQpO1xuXHRcdHZhciBmdWxsaHJlZiA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIGhyZWY7XG5cdFx0dmFyIG9sZFRhZyA9IGZpbmRTdHlsZXNoZWV0KGhyZWYsIGZ1bGxocmVmKTtcblx0XHRpZighb2xkVGFnKSByZXR1cm47XG5cdFx0cHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHR2YXIgdGFnID0gY3JlYXRlU3R5bGVzaGVldChjaHVua0lkLCBmdWxsaHJlZiwgKCkgPT4ge1xuXHRcdFx0XHR0YWcuYXMgPSBcInN0eWxlXCI7XG5cdFx0XHRcdHRhZy5yZWwgPSBcInByZWxvYWRcIjtcblx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0fSwgcmVqZWN0KTtcblx0XHRcdG9sZFRhZ3MucHVzaChvbGRUYWcpO1xuXHRcdFx0bmV3VGFncy5wdXNoKHRhZyk7XG5cdFx0fSkpO1xuXHR9KTtcbn0iLCIvLyBubyBiYXNlVVJJXG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IF9fd2VicGFja19yZXF1aXJlX18uaG1yU19qc29ucCA9IF9fd2VicGFja19yZXF1aXJlX18uaG1yU19qc29ucCB8fCB7XG5cdFwibWFpblwiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxudmFyIGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3Q7XG52YXIgd2FpdGluZ1VwZGF0ZVJlc29sdmVzID0ge307XG5mdW5jdGlvbiBsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSA9IHJlc29sdmU7XG5cdFx0Ly8gc3RhcnQgdXBkYXRlIGNodW5rIGxvYWRpbmdcblx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy5odShjaHVua0lkKTtcblx0XHQvLyBjcmVhdGUgZXJyb3IgYmVmb3JlIHN0YWNrIHVud291bmQgdG8gZ2V0IHVzZWZ1bCBzdGFja3RyYWNlIGxhdGVyXG5cdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG5cdFx0dmFyIGxvYWRpbmdFbmRlZCA9IChldmVudCkgPT4ge1xuXHRcdFx0aWYod2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdKSB7XG5cdFx0XHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSA9IHVuZGVmaW5lZFxuXHRcdFx0XHR2YXIgZXJyb3JUeXBlID0gZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyA/ICdtaXNzaW5nJyA6IGV2ZW50LnR5cGUpO1xuXHRcdFx0XHR2YXIgcmVhbFNyYyA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuc3JjO1xuXHRcdFx0XHRlcnJvci5tZXNzYWdlID0gJ0xvYWRpbmcgaG90IHVwZGF0ZSBjaHVuayAnICsgY2h1bmtJZCArICcgZmFpbGVkLlxcbignICsgZXJyb3JUeXBlICsgJzogJyArIHJlYWxTcmMgKyAnKSc7XG5cdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuXHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuXHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVhbFNyYztcblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18ubCh1cmwsIGxvYWRpbmdFbmRlZCk7XG5cdH0pO1xufVxuXG5zZWxmW1wid2VicGFja0hvdFVwZGF0ZWZsb2VtYVwiXSA9IChjaHVua0lkLCBtb3JlTW9kdWxlcywgcnVudGltZSkgPT4ge1xuXHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdGN1cnJlbnRVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdFx0aWYoY3VycmVudFVwZGF0ZWRNb2R1bGVzTGlzdCkgY3VycmVudFVwZGF0ZWRNb2R1bGVzTGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHR9XG5cdH1cblx0aWYocnVudGltZSkgY3VycmVudFVwZGF0ZVJ1bnRpbWUucHVzaChydW50aW1lKTtcblx0aWYod2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdKSB7XG5cdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdKCk7XG5cdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuXHR9XG59O1xuXG52YXIgY3VycmVudFVwZGF0ZUNodW5rcztcbnZhciBjdXJyZW50VXBkYXRlO1xudmFyIGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzO1xudmFyIGN1cnJlbnRVcGRhdGVSdW50aW1lO1xuZnVuY3Rpb24gYXBwbHlIYW5kbGVyKG9wdGlvbnMpIHtcblx0aWYgKF9fd2VicGFja19yZXF1aXJlX18uZikgZGVsZXRlIF9fd2VicGFja19yZXF1aXJlX18uZi5qc29ucEhtcjtcblx0Y3VycmVudFVwZGF0ZUNodW5rcyA9IHVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRNb2R1bGVFZmZlY3RzKHVwZGF0ZU1vZHVsZUlkKSB7XG5cdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFt1cGRhdGVNb2R1bGVJZF07XG5cdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG5cblx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2hhaW46IFtpZF0sXG5cdFx0XHRcdGlkOiBpZFxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xuXHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xuXHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF07XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFtb2R1bGUgfHxcblx0XHRcdFx0KG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCAmJiAhbW9kdWxlLmhvdC5fc2VsZkludmFsaWRhdGVkKVxuXHRcdFx0KVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGlmIChtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBcInNlbGYtZGVjbGluZWRcIixcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9kdWxlLmhvdC5fbWFpbikge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxuXHRcdFx0XHRcdGNoYWluOiBjaGFpbixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbcGFyZW50SWRdO1xuXHRcdFx0XHRpZiAoIXBhcmVudCkgY29udGludWU7XG5cdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxuXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcblx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSAhPT0gLTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG5cdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG5cdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcblx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcblx0XHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcblx0XHRcdFx0XHRpZDogcGFyZW50SWRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcblx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcblx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxuXHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gYltpXTtcblx0XHRcdGlmIChhLmluZGV4T2YoaXRlbSkgPT09IC0xKSBhLnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcblx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxuXHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcblx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuXHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xuXG5cdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUobW9kdWxlKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyBtb2R1bGUuaWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCJcblx0XHQpO1xuXHR9O1xuXG5cdGZvciAodmFyIG1vZHVsZUlkIGluIGN1cnJlbnRVcGRhdGUpIHtcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGUsIG1vZHVsZUlkKSkge1xuXHRcdFx0dmFyIG5ld01vZHVsZUZhY3RvcnkgPSBjdXJyZW50VXBkYXRlW21vZHVsZUlkXTtcblx0XHRcdC8qKiBAdHlwZSB7VE9ET30gKi9cblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHRpZiAobmV3TW9kdWxlRmFjdG9yeSkge1xuXHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZE1vZHVsZUVmZmVjdHMobW9kdWxlSWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdHR5cGU6IFwiZGlzcG9zZWRcIixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8qKiBAdHlwZSB7RXJyb3J8ZmFsc2V9ICovXG5cdFx0XHR2YXIgYWJvcnRFcnJvciA9IGZhbHNlO1xuXHRcdFx0dmFyIGRvQXBwbHkgPSBmYWxzZTtcblx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcblx0XHRcdHZhciBjaGFpbkluZm8gPSBcIlwiO1xuXHRcdFx0aWYgKHJlc3VsdC5jaGFpbikge1xuXHRcdFx0XHRjaGFpbkluZm8gPSBcIlxcblVwZGF0ZSBwcm9wYWdhdGlvbjogXCIgKyByZXN1bHQuY2hhaW4uam9pbihcIiAtPiBcIik7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG5cdFx0XHRcdGNhc2UgXCJzZWxmLWRlY2xpbmVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2Ygc2VsZiBkZWNsaW5lOiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcblx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJkZWNsaW5lZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuXHRcdFx0XHRcdFx0XHRcdFwiIGluIFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQucGFyZW50SWQgK1xuXHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInVuYWNjZXB0ZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vblVuYWNjZXB0ZWQpIG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZVVuYWNjZXB0ZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIgKyBjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhY2NlcHRlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uQWNjZXB0ZWQpIG9wdGlvbnMub25BY2NlcHRlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGRvQXBwbHkgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRpc3Bvc2VkKSBvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcblx0XHRcdFx0XHRkb0Rpc3Bvc2UgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhjZXB0aW9uIHR5cGUgXCIgKyByZXN1bHQudHlwZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWJvcnRFcnJvcikge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGVycm9yOiBhYm9ydEVycm9yXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9BcHBseSkge1xuXHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IG5ld01vZHVsZUZhY3Rvcnk7XG5cdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XG5cdFx0XHRcdGZvciAobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSA9IFtdO1xuXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQoXG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSxcblx0XHRcdFx0XHRcdFx0cmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkb0Rpc3Bvc2UpIHtcblx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XG5cdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjdXJyZW50VXBkYXRlID0gdW5kZWZpbmVkO1xuXG5cdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cblx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xuXHRmb3IgKHZhciBqID0gMDsgaiA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBvdXRkYXRlZE1vZHVsZUlkID0gb3V0ZGF0ZWRNb2R1bGVzW2pdO1xuXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0aWYgKFxuXHRcdFx0bW9kdWxlICYmXG5cdFx0XHQobW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkIHx8IG1vZHVsZS5ob3QuX21haW4pICYmXG5cdFx0XHQvLyByZW1vdmVkIHNlbGYtYWNjZXB0ZWQgbW9kdWxlcyBzaG91bGQgbm90IGJlIHJlcXVpcmVkXG5cdFx0XHRhcHBsaWVkVXBkYXRlW291dGRhdGVkTW9kdWxlSWRdICE9PSB3YXJuVW5leHBlY3RlZFJlcXVpcmUgJiZcblx0XHRcdC8vIHdoZW4gY2FsbGVkIGludmFsaWRhdGUgc2VsZi1hY2NlcHRpbmcgaXMgbm90IHBvc3NpYmxlXG5cdFx0XHQhbW9kdWxlLmhvdC5fc2VsZkludmFsaWRhdGVkXG5cdFx0KSB7XG5cdFx0XHRvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMucHVzaCh7XG5cdFx0XHRcdG1vZHVsZTogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0cmVxdWlyZTogbW9kdWxlLmhvdC5fcmVxdWlyZVNlbGYsXG5cdFx0XHRcdGVycm9ySGFuZGxlcjogbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXM7XG5cblx0cmV0dXJuIHtcblx0XHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVua0lkKSB7XG5cdFx0XHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG5cdFx0XHR9KTtcblx0XHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR2YXIgaWR4O1xuXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XG5cdFx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZS5wb3AoKTtcblx0XHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF07XG5cdFx0XHRcdGlmICghbW9kdWxlKSBjb250aW51ZTtcblxuXHRcdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xuXHRcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0ZGlzcG9zZUhhbmRsZXJzW2pdLmNhbGwobnVsbCwgZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJEW21vZHVsZUlkXSA9IGRhdGE7XG5cblx0XHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcblx0XHRcdFx0bW9kdWxlLmhvdC5hY3RpdmUgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyByZW1vdmUgbW9kdWxlIGZyb20gY2FjaGVcblx0XHRcdFx0ZGVsZXRlIF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF07XG5cblx0XHRcdFx0Ly8gd2hlbiBkaXNwb3NpbmcgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGRpc3Bvc2UgaGFuZGxlclxuXHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlLmNoaWxkcmVuW2pdXTtcblx0XHRcdFx0XHRpZiAoIWNoaWxkKSBjb250aW51ZTtcblx0XHRcdFx0XHRpZHggPSBjaGlsZC5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpO1xuXHRcdFx0XHRcdGlmIChpZHggPj0gMCkge1xuXHRcdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cblx0XHRcdHZhciBkZXBlbmRlbmN5O1xuXHRcdFx0Zm9yICh2YXIgb3V0ZGF0ZWRNb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuXHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBvdXRkYXRlZE1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRpZiAobW9kdWxlKSB7XG5cdFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9XG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcblx0XHRcdFx0XHRcdFx0aWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XG5cdFx0XHRcdFx0XHRcdGlmIChpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXBwbHk6IGZ1bmN0aW9uIChyZXBvcnRFcnJvcikge1xuXHRcdFx0Ly8gaW5zZXJ0IG5ldyBjb2RlXG5cdFx0XHRmb3IgKHZhciB1cGRhdGVNb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8oYXBwbGllZFVwZGF0ZSwgdXBkYXRlTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW3VwZGF0ZU1vZHVsZUlkXSA9IGFwcGxpZWRVcGRhdGVbdXBkYXRlTW9kdWxlSWRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJ1biBuZXcgcnVudGltZSBtb2R1bGVzXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnRVcGRhdGVSdW50aW1lLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVSdW50aW1lW2ldKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xuXHRcdFx0Zm9yICh2YXIgb3V0ZGF0ZWRNb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuXHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBvdXRkYXRlZE1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuXHRcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPVxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBlcnJvckhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbal07XG5cdFx0XHRcdFx0XHRcdHZhciBhY2NlcHRDYWxsYmFjayA9XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwZW5kZW5jeV07XG5cdFx0XHRcdFx0XHRcdHZhciBlcnJvckhhbmRsZXIgPVxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5ob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBlbmRlbmN5XTtcblx0XHRcdFx0XHRcdFx0aWYgKGFjY2VwdENhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrcy5pbmRleE9mKGFjY2VwdENhbGxiYWNrKSAhPT0gLTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGFjY2VwdENhbGxiYWNrKTtcblx0XHRcdFx0XHRcdFx0XHRlcnJvckhhbmRsZXJzLnB1c2goZXJyb3JIYW5kbGVyKTtcblx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3MucHVzaChkZXBlbmRlbmN5KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBjYWxsYmFja3MubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFja3Nba10uY2FsbChudWxsLCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZXJyb3JIYW5kbGVyc1trXSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvckhhbmRsZXJzW2tdKGVyciwge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba10sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsRXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyMik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcblx0XHRcdGZvciAodmFyIG8gPSAwOyBvIDwgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLmxlbmd0aDsgbysrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW29dO1xuXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpdGVtLnJlcXVpcmUobW9kdWxlSWQpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0uZXJyb3JIYW5kbGVyKGVyciwge1xuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGU6IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIyKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsRXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyMik7XG5cdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dGRhdGVkTW9kdWxlcztcblx0XHR9XG5cdH07XG59XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckkuanNvbnAgPSBmdW5jdGlvbiAobW9kdWxlSWQsIGFwcGx5SGFuZGxlcnMpIHtcblx0aWYgKCFjdXJyZW50VXBkYXRlKSB7XG5cdFx0Y3VycmVudFVwZGF0ZSA9IHt9O1xuXHRcdGN1cnJlbnRVcGRhdGVSdW50aW1lID0gW107XG5cdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSBbXTtcblx0XHRhcHBseUhhbmRsZXJzLnB1c2goYXBwbHlIYW5kbGVyKTtcblx0fVxuXHRpZiAoIV9fd2VicGFja19yZXF1aXJlX18ubyhjdXJyZW50VXBkYXRlLCBtb2R1bGVJZCkpIHtcblx0XHRjdXJyZW50VXBkYXRlW21vZHVsZUlkXSA9IF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF07XG5cdH1cbn07XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMuanNvbnAgPSBmdW5jdGlvbiAoXG5cdGNodW5rSWRzLFxuXHRyZW1vdmVkQ2h1bmtzLFxuXHRyZW1vdmVkTW9kdWxlcyxcblx0cHJvbWlzZXMsXG5cdGFwcGx5SGFuZGxlcnMsXG5cdHVwZGF0ZWRNb2R1bGVzTGlzdFxuKSB7XG5cdGFwcGx5SGFuZGxlcnMucHVzaChhcHBseUhhbmRsZXIpO1xuXHRjdXJyZW50VXBkYXRlQ2h1bmtzID0ge307XG5cdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzID0gcmVtb3ZlZENodW5rcztcblx0Y3VycmVudFVwZGF0ZSA9IHJlbW92ZWRNb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcblx0XHRvYmpba2V5XSA9IGZhbHNlO1xuXHRcdHJldHVybiBvYmo7XG5cdH0sIHt9KTtcblx0Y3VycmVudFVwZGF0ZVJ1bnRpbWUgPSBbXTtcblx0Y2h1bmtJZHMuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdGlmIChcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gIT09IHVuZGVmaW5lZFxuXHRcdCkge1xuXHRcdFx0cHJvbWlzZXMucHVzaChsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgdXBkYXRlZE1vZHVsZXNMaXN0KSk7XG5cdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xuXHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5mKSB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mLmpzb25wSG1yID0gZnVuY3Rpb24gKGNodW5rSWQsIHByb21pc2VzKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3MgJiZcblx0XHRcdFx0IV9fd2VicGFja19yZXF1aXJlX18ubyhjdXJyZW50VXBkYXRlQ2h1bmtzLCBjaHVua0lkKSAmJlxuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJlxuXHRcdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gIT09IHVuZGVmaW5lZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHByb21pc2VzLnB1c2gobG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpKTtcblx0XHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rc1tjaHVua0lkXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJNID0gKCkgPT4ge1xuXHRpZiAodHlwZW9mIGZldGNoID09PSBcInVuZGVmaW5lZFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnQ6IG5lZWQgZmV0Y2ggQVBJXCIpO1xuXHRyZXR1cm4gZmV0Y2goX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy5obXJGKCkpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0aWYocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHJldHVybjsgLy8gbm8gdXBkYXRlIGF2YWlsYWJsZVxuXHRcdGlmKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHVwZGF0ZSBtYW5pZmVzdCBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuXHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cdH0pO1xufTtcblxuLy8gbm8gb24gY2h1bmtzIGxvYWRlZFxuXG4vLyBubyBqc29ucCBmdW5jdGlvbiIsIiIsIi8vIG1vZHVsZSBjYWNoZSBhcmUgdXNlZCBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9pbmRleC5qcz9wcm90b2NvbD13cyUzQSZob3N0bmFtZT0wLjAuMC4wJnBvcnQ9ODA4MCZwYXRobmFtZT0lMkZ3cyZsb2dnaW5nPWluZm9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZGV2LXNlcnZlci5qc1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL2FwcC9pbmRleC5qc1wiKTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3R5bGVzL2luZGV4LnNjc3NcIik7XG4iLCIiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiZWFjaCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwiZWxlbWVudCIsImVsZW1lbnRzIiwic2VsZWN0b3IiLCJzZWxlY3RvckNoaWxkcmVuIiwiY3JlYXRlIiwiYWRkRXZlbnRMaXN0ZW5lcnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJlbnRyeSIsImtleSIsIndpbmRvdyIsIkhUTUxFbGVtZW50IiwiTm9kZUxpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwibGVuZ2h0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJHU0FQIiwiUHJlZml4IiwiUGFnZSIsImlkIiwic2Nyb2xsIiwiY3VycmVudCIsInRhcmdldCIsImxhc3QiLCJ0cmFuc2Zvcm1QcmVmaXgiLCJvbk1vdXNlV2hlZWwiLCJ1cGRhdGUiLCJzaG93IiwiYW5pbWF0ZUluIiwidGltZWxpbmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImZyb20iLCJhdXRvQWxwaGEiLCJvbkNvbXBsZXRlIiwiaGlkZSIsImFuaW1hdGVPdXQiLCJ0byIsInV0aWxzIiwiaW50ZXJwb2xhdGUiLCJldmVudCIsImNvbnNvbGUiLCJsb2ciLCJhZGRFdmVudExpc3RlbmVyIiwiZ3NhcCIsInNwbGl0IiwiUHJlbG9hZGVyIiwidGl0bGUiLCJudW1iZXIiLCJpbWFnZXMiLCJsZW5ndGgiLCJjcmVhdGVMb2FkZXIiLCJleHByZXNzaW9uIiwidGl0bGVTcGFucyIsIm9uQXNzZXRMb2FkZWQiLCJpbWFnZSIsInBlcmNlbnQiLCJNYXRoIiwicm91bmQiLCJpbm5lckhUTUwiLCJvbkxvYWRlZCIsInNyYyIsImdldEF0dHJpYnV0ZSIsIm9ubG9hZCIsIl8iLCJzdGFnZ2VyIiwiZHVyYXRpb24iLCJlYXNlIiwieSIsInNjYWxlWSIsInRyYW5zZm9ybU9yaWdpbiIsImRlc3Ryb3kiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJBYm91dCIsIkRldGFpbCIsIkNvbGxlY3Rpb25zIiwiSG9tZSIsIkFwcCIsImNyZWF0ZUNvbnRlbnQiLCJjcmVhdGVQYWdlcyIsImFkZExpbmtMaXN0ZW5lcnMiLCJjb250ZW50IiwidGVtcGxhdGUiLCJwYWdlcyIsImhvbWUiLCJjb2xsZWN0aW9ucyIsImFib3V0IiwiZGV0YWlsIiwicGFnZSIsIm9uQ2hhbmdlIiwidXJsIiwicmVxdWVzdCIsImZldGNoIiwic3RhdHVzIiwibmV4dFBhZ2UiLCJ0ZXh0IiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsImRpdkNvbnRlbnQiLCJzZXRBdHRyaWJ1dGUiLCJsaW5rcyIsImxpbmsiLCJvbmNsaWNrIiwicHJldmVudERlZmF1bHQiLCJocmVmIiwiZnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJiaW5kIiwid3JhcHBlciIsIm5hdmlnYXRpb24iLCJhcHBlbmQiLCJ3b3JkcyIsInNwbGl0VGV4dCIsInRvU3RyaW5nIiwidHJpbSIsImxpbmUiLCJpbmRleE9mIiwibGluZXMiLCJpbmRleCIsInBhcnNlTGluZSIsInNwYW5zIiwic3BhbiIsImlzU2luZ2xlTGV0dGVyIiwidGV4dENvbnRlbnQiLCJpc05vdEVtcHR5IiwiaXNOb3RBbmRDaGFyYWN0ZXIiLCJpc05vdERhc2hDaGFyYWN0ZXIiLCJjYWxjdWxhdGUiLCJwb3NpdGlvbiIsIm9mZnNldFRvcCIsInB1c2giLCJzcGxpdHMiLCJpdGVtIiwiY29uY2F0IiwiaXNMaW5rIiwid29yZCIsImluY2x1ZGVzIiwibW9kdWxlIiwiZXhwb3J0cyIsImFuc2lIVE1MIiwiX3JlZ0FOU0kiLCJfZGVmQ29sb3JzIiwicmVzZXQiLCJibGFjayIsInJlZCIsImdyZWVuIiwieWVsbG93IiwiYmx1ZSIsIm1hZ2VudGEiLCJjeWFuIiwibGlnaHRncmV5IiwiZGFya2dyZXkiLCJfc3R5bGVzIiwiX29wZW5UYWdzIiwiX2Nsb3NlVGFncyIsImZvckVhY2giLCJuIiwidGVzdCIsImFuc2lDb2RlcyIsInJldCIsInJlcGxhY2UiLCJtYXRjaCIsInNlcSIsIm90IiwicG9wIiwiY3QiLCJsIiwiam9pbiIsInNldENvbG9ycyIsImNvbG9ycyIsIkVycm9yIiwiX2ZpbmFsQ29sb3JzIiwiaGV4IiwiaGFzT3duUHJvcGVydHkiLCJzb21lIiwiaCIsImRlZkhleENvbG9yIiwic2xpY2UiLCJfc2V0VGFncyIsInRhZ3MiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsIm9wZW4iLCJjbG9zZSIsImNvZGUiLCJjb2xvciIsIm9yaUNvbG9yIiwicGFyc2VJbnQiLCJSIiwiUmVmbGVjdCIsIlJlZmxlY3RBcHBseSIsImFwcGx5IiwicmVjZWl2ZXIiLCJhcmdzIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJjYWxsIiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIlByb2Nlc3NFbWl0V2FybmluZyIsIndhcm5pbmciLCJ3YXJuIiwiTnVtYmVySXNOYU4iLCJOdW1iZXIiLCJpc05hTiIsInZhbHVlIiwiaW5pdCIsIm9uY2UiLCJfZXZlbnRzIiwidW5kZWZpbmVkIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJjaGVja0xpc3RlbmVyIiwibGlzdGVuZXIiLCJUeXBlRXJyb3IiLCJlbnVtZXJhYmxlIiwic2V0IiwiYXJnIiwiUmFuZ2VFcnJvciIsImdldFByb3RvdHlwZU9mIiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJlbWl0IiwidHlwZSIsImkiLCJhcmd1bWVudHMiLCJkb0Vycm9yIiwiZXZlbnRzIiwiZXJyb3IiLCJlciIsImVyciIsIm1lc3NhZ2UiLCJjb250ZXh0IiwiaGFuZGxlciIsImxlbiIsImxpc3RlbmVycyIsImFycmF5Q2xvbmUiLCJfYWRkTGlzdGVuZXIiLCJwcmVwZW5kIiwibSIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJ1bnNoaWZ0Iiwid2FybmVkIiwidyIsIlN0cmluZyIsIm5hbWUiLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsIm9uIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsInJlbW92ZUxpc3RlbmVyIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3QiLCJvcmlnaW5hbExpc3RlbmVyIiwic2hpZnQiLCJzcGxpY2VPbmUiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJrZXlzIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsImFyciIsImNvcHkiLCJyZWplY3QiLCJlcnJvckxpc3RlbmVyIiwicmVzb2x2ZXIiLCJldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIiLCJhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlciIsImZsYWdzIiwid3JhcExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9nZXRQcm9wZXJ0eSIsIl9udW1FeHAiLCJfbnVtV2l0aFVuaXRFeHAiLCJnZXRVbml0IiwiX2lzU3RyaW5nIiwiX2lzVW5kZWZpbmVkIiwiX3JlbmRlckNvbXBsZXhTdHJpbmciLCJfcmVsRXhwIiwiX2ZvckVhY2hOYW1lIiwiX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSIsIl9jb2xvclN0cmluZ0ZpbHRlciIsIl9jaGVja1BsdWdpbiIsIl9yZXBsYWNlUmFuZG9tIiwiX3BsdWdpbnMiLCJHU0NhY2hlIiwiUHJvcFR3ZWVuIiwiX2NvbmZpZyIsIl90aWNrZXIiLCJfcm91bmQiLCJfbWlzc2luZ1BsdWdpbiIsIl9nZXRTZXR0ZXIiLCJfZ2V0Q2FjaGUiLCJfY29sb3JFeHAiLCJfc2V0RGVmYXVsdHMiLCJfcmVtb3ZlTGlua2VkTGlzdEl0ZW0iLCJfd2luIiwiX2RvYyIsIl9kb2NFbGVtZW50IiwiX3BsdWdpbkluaXR0ZWQiLCJfdGVtcERpdiIsIl90ZW1wRGl2U3R5bGVyIiwiX3JlY2VudFNldHRlclBsdWdpbiIsIl93aW5kb3dFeGlzdHMiLCJfdHJhbnNmb3JtUHJvcHMiLCJfUkFEMkRFRyIsIlBJIiwiX0RFRzJSQUQiLCJfYXRhbjIiLCJhdGFuMiIsIl9iaWdOdW0iLCJfY2Fwc0V4cCIsIl9ob3Jpem9udGFsRXhwIiwiX2NvbXBsZXhFeHAiLCJfcHJvcGVydHlBbGlhc2VzIiwic2NhbGUiLCJhbHBoYSIsIl9yZW5kZXJDU1NQcm9wIiwicmF0aW8iLCJkYXRhIiwidCIsInAiLCJzIiwiYyIsInUiLCJfcmVuZGVyUHJvcFdpdGhFbmQiLCJlIiwiX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nIiwiYiIsIl9yZW5kZXJSb3VuZGVkQ1NTUHJvcCIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlIiwiX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQiLCJfc2V0dGVyQ1NTU3R5bGUiLCJwcm9wZXJ0eSIsInN0eWxlIiwiX3NldHRlckNTU1Byb3AiLCJzZXRQcm9wZXJ0eSIsIl9zZXR0ZXJUcmFuc2Zvcm0iLCJfZ3NhcCIsIl9zZXR0ZXJTY2FsZSIsInNjYWxlWCIsIl9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIiLCJjYWNoZSIsInJlbmRlclRyYW5zZm9ybSIsIl9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyIiwiX3RyYW5zZm9ybVByb3AiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIl9zdXBwb3J0czNEIiwiX2NyZWF0ZUVsZW1lbnQiLCJucyIsImNyZWF0ZUVsZW1lbnROUyIsIl9nZXRDb21wdXRlZFByb3BlcnR5Iiwic2tpcFByZWZpeEZhbGxiYWNrIiwiY3MiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRvTG93ZXJDYXNlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsInByZWZlclByZWZpeCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic3Vic3RyIiwiX2luaXRDb3JlIiwiZG9jdW1lbnRFbGVtZW50IiwiY3NzVGV4dCIsIl9nZXRCQm94SGFjayIsInN3YXBJZlBvc3NpYmxlIiwic3ZnIiwib3duZXJTVkdFbGVtZW50Iiwib2xkUGFyZW50Iiwib2xkU2libGluZyIsIm5leHRTaWJsaW5nIiwib2xkQ1NTIiwiYmJveCIsImFwcGVuZENoaWxkIiwiZGlzcGxheSIsImdldEJCb3giLCJfZ3NhcEJCb3giLCJpbnNlcnRCZWZvcmUiLCJfZ2V0QXR0cmlidXRlRmFsbGJhY2tzIiwiYXR0cmlidXRlc0FycmF5IiwiaGFzQXR0cmlidXRlIiwiX2dldEJCb3giLCJib3VuZHMiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJfaXNTVkciLCJnZXRDVE0iLCJfcmVtb3ZlUHJvcGVydHkiLCJyZW1vdmVQcm9wZXJ0eSIsInJlbW92ZUF0dHJpYnV0ZSIsIl9hZGROb25Ud2VlbmluZ1BUIiwicGx1Z2luIiwiYmVnaW5uaW5nIiwiZW5kIiwib25seVNldEF0RW5kIiwicHQiLCJfcHQiLCJfcHJvcHMiLCJfbm9uQ29udmVydGlibGVVbml0cyIsImRlZyIsInJhZCIsInR1cm4iLCJfY29udmVydFRvVW5pdCIsInVuaXQiLCJjdXJWYWx1ZSIsInBhcnNlRmxvYXQiLCJjdXJVbml0IiwiaG9yaXpvbnRhbCIsImlzUm9vdFNWRyIsInRhZ05hbWUiLCJtZWFzdXJlUHJvcGVydHkiLCJhbW91bnQiLCJ0b1BpeGVscyIsInRvUGVyY2VudCIsInB4IiwicGFyZW50IiwiaXNTVkciLCJib2R5IiwidGltZSIsIl9nZXQiLCJ1bmNhY2hlIiwiX3BhcnNlVHJhbnNmb3JtIiwib3JpZ2luIiwiX2ZpcnN0VHdvT25seSIsInpPcmlnaW4iLCJfc3BlY2lhbFByb3BzIiwiX3R3ZWVuQ29tcGxleENTU1N0cmluZyIsInByb3AiLCJzdGFydCIsIm1hdGNoSW5kZXgiLCJhIiwicmVzdWx0Iiwic3RhcnRWYWx1ZXMiLCJzdGFydE51bSIsInN0YXJ0VmFsdWUiLCJlbmRWYWx1ZSIsImVuZE51bSIsImNodW5rIiwiZW5kVW5pdCIsInN0YXJ0VW5pdCIsInJlbGF0aXZlIiwiZW5kVmFsdWVzIiwiZXhlYyIsInN1YnN0cmluZyIsImxhc3RJbmRleCIsInVuaXRzIiwiX25leHQiLCJyIiwiX2tleXdvcmRUb1BlcmNlbnQiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJjZW50ZXIiLCJfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyIsIl9yZW5kZXJDbGVhclByb3BzIiwidHdlZW4iLCJfdGltZSIsIl9kdXIiLCJwcm9wcyIsImNsZWFyVHJhbnNmb3JtcyIsImNsZWFyUHJvcHMiLCJwciIsIl9pZGVudGl0eTJETWF0cml4IiwiX3JvdGF0aW9uYWxQcm9wZXJ0aWVzIiwiX2lzTnVsbFRyYW5zZm9ybSIsIl9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkiLCJtYXRyaXhTdHJpbmciLCJtYXAiLCJfZ2V0TWF0cml4IiwiZm9yY2UyRCIsIm1hdHJpeCIsInRlbXAiLCJhZGRlZFRvRE9NIiwidHJhbnNmb3JtIiwiYmFzZVZhbCIsImNvbnNvbGlkYXRlIiwiZCIsImYiLCJvZmZzZXRQYXJlbnQiLCJfYXBwbHlTVkdPcmlnaW4iLCJvcmlnaW5Jc0Fic29sdXRlIiwic21vb3RoIiwibWF0cml4QXJyYXkiLCJwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbyIsInhPcmlnaW5PbGQiLCJ4T3JpZ2luIiwieU9yaWdpbk9sZCIsInlPcmlnaW4iLCJ4T2Zmc2V0T2xkIiwieE9mZnNldCIsInlPZmZzZXRPbGQiLCJ5T2Zmc2V0IiwidHgiLCJ0eSIsIm9yaWdpblNwbGl0IiwiZGV0ZXJtaW5hbnQiLCJpbnZlcnRlZFNjYWxlWCIsInoiLCJyb3RhdGlvbiIsInJvdGF0aW9uWCIsInJvdGF0aW9uWSIsInNrZXdYIiwic2tld1kiLCJwZXJzcGVjdGl2ZSIsImFuZ2xlIiwiY29zIiwic2luIiwiYTEyIiwiYTIyIiwidDEiLCJ0MiIsInQzIiwiYTEzIiwiYTIzIiwiYTMzIiwiYTQyIiwiYTQzIiwiYTMyIiwic3FydCIsImFicyIsImZvcmNlQ1NTIiwieFBlcmNlbnQiLCJvZmZzZXRXaWR0aCIsInlQZXJjZW50Iiwib2Zmc2V0SGVpZ2h0IiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJmb3JjZTNEIiwiX3JlbmRlclNWR1RyYW5zZm9ybXMiLCJfcmVuZGVyQ1NTVHJhbnNmb3JtcyIsIl9yZW5kZXJOb24zRFRyYW5zZm9ybXMiLCJfYWRkUHhUcmFuc2xhdGUiLCJfemVyb0RlZyIsIl96ZXJvUHgiLCJfZW5kUGFyZW50aGVzaXMiLCJfcmVmIiwidHJhbnNmb3JtcyIsInVzZTNEIiwiX3JlZjIiLCJhMTEiLCJhMjEiLCJ0YW4iLCJfYWRkUm90YXRpb25hbFByb3BUd2VlbiIsImNhcCIsImlzU3RyaW5nIiwiY2hhbmdlIiwiZmluYWxWYWx1ZSIsImRpcmVjdGlvbiIsIl9hc3NpZ24iLCJzb3VyY2UiLCJfYWRkUmF3VHJhbnNmb3JtUFRzIiwic3RhcnRDYWNoZSIsImV4Y2x1ZGUiLCJlbmRDYWNoZSIsInNpZGUiLCJ2YXJzIiwiQ1NTUGx1Z2luIiwicmVnaXN0ZXIiLCJ0YXJnZXRUZXN0Iiwibm9kZVR5cGUiLCJ0YXJnZXRzIiwic3RhcnRBdCIsInNwZWNpYWxQcm9wIiwiaXNUcmFuc2Zvcm1SZWxhdGVkIiwidHJhbnNmb3JtUHJvcFR3ZWVuIiwiaGFzUHJpb3JpdHkiLCJhZGQiLCJwYXJzZVRyYW5zZm9ybSIsInNtb290aE9yaWdpbiIsImRlcCIsImF1dG9Sb3VuZCIsImFsaWFzZXMiLCJnZXRTZXR0ZXIiLCJjb3JlIiwiY2hlY2tQcmVmaXgiLCJwb3NpdGlvbkFuZFNjYWxlIiwib3RoZXJzIiwiYWxsIiwicmVnaXN0ZXJQbHVnaW4iLCJkZWZhdWx0IiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX19wcm90b19fIiwiYXV0b1NsZWVwIiwibnVsbFRhcmdldFdhcm4iLCJsaW5lSGVpZ2h0IiwiX2RlZmF1bHRzIiwib3ZlcndyaXRlIiwiZGVsYXkiLCJfc3VwcHJlc3NPdmVyd3JpdGVzIiwiX3RpbnlOdW0iLCJfMlBJIiwiX0hBTEZfUEkiLCJfZ3NJRCIsIl9zcXJ0IiwiX2NvcyIsIl9zaW4iLCJfaXNGdW5jdGlvbiIsIl9pc051bWJlciIsIl9pc09iamVjdCIsIl9pc05vdEZhbHNlIiwiX2lzRnVuY09yU3RyaW5nIiwiX2lzVHlwZWRBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiX2lzQXJyYXkiLCJfc3RyaWN0TnVtRXhwIiwiX2NvbXBsZXhTdHJpbmdOdW1FeHAiLCJfZGVsaW1pdGVkVmFsdWVFeHAiLCJfdW5pdEV4cCIsIl9nbG9iYWxUaW1lbGluZSIsIl9jb3JlSW5pdHRlZCIsIl9nbG9iYWxzIiwiX2luc3RhbGxTY29wZSIsIl9jb3JlUmVhZHkiLCJfaW5zdGFsbCIsInNjb3BlIiwiX21lcmdlIiwiX3dhcm4iLCJzdXBwcmVzcyIsIl9hZGRHbG9iYWwiLCJvYmoiLCJfZW1wdHlGdW5jIiwiX3Jlc2VydmVkUHJvcHMiLCJfbGF6eVR3ZWVucyIsIl9sYXp5TG9va3VwIiwiX2xhc3RSZW5kZXJlZEZyYW1lIiwiX2VmZmVjdHMiLCJfbmV4dEdDRnJhbWUiLCJfaGFybmVzc1BsdWdpbnMiLCJfY2FsbGJhY2tOYW1lcyIsIl9oYXJuZXNzIiwiaGFybmVzc1BsdWdpbiIsImhhcm5lc3MiLCJzcGxpY2UiLCJ0b0FycmF5IiwidiIsIm5hbWVzIiwiZnVuYyIsIl9yb3VuZFByZWNpc2UiLCJfYXJyYXlDb250YWluc0FueSIsInRvU2VhcmNoIiwidG9GaW5kIiwiX2xhenlSZW5kZXIiLCJfbGF6eSIsInJlbmRlciIsIl9sYXp5U2FmZVJlbmRlciIsImFuaW1hdGlvbiIsInN1cHByZXNzRXZlbnRzIiwiZm9yY2UiLCJfbnVtZXJpY0lmUG9zc2libGUiLCJfcGFzc1Rocm91Z2giLCJkZWZhdWx0cyIsIl9zZXRLZXlmcmFtZURlZmF1bHRzIiwiYmFzZSIsInRvTWVyZ2UiLCJfbWVyZ2VEZWVwIiwiX2NvcHlFeGNsdWRpbmciLCJleGNsdWRpbmciLCJfaW5oZXJpdERlZmF1bHRzIiwia2V5ZnJhbWVzIiwiaW5oZXJpdCIsIl9kcCIsIl9hcnJheXNNYXRjaCIsImExIiwiYTIiLCJfYWRkTGlua2VkTGlzdEl0ZW0iLCJjaGlsZCIsImZpcnN0UHJvcCIsImxhc3RQcm9wIiwic29ydEJ5IiwicHJldiIsIl9wcmV2IiwibmV4dCIsIl9yZW1vdmVGcm9tUGFyZW50Iiwib25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSIsImF1dG9SZW1vdmVDaGlsZHJlbiIsInJlbW92ZSIsIl9hY3QiLCJfdW5jYWNoZSIsIl9lbmQiLCJfc3RhcnQiLCJfZGlydHkiLCJfcmVjYWNoZUFuY2VzdG9ycyIsInRvdGFsRHVyYXRpb24iLCJfaGFzTm9QYXVzZWRBbmNlc3RvcnMiLCJfdHMiLCJfZWxhcHNlZEN5Y2xlRHVyYXRpb24iLCJfcmVwZWF0IiwiX2FuaW1hdGlvbkN5Y2xlIiwiX3RUaW1lIiwiX3JEZWxheSIsInRUaW1lIiwiY3ljbGVEdXJhdGlvbiIsIndob2xlIiwiZmxvb3IiLCJfcGFyZW50VG9DaGlsZFRvdGFsVGltZSIsInBhcmVudFRpbWUiLCJfdER1ciIsIl9zZXRFbmQiLCJfcnRzIiwiX2FsaWduUGxheWhlYWQiLCJ0b3RhbFRpbWUiLCJzbW9vdGhDaGlsZFRpbWluZyIsIl9wb3N0QWRkQ2hlY2tzIiwiX2luaXR0ZWQiLCJyYXdUaW1lIiwiX2NsYW1wIiwiX3pUaW1lIiwiX2FkZFRvVGltZWxpbmUiLCJza2lwQ2hlY2tzIiwiX3BhcnNlUG9zaXRpb24iLCJfZGVsYXkiLCJ0aW1lU2NhbGUiLCJfc29ydCIsIl9pc0Zyb21PckZyb21TdGFydCIsIl9yZWNlbnQiLCJfc2Nyb2xsVHJpZ2dlciIsInRyaWdnZXIiLCJTY3JvbGxUcmlnZ2VyIiwiX2F0dGVtcHRJbml0VHdlZW4iLCJfaW5pdFR3ZWVuIiwibGF6eSIsIl9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQiLCJfbG9jayIsIl9yZW5kZXJaZXJvRHVyYXRpb25Ud2VlbiIsInByZXZSYXRpbyIsInJlcGVhdERlbGF5IiwiaXRlcmF0aW9uIiwicHJldkl0ZXJhdGlvbiIsIl95b3lvIiwicmVwZWF0UmVmcmVzaCIsImludmFsaWRhdGUiLCJfZnJvbSIsIl9zdGFydEF0IiwiX29uVXBkYXRlIiwiX2NhbGxiYWNrIiwiX3Byb20iLCJfZmluZE5leHRQYXVzZVR3ZWVuIiwicHJldlRpbWUiLCJfZmlyc3QiLCJfbGFzdCIsIl9zZXREdXJhdGlvbiIsInNraXBVbmNhY2hlIiwibGVhdmVQbGF5aGVhZCIsInJlcGVhdCIsImR1ciIsInRvdGFsUHJvZ3Jlc3MiLCJfb25VcGRhdGVUb3RhbER1cmF0aW9uIiwiVGltZWxpbmUiLCJfemVyb1Bvc2l0aW9uIiwiZW5kVGltZSIsInBlcmNlbnRBbmltYXRpb24iLCJsYWJlbHMiLCJyZWNlbnQiLCJjbGlwcGVkRHVyYXRpb24iLCJvZmZzZXQiLCJpc1BlcmNlbnQiLCJfY3JlYXRlVHdlZW5UeXBlIiwicGFyYW1zIiwiaXNMZWdhY3kiLCJ2YXJzSW5kZXgiLCJpclZhcnMiLCJpbW1lZGlhdGVSZW5kZXIiLCJydW5CYWNrd2FyZHMiLCJUd2VlbiIsIl9jb25kaXRpb25hbFJldHVybiIsIm1pbiIsIm1heCIsImNsYW1wIiwiX3NsaWNlIiwiX2lzQXJyYXlMaWtlIiwibm9uRW1wdHkiLCJfZmxhdHRlbiIsImFyIiwibGVhdmVTdHJpbmdzIiwiYWNjdW11bGF0b3IiLCJfYWNjdW11bGF0b3IiLCJfd2FrZSIsImVsIiwibmF0aXZlRWxlbWVudCIsInNodWZmbGUiLCJzb3J0IiwicmFuZG9tIiwiZGlzdHJpYnV0ZSIsIl9wYXJzZUVhc2UiLCJpc0RlY2ltYWwiLCJyYXRpb3MiLCJheGlzIiwicmF0aW9YIiwicmF0aW9ZIiwiZWRnZXMiLCJkaXN0YW5jZXMiLCJvcmlnaW5YIiwib3JpZ2luWSIsImoiLCJ3cmFwQXQiLCJncmlkIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2ludmVydEVhc2UiLCJfcm91bmRNb2RpZmllciIsInBvdyIsInJhdyIsInNuYXAiLCJzbmFwVG8iLCJyYWRpdXMiLCJpczJEIiwidmFsdWVzIiwiaW5jcmVtZW50IiwiY2xvc2VzdCIsImR4IiwiZHkiLCJyb3VuZGluZ0luY3JlbWVudCIsInJldHVybkZ1bmN0aW9uIiwicGlwZSIsIl9sZW4iLCJmdW5jdGlvbnMiLCJfa2V5IiwicmVkdWNlIiwidW5pdGl6ZSIsIm5vcm1hbGl6ZSIsIm1hcFJhbmdlIiwiX3dyYXBBcnJheSIsIndyYXAiLCJyYW5nZSIsIndyYXBZb3lvIiwidG90YWwiLCJudW1zIiwiaW5NaW4iLCJpbk1heCIsIm91dE1pbiIsIm91dE1heCIsImluUmFuZ2UiLCJvdXRSYW5nZSIsInByb2dyZXNzIiwibXV0YXRlIiwibWFzdGVyIiwiaW50ZXJwb2xhdG9ycyIsImlsIiwiX2FkZFByb3BUd2VlbiIsIl9yZW5kZXJQcm9wVHdlZW5zIiwiX2dldExhYmVsSW5EaXJlY3Rpb24iLCJmcm9tVGltZSIsImJhY2t3YXJkIiwiZGlzdGFuY2UiLCJsYWJlbCIsImV4ZWN1dGVMYXp5Rmlyc3QiLCJjYWxsYmFjayIsImNhbGxiYWNrU2NvcGUiLCJfaW50ZXJydXB0Iiwic2Nyb2xsVHJpZ2dlciIsImtpbGwiLCJfcXVpY2tUd2VlbiIsIl9jcmVhdGVQbHVnaW4iLCJjb25maWciLCJpc0Z1bmMiLCJQbHVnaW4iLCJpbnN0YW5jZURlZmF1bHRzIiwiX2tpbGxQcm9wVHdlZW5zT2YiLCJtb2RpZmllciIsIl9hZGRQbHVnaW5Nb2RpZmllciIsInJhd1ZhcnMiLCJzdGF0aWNzIiwiXzI1NSIsIl9jb2xvckxvb2t1cCIsImFxdWEiLCJsaW1lIiwic2lsdmVyIiwibWFyb29uIiwidGVhbCIsIm5hdnkiLCJ3aGl0ZSIsIm9saXZlIiwib3JhbmdlIiwiZ3JheSIsInB1cnBsZSIsInBpbmsiLCJ0cmFuc3BhcmVudCIsIl9odWUiLCJtMSIsIm0yIiwic3BsaXRDb2xvciIsInRvSFNMIiwiZm9yY2VBbHBoYSIsImciLCJ3YXNIU0wiLCJfY29sb3JPcmRlckRhdGEiLCJfZm9ybWF0Q29sb3JzIiwib3JkZXJNYXRjaERhdGEiLCJzaGVsbCIsIlJlZ0V4cCIsIl9oc2xFeHAiLCJjb21iaW5lZCIsIl90aWNrZXJBY3RpdmUiLCJfZ2V0VGltZSIsIkRhdGUiLCJub3ciLCJfbGFnVGhyZXNob2xkIiwiX2FkanVzdGVkTGFnIiwiX3N0YXJ0VGltZSIsIl9sYXN0VXBkYXRlIiwiX2dhcCIsIl9uZXh0VGltZSIsIl9pZCIsIl9yZXEiLCJfcmFmIiwiX3NlbGYiLCJfZGVsdGEiLCJfaSIsIl90aWNrIiwiZWxhcHNlZCIsIm1hbnVhbCIsIm92ZXJsYXAiLCJkaXNwYXRjaCIsInRpY2siLCJkZWx0YVJhdGlvIiwiZnBzIiwid2FrZSIsImdzYXBWZXJzaW9ucyIsInZlcnNpb24iLCJHcmVlblNvY2tHbG9iYWxzIiwic2xlZXAiLCJzZXRUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJsYWdTbW9vdGhpbmciLCJ0aHJlc2hvbGQiLCJhZGp1c3RlZExhZyIsIl9mcHMiLCJfZWFzZU1hcCIsIl9jdXN0b21FYXNlRXhwIiwiX3F1b3Rlc0V4cCIsIl9wYXJzZU9iamVjdEluU3RyaW5nIiwidmFsIiwicGFyc2VkVmFsIiwibGFzdEluZGV4T2YiLCJfdmFsdWVJblBhcmVudGhlc2VzIiwibmVzdGVkIiwiX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nIiwiX0NFIiwiX3Byb3BhZ2F0ZVlveW9FYXNlIiwiaXNZb3lvIiwieW95b0Vhc2UiLCJfZWFzZSIsIl95RWFzZSIsImRlZmF1bHRFYXNlIiwiX2luc2VydEVhc2UiLCJlYXNlSW4iLCJlYXNlT3V0IiwiZWFzZUluT3V0IiwibG93ZXJjYXNlTmFtZSIsIl9lYXNlSW5PdXRGcm9tT3V0IiwiX2NvbmZpZ0VsYXN0aWMiLCJhbXBsaXR1ZGUiLCJwZXJpb2QiLCJwMSIsInAyIiwicDMiLCJhc2luIiwiX2NvbmZpZ0JhY2siLCJvdmVyc2hvb3QiLCJwb3dlciIsIkxpbmVhciIsImVhc2VOb25lIiwibm9uZSIsIm4xIiwibjIiLCJuMyIsIlN0ZXBwZWRFYXNlIiwic3RlcHMiLCJpbW1lZGlhdGVTdGFydCIsIkFuaW1hdGlvbiIsIkluZmluaXR5IiwieW95byIsIl9wcm90byIsInN0YXJ0VGltZSIsIl90b3RhbFRpbWUiLCJfcHRMb29rdXAiLCJfcFRpbWUiLCJfcHMiLCJwYXVzZWQiLCJpbmNsdWRlUmVwZWF0cyIsIndyYXBSZXBlYXRzIiwiZ2xvYmFsVGltZSIsInNlZWsiLCJyZXN0YXJ0IiwiaW5jbHVkZURlbGF5IiwicGxheSIsInJldmVyc2VkIiwicmV2ZXJzZSIsInBhdXNlIiwiYXRUaW1lIiwicmVzdW1lIiwiaXNBY3RpdmUiLCJldmVudENhbGxiYWNrIiwidGhlbiIsIm9uRnVsZmlsbGVkIiwiX3Jlc29sdmUiLCJfdGhlbiIsIl9BbmltYXRpb24iLCJfdGhpcyIsInNvcnRDaGlsZHJlbiIsIl9wcm90bzIiLCJmcm9tVG8iLCJmcm9tVmFycyIsInRvVmFycyIsImRlbGF5ZWRDYWxsIiwic3RhZ2dlclRvIiwib25Db21wbGV0ZUFsbCIsIm9uQ29tcGxldGVBbGxQYXJhbXMiLCJvbkNvbXBsZXRlUGFyYW1zIiwic3RhZ2dlckZyb20iLCJzdGFnZ2VyRnJvbVRvIiwidER1ciIsImNyb3NzaW5nU3RhcnQiLCJwcmV2UGF1c2VkIiwicGF1c2VUd2VlbiIsInByZXZTdGFydCIsInJld2luZGluZyIsImRvZXNXcmFwIiwib25SZXBlYXQiLCJfaGFzUGF1c2UiLCJfZm9yY2luZyIsIm9uVXBkYXRlIiwiYWRqdXN0ZWRUaW1lIiwiX3RoaXMyIiwiYWRkTGFiZWwiLCJnZXRDaGlsZHJlbiIsInR3ZWVucyIsInRpbWVsaW5lcyIsImlnbm9yZUJlZm9yZVRpbWUiLCJnZXRCeUlkIiwiYW5pbWF0aW9ucyIsInJlbW92ZUxhYmVsIiwia2lsbFR3ZWVuc09mIiwiX3RvdGFsVGltZTIiLCJhZGRQYXVzZSIsInJlbW92ZVBhdXNlIiwib25seUFjdGl2ZSIsImdldFR3ZWVuc09mIiwiX292ZXJ3cml0aW5nVHdlZW4iLCJwYXJzZWRUYXJnZXRzIiwiaXNHbG9iYWxUaW1lIiwiY2hpbGRyZW4iLCJfdGFyZ2V0cyIsInR3ZWVuVG8iLCJ0bCIsIl92YXJzIiwiX29uU3RhcnQiLCJvblN0YXJ0Iiwib25TdGFydFBhcmFtcyIsImluaXR0ZWQiLCJ0d2VlbkZyb21UbyIsImZyb21Qb3NpdGlvbiIsInRvUG9zaXRpb24iLCJuZXh0TGFiZWwiLCJhZnRlclRpbWUiLCJwcmV2aW91c0xhYmVsIiwiYmVmb3JlVGltZSIsImN1cnJlbnRMYWJlbCIsInNoaWZ0Q2hpbGRyZW4iLCJhZGp1c3RMYWJlbHMiLCJjbGVhciIsImluY2x1ZGVMYWJlbHMiLCJ1cGRhdGVSb290IiwiX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4iLCJzZXR0ZXIiLCJzdHJpbmdGaWx0ZXIiLCJmdW5jUGFyYW0iLCJzdGFydE51bXMiLCJoYXNSYW5kb20iLCJmcCIsImN1cnJlbnRWYWx1ZSIsInBhcnNlZFN0YXJ0IiwiX3NldHRlclBsYWluIiwiX3NldHRlckZ1bmNXaXRoUGFyYW0iLCJfc2V0dGVyRnVuYyIsIl9yZW5kZXJCb29sZWFuIiwiX3JlbmRlclBsYWluIiwiX3Byb2Nlc3NWYXJzIiwiX3BhcnNlRnVuY09yU3RyaW5nIiwicHRMb29rdXAiLCJwcmlvcml0eSIsIm9uVXBkYXRlUGFyYW1zIiwiYXV0b1JldmVydCIsInByZXZTdGFydEF0IiwiZnVsbFRhcmdldHMiLCJhdXRvT3ZlcndyaXRlIiwiX292ZXJ3cml0ZSIsImNsZWFuVmFycyIsImdzRGF0YSIsImhhcm5lc3NWYXJzIiwib3ZlcndyaXR0ZW4iLCJfb3AiLCJfb25Jbml0IiwiX2FkZEFsaWFzZXNUb1ZhcnMiLCJwcm9wZXJ0eUFsaWFzZXMiLCJfc3RhZ2dlclR3ZWVuUHJvcHMiLCJfc3RhZ2dlclByb3BzVG9Ta2lwIiwiX0FuaW1hdGlvbjIiLCJza2lwSW5oZXJpdCIsIl90aGlzMyIsIl90aGlzMyR2YXJzIiwiY3VyVGFyZ2V0Iiwic3RhZ2dlckZ1bmMiLCJzdGFnZ2VyVmFyc1RvTWVyZ2UiLCJfcHJvdG8zIiwia2lsbGluZ1RhcmdldHMiLCJwcm9wVHdlZW5Mb29rdXAiLCJmaXJzdFBUIiwib3ZlcndyaXR0ZW5Qcm9wcyIsImN1ckxvb2t1cCIsImN1ck92ZXJ3cml0ZVByb3BzIiwib25SZXZlcnNlQ29tcGxldGUiLCJvblJldmVyc2VDb21wbGV0ZVBhcmFtcyIsIl9zZXR0ZXJBdHRyaWJ1dGUiLCJoYXNOb25EZXBlbmRlbnRSZW1haW5pbmciLCJvcCIsIl9zZXR0ZXJXaXRoTW9kaWZpZXIiLCJtU2V0IiwibXQiLCJwdDIiLCJmaXJzdCIsInJlbmRlcmVyIiwiX3Byb3RvNCIsIlR3ZWVuTWF4IiwiVHdlZW5MaXRlIiwiVGltZWxpbmVMaXRlIiwiVGltZWxpbmVNYXgiLCJfbGVuMiIsIl9rZXkyIiwiZ2V0UHJvcGVydHkiLCJnZXR0ZXIiLCJmb3JtYXQiLCJxdWlja1NldHRlciIsInNldHRlcnMiLCJpc1R3ZWVuaW5nIiwicmVnaXN0ZXJFZmZlY3QiLCJfcmVmMyIsImVmZmVjdCIsInBsdWdpbnMiLCJleHRlbmRUaW1lbGluZSIsInBsdWdpbk5hbWUiLCJyZWdpc3RlckVhc2UiLCJwYXJzZUVhc2UiLCJleHBvcnRSb290IiwiaW5jbHVkZURlbGF5ZWRDYWxscyIsImluc3RhbGwiLCJlZmZlY3RzIiwidGlja2VyIiwiZ2xvYmFsVGltZWxpbmUiLCJnbG9iYWxzIiwiZ2V0Q2FjaGUiLCJzdXBwcmVzc092ZXJ3cml0ZXMiLCJfZ2V0UGx1Z2luUHJvcFR3ZWVuIiwiX2FkZE1vZGlmaWVycyIsIm1vZGlmaWVycyIsIl9idWlsZE1vZGlmaWVyUGx1Z2luIiwiUG93ZXIwIiwiUG93ZXIxIiwiUG93ZXIyIiwiUG93ZXIzIiwiUG93ZXI0IiwiUXVhZCIsIkN1YmljIiwiUXVhcnQiLCJRdWludCIsIlN0cm9uZyIsIkVsYXN0aWMiLCJCYWNrIiwiQm91bmNlIiwiU2luZSIsIkV4cG8iLCJDaXJjIiwiZ3NhcFdpdGhDU1MiLCJUd2Vlbk1heFdpdGhDU1MiLCJfX2Fzc2lnbiIsImFzc2lnbiIsIm5hbWVkX3JlZmVyZW5jZXNfMSIsInJlcXVpcmUiLCJudW1lcmljX3VuaWNvZGVfbWFwXzEiLCJzdXJyb2dhdGVfcGFpcnNfMSIsImFsbE5hbWVkUmVmZXJlbmNlcyIsIm5hbWVkUmVmZXJlbmNlcyIsImh0bWw1IiwiZW5jb2RlUmVnRXhwcyIsInNwZWNpYWxDaGFycyIsIm5vbkFzY2lpIiwibm9uQXNjaWlQcmludGFibGUiLCJleHRlbnNpdmUiLCJkZWZhdWx0RW5jb2RlT3B0aW9ucyIsIm1vZGUiLCJsZXZlbCIsIm51bWVyaWMiLCJlbmNvZGUiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiZW5jb2RlUmVnRXhwIiwicmVmZXJlbmNlcyIsImNoYXJhY3RlcnMiLCJpc0hleCIsInJlc3VsdF8xIiwiY29kZV8xIiwiZ2V0Q29kZVBvaW50IiwiY2hhckNvZGVBdCIsImRlZmF1bHREZWNvZGVPcHRpb25zIiwic3RyaWN0IiwiYXR0cmlidXRlIiwiYmFzZURlY29kZVJlZ0V4cHMiLCJ4bWwiLCJib2R5UmVnRXhwcyIsImh0bWw0IiwiZGVjb2RlUmVnRXhwcyIsImZyb21DaGFyQ29kZSIsIm91dE9mQm91bmRzQ2hhciIsImRlZmF1bHREZWNvZGVFbnRpdHlPcHRpb25zIiwiZGVjb2RlRW50aXR5IiwiZW50aXR5IiwiZGVjb2RlRW50aXR5TGFzdENoYXJfMSIsImRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlXzEiLCJlbnRpdGllcyIsImRlY29kZVNlY29uZENoYXJfMSIsImRlY29kZUNvZGVfMSIsImZyb21Db2RlUG9pbnQiLCJudW1lcmljVW5pY29kZU1hcCIsImRlY29kZSIsImRlY29kZVJlZ0V4cCIsImlzQXR0cmlidXRlIiwiaXNTdHJpY3QiLCJyZXBsYWNlTWF0Y2hfMSIsInJlcGxhY2VSZXN1bHRfMSIsInJlcGxhY2VMYXN0SW5kZXhfMSIsInJlcGxhY2VJbnB1dF8xIiwiZGVjb2RlUmVzdWx0XzEiLCJkZWNvZGVFbnRpdHlMYXN0Q2hhcl8yIiwiZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2VfMiIsImRlY29kZVNlY29uZENoYXJfMiIsImRlY29kZUNvZGVfMiIsIiQiLCJmaiIsImFzdHJhbENvZGVQb2ludCIsImNvZGVQb2ludEF0IiwiaW5wdXQiLCJoaWdoU3Vycm9nYXRlRnJvbSIsImhpZ2hTdXJyb2dhdGVUbyIsInJvb3QiLCJTeW1ib2wiLCJhcnJheUVhY2giLCJhcnJheSIsIml0ZXJhdGVlIiwiYmFzZVRpbWVzIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzSW5kZXgiLCJpc1R5cGVkQXJyYXkiLCJvYmplY3RQcm90byIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJiYXNlRm9yT3duIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRWFjaCIsImNyZWF0ZUJhc2VGb3IiLCJiYXNlRm9yIiwib2JqZWN0IiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJpc09iamVjdExpa2UiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwiaXNMZW5ndGgiLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkiLCJpc1Byb3RvdHlwZSIsIm5hdGl2ZUtleXMiLCJiYXNlS2V5cyIsImJhc2VVbmFyeSIsImlkZW50aXR5IiwiY2FzdEZ1bmN0aW9uIiwiaXNBcnJheUxpa2UiLCJlYWNoRnVuYyIsImZyb21SaWdodCIsImNvbGxlY3Rpb24iLCJpdGVyYWJsZSIsImtleXNGdW5jIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ0YWciLCJ1bm1hc2tlZCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZUlzVWludCIsIkN0b3IiLCJwcm90byIsIm92ZXJBcmciLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsImJpbmRpbmciLCJmcmVlU2VsZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNGdW5jdGlvbiIsInN0dWJGYWxzZSIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNPYmplY3QiLCJhc3luY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwibm9kZUlzVHlwZWRBcnJheSIsIlZFUlNJT04iLCJMQVJHRV9BUlJBWV9TSVpFIiwiQ09SRV9FUlJPUl9URVhUIiwiRlVOQ19FUlJPUl9URVhUIiwiSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCIsIkhBU0hfVU5ERUZJTkVEIiwiTUFYX01FTU9JWkVfU0laRSIsIlBMQUNFSE9MREVSIiwiQ0xPTkVfREVFUF9GTEFHIiwiQ0xPTkVfRkxBVF9GTEFHIiwiQ0xPTkVfU1lNQk9MU19GTEFHIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiV1JBUF9CSU5EX0ZMQUciLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiV1JBUF9BUllfRkxBRyIsIldSQVBfUkVBUkdfRkxBRyIsIldSQVBfRkxJUF9GTEFHIiwiREVGQVVMVF9UUlVOQ19MRU5HVEgiLCJERUZBVUxUX1RSVU5DX09NSVNTSU9OIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJMQVpZX0ZJTFRFUl9GTEFHIiwiTEFaWV9NQVBfRkxBRyIsIkxBWllfV0hJTEVfRkxBRyIsIklORklOSVRZIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJNQVhfQVJSQVlfTEVOR1RIIiwiTUFYX0FSUkFZX0lOREVYIiwiSEFMRl9NQVhfQVJSQVlfTEVOR1RIIiwid3JhcEZsYWdzIiwiZG9tRXhjVGFnIiwicHJvbWlzZVRhZyIsInN5bWJvbFRhZyIsIndlYWtTZXRUYWciLCJyZUVtcHR5U3RyaW5nTGVhZGluZyIsInJlRW1wdHlTdHJpbmdNaWRkbGUiLCJyZUVtcHR5U3RyaW5nVHJhaWxpbmciLCJyZUVzY2FwZWRIdG1sIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNFc2NhcGVkSHRtbCIsInJlSGFzVW5lc2NhcGVkSHRtbCIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInJlSW50ZXJwb2xhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwicmVQcm9wTmFtZSIsInJlUmVnRXhwQ2hhciIsInJlSGFzUmVnRXhwQ2hhciIsInJlVHJpbVN0YXJ0IiwicmVXaGl0ZXNwYWNlIiwicmVXcmFwQ29tbWVudCIsInJlV3JhcERldGFpbHMiLCJyZVNwbGl0RGV0YWlscyIsInJlQXNjaWlXb3JkIiwicmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMiLCJyZUVzY2FwZUNoYXIiLCJyZUVzVGVtcGxhdGUiLCJyZUZsYWdzIiwicmVJc0JhZEhleCIsInJlSXNCaW5hcnkiLCJyZUlzSG9zdEN0b3IiLCJyZUlzT2N0YWwiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc09yZExvd2VyIiwicnNPcmRVcHBlciIsInJzU2VxIiwicnNFbW9qaSIsInJzU3ltYm9sIiwicmVBcG9zIiwicmVDb21ib01hcmsiLCJyZVVuaWNvZGUiLCJyZVVuaWNvZGVXb3JkIiwicmVIYXNVbmljb2RlIiwicmVIYXNVbmljb2RlV29yZCIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsImNsb25lYWJsZVRhZ3MiLCJkZWJ1cnJlZExldHRlcnMiLCJodG1sRXNjYXBlcyIsImh0bWxVbmVzY2FwZXMiLCJzdHJpbmdFc2NhcGVzIiwiZnJlZVBhcnNlRmxvYXQiLCJmcmVlUGFyc2VJbnQiLCJub2RlSXNBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXIiLCJub2RlSXNEYXRlIiwiaXNEYXRlIiwibm9kZUlzTWFwIiwiaXNNYXAiLCJub2RlSXNSZWdFeHAiLCJpc1JlZ0V4cCIsIm5vZGVJc1NldCIsImlzU2V0IiwidGhpc0FyZyIsImFycmF5QWdncmVnYXRvciIsImFycmF5RWFjaFJpZ2h0IiwiYXJyYXlFdmVyeSIsInByZWRpY2F0ZSIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJhcnJheUluY2x1ZGVzIiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJhcnJheU1hcCIsImFycmF5UHVzaCIsImFycmF5UmVkdWNlIiwiaW5pdEFjY3VtIiwiYXJyYXlSZWR1Y2VSaWdodCIsImFycmF5U29tZSIsImFzY2lpU2l6ZSIsImJhc2VQcm9wZXJ0eSIsImFzY2lpVG9BcnJheSIsInN0cmluZyIsImFzY2lpV29yZHMiLCJiYXNlRmluZEtleSIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJzdHJpY3RJbmRleE9mIiwiYmFzZUlzTmFOIiwiYmFzZUluZGV4T2ZXaXRoIiwiYmFzZU1lYW4iLCJiYXNlU3VtIiwiYmFzZVByb3BlcnR5T2YiLCJiYXNlUmVkdWNlIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVyIiwiYmFzZVRvUGFpcnMiLCJiYXNlVHJpbSIsInRyaW1tZWRFbmRJbmRleCIsImJhc2VWYWx1ZXMiLCJjYWNoZUhhcyIsImhhcyIsImNoYXJzU3RhcnRJbmRleCIsInN0clN5bWJvbHMiLCJjaHJTeW1ib2xzIiwiY2hhcnNFbmRJbmRleCIsImNvdW50SG9sZGVycyIsInBsYWNlaG9sZGVyIiwiZGVidXJyTGV0dGVyIiwiZXNjYXBlSHRtbENoYXIiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiZ2V0VmFsdWUiLCJoYXNVbmljb2RlIiwiaGFzVW5pY29kZVdvcmQiLCJpdGVyYXRvclRvQXJyYXkiLCJpdGVyYXRvciIsImRvbmUiLCJtYXBUb0FycmF5Iiwic2l6ZSIsInJlcGxhY2VIb2xkZXJzIiwic2V0VG9BcnJheSIsInNldFRvUGFpcnMiLCJzdHJpY3RMYXN0SW5kZXhPZiIsInN0cmluZ1NpemUiLCJ1bmljb2RlU2l6ZSIsInN0cmluZ1RvQXJyYXkiLCJ1bmljb2RlVG9BcnJheSIsInVuZXNjYXBlSHRtbENoYXIiLCJ1bmljb2RlV29yZHMiLCJydW5JbkNvbnRleHQiLCJwaWNrIiwiYXJyYXlQcm90byIsImZ1bmNQcm90byIsImNvcmVKc0RhdGEiLCJmdW5jVG9TdHJpbmciLCJpZENvdW50ZXIiLCJtYXNrU3JjS2V5IiwidWlkIiwiSUVfUFJPVE8iLCJvYmplY3RDdG9yU3RyaW5nIiwib2xkRGFzaCIsInJlSXNOYXRpdmUiLCJVaW50OEFycmF5IiwiYWxsb2NVbnNhZmUiLCJnZXRQcm90b3R5cGUiLCJvYmplY3RDcmVhdGUiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwic3ltSXRlcmF0b3IiLCJnZXROYXRpdmUiLCJjdHhDbGVhclRpbWVvdXQiLCJjdHhOb3ciLCJjdHhTZXRUaW1lb3V0IiwibmF0aXZlQ2VpbCIsImNlaWwiLCJuYXRpdmVGbG9vciIsIm5hdGl2ZUdldFN5bWJvbHMiLCJuYXRpdmVJc0Zpbml0ZSIsImlzRmluaXRlIiwibmF0aXZlSm9pbiIsIm5hdGl2ZU1heCIsIm5hdGl2ZU1pbiIsIm5hdGl2ZU5vdyIsIm5hdGl2ZVBhcnNlSW50IiwibmF0aXZlUmFuZG9tIiwibmF0aXZlUmV2ZXJzZSIsIkRhdGFWaWV3IiwiTWFwIiwiU2V0IiwiV2Vha01hcCIsIm5hdGl2ZUNyZWF0ZSIsIm1ldGFNYXAiLCJyZWFsTmFtZXMiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJ0b1NvdXJjZSIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJzeW1ib2xUb1N0cmluZyIsImxvZGFzaCIsIkxhenlXcmFwcGVyIiwiTG9kYXNoV3JhcHBlciIsIndyYXBwZXJDbG9uZSIsImJhc2VDcmVhdGUiLCJiYXNlTG9kYXNoIiwiY2hhaW5BbGwiLCJfX3dyYXBwZWRfXyIsIl9fYWN0aW9uc19fIiwiX19jaGFpbl9fIiwiX19pbmRleF9fIiwiX192YWx1ZXNfXyIsInRlbXBsYXRlU2V0dGluZ3MiLCJfX2Rpcl9fIiwiX19maWx0ZXJlZF9fIiwiX19pdGVyYXRlZXNfXyIsIl9fdGFrZUNvdW50X18iLCJfX3ZpZXdzX18iLCJsYXp5Q2xvbmUiLCJjb3B5QXJyYXkiLCJsYXp5UmV2ZXJzZSIsImNsb25lIiwibGF6eVZhbHVlIiwiZGlyIiwiaXNSaWdodCIsImFyckxlbmd0aCIsInZpZXciLCJnZXRWaWV3IiwiaXRlcmF0ZWVzIiwiaXRlckxlbmd0aCIsInRha2VDb3VudCIsImJhc2VXcmFwcGVyVmFsdWUiLCJvdXRlciIsIml0ZXJJbmRleCIsImNvbXB1dGVkIiwiSGFzaCIsImVudHJpZXMiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJMaXN0Q2FjaGUiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIk1hcENhY2hlIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIlNldENhY2hlIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlN0YWNrIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwicGFpcnMiLCJhcnJheVNhbXBsZSIsImJhc2VSYW5kb20iLCJhcnJheVNhbXBsZVNpemUiLCJzaHVmZmxlU2VsZiIsImJhc2VDbGFtcCIsImFycmF5U2h1ZmZsZSIsImFzc2lnbk1lcmdlVmFsdWUiLCJlcSIsImJhc2VBc3NpZ25WYWx1ZSIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJiYXNlQWdncmVnYXRvciIsImJhc2VBc3NpZ24iLCJjb3B5T2JqZWN0IiwiYmFzZUFzc2lnbkluIiwia2V5c0luIiwiYmFzZUF0IiwicGF0aHMiLCJza2lwIiwibG93ZXIiLCJ1cHBlciIsImJhc2VDbG9uZSIsImJpdG1hc2siLCJjdXN0b21pemVyIiwic3RhY2siLCJpc0RlZXAiLCJpc0ZsYXQiLCJpc0Z1bGwiLCJpbml0Q2xvbmVBcnJheSIsImdldFRhZyIsImNsb25lQnVmZmVyIiwiaW5pdENsb25lT2JqZWN0IiwiY29weVN5bWJvbHNJbiIsImNvcHlTeW1ib2xzIiwiaW5pdENsb25lQnlUYWciLCJzdGFja2VkIiwic3ViVmFsdWUiLCJnZXRBbGxLZXlzSW4iLCJnZXRBbGxLZXlzIiwiYmFzZUNvbmZvcm1zIiwiYmFzZUNvbmZvcm1zVG8iLCJiYXNlRGVsYXkiLCJ3YWl0IiwiYmFzZURpZmZlcmVuY2UiLCJpc0NvbW1vbiIsInZhbHVlc0xlbmd0aCIsInZhbHVlc0luZGV4IiwiYmFzZUVhY2hSaWdodCIsImJhc2VGb3JPd25SaWdodCIsImJhc2VFdmVyeSIsImJhc2VFeHRyZW11bSIsImlzU3ltYm9sIiwiYmFzZUZpbGwiLCJ0b0ludGVnZXIiLCJ0b0xlbmd0aCIsImJhc2VGaWx0ZXIiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwiaXNGbGF0dGVuYWJsZSIsImJhc2VGb3JSaWdodCIsImJhc2VGdW5jdGlvbnMiLCJiYXNlR2V0IiwicGF0aCIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYmFzZUd0Iiwib3RoZXIiLCJiYXNlSGFzIiwiYmFzZUhhc0luIiwiYmFzZUluUmFuZ2UiLCJiYXNlSW50ZXJzZWN0aW9uIiwiYXJyYXlzIiwib3RoTGVuZ3RoIiwib3RoSW5kZXgiLCJjYWNoZXMiLCJtYXhMZW5ndGgiLCJzZWVuIiwiYmFzZUludmVydGVyIiwiYmFzZUludm9rZSIsImJhc2VJc0FycmF5QnVmZmVyIiwiYmFzZUlzRGF0ZSIsImJhc2VJc0VxdWFsIiwiYmFzZUlzRXF1YWxEZWVwIiwiZXF1YWxGdW5jIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNNYXAiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsInNyY1ZhbHVlIiwiYmFzZUlzTmF0aXZlIiwiaXNNYXNrZWQiLCJwYXR0ZXJuIiwiYmFzZUlzUmVnRXhwIiwiYmFzZUlzU2V0IiwiYmFzZUl0ZXJhdGVlIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VNYXRjaGVzIiwiYmFzZUtleXNJbiIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlTHQiLCJiYXNlTWFwIiwiZ2V0TWF0Y2hEYXRhIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJpc0tleSIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImhhc0luIiwiYmFzZU1lcmdlIiwic3JjSW5kZXgiLCJiYXNlTWVyZ2VEZWVwIiwibmV3VmFsdWUiLCJzYWZlR2V0IiwibWVyZ2VGdW5jIiwiaXNUeXBlZCIsImlzQXJyYXlMaWtlT2JqZWN0IiwiY2xvbmVUeXBlZEFycmF5IiwiaXNQbGFpbk9iamVjdCIsInRvUGxhaW5PYmplY3QiLCJiYXNlTnRoIiwiYmFzZU9yZGVyQnkiLCJvcmRlcnMiLCJnZXRJdGVyYXRlZSIsImNyaXRlcmlhIiwiY29tcGFyZU11bHRpcGxlIiwiYmFzZVBpY2siLCJiYXNlUGlja0J5IiwiYmFzZVNldCIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlUHVsbEFsbCIsImJhc2VQdWxsQXQiLCJpbmRleGVzIiwicHJldmlvdXMiLCJiYXNlVW5zZXQiLCJiYXNlUmFuZ2UiLCJzdGVwIiwiYmFzZVJlcGVhdCIsImJhc2VSZXN0Iiwic2V0VG9TdHJpbmciLCJvdmVyUmVzdCIsImJhc2VTYW1wbGUiLCJiYXNlU2FtcGxlU2l6ZSIsImJhc2VTZXREYXRhIiwiYmFzZVNldFRvU3RyaW5nIiwiY29uc3RhbnQiLCJiYXNlU2h1ZmZsZSIsImJhc2VTbGljZSIsImJhc2VTb21lIiwiYmFzZVNvcnRlZEluZGV4IiwicmV0SGlnaGVzdCIsImxvdyIsImhpZ2giLCJtaWQiLCJiYXNlU29ydGVkSW5kZXhCeSIsInZhbElzTmFOIiwidmFsSXNOdWxsIiwidmFsSXNTeW1ib2wiLCJ2YWxJc1VuZGVmaW5lZCIsIm90aElzRGVmaW5lZCIsIm90aElzTnVsbCIsIm90aElzUmVmbGV4aXZlIiwib3RoSXNTeW1ib2wiLCJzZXRMb3ciLCJiYXNlU29ydGVkVW5pcSIsImJhc2VUb051bWJlciIsImJhc2VUb1N0cmluZyIsImJhc2VVbmlxIiwiY3JlYXRlU2V0Iiwic2VlbkluZGV4IiwiYmFzZVVwZGF0ZSIsInVwZGF0ZXIiLCJiYXNlV2hpbGUiLCJpc0Ryb3AiLCJhY3Rpb25zIiwiYWN0aW9uIiwiYmFzZVhvciIsImJhc2VaaXBPYmplY3QiLCJhc3NpZ25GdW5jIiwidmFsc0xlbmd0aCIsImNhc3RBcnJheUxpa2VPYmplY3QiLCJzdHJpbmdUb1BhdGgiLCJjYXN0UmVzdCIsImNhc3RTbGljZSIsImJ1ZmZlciIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZURhdGFWaWV3IiwiZGF0YVZpZXciLCJieXRlT2Zmc2V0IiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsInR5cGVkQXJyYXkiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNSZWZsZXhpdmUiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiaXNOZXciLCJnZXRTeW1ib2xzIiwiZ2V0U3ltYm9sc0luIiwiY3JlYXRlQWdncmVnYXRvciIsImluaXRpYWxpemVyIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsImlzSXRlcmF0ZWVDYWxsIiwiY3JlYXRlQmluZCIsImlzQmluZCIsImNyZWF0ZUN0b3IiLCJmbiIsImNyZWF0ZUNhc2VGaXJzdCIsIm1ldGhvZE5hbWUiLCJ0cmFpbGluZyIsImNyZWF0ZUNvbXBvdW5kZXIiLCJkZWJ1cnIiLCJ0aGlzQmluZGluZyIsImNyZWF0ZUN1cnJ5IiwiYXJpdHkiLCJnZXRIb2xkZXIiLCJjcmVhdGVSZWN1cnJ5IiwiY3JlYXRlSHlicmlkIiwiY3JlYXRlRmluZCIsImZpbmRJbmRleEZ1bmMiLCJjcmVhdGVGbG93IiwiZmxhdFJlc3QiLCJmdW5jcyIsInByZXJlcSIsInRocnUiLCJnZXRGdW5jTmFtZSIsImZ1bmNOYW1lIiwiZ2V0RGF0YSIsImlzTGF6aWFibGUiLCJwbGFudCIsInBhcnRpYWxzUmlnaHQiLCJob2xkZXJzUmlnaHQiLCJhcmdQb3MiLCJhcnkiLCJpc0FyeSIsImlzQmluZEtleSIsImlzRmxpcCIsImhvbGRlcnNDb3VudCIsIm5ld0hvbGRlcnMiLCJyZW9yZGVyIiwiY3JlYXRlSW52ZXJ0ZXIiLCJ0b0l0ZXJhdGVlIiwiY3JlYXRlTWF0aE9wZXJhdGlvbiIsIm9wZXJhdG9yIiwiZGVmYXVsdFZhbHVlIiwiY3JlYXRlT3ZlciIsImFycmF5RnVuYyIsImNyZWF0ZVBhZGRpbmciLCJjaGFycyIsImNoYXJzTGVuZ3RoIiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVJhbmdlIiwidG9GaW5pdGUiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwidG9OdW1iZXIiLCJ3cmFwRnVuYyIsImlzQ3VycnkiLCJuZXdIb2xkZXJzUmlnaHQiLCJuZXdQYXJ0aWFscyIsIm5ld1BhcnRpYWxzUmlnaHQiLCJuZXdEYXRhIiwic2V0RGF0YSIsInNldFdyYXBUb1N0cmluZyIsImNyZWF0ZVJvdW5kIiwicHJlY2lzaW9uIiwicGFpciIsIm5vb3AiLCJjcmVhdGVUb1BhaXJzIiwiY3JlYXRlV3JhcCIsIm1lcmdlRGF0YSIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJjdXN0b21EZWZhdWx0c01lcmdlIiwiY3VzdG9tT21pdENsb25lIiwiaXNQYXJ0aWFsIiwiYXJyU3RhY2tlZCIsIm90aFN0YWNrZWQiLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJjb252ZXJ0Iiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsIm9ialN0YWNrZWQiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiZmxhdHRlbiIsIm90aGVyRnVuYyIsImlzS2V5YWJsZSIsInN0dWJBcnJheSIsImN0b3JTdHJpbmciLCJnZXRXcmFwRGV0YWlscyIsImhhc1BhdGgiLCJoYXNGdW5jIiwiaW5zZXJ0V3JhcERldGFpbHMiLCJkZXRhaWxzIiwiaXNNYXNrYWJsZSIsIm1lbW9pemVDYXBwZWQiLCJtZW1vaXplIiwic3JjQml0bWFzayIsIm5ld0JpdG1hc2siLCJpc0NvbWJvIiwib3RoZXJBcmdzIiwib2xkQXJyYXkiLCJzaG9ydE91dCIsInJlZmVyZW5jZSIsInVwZGF0ZVdyYXBEZXRhaWxzIiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwicmFuZCIsInF1b3RlIiwic3ViU3RyaW5nIiwiY29tcGFjdCIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlQnkiLCJkaWZmZXJlbmNlV2l0aCIsImRyb3AiLCJkcm9wUmlnaHQiLCJkcm9wUmlnaHRXaGlsZSIsImRyb3BXaGlsZSIsImZpbGwiLCJmaW5kSW5kZXgiLCJmaW5kTGFzdEluZGV4IiwiZmxhdHRlbkRlZXAiLCJmbGF0dGVuRGVwdGgiLCJmcm9tUGFpcnMiLCJoZWFkIiwiaW5pdGlhbCIsImludGVyc2VjdGlvbiIsIm1hcHBlZCIsImludGVyc2VjdGlvbkJ5IiwiaW50ZXJzZWN0aW9uV2l0aCIsInNlcGFyYXRvciIsIm50aCIsInB1bGwiLCJwdWxsQWxsIiwicHVsbEFsbEJ5IiwicHVsbEFsbFdpdGgiLCJwdWxsQXQiLCJzb3J0ZWRJbmRleCIsInNvcnRlZEluZGV4QnkiLCJzb3J0ZWRJbmRleE9mIiwic29ydGVkTGFzdEluZGV4Iiwic29ydGVkTGFzdEluZGV4QnkiLCJzb3J0ZWRMYXN0SW5kZXhPZiIsInNvcnRlZFVuaXEiLCJzb3J0ZWRVbmlxQnkiLCJ0YWlsIiwidGFrZSIsInRha2VSaWdodCIsInRha2VSaWdodFdoaWxlIiwidGFrZVdoaWxlIiwidW5pb24iLCJ1bmlvbkJ5IiwidW5pb25XaXRoIiwidW5pcSIsInVuaXFCeSIsInVuaXFXaXRoIiwidW56aXAiLCJncm91cCIsInVuemlwV2l0aCIsIndpdGhvdXQiLCJ4b3IiLCJ4b3JCeSIsInhvcldpdGgiLCJ6aXAiLCJ6aXBPYmplY3QiLCJ6aXBPYmplY3REZWVwIiwiemlwV2l0aCIsImNoYWluIiwidGFwIiwiaW50ZXJjZXB0b3IiLCJ3cmFwcGVyQXQiLCJ3cmFwcGVyQ2hhaW4iLCJ3cmFwcGVyQ29tbWl0Iiwid3JhcHBlck5leHQiLCJ3cmFwcGVyVG9JdGVyYXRvciIsIndyYXBwZXJQbGFudCIsIndyYXBwZXJSZXZlcnNlIiwid3JhcHBlclZhbHVlIiwiY291bnRCeSIsImV2ZXJ5IiwiZmlsdGVyIiwiZmluZCIsImZpbmRMYXN0IiwiZmxhdE1hcCIsImZsYXRNYXBEZWVwIiwiZmxhdE1hcERlcHRoIiwiZm9yRWFjaFJpZ2h0IiwiZ3JvdXBCeSIsImludm9rZU1hcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZVJpZ2h0IiwibmVnYXRlIiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsImFmdGVyIiwiYmVmb3JlIiwiYmluZEtleSIsImN1cnJ5IiwiY3VycnlSaWdodCIsImRlYm91bmNlIiwib3B0aW9ucyIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsImludm9rZUZ1bmMiLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsImRlZmVyIiwiZmxpcCIsIm1lbW9pemVkIiwiQ2FjaGUiLCJvdmVyQXJncyIsImZ1bmNzTGVuZ3RoIiwicGFydGlhbCIsInBhcnRpYWxSaWdodCIsInJlYXJnIiwicmVzdCIsInNwcmVhZCIsInRocm90dGxlIiwidW5hcnkiLCJjYXN0QXJyYXkiLCJjbG9uZVdpdGgiLCJjbG9uZURlZXAiLCJjbG9uZURlZXBXaXRoIiwiY29uZm9ybXNUbyIsImd0IiwiZ3RlIiwiaXNCb29sZWFuIiwiaXNFbGVtZW50IiwiaXNFbXB0eSIsImlzRXF1YWwiLCJpc0VxdWFsV2l0aCIsImlzRXJyb3IiLCJpc0ludGVnZXIiLCJpc01hdGNoIiwiaXNNYXRjaFdpdGgiLCJpc051bWJlciIsImlzTmF0aXZlIiwiaXNOdWxsIiwiaXNOaWwiLCJpc1NhZmVJbnRlZ2VyIiwiaXNVbmRlZmluZWQiLCJpc1dlYWtNYXAiLCJpc1dlYWtTZXQiLCJsdCIsImx0ZSIsInNpZ24iLCJyZW1haW5kZXIiLCJpc0JpbmFyeSIsInRvU2FmZUludGVnZXIiLCJhc3NpZ25JbiIsImFzc2lnbkluV2l0aCIsImFzc2lnbldpdGgiLCJhdCIsInByb3BlcnRpZXMiLCJwcm9wc0luZGV4IiwicHJvcHNMZW5ndGgiLCJkZWZhdWx0c0RlZXAiLCJtZXJnZVdpdGgiLCJmaW5kS2V5IiwiZmluZExhc3RLZXkiLCJmb3JJbiIsImZvckluUmlnaHQiLCJmb3JPd24iLCJmb3JPd25SaWdodCIsImZ1bmN0aW9uc0luIiwiaW52ZXJ0IiwiaW52ZXJ0QnkiLCJpbnZva2UiLCJtYXBLZXlzIiwibWFwVmFsdWVzIiwibWVyZ2UiLCJvbWl0Iiwib21pdEJ5IiwicGlja0J5Iiwic2V0V2l0aCIsInRvUGFpcnMiLCJ0b1BhaXJzSW4iLCJpc0Fyckxpa2UiLCJ1bnNldCIsInVwZGF0ZVdpdGgiLCJ2YWx1ZXNJbiIsImZsb2F0aW5nIiwiY2FtZWxDYXNlIiwiY2FwaXRhbGl6ZSIsInVwcGVyRmlyc3QiLCJlbmRzV2l0aCIsImVzY2FwZSIsImVzY2FwZVJlZ0V4cCIsImtlYmFiQ2FzZSIsImxvd2VyQ2FzZSIsImxvd2VyRmlyc3QiLCJwYWQiLCJzdHJMZW5ndGgiLCJwYWRFbmQiLCJwYWRTdGFydCIsInJhZGl4Iiwic25ha2VDYXNlIiwibGltaXQiLCJzdGFydENhc2UiLCJzdGFydHNXaXRoIiwic2V0dGluZ3MiLCJpbXBvcnRzIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFc2NhcGluZyIsImlzRXZhbHVhdGluZyIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsInZhcmlhYmxlIiwiYXR0ZW1wdCIsInRvTG93ZXIiLCJ0b1VwcGVyIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInRydW5jYXRlIiwib21pc3Npb24iLCJzZWFyY2giLCJuZXdFbmQiLCJ1bmVzY2FwZSIsInVwcGVyQ2FzZSIsImJpbmRBbGwiLCJtZXRob2ROYW1lcyIsImNvbmQiLCJjb25mb3JtcyIsImRlZmF1bHRUbyIsImZsb3ciLCJmbG93UmlnaHQiLCJtYXRjaGVzIiwibWF0Y2hlc1Byb3BlcnR5IiwibWV0aG9kIiwibWV0aG9kT2YiLCJtaXhpbiIsIm5vQ29uZmxpY3QiLCJudGhBcmciLCJvdmVyIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwcm9wZXJ0eU9mIiwicmFuZ2VSaWdodCIsInN0dWJPYmplY3QiLCJzdHViU3RyaW5nIiwic3R1YlRydWUiLCJ0aW1lcyIsInRvUGF0aCIsInVuaXF1ZUlkIiwicHJlZml4IiwiYXVnZW5kIiwiYWRkZW5kIiwiZGl2aWRlIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwibWF4QnkiLCJtZWFuIiwibWVhbkJ5IiwibWluQnkiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJtdWx0aXBsaWNhbmQiLCJzdWJ0cmFjdCIsIm1pbnVlbmQiLCJzdWJ0cmFoZW5kIiwic3VtIiwic3VtQnkiLCJlbnRyaWVzSW4iLCJleHRlbmQiLCJleHRlbmRXaXRoIiwiZWFjaFJpZ2h0IiwiaXNGaWx0ZXIiLCJ0YWtlTmFtZSIsImRyb3BOYW1lIiwiY2hlY2tJdGVyYXRlZSIsImlzVGFrZXIiLCJsb2Rhc2hGdW5jIiwicmV0VW53cmFwcGVkIiwiaXNMYXp5IiwidXNlTGF6eSIsImlzSHlicmlkIiwiaXNVbndyYXBwZWQiLCJvbmx5TGF6eSIsImNoYWluTmFtZSIsImNvbW1pdCIsInRvSlNPTiIsImRlZmluZSIsImFtZCIsIm5vcm1hbGl6ZVVybCIsInNyY0J5TW9kdWxlSWQiLCJub0RvY3VtZW50IiwidGltZW91dCIsImZ1bmN0aW9uQ2FsbCIsImdldEN1cnJlbnRTY3JpcHRVcmwiLCJtb2R1bGVJZCIsImN1cnJlbnRTY3JpcHQiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJsYXN0U2NyaXB0VGFnIiwiZmlsZU1hcCIsInNwbGl0UmVzdWx0IiwiZmlsZW5hbWUiLCJtYXBSdWxlIiwicmVnIiwidXBkYXRlQ3NzIiwiaXNVcmxSZXF1ZXN0IiwiaXNMb2FkZWQiLCJ2aXNpdGVkIiwibmV3RWwiLCJjbG9uZU5vZGUiLCJnZXRSZWxvYWRVcmwiLCJzdHJpcFdXVyIsInJlbG9hZFN0eWxlIiwibG9hZGVkIiwicmVsb2FkQWxsIiwiZ2V0U2NyaXB0U3JjIiwicmVsb2FkZWQiLCJsb2NhbHMiLCJwYXRoQ29tcG9uZW50cyIsInVybFN0cmluZyIsInByb3RvY29sIiwiY29tcG9uZW50cyIsImhvc3QiLCJwcmVmaXhlcyIsIm1lbW8iLCJjaGFyIiwiS2V5IiwicHJlZml4TWVtb3ppZWQiLCJwcmVmaXhEYXNoZWQiLCJkYXNoIiwicXMiLCJzZXAiLCJtYXhLZXlzIiwiaWR4Iiwia3N0ciIsInZzdHIiLCJrIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3RyaW5naWZ5UHJpbWl0aXZlIiwia3MiLCJlbmNvZGVVUklDb21wb25lbnQiLCJwYXJzZSIsInN0cmluZ2lmeSIsInB1bnljb2RlIiwibWF4SW50IiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJtYXBEb21haW4iLCJwYXJ0cyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJpbnB1dExlbmd0aCIsIm91dCIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJiYXNlTWludXNUIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwidG9Vbmljb2RlIiwidG9BU0NJSSIsInV0aWwiLCJ1cmxQYXJzZSIsInVybFJlc29sdmUiLCJyZXNvbHZlT2JqZWN0IiwidXJsUmVzb2x2ZU9iamVjdCIsInVybEZvcm1hdCIsIlVybCIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsImhvc3RuYW1lIiwiaGFzaCIsInF1ZXJ5IiwicGF0aG5hbWUiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJxdWVyeUluZGV4Iiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzbGFzaFJlZ2V4Iiwic2ltcGxlUGF0aCIsImxvd2VyUHJvdG8iLCJob3N0RW5kIiwiaGVjIiwiYXRTaWduIiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsImFlIiwiZXNjIiwicW0iLCJyZWwiLCJ0a2V5cyIsInRrIiwidGtleSIsInJrZXlzIiwicmsiLCJya2V5IiwicmVsUGF0aCIsImlzU291cmNlQWJzIiwiaXNSZWxBYnMiLCJtdXN0RW5kQWJzIiwicmVtb3ZlQWxsRG90cyIsInNyY1BhdGgiLCJwc3ljaG90aWMiLCJpc051bGxPclVuZGVmaW5lZCIsImF1dGhJbkhvc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJpc0Fic29sdXRlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiV2ViU29ja2V0Q2xpZW50IiwiY2xpZW50IiwiV2ViU29ja2V0Iiwib25lcnJvciIsIm9uT3BlbiIsIm9ub3BlbiIsIm9uQ2xvc2UiLCJvbmNsb3NlIiwib25NZXNzYWdlIiwib25tZXNzYWdlIiwid2VicGFja0hvdExvZyIsInN0cmlwQW5zaSIsInBhcnNlVVJMIiwic29ja2V0Iiwic2V0TG9nTGV2ZWwiLCJzZW5kTWVzc2FnZSIsInJlbG9hZEFwcCIsImNyZWF0ZVNvY2tldFVSTCIsImlzVW5sb2FkaW5nIiwiY3VycmVudEhhc2giLCJfX3dlYnBhY2tfaGFzaF9fIiwiaG90IiwibGl2ZVJlbG9hZCIsIm92ZXJsYXkiLCJwYXJzZWRSZXNvdXJjZVF1ZXJ5IiwiX19yZXNvdXJjZVF1ZXJ5IiwiaW5mbyIsImxvZ2dpbmciLCJzZXRBbGxMb2dMZXZlbCIsIm9uU29ja2V0TWVzc2FnZSIsImludmFsaWQiLCJfaGFzaCIsInByZXZpb3VzSGFzaCIsIl9wcm9ncmVzcyIsInByb2dyZXNzVXBkYXRlIiwibXNnIiwic3RpbGxPayIsIm9rIiwiY29udGVudENoYW5nZWQiLCJmaWxlIiwibG9jYXRpb24iLCJyZWxvYWQiLCJzdGF0aWNDaGFuZ2VkIiwid2FybmluZ3MiLCJfd2FybmluZ3MiLCJzdHJpcHBlZFdhcm5pbmdzIiwibmVlZFNob3dPdmVybGF5Rm9yV2FybmluZ3MiLCJfZXJyb3JzIiwic3RyaXBwZWRFcnJvcnMiLCJuZWVkU2hvd092ZXJsYXlGb3JFcnJvcnMiLCJfZXJyb3IiLCJzb2NrZXRVUkwiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiY2xpZW50VGFwYWJsZVN5bmNCYWlsSG9vayIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIml0ZXIiLCJhcnIyIiwiTG9nVHlwZSIsImZyZWV6ZSIsImRlYnVnIiwidHJhY2UiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwicHJvZmlsZSIsInByb2ZpbGVFbmQiLCJMT0dfU1lNQk9MIiwiVElNRVJTX1NZTUJPTCIsIlRJTUVSU19BR0dSRUdBVEVTX1NZTUJPTCIsIldlYnBhY2tMb2dnZXIiLCJnZXRDaGlsZExvZ2dlciIsIl9sZW4zIiwiX2tleTMiLCJfbGVuNCIsIl9rZXk0IiwiX2xlbjUiLCJfa2V5NSIsImFzc2VydCIsImFzc2VydGlvbiIsIl9sZW42IiwiX2tleTYiLCJfbGVuNyIsIl9rZXk3IiwiX2xlbjgiLCJfa2V5OCIsIl9sZW45IiwiX2tleTkiLCJfbGVuMTAiLCJfa2V5MTAiLCJocnRpbWUiLCJ0aW1lTG9nIiwidGltZUVuZCIsImRlbGV0ZSIsInRpbWVBZ2dyZWdhdGUiLCJ0aW1lQWdncmVnYXRlRW5kIiwiTG9nZ2VyIiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIl9yZXF1aXJlIiwiZmlsdGVyVG9GdW5jdGlvbiIsInJlZ0V4cCIsImlkZW50IiwiTG9nTGV2ZWwiLCJmYWxzZSIsInRydWUiLCJ2ZXJib3NlIiwiX3JlZiRsZXZlbCIsIl9yZWYkZGVidWciLCJkZWJ1Z0ZpbHRlcnMiLCJsb2dsZXZlbCIsImxvZ2dlciIsImxhYmVsZWRBcmdzIiwibXMiLCJsb2dUaW1lIiwiX2V4dGVuZHMiLCJTeW5jQmFpbEhvb2siLCJjcmVhdGVDb25zb2xlTG9nZ2VyIiwiY3VycmVudERlZmF1bHRMb2dnZXJPcHRpb25zIiwiY3VycmVudERlZmF1bHRMb2dnZXIiLCJnZXRMb2dnZXIiLCJob29rcyIsImNoaWxkTmFtZSIsImNvbmZpZ3VyZURlZmF1bHRMb2dnZXIiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJjYWNoZWRNb2R1bGUiLCJkZWZpbml0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsIndlYnBhY2tfbGliX2xvZ2dpbmdfcnVudGltZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXyIsIl9fZXNNb2R1bGUiLCJfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXyIsImFuc2lfcmVnZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImFuc2lSZWdleCIsIl9yZWYkb25seUZpcnN0Iiwib25seUZpcnN0Iiwic3RyaXBfYW5zaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiaWZyYW1lQ29udGFpbmVyRWxlbWVudCIsImNvbnRhaW5lckVsZW1lbnQiLCJvbkxvYWRRdWV1ZSIsImNyZWF0ZUNvbnRhaW5lciIsImJvcmRlciIsInpJbmRleCIsImNvbnRlbnREb2N1bWVudCIsImJveFNpemluZyIsImJhY2tncm91bmRDb2xvciIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsInBhZGRpbmciLCJ3aGl0ZVNwYWNlIiwib3ZlcmZsb3ciLCJoZWFkZXJFbGVtZW50IiwiaW5uZXJUZXh0IiwiY2xvc2VCdXR0b25FbGVtZW50IiwiYmFja2dyb3VuZCIsImZvbnRXZWlnaHQiLCJjdXJzb3IiLCJjc3NGbG9hdCIsInN0eWxlRmxvYXQiLCJvbkxvYWQiLCJlbnN1cmVPdmVybGF5RXhpc3RzIiwibWVzc2FnZXMiLCJlbnRyeUVsZW1lbnQiLCJ0eXBlRWxlbWVudCIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2VUZXh0Tm9kZSIsIkNsaWVudCIsIl9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIiwicmV0cmllcyIsImluaXRTb2NrZXQiLCJoYW5kbGVycyIsInJldHJ5SW5NcyIsIkpTT04iLCJwYXJzZWRVUkwiLCJpc0luQWRkckFueSIsInNvY2tldFVSTFByb3RvY29sIiwic29ja2V0VVJMQXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJzb2NrZXRVUkxIb3N0bmFtZSIsInNvY2tldFVSTFBvcnQiLCJzb2NrZXRVUkxQYXRobmFtZSIsImZyb21DdXJyZW50U2NyaXB0IiwiZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSIsInNjcmlwdEVsZW1lbnRzIiwic2NyaXB0RWxlbWVudHNXaXRoU3JjIiwiZGVmYXVsdExldmVsIiwicmVzb3VyY2VRdWVyeSIsInNlYXJjaFBhcmFtcyIsInNjcmlwdFNvdXJjZSIsInNjcmlwdFNvdXJjZVVSTCIsIlVSTCIsImhvdEVtaXR0ZXIiLCJpc0luaXRpYWwiLCJhcHBseVJlbG9hZCIsInJvb3RXaW5kb3ciLCJpbnRlcnZhbElkIiwiY2xlYXJJbnRlcnZhbCIsImFsbG93VG9Ib3QiLCJhbGxvd1RvTGl2ZVJlbG9hZCIsInBvc3RNZXNzYWdlIiwic2V0SW50ZXJ2YWwiLCJzZW5kTXNnIiwiV29ya2VyR2xvYmFsU2NvcGUiLCJsYXN0SGFzaCIsInVwVG9EYXRlIiwiY2hlY2siLCJ1cGRhdGVkTW9kdWxlcyIsImNhdGNoIiwiZm9ybWF0RXJyb3IiLCJyZW5ld2VkTW9kdWxlcyIsInVuYWNjZXB0ZWRNb2R1bGVzIiwibnVtYmVySWRzIiwibG9nTGV2ZWwiLCJkdW1teSIsInNob3VsZExvZyIsImxvZ0dyb3VwIiwibG9nRm4iXSwic291cmNlUm9vdCI6IiJ9