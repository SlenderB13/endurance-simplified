/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./app/classes/Component.js":
/*!**********************************!*\
  !*** ./app/classes/Component.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js");
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_each__WEBPACK_IMPORTED_MODULE_1__);


class Component extends (events__WEBPACK_IMPORTED_MODULE_0___default()) {
  constructor({
    element,
    elements
  }) {
    super();
    this.selector = element;
    this.selectorChildren = { ...elements
    };
    this.create();
    this.addEventListeners();
  }

  create() {
    this.element = document.querySelector(this.selector);
    this.elements = {};
    lodash_each__WEBPACK_IMPORTED_MODULE_1___default()(this.selectorChildren, (entry, key) => {
      if (entry instanceof window.HTMLElement || entry instanceof window.NodeList || Array.isArray(entry)) {
        this.elements[key] = entry;
      } else {
        this.elements[key] = document.querySelectorAll(entry);

        if (this.elements[key].lenght === 0) {
          this.elements[key] = null;
        } else if (this.elements[key].lenght === 1) {
          this.elements[key] = document.querySelector(entry);
        }
      }
    });
  }

  addEventListeners() {}

  removeEventListeners() {}

}

/***/ }),

/***/ "./app/classes/Page.js":
/*!*****************************!*\
  !*** ./app/classes/Page.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Page)
/* harmony export */ });
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js");
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_each__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prefix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prefix */ "./node_modules/prefix/index.js");
/* harmony import */ var prefix__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prefix__WEBPACK_IMPORTED_MODULE_1__);



class Page {
  constructor({
    id,
    element,
    elements
  }) {
    this.id = id;
    this.selector = element;
    this.selectorChildren = { ...elements
    };
    this.scroll = {
      current: 0,
      target: 0,
      limit: 4000
    };
    this.transformPrefix = prefix__WEBPACK_IMPORTED_MODULE_1___default()('left');
    this.addEventListeners();
    this.getCursor(); //this.onMouseWheel()
    // this.onMouseWheelEvent = this.onMouseWheel.bind(this)
  }

  create() {
    this.element = document.querySelector(this.selector);
    this.elements = {};
    lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(this.selectorChildren, (entry, key) => {
      if (entry instanceof window.HTMLElement || entry instanceof window.NodeList || Array.isArray(entry)) {
        this.elements[key] = entry;
      } else {
        this.elements[key] = document.querySelectorAll(entry);

        if (this.elements[key].length === 0) {
          this.elements[key] = null;
        } else if (this.elements[key].length === 1) {
          this.elements[key] = document.querySelector(entry);
        }
      } //TODO: check the video to see how is he using the elements[key] outside this each loop


      console.log(this.elements[key]);
    });
  }

  show() {
    this.animateIn = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].timeline();
    return new Promise(resolve => {
      gsap__WEBPACK_IMPORTED_MODULE_2__["default"].from(this.element, {
        autoAlpha: 0,
        onComplete: resolve
      });
    });
  }

  hide() {
    this.animateOut = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].timeline();
    return new Promise(resolve => {
      gsap__WEBPACK_IMPORTED_MODULE_2__["default"].to(this.element, {
        autoAlpha: 0,
        onComplete: resolve
      });
    });
  }

  update() {
    this.scroll.current = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].utils.interpolate(this.scroll.current, this.scroll.target, 0.1);
    this.scroll.current = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].utils.clamp(0, this.scroll.limit, this.scroll.current);
    lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(this.elements, item => {
      item.style[this.transformPrefix] = `-${this.scroll.current}px`;
    });
  }

  addEventListeners() {
    window.addEventListener('mousewheel', event => {
      const {
        deltaY
      } = event;
      this.scroll.target += deltaY;
    });
    window.addEventListener('mousemove', event => {
      this.cursor.style.left = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].utils.interpolate(this.cursor.style.left, event.clientX + 'px', 0.1);
      this.cursor.style.top = gsap__WEBPACK_IMPORTED_MODULE_2__["default"].utils.interpolate(this.cursor.style.top, event.clientY + 'px', 0.1);
    });
  }

  getCursor() {
    this.cursor = document.querySelector('.cursor');
  }

}

/***/ }),

/***/ "./app/components/Preloader.js":
/*!*************************************!*\
  !*** ./app/components/Preloader.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Preloader)
/* harmony export */ });
/* harmony import */ var classes_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classes/Component */ "./app/classes/Component.js");
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var utils_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/text */ "./app/utils/text.js");




class Preloader extends classes_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super({
      element: '.preloader',
      elements: {
        title: document.querySelector('.preloader__text__title'),
        number: document.querySelector('.preloader__number'),
        images: document.querySelectorAll('img')
      }
    });
    console.log(this.elements.title);
    this.length = 0;
    this.createLoader();
    (0,utils_text__WEBPACK_IMPORTED_MODULE_2__.split)({
      element: this.elements.title
    });
    (0,utils_text__WEBPACK_IMPORTED_MODULE_2__.split)({
      element: this.elements.title
    });
    (0,utils_text__WEBPACK_IMPORTED_MODULE_2__.split)({
      element: this.elements.title
    });
    this.elements.titleSpans = this.elements.title.querySelectorAll('span span span');
  }

  onAssetLoaded(image) {
    this.length += 1;
    const percent = Math.round(this.length / this.elements.images.length * 100);
    this.elements.number.innerHTML = `${percent}%`;

    if (percent === 100) {
      this.onLoaded();
    }
  }

  createLoader() {
    (0,lodash__WEBPACK_IMPORTED_MODULE_1__.each)(this.elements.images, element => {
      element.src = element.getAttribute('src');

      element.onload = _ => this.onAssetLoaded(element);
    });
  }

  onLoaded() {
    // TODO: ADD THE ANIMATIONS AFTER THE PAGE IS LOADED
    return new Promise(resolve => {
      /*  this.animateOut.to(this.element, {
        autoAlpha: 0,
        delay: 2
      }) */
      this.animateOut = gsap__WEBPACK_IMPORTED_MODULE_3__["default"].timeline();
      this.animateOut.to(this.elements.titleSpans, {
        stagger: 0.03,
        duration: 2,
        ease: 'expo.out',
        y: '-100%',
        delay: 0.5
      });
      this.animateOut.to(this.elements.number, {
        autoAlpha: 0,
        ease: 'expo.out',
        duration: 1
      });
      this.animateOut.to(this.element, {
        autoAlpha: 0,
        ease: 'expo.out',
        duration: 1
      });
    });
  }

  destroy() {
    this.element.parentNode.removeChild(this.element);
  }

}

/***/ }),

/***/ "./app/index.js":
/*!**********************!*\
  !*** ./app/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pages_About__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pages/About */ "./app/pages/About/index.js");
/* harmony import */ var _pages_Home__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pages/Home */ "./app/pages/Home/index.js");
/* harmony import */ var _components_Preloader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Preloader */ "./app/components/Preloader.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);





class App {
  constructor() {
    this.createPreloader();
    this.createContent();
    this.createPages();
    this.addLinkListeners();
    this.update();
  }

  onPreloaded() {
    this.preloader.hide();
    this.preloader.destroy();
  }

  createPreloader() {
    this.preloader = new _components_Preloader__WEBPACK_IMPORTED_MODULE_2__["default"]();
    this.preloader.once('completed', this.onPreloaded.bind(this));
  }

  createContent() {
    this.content = document.querySelector('.content');
    this.template = this.content.getAttribute('data-template');
  }

  createPages() {
    this.pages = {
      home: new _pages_Home__WEBPACK_IMPORTED_MODULE_1__["default"](),
      about: new _pages_About__WEBPACK_IMPORTED_MODULE_0__["default"]()
    };
    this.page = this.pages[this.template];
    this.page.create();
    this.page.show();
  }

  async onChange(url) {
    this.page.hide();
    const request = await window.fetch(url);

    if (request.status === 200) {
      const nextPage = await request.text();
      const div = document.createElement('div');
      div.innerHTML = nextPage;
      const divContent = div.querySelector('.content');
      this.content.setAttribute('data-template', divContent.getAttribute('data-template'));
      this.content.innerHTML = divContent.innerHTML;
      this.page.create();
      this.page.show();
      this.addLinkListeners();
    } else {
      console.log('Deu pau, bixo!!');
    }
  }

  addLinkListeners() {
    const links = document.querySelectorAll('a');
    (0,lodash__WEBPACK_IMPORTED_MODULE_3__.each)(links, link => {
      link.onclick = event => {
        event.preventDefault();
        const {
          href
        } = link;
        this.onChange(href);
      };
    });
  }

  update() {
    if (this.page && this.page.update) {
      this.page.update();
    }

    this.frame = window.requestAnimationFrame(this.update.bind(this));
  }

}
/* eslint no-new: "off" */


new App();

/***/ }),

/***/ "./app/pages/About/index.js":
/*!**********************************!*\
  !*** ./app/pages/About/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ About)
/* harmony export */ });
/* harmony import */ var classes_Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classes/Page */ "./app/classes/Page.js");

class About extends classes_Page__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super({
      id: 'about',
      element: '.about',
      elements: {
        wrapper: '.about__wrapper',
        navigation: '.navigation',
        title: '.about__title'
      }
    });
  }

}

/***/ }),

/***/ "./app/pages/Home/index.js":
/*!*********************************!*\
  !*** ./app/pages/Home/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Home)
/* harmony export */ });
/* harmony import */ var classes_Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classes/Page */ "./app/classes/Page.js");

class Home extends classes_Page__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super({
      id: 'home',
      element: '.home',
      elements: {
        // navigation: document.querySelector('.nav'),
        wrapper: '.home__titles__wrapper'
      }
    });
  }

  create() {
    super.create();
  }

}

/***/ }),

/***/ "./app/utils/text.js":
/*!***************************!*\
  !*** ./app/utils/text.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "split": () => (/* binding */ split),
/* harmony export */   "calculate": () => (/* binding */ calculate)
/* harmony export */ });
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js");
/* harmony import */ var lodash_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_each__WEBPACK_IMPORTED_MODULE_0__);

function split({
  element,
  expression = ' ',
  append = true
}) {
  const words = splitText(element.innerHTML.toString().trim(), expression);
  let innerHTML = '';
  lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(words, line => {
    if (line.indexOf('<br>') > -1) {
      const lines = line.split('<br>');
      lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(lines, (line, index) => {
        innerHTML += index > 0 ? '<br>' + parseLine(line) : parseLine(line);
      });
    } else {
      innerHTML += parseLine(line);
    }
  });
  element.innerHTML = innerHTML;
  const spans = element.querySelectorAll('span');

  if (append) {
    lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(spans, span => {
      const isSingleLetter = span.textContent.length === 1;
      const isNotEmpty = span.innerHTML.trim() !== '';
      const isNotAndCharacter = span.textContent !== '&';
      const isNotDashCharacter = span.textContent !== '-';

      if (isSingleLetter && isNotEmpty && isNotAndCharacter && isNotDashCharacter) {
        span.innerHTML = `${span.textContent}&nbsp;`;
      }
    });
  }

  return spans;
}
function calculate(spans) {
  const lines = [];
  let words = [];
  let position = spans[0].offsetTop;
  lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(spans, (span, index) => {
    if (span.offsetTop === position) {
      words.push(span);
    }

    if (span.offsetTop !== position) {
      lines.push(words);
      words = [];
      words.push(span);
      position = span.offsetTop;
    }

    if (index + 1 === spans.length) {
      lines.push(words);
    }
  });
  return lines;
}

function splitText(text, expression) {
  const splits = text.split('<br>');
  let words = [];
  lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(splits, (item, index) => {
    if (index > 0) {
      words.push('<br>');
    }

    words = words.concat(item.split(expression));
    let isLink = false;
    let link = '';
    const innerHTML = [];
    lodash_each__WEBPACK_IMPORTED_MODULE_0___default()(words, word => {
      if (!isLink && (word.includes('<a') || word.includes('<strong'))) {
        link = '';
        isLink = true;
      }

      if (isLink) {
        link += ` ${word}`;
      }

      if (isLink && (word.includes('/a>') || word.includes('/strong>'))) {
        innerHTML.push(link);
        link = '';
      }

      if (!isLink && link === '') {
        innerHTML.push(word);
      }

      if (isLink && (word.includes('/a>') || word.includes('/strong>'))) {
        isLink = false;
      }
    });
    words = innerHTML;
  });
  return words;
}

function parseLine(line) {
  if (line === '') {
    return line;
  } else if (line === ' ') {
    return '&nbsp;';
  } else {
    line = line.trim();
    return line === '<br>' ? '<br>' : `<span>${line}</span>` + (line.length > 1 ? ' ' : '');
  }
}

/***/ }),

/***/ "./node_modules/ansi-html-community/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ansi-html-community/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = ansiHTML; // Reference to https://github.com/sindresorhus/ansi-regex

var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/;
var _defColors = {
  reset: ['fff', '000'],
  // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
};
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
};
var _openTags = {
  '1': 'font-weight:bold',
  // bold
  '2': 'opacity:0.5',
  // dim
  '3': '<i>',
  // italic
  '4': '<u>',
  // underscore
  '8': 'display:none',
  // hidden
  '9': '<del>' // delete

};
var _closeTags = {
  '23': '</i>',
  // reset italic
  '24': '</u>',
  // reset underscore
  '29': '</del>' // reset delete

};
[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>';
});
/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */

function ansiHTML(text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text;
  } // Cache opened sequence.


  var ansiCodes = []; // Replace with markup.

  var ret = text.replace(/\033\[(\d+)m/g, function (match, seq) {
    var ot = _openTags[seq];

    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) {
        // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop();
        return '</span>';
      } // Open tag.


      ansiCodes.push(seq);
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">';
    }

    var ct = _closeTags[seq];

    if (ct) {
      // Pop sequence
      ansiCodes.pop();
      return ct;
    }

    return '';
  }); // Make sure tags are closed.

  var l = ansiCodes.length;
  l > 0 && (ret += Array(l + 1).join('</span>'));
  return ret;
}
/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */


ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.');
  }

  var _finalColors = {};

  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null;

    if (!hex) {
      _finalColors[key] = _defColors[key];
      continue;
    }

    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex];
      }

      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string';
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');
      }

      var defHexColor = _defColors[key];

      if (!hex[0]) {
        hex[0] = defHexColor[0];
      }

      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]];
        hex.push(defHexColor[1]);
      }

      hex = hex.slice(0, 2);
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');
    }

    _finalColors[key] = hex;
  }

  _setTags(_finalColors);
};
/**
 * Reset colors.
 */


ansiHTML.reset = function () {
  _setTags(_defColors);
};
/**
 * Expose tags, including open and close.
 * @type {Object}
 */


ansiHTML.tags = {};

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () {
      return _openTags;
    }
  });
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () {
      return _closeTags;
    }
  });
} else {
  ansiHTML.tags.open = _openTags;
  ansiHTML.tags.close = _closeTags;
}

function _setTags(colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]; // inverse

  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]; // dark grey

  _openTags['90'] = 'color:#' + colors.darkgrey;

  for (var code in _styles) {
    var color = _styles[code];
    var oriColor = colors[color] || '000';
    _openTags[code] = 'color:#' + oriColor;
    code = parseInt(code);
    _openTags[(code + 10).toString()] = 'background:#' + oriColor;
  }
}

ansiHTML.reset();

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

/***/ }),

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSPlugin": () => (/* binding */ CSSPlugin),
/* harmony export */   "default": () => (/* binding */ CSSPlugin),
/* harmony export */   "_getBBox": () => (/* binding */ _getBBox),
/* harmony export */   "_createElement": () => (/* binding */ _createElement),
/* harmony export */   "checkPrefix": () => (/* binding */ _checkPropPrefix)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/*!
 * CSSPlugin 3.8.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time) {
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      relative,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: relative ? relative * endNum : endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
      scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
  cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
  cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
  cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
  cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
    a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
    a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
    a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
  var cap = 360,
      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
      endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;

        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue) && (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p]); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));
          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], endValue, index, targets);
          } else {
            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, endValue);
        }

        props.push(p);
      }
    }

    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);


/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GSCache": () => (/* binding */ GSCache),
/* harmony export */   "Animation": () => (/* binding */ Animation),
/* harmony export */   "Timeline": () => (/* binding */ Timeline),
/* harmony export */   "Tween": () => (/* binding */ Tween),
/* harmony export */   "PropTween": () => (/* binding */ PropTween),
/* harmony export */   "gsap": () => (/* binding */ gsap),
/* harmony export */   "Power0": () => (/* binding */ Power0),
/* harmony export */   "Power1": () => (/* binding */ Power1),
/* harmony export */   "Power2": () => (/* binding */ Power2),
/* harmony export */   "Power3": () => (/* binding */ Power3),
/* harmony export */   "Power4": () => (/* binding */ Power4),
/* harmony export */   "Linear": () => (/* binding */ Linear),
/* harmony export */   "Quad": () => (/* binding */ Quad),
/* harmony export */   "Cubic": () => (/* binding */ Cubic),
/* harmony export */   "Quart": () => (/* binding */ Quart),
/* harmony export */   "Quint": () => (/* binding */ Quint),
/* harmony export */   "Strong": () => (/* binding */ Strong),
/* harmony export */   "Elastic": () => (/* binding */ Elastic),
/* harmony export */   "Back": () => (/* binding */ Back),
/* harmony export */   "SteppedEase": () => (/* binding */ SteppedEase),
/* harmony export */   "Bounce": () => (/* binding */ Bounce),
/* harmony export */   "Sine": () => (/* binding */ Sine),
/* harmony export */   "Expo": () => (/* binding */ Expo),
/* harmony export */   "Circ": () => (/* binding */ Circ),
/* harmony export */   "TweenMax": () => (/* binding */ Tween),
/* harmony export */   "TweenLite": () => (/* binding */ Tween),
/* harmony export */   "TimelineMax": () => (/* binding */ Timeline),
/* harmony export */   "TimelineLite": () => (/* binding */ Timeline),
/* harmony export */   "default": () => (/* binding */ gsap),
/* harmony export */   "wrap": () => (/* binding */ wrap),
/* harmony export */   "wrapYoyo": () => (/* binding */ wrapYoyo),
/* harmony export */   "distribute": () => (/* binding */ distribute),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "snap": () => (/* binding */ snap),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "getUnit": () => (/* binding */ getUnit),
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "splitColor": () => (/* binding */ splitColor),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "selector": () => (/* binding */ selector),
/* harmony export */   "mapRange": () => (/* binding */ mapRange),
/* harmony export */   "pipe": () => (/* binding */ pipe),
/* harmony export */   "unitize": () => (/* binding */ unitize),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "shuffle": () => (/* binding */ shuffle),
/* harmony export */   "_getProperty": () => (/* binding */ _getProperty),
/* harmony export */   "_numExp": () => (/* binding */ _numExp),
/* harmony export */   "_numWithUnitExp": () => (/* binding */ _numWithUnitExp),
/* harmony export */   "_isString": () => (/* binding */ _isString),
/* harmony export */   "_isUndefined": () => (/* binding */ _isUndefined),
/* harmony export */   "_renderComplexString": () => (/* binding */ _renderComplexString),
/* harmony export */   "_relExp": () => (/* binding */ _relExp),
/* harmony export */   "_setDefaults": () => (/* binding */ _setDefaults),
/* harmony export */   "_removeLinkedListItem": () => (/* binding */ _removeLinkedListItem),
/* harmony export */   "_forEachName": () => (/* binding */ _forEachName),
/* harmony export */   "_sortPropTweensByPriority": () => (/* binding */ _sortPropTweensByPriority),
/* harmony export */   "_colorStringFilter": () => (/* binding */ _colorStringFilter),
/* harmony export */   "_replaceRandom": () => (/* binding */ _replaceRandom),
/* harmony export */   "_checkPlugin": () => (/* binding */ _checkPlugin),
/* harmony export */   "_plugins": () => (/* binding */ _plugins),
/* harmony export */   "_ticker": () => (/* binding */ _ticker),
/* harmony export */   "_config": () => (/* binding */ _config),
/* harmony export */   "_roundModifier": () => (/* binding */ _roundModifier),
/* harmony export */   "_round": () => (/* binding */ _round),
/* harmony export */   "_missingPlugin": () => (/* binding */ _missingPlugin),
/* harmony export */   "_getSetter": () => (/* binding */ _getSetter),
/* harmony export */   "_getCache": () => (/* binding */ _getCache),
/* harmony export */   "_colorExp": () => (/* binding */ _colorExp)
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * GSAP 3.8.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);
  }
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    prevIteration = _animationCycle(tween._tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== prevIteration) {
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (!child._dur && child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (!child._dur && child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value) {
  if (typeof value !== "string") {
    return "";
  }

  var v = _unitExp.exec(value);

  return v ? value.substr(v.index + v[0].length) : "";
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    _hue = function _hue(h, m1, m2) {
  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback) {
      _listeners.indexOf(callback) < 0 && _listeners.push(callback);

      _wake();
    },
    remove: function remove(callback) {
      var i;
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return this;
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (parsedStart !== end) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);
    prevStartAt && prevStartAt.render(-1, true).kill();

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        } // if (time > 0) {
        // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        // } else if (dur && !(time < 0 && prevStartAt)) {
        // 	time && (tween._zTime = time);
        // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        // }

      } else if (autoRevert === false) {
        tween._startAt = 0;
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        stagger ? parsedTargets.forEach(function (t, i) {
          return keyframes.forEach(function (frame, j) {
            return tl.to(t, frame, j ? ">" : i * stagger);
          });
        }) : keyframes.forEach(function (frame) {
          return tl.to(parsedTargets, frame, ">");
        });
      } else {
        l = parsedTargets.length;
        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = {};

          for (p in vars) {
            if (_staggerPropsToSkip.indexOf(p) < 0) {
              copy[p] = vars[p];
            }
          }

          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.8.0";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gsap": () => (/* binding */ gsapWithCSS),
/* harmony export */   "default": () => (/* binding */ gsapWithCSS),
/* harmony export */   "CSSPlugin": () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin),
/* harmony export */   "TweenMax": () => (/* binding */ TweenMaxWithCSS),
/* harmony export */   "TweenLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),
/* harmony export */   "TimelineMax": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),
/* harmony export */   "TimelineLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),
/* harmony export */   "Power0": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),
/* harmony export */   "Power1": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),
/* harmony export */   "Power2": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),
/* harmony export */   "Power3": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),
/* harmony export */   "Power4": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),
/* harmony export */   "Linear": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),
/* harmony export */   "Quad": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),
/* harmony export */   "Cubic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),
/* harmony export */   "Quart": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),
/* harmony export */   "Quint": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),
/* harmony export */   "Strong": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),
/* harmony export */   "Elastic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),
/* harmony export */   "Back": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),
/* harmony export */   "SteppedEase": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),
/* harmony export */   "Bounce": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),
/* harmony export */   "Sine": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),
/* harmony export */   "Expo": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),
/* harmony export */   "Circ": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");


var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ "./node_modules/html-entities/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/html-entities/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var named_references_1 = __webpack_require__(/*! ./named-references */ "./node_modules/html-entities/lib/named-references.js");

var numeric_unicode_map_1 = __webpack_require__(/*! ./numeric-unicode-map */ "./node_modules/html-entities/lib/numeric-unicode-map.js");

var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/html-entities/lib/surrogate-pairs.js");

var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), {
  all: named_references_1.namedReferences.html5
});

var encodeRegExps = {
  specialChars: /[<>'"&]/g,
  nonAscii: /(?:[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
  nonAsciiPrintable: /(?:[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
  extensive: /(?:[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g
};
var defaultEncodeOptions = {
  mode: 'specialChars',
  level: 'all',
  numeric: 'decimal'
};
/** Encodes all the necessary (specified by `level`) characters in the text */

function encode(text, _a) {
  var _b = _a === void 0 ? defaultEncodeOptions : _a,
      _c = _b.mode,
      mode = _c === void 0 ? 'specialChars' : _c,
      _d = _b.numeric,
      numeric = _d === void 0 ? 'decimal' : _d,
      _e = _b.level,
      level = _e === void 0 ? 'all' : _e;

  if (!text) {
    return '';
  }

  var encodeRegExp = encodeRegExps[mode];
  var references = allNamedReferences[level].characters;
  var isHex = numeric === 'hexadecimal';
  encodeRegExp.lastIndex = 0;

  var _b = encodeRegExp.exec(text);

  var _c;

  if (_b) {
    _c = '';
    var _d = 0;

    do {
      if (_d !== _b.index) {
        _c += text.substring(_d, _b.index);
      }

      var _e = _b[0];
      var result_1 = references[_e];

      if (!result_1) {
        var code_1 = _e.length > 1 ? surrogate_pairs_1.getCodePoint(_e, 0) : _e.charCodeAt(0);
        result_1 = (isHex ? '&#x' + code_1.toString(16) : '&#' + code_1) + ';';
      }

      _c += result_1;
      _d = _b.index + _e.length;
    } while (_b = encodeRegExp.exec(text));

    if (_d !== text.length) {
      _c += text.substring(_d);
    }
  } else {
    _c = text;
  }

  return _c;
}

exports.encode = encode;
var defaultDecodeOptions = {
  scope: 'body',
  level: 'all'
};
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = {
  xml: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.xml
  },
  html4: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.html4
  },
  html5: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.html5
  }
};

var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), {
  all: baseDecodeRegExps.html5
});

var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
var defaultDecodeEntityOptions = {
  level: 'all'
};
/** Decodes a single entity */

function decodeEntity(entity, _a) {
  var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level,
      level = _b === void 0 ? 'all' : _b;

  if (!entity) {
    return '';
  }

  var _b = entity;
  var decodeEntityLastChar_1 = entity[entity.length - 1];

  if (false) {} else if (false) {} else {
    var decodeResultByReference_1 = allNamedReferences[level].entities[entity];

    if (decodeResultByReference_1) {
      _b = decodeResultByReference_1;
    } else if (entity[0] === '&' && entity[1] === '#') {
      var decodeSecondChar_1 = entity[2];
      var decodeCode_1 = decodeSecondChar_1 == 'x' || decodeSecondChar_1 == 'X' ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
      _b = decodeCode_1 >= 0x10ffff ? outOfBoundsChar : decodeCode_1 > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode_1) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_1] || decodeCode_1);
    }
  }

  return _b;
}

exports.decodeEntity = decodeEntity;
/** Decodes all entities in the text */

function decode(text, _a) {
  var decodeSecondChar_1 = _a === void 0 ? defaultDecodeOptions : _a,
      decodeCode_1 = decodeSecondChar_1.level,
      level = decodeCode_1 === void 0 ? 'all' : decodeCode_1,
      _b = decodeSecondChar_1.scope,
      scope = _b === void 0 ? level === 'xml' ? 'strict' : 'body' : _b;

  if (!text) {
    return '';
  }

  var decodeRegExp = decodeRegExps[level][scope];
  var references = allNamedReferences[level].entities;
  var isAttribute = scope === 'attribute';
  var isStrict = scope === 'strict';
  decodeRegExp.lastIndex = 0;
  var replaceMatch_1 = decodeRegExp.exec(text);
  var replaceResult_1;

  if (replaceMatch_1) {
    replaceResult_1 = '';
    var replaceLastIndex_1 = 0;

    do {
      if (replaceLastIndex_1 !== replaceMatch_1.index) {
        replaceResult_1 += text.substring(replaceLastIndex_1, replaceMatch_1.index);
      }

      var replaceInput_1 = replaceMatch_1[0];
      var decodeResult_1 = replaceInput_1;
      var decodeEntityLastChar_2 = replaceInput_1[replaceInput_1.length - 1];

      if (isAttribute && decodeEntityLastChar_2 === '=') {
        decodeResult_1 = replaceInput_1;
      } else if (isStrict && decodeEntityLastChar_2 !== ';') {
        decodeResult_1 = replaceInput_1;
      } else {
        var decodeResultByReference_2 = references[replaceInput_1];

        if (decodeResultByReference_2) {
          decodeResult_1 = decodeResultByReference_2;
        } else if (replaceInput_1[0] === '&' && replaceInput_1[1] === '#') {
          var decodeSecondChar_2 = replaceInput_1[2];
          var decodeCode_2 = decodeSecondChar_2 == 'x' || decodeSecondChar_2 == 'X' ? parseInt(replaceInput_1.substr(3), 16) : parseInt(replaceInput_1.substr(2));
          decodeResult_1 = decodeCode_2 >= 0x10ffff ? outOfBoundsChar : decodeCode_2 > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode_2) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_2] || decodeCode_2);
        }
      }

      replaceResult_1 += decodeResult_1;
      replaceLastIndex_1 = replaceMatch_1.index + replaceInput_1.length;
    } while (replaceMatch_1 = decodeRegExp.exec(text));

    if (replaceLastIndex_1 !== text.length) {
      replaceResult_1 += text.substring(replaceLastIndex_1);
    }
  } else {
    replaceResult_1 = text;
  }

  return replaceResult_1;
}

exports.decode = decode;

/***/ }),

/***/ "./node_modules/html-entities/lib/named-references.js":
/*!************************************************************!*\
  !*** ./node_modules/html-entities/lib/named-references.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bodyRegExps = {
  xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html4: /&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html5: /&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g
};
exports.namedReferences = {
  xml: {
    entities: {
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&apos;": "'",
      "&amp;": "&"
    },
    characters: {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&apos;",
      "&": "&amp;"
    }
  },
  html4: {
    entities: {
      "&apos;": "'",
      "&nbsp": "",
      "&nbsp;": "",
      "&iexcl": "",
      "&iexcl;": "",
      "&cent": "",
      "&cent;": "",
      "&pound": "",
      "&pound;": "",
      "&curren": "",
      "&curren;": "",
      "&yen": "",
      "&yen;": "",
      "&brvbar": "",
      "&brvbar;": "",
      "&sect": "",
      "&sect;": "",
      "&uml": "",
      "&uml;": "",
      "&copy": "",
      "&copy;": "",
      "&ordf": "",
      "&ordf;": "",
      "&laquo": "",
      "&laquo;": "",
      "&not": "",
      "&not;": "",
      "&shy": "",
      "&shy;": "",
      "&reg": "",
      "&reg;": "",
      "&macr": "",
      "&macr;": "",
      "&deg": "",
      "&deg;": "",
      "&plusmn": "",
      "&plusmn;": "",
      "&sup2": "",
      "&sup2;": "",
      "&sup3": "",
      "&sup3;": "",
      "&acute": "",
      "&acute;": "",
      "&micro": "",
      "&micro;": "",
      "&para": "",
      "&para;": "",
      "&middot": "",
      "&middot;": "",
      "&cedil": "",
      "&cedil;": "",
      "&sup1": "",
      "&sup1;": "",
      "&ordm": "",
      "&ordm;": "",
      "&raquo": "",
      "&raquo;": "",
      "&frac14": "",
      "&frac14;": "",
      "&frac12": "",
      "&frac12;": "",
      "&frac34": "",
      "&frac34;": "",
      "&iquest": "",
      "&iquest;": "",
      "&Agrave": "",
      "&Agrave;": "",
      "&Aacute": "",
      "&Aacute;": "",
      "&Acirc": "",
      "&Acirc;": "",
      "&Atilde": "",
      "&Atilde;": "",
      "&Auml": "",
      "&Auml;": "",
      "&Aring": "",
      "&Aring;": "",
      "&AElig": "",
      "&AElig;": "",
      "&Ccedil": "",
      "&Ccedil;": "",
      "&Egrave": "",
      "&Egrave;": "",
      "&Eacute": "",
      "&Eacute;": "",
      "&Ecirc": "",
      "&Ecirc;": "",
      "&Euml": "",
      "&Euml;": "",
      "&Igrave": "",
      "&Igrave;": "",
      "&Iacute": "",
      "&Iacute;": "",
      "&Icirc": "",
      "&Icirc;": "",
      "&Iuml": "",
      "&Iuml;": "",
      "&ETH": "",
      "&ETH;": "",
      "&Ntilde": "",
      "&Ntilde;": "",
      "&Ograve": "",
      "&Ograve;": "",
      "&Oacute": "",
      "&Oacute;": "",
      "&Ocirc": "",
      "&Ocirc;": "",
      "&Otilde": "",
      "&Otilde;": "",
      "&Ouml": "",
      "&Ouml;": "",
      "&times": "",
      "&times;": "",
      "&Oslash": "",
      "&Oslash;": "",
      "&Ugrave": "",
      "&Ugrave;": "",
      "&Uacute": "",
      "&Uacute;": "",
      "&Ucirc": "",
      "&Ucirc;": "",
      "&Uuml": "",
      "&Uuml;": "",
      "&Yacute": "",
      "&Yacute;": "",
      "&THORN": "",
      "&THORN;": "",
      "&szlig": "",
      "&szlig;": "",
      "&agrave": "",
      "&agrave;": "",
      "&aacute": "",
      "&aacute;": "",
      "&acirc": "",
      "&acirc;": "",
      "&atilde": "",
      "&atilde;": "",
      "&auml": "",
      "&auml;": "",
      "&aring": "",
      "&aring;": "",
      "&aelig": "",
      "&aelig;": "",
      "&ccedil": "",
      "&ccedil;": "",
      "&egrave": "",
      "&egrave;": "",
      "&eacute": "",
      "&eacute;": "",
      "&ecirc": "",
      "&ecirc;": "",
      "&euml": "",
      "&euml;": "",
      "&igrave": "",
      "&igrave;": "",
      "&iacute": "",
      "&iacute;": "",
      "&icirc": "",
      "&icirc;": "",
      "&iuml": "",
      "&iuml;": "",
      "&eth": "",
      "&eth;": "",
      "&ntilde": "",
      "&ntilde;": "",
      "&ograve": "",
      "&ograve;": "",
      "&oacute": "",
      "&oacute;": "",
      "&ocirc": "",
      "&ocirc;": "",
      "&otilde": "",
      "&otilde;": "",
      "&ouml": "",
      "&ouml;": "",
      "&divide": "",
      "&divide;": "",
      "&oslash": "",
      "&oslash;": "",
      "&ugrave": "",
      "&ugrave;": "",
      "&uacute": "",
      "&uacute;": "",
      "&ucirc": "",
      "&ucirc;": "",
      "&uuml": "",
      "&uuml;": "",
      "&yacute": "",
      "&yacute;": "",
      "&thorn": "",
      "&thorn;": "",
      "&yuml": "",
      "&yuml;": "",
      "&quot": '"',
      "&quot;": '"',
      "&amp": "&",
      "&amp;": "&",
      "&lt": "<",
      "&lt;": "<",
      "&gt": ">",
      "&gt;": ">",
      "&OElig;": "",
      "&oelig;": "",
      "&Scaron;": "",
      "&scaron;": "",
      "&Yuml;": "",
      "&circ;": "",
      "&tilde;": "",
      "&ensp;": "",
      "&emsp;": "",
      "&thinsp;": "",
      "&zwnj;": "",
      "&zwj;": "",
      "&lrm;": "",
      "&rlm;": "",
      "&ndash;": "",
      "&mdash;": "",
      "&lsquo;": "",
      "&rsquo;": "",
      "&sbquo;": "",
      "&ldquo;": "",
      "&rdquo;": "",
      "&bdquo;": "",
      "&dagger;": "",
      "&Dagger;": "",
      "&permil;": "",
      "&lsaquo;": "",
      "&rsaquo;": "",
      "&euro;": "",
      "&fnof;": "",
      "&Alpha;": "",
      "&Beta;": "",
      "&Gamma;": "",
      "&Delta;": "",
      "&Epsilon;": "",
      "&Zeta;": "",
      "&Eta;": "",
      "&Theta;": "",
      "&Iota;": "",
      "&Kappa;": "",
      "&Lambda;": "",
      "&Mu;": "",
      "&Nu;": "",
      "&Xi;": "",
      "&Omicron;": "",
      "&Pi;": "",
      "&Rho;": "",
      "&Sigma;": "",
      "&Tau;": "",
      "&Upsilon;": "",
      "&Phi;": "",
      "&Chi;": "",
      "&Psi;": "",
      "&Omega;": "",
      "&alpha;": "",
      "&beta;": "",
      "&gamma;": "",
      "&delta;": "",
      "&epsilon;": "",
      "&zeta;": "",
      "&eta;": "",
      "&theta;": "",
      "&iota;": "",
      "&kappa;": "",
      "&lambda;": "",
      "&mu;": "",
      "&nu;": "",
      "&xi;": "",
      "&omicron;": "",
      "&pi;": "",
      "&rho;": "",
      "&sigmaf;": "",
      "&sigma;": "",
      "&tau;": "",
      "&upsilon;": "",
      "&phi;": "",
      "&chi;": "",
      "&psi;": "",
      "&omega;": "",
      "&thetasym;": "",
      "&upsih;": "",
      "&piv;": "",
      "&bull;": "",
      "&hellip;": "",
      "&prime;": "",
      "&Prime;": "",
      "&oline;": "",
      "&frasl;": "",
      "&weierp;": "",
      "&image;": "",
      "&real;": "",
      "&trade;": "",
      "&alefsym;": "",
      "&larr;": "",
      "&uarr;": "",
      "&rarr;": "",
      "&darr;": "",
      "&harr;": "",
      "&crarr;": "",
      "&lArr;": "",
      "&uArr;": "",
      "&rArr;": "",
      "&dArr;": "",
      "&hArr;": "",
      "&forall;": "",
      "&part;": "",
      "&exist;": "",
      "&empty;": "",
      "&nabla;": "",
      "&isin;": "",
      "&notin;": "",
      "&ni;": "",
      "&prod;": "",
      "&sum;": "",
      "&minus;": "",
      "&lowast;": "",
      "&radic;": "",
      "&prop;": "",
      "&infin;": "",
      "&ang;": "",
      "&and;": "",
      "&or;": "",
      "&cap;": "",
      "&cup;": "",
      "&int;": "",
      "&there4;": "",
      "&sim;": "",
      "&cong;": "",
      "&asymp;": "",
      "&ne;": "",
      "&equiv;": "",
      "&le;": "",
      "&ge;": "",
      "&sub;": "",
      "&sup;": "",
      "&nsub;": "",
      "&sube;": "",
      "&supe;": "",
      "&oplus;": "",
      "&otimes;": "",
      "&perp;": "",
      "&sdot;": "",
      "&lceil;": "",
      "&rceil;": "",
      "&lfloor;": "",
      "&rfloor;": "",
      "&lang;": "",
      "&rang;": "",
      "&loz;": "",
      "&spades;": "",
      "&clubs;": "",
      "&hearts;": "",
      "&diams;": ""
    },
    characters: {
      "'": "&apos;",
      "": "&nbsp;",
      "": "&iexcl;",
      "": "&cent;",
      "": "&pound;",
      "": "&curren;",
      "": "&yen;",
      "": "&brvbar;",
      "": "&sect;",
      "": "&uml;",
      "": "&copy;",
      "": "&ordf;",
      "": "&laquo;",
      "": "&not;",
      "": "&shy;",
      "": "&reg;",
      "": "&macr;",
      "": "&deg;",
      "": "&plusmn;",
      "": "&sup2;",
      "": "&sup3;",
      "": "&acute;",
      "": "&micro;",
      "": "&para;",
      "": "&middot;",
      "": "&cedil;",
      "": "&sup1;",
      "": "&ordm;",
      "": "&raquo;",
      "": "&frac14;",
      "": "&frac12;",
      "": "&frac34;",
      "": "&iquest;",
      "": "&Agrave;",
      "": "&Aacute;",
      "": "&Acirc;",
      "": "&Atilde;",
      "": "&Auml;",
      "": "&Aring;",
      "": "&AElig;",
      "": "&Ccedil;",
      "": "&Egrave;",
      "": "&Eacute;",
      "": "&Ecirc;",
      "": "&Euml;",
      "": "&Igrave;",
      "": "&Iacute;",
      "": "&Icirc;",
      "": "&Iuml;",
      "": "&ETH;",
      "": "&Ntilde;",
      "": "&Ograve;",
      "": "&Oacute;",
      "": "&Ocirc;",
      "": "&Otilde;",
      "": "&Ouml;",
      "": "&times;",
      "": "&Oslash;",
      "": "&Ugrave;",
      "": "&Uacute;",
      "": "&Ucirc;",
      "": "&Uuml;",
      "": "&Yacute;",
      "": "&THORN;",
      "": "&szlig;",
      "": "&agrave;",
      "": "&aacute;",
      "": "&acirc;",
      "": "&atilde;",
      "": "&auml;",
      "": "&aring;",
      "": "&aelig;",
      "": "&ccedil;",
      "": "&egrave;",
      "": "&eacute;",
      "": "&ecirc;",
      "": "&euml;",
      "": "&igrave;",
      "": "&iacute;",
      "": "&icirc;",
      "": "&iuml;",
      "": "&eth;",
      "": "&ntilde;",
      "": "&ograve;",
      "": "&oacute;",
      "": "&ocirc;",
      "": "&otilde;",
      "": "&ouml;",
      "": "&divide;",
      "": "&oslash;",
      "": "&ugrave;",
      "": "&uacute;",
      "": "&ucirc;",
      "": "&uuml;",
      "": "&yacute;",
      "": "&thorn;",
      "": "&yuml;",
      '"': "&quot;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "": "&OElig;",
      "": "&oelig;",
      "": "&Scaron;",
      "": "&scaron;",
      "": "&Yuml;",
      "": "&circ;",
      "": "&tilde;",
      "": "&ensp;",
      "": "&emsp;",
      "": "&thinsp;",
      "": "&zwnj;",
      "": "&zwj;",
      "": "&lrm;",
      "": "&rlm;",
      "": "&ndash;",
      "": "&mdash;",
      "": "&lsquo;",
      "": "&rsquo;",
      "": "&sbquo;",
      "": "&ldquo;",
      "": "&rdquo;",
      "": "&bdquo;",
      "": "&dagger;",
      "": "&Dagger;",
      "": "&permil;",
      "": "&lsaquo;",
      "": "&rsaquo;",
      "": "&euro;",
      "": "&fnof;",
      "": "&Alpha;",
      "": "&Beta;",
      "": "&Gamma;",
      "": "&Delta;",
      "": "&Epsilon;",
      "": "&Zeta;",
      "": "&Eta;",
      "": "&Theta;",
      "": "&Iota;",
      "": "&Kappa;",
      "": "&Lambda;",
      "": "&Mu;",
      "": "&Nu;",
      "": "&Xi;",
      "": "&Omicron;",
      "": "&Pi;",
      "": "&Rho;",
      "": "&Sigma;",
      "": "&Tau;",
      "": "&Upsilon;",
      "": "&Phi;",
      "": "&Chi;",
      "": "&Psi;",
      "": "&Omega;",
      "": "&alpha;",
      "": "&beta;",
      "": "&gamma;",
      "": "&delta;",
      "": "&epsilon;",
      "": "&zeta;",
      "": "&eta;",
      "": "&theta;",
      "": "&iota;",
      "": "&kappa;",
      "": "&lambda;",
      "": "&mu;",
      "": "&nu;",
      "": "&xi;",
      "": "&omicron;",
      "": "&pi;",
      "": "&rho;",
      "": "&sigmaf;",
      "": "&sigma;",
      "": "&tau;",
      "": "&upsilon;",
      "": "&phi;",
      "": "&chi;",
      "": "&psi;",
      "": "&omega;",
      "": "&thetasym;",
      "": "&upsih;",
      "": "&piv;",
      "": "&bull;",
      "": "&hellip;",
      "": "&prime;",
      "": "&Prime;",
      "": "&oline;",
      "": "&frasl;",
      "": "&weierp;",
      "": "&image;",
      "": "&real;",
      "": "&trade;",
      "": "&alefsym;",
      "": "&larr;",
      "": "&uarr;",
      "": "&rarr;",
      "": "&darr;",
      "": "&harr;",
      "": "&crarr;",
      "": "&lArr;",
      "": "&uArr;",
      "": "&rArr;",
      "": "&dArr;",
      "": "&hArr;",
      "": "&forall;",
      "": "&part;",
      "": "&exist;",
      "": "&empty;",
      "": "&nabla;",
      "": "&isin;",
      "": "&notin;",
      "": "&ni;",
      "": "&prod;",
      "": "&sum;",
      "": "&minus;",
      "": "&lowast;",
      "": "&radic;",
      "": "&prop;",
      "": "&infin;",
      "": "&ang;",
      "": "&and;",
      "": "&or;",
      "": "&cap;",
      "": "&cup;",
      "": "&int;",
      "": "&there4;",
      "": "&sim;",
      "": "&cong;",
      "": "&asymp;",
      "": "&ne;",
      "": "&equiv;",
      "": "&le;",
      "": "&ge;",
      "": "&sub;",
      "": "&sup;",
      "": "&nsub;",
      "": "&sube;",
      "": "&supe;",
      "": "&oplus;",
      "": "&otimes;",
      "": "&perp;",
      "": "&sdot;",
      "": "&lceil;",
      "": "&rceil;",
      "": "&lfloor;",
      "": "&rfloor;",
      "": "&lang;",
      "": "&rang;",
      "": "&loz;",
      "": "&spades;",
      "": "&clubs;",
      "": "&hearts;",
      "": "&diams;"
    }
  },
  html5: {
    entities: {
      "&AElig": "",
      "&AElig;": "",
      "&AMP": "&",
      "&AMP;": "&",
      "&Aacute": "",
      "&Aacute;": "",
      "&Abreve;": "",
      "&Acirc": "",
      "&Acirc;": "",
      "&Acy;": "",
      "&Afr;": "",
      "&Agrave": "",
      "&Agrave;": "",
      "&Alpha;": "",
      "&Amacr;": "",
      "&And;": "",
      "&Aogon;": "",
      "&Aopf;": "",
      "&ApplyFunction;": "",
      "&Aring": "",
      "&Aring;": "",
      "&Ascr;": "",
      "&Assign;": "",
      "&Atilde": "",
      "&Atilde;": "",
      "&Auml": "",
      "&Auml;": "",
      "&Backslash;": "",
      "&Barv;": "",
      "&Barwed;": "",
      "&Bcy;": "",
      "&Because;": "",
      "&Bernoullis;": "",
      "&Beta;": "",
      "&Bfr;": "",
      "&Bopf;": "",
      "&Breve;": "",
      "&Bscr;": "",
      "&Bumpeq;": "",
      "&CHcy;": "",
      "&COPY": "",
      "&COPY;": "",
      "&Cacute;": "",
      "&Cap;": "",
      "&CapitalDifferentialD;": "",
      "&Cayleys;": "",
      "&Ccaron;": "",
      "&Ccedil": "",
      "&Ccedil;": "",
      "&Ccirc;": "",
      "&Cconint;": "",
      "&Cdot;": "",
      "&Cedilla;": "",
      "&CenterDot;": "",
      "&Cfr;": "",
      "&Chi;": "",
      "&CircleDot;": "",
      "&CircleMinus;": "",
      "&CirclePlus;": "",
      "&CircleTimes;": "",
      "&ClockwiseContourIntegral;": "",
      "&CloseCurlyDoubleQuote;": "",
      "&CloseCurlyQuote;": "",
      "&Colon;": "",
      "&Colone;": "",
      "&Congruent;": "",
      "&Conint;": "",
      "&ContourIntegral;": "",
      "&Copf;": "",
      "&Coproduct;": "",
      "&CounterClockwiseContourIntegral;": "",
      "&Cross;": "",
      "&Cscr;": "",
      "&Cup;": "",
      "&CupCap;": "",
      "&DD;": "",
      "&DDotrahd;": "",
      "&DJcy;": "",
      "&DScy;": "",
      "&DZcy;": "",
      "&Dagger;": "",
      "&Darr;": "",
      "&Dashv;": "",
      "&Dcaron;": "",
      "&Dcy;": "",
      "&Del;": "",
      "&Delta;": "",
      "&Dfr;": "",
      "&DiacriticalAcute;": "",
      "&DiacriticalDot;": "",
      "&DiacriticalDoubleAcute;": "",
      "&DiacriticalGrave;": "`",
      "&DiacriticalTilde;": "",
      "&Diamond;": "",
      "&DifferentialD;": "",
      "&Dopf;": "",
      "&Dot;": "",
      "&DotDot;": "",
      "&DotEqual;": "",
      "&DoubleContourIntegral;": "",
      "&DoubleDot;": "",
      "&DoubleDownArrow;": "",
      "&DoubleLeftArrow;": "",
      "&DoubleLeftRightArrow;": "",
      "&DoubleLeftTee;": "",
      "&DoubleLongLeftArrow;": "",
      "&DoubleLongLeftRightArrow;": "",
      "&DoubleLongRightArrow;": "",
      "&DoubleRightArrow;": "",
      "&DoubleRightTee;": "",
      "&DoubleUpArrow;": "",
      "&DoubleUpDownArrow;": "",
      "&DoubleVerticalBar;": "",
      "&DownArrow;": "",
      "&DownArrowBar;": "",
      "&DownArrowUpArrow;": "",
      "&DownBreve;": "",
      "&DownLeftRightVector;": "",
      "&DownLeftTeeVector;": "",
      "&DownLeftVector;": "",
      "&DownLeftVectorBar;": "",
      "&DownRightTeeVector;": "",
      "&DownRightVector;": "",
      "&DownRightVectorBar;": "",
      "&DownTee;": "",
      "&DownTeeArrow;": "",
      "&Downarrow;": "",
      "&Dscr;": "",
      "&Dstrok;": "",
      "&ENG;": "",
      "&ETH": "",
      "&ETH;": "",
      "&Eacute": "",
      "&Eacute;": "",
      "&Ecaron;": "",
      "&Ecirc": "",
      "&Ecirc;": "",
      "&Ecy;": "",
      "&Edot;": "",
      "&Efr;": "",
      "&Egrave": "",
      "&Egrave;": "",
      "&Element;": "",
      "&Emacr;": "",
      "&EmptySmallSquare;": "",
      "&EmptyVerySmallSquare;": "",
      "&Eogon;": "",
      "&Eopf;": "",
      "&Epsilon;": "",
      "&Equal;": "",
      "&EqualTilde;": "",
      "&Equilibrium;": "",
      "&Escr;": "",
      "&Esim;": "",
      "&Eta;": "",
      "&Euml": "",
      "&Euml;": "",
      "&Exists;": "",
      "&ExponentialE;": "",
      "&Fcy;": "",
      "&Ffr;": "",
      "&FilledSmallSquare;": "",
      "&FilledVerySmallSquare;": "",
      "&Fopf;": "",
      "&ForAll;": "",
      "&Fouriertrf;": "",
      "&Fscr;": "",
      "&GJcy;": "",
      "&GT": ">",
      "&GT;": ">",
      "&Gamma;": "",
      "&Gammad;": "",
      "&Gbreve;": "",
      "&Gcedil;": "",
      "&Gcirc;": "",
      "&Gcy;": "",
      "&Gdot;": "",
      "&Gfr;": "",
      "&Gg;": "",
      "&Gopf;": "",
      "&GreaterEqual;": "",
      "&GreaterEqualLess;": "",
      "&GreaterFullEqual;": "",
      "&GreaterGreater;": "",
      "&GreaterLess;": "",
      "&GreaterSlantEqual;": "",
      "&GreaterTilde;": "",
      "&Gscr;": "",
      "&Gt;": "",
      "&HARDcy;": "",
      "&Hacek;": "",
      "&Hat;": "^",
      "&Hcirc;": "",
      "&Hfr;": "",
      "&HilbertSpace;": "",
      "&Hopf;": "",
      "&HorizontalLine;": "",
      "&Hscr;": "",
      "&Hstrok;": "",
      "&HumpDownHump;": "",
      "&HumpEqual;": "",
      "&IEcy;": "",
      "&IJlig;": "",
      "&IOcy;": "",
      "&Iacute": "",
      "&Iacute;": "",
      "&Icirc": "",
      "&Icirc;": "",
      "&Icy;": "",
      "&Idot;": "",
      "&Ifr;": "",
      "&Igrave": "",
      "&Igrave;": "",
      "&Im;": "",
      "&Imacr;": "",
      "&ImaginaryI;": "",
      "&Implies;": "",
      "&Int;": "",
      "&Integral;": "",
      "&Intersection;": "",
      "&InvisibleComma;": "",
      "&InvisibleTimes;": "",
      "&Iogon;": "",
      "&Iopf;": "",
      "&Iota;": "",
      "&Iscr;": "",
      "&Itilde;": "",
      "&Iukcy;": "",
      "&Iuml": "",
      "&Iuml;": "",
      "&Jcirc;": "",
      "&Jcy;": "",
      "&Jfr;": "",
      "&Jopf;": "",
      "&Jscr;": "",
      "&Jsercy;": "",
      "&Jukcy;": "",
      "&KHcy;": "",
      "&KJcy;": "",
      "&Kappa;": "",
      "&Kcedil;": "",
      "&Kcy;": "",
      "&Kfr;": "",
      "&Kopf;": "",
      "&Kscr;": "",
      "&LJcy;": "",
      "&LT": "<",
      "&LT;": "<",
      "&Lacute;": "",
      "&Lambda;": "",
      "&Lang;": "",
      "&Laplacetrf;": "",
      "&Larr;": "",
      "&Lcaron;": "",
      "&Lcedil;": "",
      "&Lcy;": "",
      "&LeftAngleBracket;": "",
      "&LeftArrow;": "",
      "&LeftArrowBar;": "",
      "&LeftArrowRightArrow;": "",
      "&LeftCeiling;": "",
      "&LeftDoubleBracket;": "",
      "&LeftDownTeeVector;": "",
      "&LeftDownVector;": "",
      "&LeftDownVectorBar;": "",
      "&LeftFloor;": "",
      "&LeftRightArrow;": "",
      "&LeftRightVector;": "",
      "&LeftTee;": "",
      "&LeftTeeArrow;": "",
      "&LeftTeeVector;": "",
      "&LeftTriangle;": "",
      "&LeftTriangleBar;": "",
      "&LeftTriangleEqual;": "",
      "&LeftUpDownVector;": "",
      "&LeftUpTeeVector;": "",
      "&LeftUpVector;": "",
      "&LeftUpVectorBar;": "",
      "&LeftVector;": "",
      "&LeftVectorBar;": "",
      "&Leftarrow;": "",
      "&Leftrightarrow;": "",
      "&LessEqualGreater;": "",
      "&LessFullEqual;": "",
      "&LessGreater;": "",
      "&LessLess;": "",
      "&LessSlantEqual;": "",
      "&LessTilde;": "",
      "&Lfr;": "",
      "&Ll;": "",
      "&Lleftarrow;": "",
      "&Lmidot;": "",
      "&LongLeftArrow;": "",
      "&LongLeftRightArrow;": "",
      "&LongRightArrow;": "",
      "&Longleftarrow;": "",
      "&Longleftrightarrow;": "",
      "&Longrightarrow;": "",
      "&Lopf;": "",
      "&LowerLeftArrow;": "",
      "&LowerRightArrow;": "",
      "&Lscr;": "",
      "&Lsh;": "",
      "&Lstrok;": "",
      "&Lt;": "",
      "&Map;": "",
      "&Mcy;": "",
      "&MediumSpace;": "",
      "&Mellintrf;": "",
      "&Mfr;": "",
      "&MinusPlus;": "",
      "&Mopf;": "",
      "&Mscr;": "",
      "&Mu;": "",
      "&NJcy;": "",
      "&Nacute;": "",
      "&Ncaron;": "",
      "&Ncedil;": "",
      "&Ncy;": "",
      "&NegativeMediumSpace;": "",
      "&NegativeThickSpace;": "",
      "&NegativeThinSpace;": "",
      "&NegativeVeryThinSpace;": "",
      "&NestedGreaterGreater;": "",
      "&NestedLessLess;": "",
      "&NewLine;": "\n",
      "&Nfr;": "",
      "&NoBreak;": "",
      "&NonBreakingSpace;": "",
      "&Nopf;": "",
      "&Not;": "",
      "&NotCongruent;": "",
      "&NotCupCap;": "",
      "&NotDoubleVerticalBar;": "",
      "&NotElement;": "",
      "&NotEqual;": "",
      "&NotEqualTilde;": "",
      "&NotExists;": "",
      "&NotGreater;": "",
      "&NotGreaterEqual;": "",
      "&NotGreaterFullEqual;": "",
      "&NotGreaterGreater;": "",
      "&NotGreaterLess;": "",
      "&NotGreaterSlantEqual;": "",
      "&NotGreaterTilde;": "",
      "&NotHumpDownHump;": "",
      "&NotHumpEqual;": "",
      "&NotLeftTriangle;": "",
      "&NotLeftTriangleBar;": "",
      "&NotLeftTriangleEqual;": "",
      "&NotLess;": "",
      "&NotLessEqual;": "",
      "&NotLessGreater;": "",
      "&NotLessLess;": "",
      "&NotLessSlantEqual;": "",
      "&NotLessTilde;": "",
      "&NotNestedGreaterGreater;": "",
      "&NotNestedLessLess;": "",
      "&NotPrecedes;": "",
      "&NotPrecedesEqual;": "",
      "&NotPrecedesSlantEqual;": "",
      "&NotReverseElement;": "",
      "&NotRightTriangle;": "",
      "&NotRightTriangleBar;": "",
      "&NotRightTriangleEqual;": "",
      "&NotSquareSubset;": "",
      "&NotSquareSubsetEqual;": "",
      "&NotSquareSuperset;": "",
      "&NotSquareSupersetEqual;": "",
      "&NotSubset;": "",
      "&NotSubsetEqual;": "",
      "&NotSucceeds;": "",
      "&NotSucceedsEqual;": "",
      "&NotSucceedsSlantEqual;": "",
      "&NotSucceedsTilde;": "",
      "&NotSuperset;": "",
      "&NotSupersetEqual;": "",
      "&NotTilde;": "",
      "&NotTildeEqual;": "",
      "&NotTildeFullEqual;": "",
      "&NotTildeTilde;": "",
      "&NotVerticalBar;": "",
      "&Nscr;": "",
      "&Ntilde": "",
      "&Ntilde;": "",
      "&Nu;": "",
      "&OElig;": "",
      "&Oacute": "",
      "&Oacute;": "",
      "&Ocirc": "",
      "&Ocirc;": "",
      "&Ocy;": "",
      "&Odblac;": "",
      "&Ofr;": "",
      "&Ograve": "",
      "&Ograve;": "",
      "&Omacr;": "",
      "&Omega;": "",
      "&Omicron;": "",
      "&Oopf;": "",
      "&OpenCurlyDoubleQuote;": "",
      "&OpenCurlyQuote;": "",
      "&Or;": "",
      "&Oscr;": "",
      "&Oslash": "",
      "&Oslash;": "",
      "&Otilde": "",
      "&Otilde;": "",
      "&Otimes;": "",
      "&Ouml": "",
      "&Ouml;": "",
      "&OverBar;": "",
      "&OverBrace;": "",
      "&OverBracket;": "",
      "&OverParenthesis;": "",
      "&PartialD;": "",
      "&Pcy;": "",
      "&Pfr;": "",
      "&Phi;": "",
      "&Pi;": "",
      "&PlusMinus;": "",
      "&Poincareplane;": "",
      "&Popf;": "",
      "&Pr;": "",
      "&Precedes;": "",
      "&PrecedesEqual;": "",
      "&PrecedesSlantEqual;": "",
      "&PrecedesTilde;": "",
      "&Prime;": "",
      "&Product;": "",
      "&Proportion;": "",
      "&Proportional;": "",
      "&Pscr;": "",
      "&Psi;": "",
      "&QUOT": '"',
      "&QUOT;": '"',
      "&Qfr;": "",
      "&Qopf;": "",
      "&Qscr;": "",
      "&RBarr;": "",
      "&REG": "",
      "&REG;": "",
      "&Racute;": "",
      "&Rang;": "",
      "&Rarr;": "",
      "&Rarrtl;": "",
      "&Rcaron;": "",
      "&Rcedil;": "",
      "&Rcy;": "",
      "&Re;": "",
      "&ReverseElement;": "",
      "&ReverseEquilibrium;": "",
      "&ReverseUpEquilibrium;": "",
      "&Rfr;": "",
      "&Rho;": "",
      "&RightAngleBracket;": "",
      "&RightArrow;": "",
      "&RightArrowBar;": "",
      "&RightArrowLeftArrow;": "",
      "&RightCeiling;": "",
      "&RightDoubleBracket;": "",
      "&RightDownTeeVector;": "",
      "&RightDownVector;": "",
      "&RightDownVectorBar;": "",
      "&RightFloor;": "",
      "&RightTee;": "",
      "&RightTeeArrow;": "",
      "&RightTeeVector;": "",
      "&RightTriangle;": "",
      "&RightTriangleBar;": "",
      "&RightTriangleEqual;": "",
      "&RightUpDownVector;": "",
      "&RightUpTeeVector;": "",
      "&RightUpVector;": "",
      "&RightUpVectorBar;": "",
      "&RightVector;": "",
      "&RightVectorBar;": "",
      "&Rightarrow;": "",
      "&Ropf;": "",
      "&RoundImplies;": "",
      "&Rrightarrow;": "",
      "&Rscr;": "",
      "&Rsh;": "",
      "&RuleDelayed;": "",
      "&SHCHcy;": "",
      "&SHcy;": "",
      "&SOFTcy;": "",
      "&Sacute;": "",
      "&Sc;": "",
      "&Scaron;": "",
      "&Scedil;": "",
      "&Scirc;": "",
      "&Scy;": "",
      "&Sfr;": "",
      "&ShortDownArrow;": "",
      "&ShortLeftArrow;": "",
      "&ShortRightArrow;": "",
      "&ShortUpArrow;": "",
      "&Sigma;": "",
      "&SmallCircle;": "",
      "&Sopf;": "",
      "&Sqrt;": "",
      "&Square;": "",
      "&SquareIntersection;": "",
      "&SquareSubset;": "",
      "&SquareSubsetEqual;": "",
      "&SquareSuperset;": "",
      "&SquareSupersetEqual;": "",
      "&SquareUnion;": "",
      "&Sscr;": "",
      "&Star;": "",
      "&Sub;": "",
      "&Subset;": "",
      "&SubsetEqual;": "",
      "&Succeeds;": "",
      "&SucceedsEqual;": "",
      "&SucceedsSlantEqual;": "",
      "&SucceedsTilde;": "",
      "&SuchThat;": "",
      "&Sum;": "",
      "&Sup;": "",
      "&Superset;": "",
      "&SupersetEqual;": "",
      "&Supset;": "",
      "&THORN": "",
      "&THORN;": "",
      "&TRADE;": "",
      "&TSHcy;": "",
      "&TScy;": "",
      "&Tab;": "\t",
      "&Tau;": "",
      "&Tcaron;": "",
      "&Tcedil;": "",
      "&Tcy;": "",
      "&Tfr;": "",
      "&Therefore;": "",
      "&Theta;": "",
      "&ThickSpace;": "",
      "&ThinSpace;": "",
      "&Tilde;": "",
      "&TildeEqual;": "",
      "&TildeFullEqual;": "",
      "&TildeTilde;": "",
      "&Topf;": "",
      "&TripleDot;": "",
      "&Tscr;": "",
      "&Tstrok;": "",
      "&Uacute": "",
      "&Uacute;": "",
      "&Uarr;": "",
      "&Uarrocir;": "",
      "&Ubrcy;": "",
      "&Ubreve;": "",
      "&Ucirc": "",
      "&Ucirc;": "",
      "&Ucy;": "",
      "&Udblac;": "",
      "&Ufr;": "",
      "&Ugrave": "",
      "&Ugrave;": "",
      "&Umacr;": "",
      "&UnderBar;": "_",
      "&UnderBrace;": "",
      "&UnderBracket;": "",
      "&UnderParenthesis;": "",
      "&Union;": "",
      "&UnionPlus;": "",
      "&Uogon;": "",
      "&Uopf;": "",
      "&UpArrow;": "",
      "&UpArrowBar;": "",
      "&UpArrowDownArrow;": "",
      "&UpDownArrow;": "",
      "&UpEquilibrium;": "",
      "&UpTee;": "",
      "&UpTeeArrow;": "",
      "&Uparrow;": "",
      "&Updownarrow;": "",
      "&UpperLeftArrow;": "",
      "&UpperRightArrow;": "",
      "&Upsi;": "",
      "&Upsilon;": "",
      "&Uring;": "",
      "&Uscr;": "",
      "&Utilde;": "",
      "&Uuml": "",
      "&Uuml;": "",
      "&VDash;": "",
      "&Vbar;": "",
      "&Vcy;": "",
      "&Vdash;": "",
      "&Vdashl;": "",
      "&Vee;": "",
      "&Verbar;": "",
      "&Vert;": "",
      "&VerticalBar;": "",
      "&VerticalLine;": "|",
      "&VerticalSeparator;": "",
      "&VerticalTilde;": "",
      "&VeryThinSpace;": "",
      "&Vfr;": "",
      "&Vopf;": "",
      "&Vscr;": "",
      "&Vvdash;": "",
      "&Wcirc;": "",
      "&Wedge;": "",
      "&Wfr;": "",
      "&Wopf;": "",
      "&Wscr;": "",
      "&Xfr;": "",
      "&Xi;": "",
      "&Xopf;": "",
      "&Xscr;": "",
      "&YAcy;": "",
      "&YIcy;": "",
      "&YUcy;": "",
      "&Yacute": "",
      "&Yacute;": "",
      "&Ycirc;": "",
      "&Ycy;": "",
      "&Yfr;": "",
      "&Yopf;": "",
      "&Yscr;": "",
      "&Yuml;": "",
      "&ZHcy;": "",
      "&Zacute;": "",
      "&Zcaron;": "",
      "&Zcy;": "",
      "&Zdot;": "",
      "&ZeroWidthSpace;": "",
      "&Zeta;": "",
      "&Zfr;": "",
      "&Zopf;": "",
      "&Zscr;": "",
      "&aacute": "",
      "&aacute;": "",
      "&abreve;": "",
      "&ac;": "",
      "&acE;": "",
      "&acd;": "",
      "&acirc": "",
      "&acirc;": "",
      "&acute": "",
      "&acute;": "",
      "&acy;": "",
      "&aelig": "",
      "&aelig;": "",
      "&af;": "",
      "&afr;": "",
      "&agrave": "",
      "&agrave;": "",
      "&alefsym;": "",
      "&aleph;": "",
      "&alpha;": "",
      "&amacr;": "",
      "&amalg;": "",
      "&amp": "&",
      "&amp;": "&",
      "&and;": "",
      "&andand;": "",
      "&andd;": "",
      "&andslope;": "",
      "&andv;": "",
      "&ang;": "",
      "&ange;": "",
      "&angle;": "",
      "&angmsd;": "",
      "&angmsdaa;": "",
      "&angmsdab;": "",
      "&angmsdac;": "",
      "&angmsdad;": "",
      "&angmsdae;": "",
      "&angmsdaf;": "",
      "&angmsdag;": "",
      "&angmsdah;": "",
      "&angrt;": "",
      "&angrtvb;": "",
      "&angrtvbd;": "",
      "&angsph;": "",
      "&angst;": "",
      "&angzarr;": "",
      "&aogon;": "",
      "&aopf;": "",
      "&ap;": "",
      "&apE;": "",
      "&apacir;": "",
      "&ape;": "",
      "&apid;": "",
      "&apos;": "'",
      "&approx;": "",
      "&approxeq;": "",
      "&aring": "",
      "&aring;": "",
      "&ascr;": "",
      "&ast;": "*",
      "&asymp;": "",
      "&asympeq;": "",
      "&atilde": "",
      "&atilde;": "",
      "&auml": "",
      "&auml;": "",
      "&awconint;": "",
      "&awint;": "",
      "&bNot;": "",
      "&backcong;": "",
      "&backepsilon;": "",
      "&backprime;": "",
      "&backsim;": "",
      "&backsimeq;": "",
      "&barvee;": "",
      "&barwed;": "",
      "&barwedge;": "",
      "&bbrk;": "",
      "&bbrktbrk;": "",
      "&bcong;": "",
      "&bcy;": "",
      "&bdquo;": "",
      "&becaus;": "",
      "&because;": "",
      "&bemptyv;": "",
      "&bepsi;": "",
      "&bernou;": "",
      "&beta;": "",
      "&beth;": "",
      "&between;": "",
      "&bfr;": "",
      "&bigcap;": "",
      "&bigcirc;": "",
      "&bigcup;": "",
      "&bigodot;": "",
      "&bigoplus;": "",
      "&bigotimes;": "",
      "&bigsqcup;": "",
      "&bigstar;": "",
      "&bigtriangledown;": "",
      "&bigtriangleup;": "",
      "&biguplus;": "",
      "&bigvee;": "",
      "&bigwedge;": "",
      "&bkarow;": "",
      "&blacklozenge;": "",
      "&blacksquare;": "",
      "&blacktriangle;": "",
      "&blacktriangledown;": "",
      "&blacktriangleleft;": "",
      "&blacktriangleright;": "",
      "&blank;": "",
      "&blk12;": "",
      "&blk14;": "",
      "&blk34;": "",
      "&block;": "",
      "&bne;": "=",
      "&bnequiv;": "",
      "&bnot;": "",
      "&bopf;": "",
      "&bot;": "",
      "&bottom;": "",
      "&bowtie;": "",
      "&boxDL;": "",
      "&boxDR;": "",
      "&boxDl;": "",
      "&boxDr;": "",
      "&boxH;": "",
      "&boxHD;": "",
      "&boxHU;": "",
      "&boxHd;": "",
      "&boxHu;": "",
      "&boxUL;": "",
      "&boxUR;": "",
      "&boxUl;": "",
      "&boxUr;": "",
      "&boxV;": "",
      "&boxVH;": "",
      "&boxVL;": "",
      "&boxVR;": "",
      "&boxVh;": "",
      "&boxVl;": "",
      "&boxVr;": "",
      "&boxbox;": "",
      "&boxdL;": "",
      "&boxdR;": "",
      "&boxdl;": "",
      "&boxdr;": "",
      "&boxh;": "",
      "&boxhD;": "",
      "&boxhU;": "",
      "&boxhd;": "",
      "&boxhu;": "",
      "&boxminus;": "",
      "&boxplus;": "",
      "&boxtimes;": "",
      "&boxuL;": "",
      "&boxuR;": "",
      "&boxul;": "",
      "&boxur;": "",
      "&boxv;": "",
      "&boxvH;": "",
      "&boxvL;": "",
      "&boxvR;": "",
      "&boxvh;": "",
      "&boxvl;": "",
      "&boxvr;": "",
      "&bprime;": "",
      "&breve;": "",
      "&brvbar": "",
      "&brvbar;": "",
      "&bscr;": "",
      "&bsemi;": "",
      "&bsim;": "",
      "&bsime;": "",
      "&bsol;": "\\",
      "&bsolb;": "",
      "&bsolhsub;": "",
      "&bull;": "",
      "&bullet;": "",
      "&bump;": "",
      "&bumpE;": "",
      "&bumpe;": "",
      "&bumpeq;": "",
      "&cacute;": "",
      "&cap;": "",
      "&capand;": "",
      "&capbrcup;": "",
      "&capcap;": "",
      "&capcup;": "",
      "&capdot;": "",
      "&caps;": "",
      "&caret;": "",
      "&caron;": "",
      "&ccaps;": "",
      "&ccaron;": "",
      "&ccedil": "",
      "&ccedil;": "",
      "&ccirc;": "",
      "&ccups;": "",
      "&ccupssm;": "",
      "&cdot;": "",
      "&cedil": "",
      "&cedil;": "",
      "&cemptyv;": "",
      "&cent": "",
      "&cent;": "",
      "&centerdot;": "",
      "&cfr;": "",
      "&chcy;": "",
      "&check;": "",
      "&checkmark;": "",
      "&chi;": "",
      "&cir;": "",
      "&cirE;": "",
      "&circ;": "",
      "&circeq;": "",
      "&circlearrowleft;": "",
      "&circlearrowright;": "",
      "&circledR;": "",
      "&circledS;": "",
      "&circledast;": "",
      "&circledcirc;": "",
      "&circleddash;": "",
      "&cire;": "",
      "&cirfnint;": "",
      "&cirmid;": "",
      "&cirscir;": "",
      "&clubs;": "",
      "&clubsuit;": "",
      "&colon;": ":",
      "&colone;": "",
      "&coloneq;": "",
      "&comma;": ",",
      "&commat;": "@",
      "&comp;": "",
      "&compfn;": "",
      "&complement;": "",
      "&complexes;": "",
      "&cong;": "",
      "&congdot;": "",
      "&conint;": "",
      "&copf;": "",
      "&coprod;": "",
      "&copy": "",
      "&copy;": "",
      "&copysr;": "",
      "&crarr;": "",
      "&cross;": "",
      "&cscr;": "",
      "&csub;": "",
      "&csube;": "",
      "&csup;": "",
      "&csupe;": "",
      "&ctdot;": "",
      "&cudarrl;": "",
      "&cudarrr;": "",
      "&cuepr;": "",
      "&cuesc;": "",
      "&cularr;": "",
      "&cularrp;": "",
      "&cup;": "",
      "&cupbrcap;": "",
      "&cupcap;": "",
      "&cupcup;": "",
      "&cupdot;": "",
      "&cupor;": "",
      "&cups;": "",
      "&curarr;": "",
      "&curarrm;": "",
      "&curlyeqprec;": "",
      "&curlyeqsucc;": "",
      "&curlyvee;": "",
      "&curlywedge;": "",
      "&curren": "",
      "&curren;": "",
      "&curvearrowleft;": "",
      "&curvearrowright;": "",
      "&cuvee;": "",
      "&cuwed;": "",
      "&cwconint;": "",
      "&cwint;": "",
      "&cylcty;": "",
      "&dArr;": "",
      "&dHar;": "",
      "&dagger;": "",
      "&daleth;": "",
      "&darr;": "",
      "&dash;": "",
      "&dashv;": "",
      "&dbkarow;": "",
      "&dblac;": "",
      "&dcaron;": "",
      "&dcy;": "",
      "&dd;": "",
      "&ddagger;": "",
      "&ddarr;": "",
      "&ddotseq;": "",
      "&deg": "",
      "&deg;": "",
      "&delta;": "",
      "&demptyv;": "",
      "&dfisht;": "",
      "&dfr;": "",
      "&dharl;": "",
      "&dharr;": "",
      "&diam;": "",
      "&diamond;": "",
      "&diamondsuit;": "",
      "&diams;": "",
      "&die;": "",
      "&digamma;": "",
      "&disin;": "",
      "&div;": "",
      "&divide": "",
      "&divide;": "",
      "&divideontimes;": "",
      "&divonx;": "",
      "&djcy;": "",
      "&dlcorn;": "",
      "&dlcrop;": "",
      "&dollar;": "$",
      "&dopf;": "",
      "&dot;": "",
      "&doteq;": "",
      "&doteqdot;": "",
      "&dotminus;": "",
      "&dotplus;": "",
      "&dotsquare;": "",
      "&doublebarwedge;": "",
      "&downarrow;": "",
      "&downdownarrows;": "",
      "&downharpoonleft;": "",
      "&downharpoonright;": "",
      "&drbkarow;": "",
      "&drcorn;": "",
      "&drcrop;": "",
      "&dscr;": "",
      "&dscy;": "",
      "&dsol;": "",
      "&dstrok;": "",
      "&dtdot;": "",
      "&dtri;": "",
      "&dtrif;": "",
      "&duarr;": "",
      "&duhar;": "",
      "&dwangle;": "",
      "&dzcy;": "",
      "&dzigrarr;": "",
      "&eDDot;": "",
      "&eDot;": "",
      "&eacute": "",
      "&eacute;": "",
      "&easter;": "",
      "&ecaron;": "",
      "&ecir;": "",
      "&ecirc": "",
      "&ecirc;": "",
      "&ecolon;": "",
      "&ecy;": "",
      "&edot;": "",
      "&ee;": "",
      "&efDot;": "",
      "&efr;": "",
      "&eg;": "",
      "&egrave": "",
      "&egrave;": "",
      "&egs;": "",
      "&egsdot;": "",
      "&el;": "",
      "&elinters;": "",
      "&ell;": "",
      "&els;": "",
      "&elsdot;": "",
      "&emacr;": "",
      "&empty;": "",
      "&emptyset;": "",
      "&emptyv;": "",
      "&emsp13;": "",
      "&emsp14;": "",
      "&emsp;": "",
      "&eng;": "",
      "&ensp;": "",
      "&eogon;": "",
      "&eopf;": "",
      "&epar;": "",
      "&eparsl;": "",
      "&eplus;": "",
      "&epsi;": "",
      "&epsilon;": "",
      "&epsiv;": "",
      "&eqcirc;": "",
      "&eqcolon;": "",
      "&eqsim;": "",
      "&eqslantgtr;": "",
      "&eqslantless;": "",
      "&equals;": "=",
      "&equest;": "",
      "&equiv;": "",
      "&equivDD;": "",
      "&eqvparsl;": "",
      "&erDot;": "",
      "&erarr;": "",
      "&escr;": "",
      "&esdot;": "",
      "&esim;": "",
      "&eta;": "",
      "&eth": "",
      "&eth;": "",
      "&euml": "",
      "&euml;": "",
      "&euro;": "",
      "&excl;": "!",
      "&exist;": "",
      "&expectation;": "",
      "&exponentiale;": "",
      "&fallingdotseq;": "",
      "&fcy;": "",
      "&female;": "",
      "&ffilig;": "",
      "&fflig;": "",
      "&ffllig;": "",
      "&ffr;": "",
      "&filig;": "",
      "&fjlig;": "fj",
      "&flat;": "",
      "&fllig;": "",
      "&fltns;": "",
      "&fnof;": "",
      "&fopf;": "",
      "&forall;": "",
      "&fork;": "",
      "&forkv;": "",
      "&fpartint;": "",
      "&frac12": "",
      "&frac12;": "",
      "&frac13;": "",
      "&frac14": "",
      "&frac14;": "",
      "&frac15;": "",
      "&frac16;": "",
      "&frac18;": "",
      "&frac23;": "",
      "&frac25;": "",
      "&frac34": "",
      "&frac34;": "",
      "&frac35;": "",
      "&frac38;": "",
      "&frac45;": "",
      "&frac56;": "",
      "&frac58;": "",
      "&frac78;": "",
      "&frasl;": "",
      "&frown;": "",
      "&fscr;": "",
      "&gE;": "",
      "&gEl;": "",
      "&gacute;": "",
      "&gamma;": "",
      "&gammad;": "",
      "&gap;": "",
      "&gbreve;": "",
      "&gcirc;": "",
      "&gcy;": "",
      "&gdot;": "",
      "&ge;": "",
      "&gel;": "",
      "&geq;": "",
      "&geqq;": "",
      "&geqslant;": "",
      "&ges;": "",
      "&gescc;": "",
      "&gesdot;": "",
      "&gesdoto;": "",
      "&gesdotol;": "",
      "&gesl;": "",
      "&gesles;": "",
      "&gfr;": "",
      "&gg;": "",
      "&ggg;": "",
      "&gimel;": "",
      "&gjcy;": "",
      "&gl;": "",
      "&glE;": "",
      "&gla;": "",
      "&glj;": "",
      "&gnE;": "",
      "&gnap;": "",
      "&gnapprox;": "",
      "&gne;": "",
      "&gneq;": "",
      "&gneqq;": "",
      "&gnsim;": "",
      "&gopf;": "",
      "&grave;": "`",
      "&gscr;": "",
      "&gsim;": "",
      "&gsime;": "",
      "&gsiml;": "",
      "&gt": ">",
      "&gt;": ">",
      "&gtcc;": "",
      "&gtcir;": "",
      "&gtdot;": "",
      "&gtlPar;": "",
      "&gtquest;": "",
      "&gtrapprox;": "",
      "&gtrarr;": "",
      "&gtrdot;": "",
      "&gtreqless;": "",
      "&gtreqqless;": "",
      "&gtrless;": "",
      "&gtrsim;": "",
      "&gvertneqq;": "",
      "&gvnE;": "",
      "&hArr;": "",
      "&hairsp;": "",
      "&half;": "",
      "&hamilt;": "",
      "&hardcy;": "",
      "&harr;": "",
      "&harrcir;": "",
      "&harrw;": "",
      "&hbar;": "",
      "&hcirc;": "",
      "&hearts;": "",
      "&heartsuit;": "",
      "&hellip;": "",
      "&hercon;": "",
      "&hfr;": "",
      "&hksearow;": "",
      "&hkswarow;": "",
      "&hoarr;": "",
      "&homtht;": "",
      "&hookleftarrow;": "",
      "&hookrightarrow;": "",
      "&hopf;": "",
      "&horbar;": "",
      "&hscr;": "",
      "&hslash;": "",
      "&hstrok;": "",
      "&hybull;": "",
      "&hyphen;": "",
      "&iacute": "",
      "&iacute;": "",
      "&ic;": "",
      "&icirc": "",
      "&icirc;": "",
      "&icy;": "",
      "&iecy;": "",
      "&iexcl": "",
      "&iexcl;": "",
      "&iff;": "",
      "&ifr;": "",
      "&igrave": "",
      "&igrave;": "",
      "&ii;": "",
      "&iiiint;": "",
      "&iiint;": "",
      "&iinfin;": "",
      "&iiota;": "",
      "&ijlig;": "",
      "&imacr;": "",
      "&image;": "",
      "&imagline;": "",
      "&imagpart;": "",
      "&imath;": "",
      "&imof;": "",
      "&imped;": "",
      "&in;": "",
      "&incare;": "",
      "&infin;": "",
      "&infintie;": "",
      "&inodot;": "",
      "&int;": "",
      "&intcal;": "",
      "&integers;": "",
      "&intercal;": "",
      "&intlarhk;": "",
      "&intprod;": "",
      "&iocy;": "",
      "&iogon;": "",
      "&iopf;": "",
      "&iota;": "",
      "&iprod;": "",
      "&iquest": "",
      "&iquest;": "",
      "&iscr;": "",
      "&isin;": "",
      "&isinE;": "",
      "&isindot;": "",
      "&isins;": "",
      "&isinsv;": "",
      "&isinv;": "",
      "&it;": "",
      "&itilde;": "",
      "&iukcy;": "",
      "&iuml": "",
      "&iuml;": "",
      "&jcirc;": "",
      "&jcy;": "",
      "&jfr;": "",
      "&jmath;": "",
      "&jopf;": "",
      "&jscr;": "",
      "&jsercy;": "",
      "&jukcy;": "",
      "&kappa;": "",
      "&kappav;": "",
      "&kcedil;": "",
      "&kcy;": "",
      "&kfr;": "",
      "&kgreen;": "",
      "&khcy;": "",
      "&kjcy;": "",
      "&kopf;": "",
      "&kscr;": "",
      "&lAarr;": "",
      "&lArr;": "",
      "&lAtail;": "",
      "&lBarr;": "",
      "&lE;": "",
      "&lEg;": "",
      "&lHar;": "",
      "&lacute;": "",
      "&laemptyv;": "",
      "&lagran;": "",
      "&lambda;": "",
      "&lang;": "",
      "&langd;": "",
      "&langle;": "",
      "&lap;": "",
      "&laquo": "",
      "&laquo;": "",
      "&larr;": "",
      "&larrb;": "",
      "&larrbfs;": "",
      "&larrfs;": "",
      "&larrhk;": "",
      "&larrlp;": "",
      "&larrpl;": "",
      "&larrsim;": "",
      "&larrtl;": "",
      "&lat;": "",
      "&latail;": "",
      "&late;": "",
      "&lates;": "",
      "&lbarr;": "",
      "&lbbrk;": "",
      "&lbrace;": "{",
      "&lbrack;": "[",
      "&lbrke;": "",
      "&lbrksld;": "",
      "&lbrkslu;": "",
      "&lcaron;": "",
      "&lcedil;": "",
      "&lceil;": "",
      "&lcub;": "{",
      "&lcy;": "",
      "&ldca;": "",
      "&ldquo;": "",
      "&ldquor;": "",
      "&ldrdhar;": "",
      "&ldrushar;": "",
      "&ldsh;": "",
      "&le;": "",
      "&leftarrow;": "",
      "&leftarrowtail;": "",
      "&leftharpoondown;": "",
      "&leftharpoonup;": "",
      "&leftleftarrows;": "",
      "&leftrightarrow;": "",
      "&leftrightarrows;": "",
      "&leftrightharpoons;": "",
      "&leftrightsquigarrow;": "",
      "&leftthreetimes;": "",
      "&leg;": "",
      "&leq;": "",
      "&leqq;": "",
      "&leqslant;": "",
      "&les;": "",
      "&lescc;": "",
      "&lesdot;": "",
      "&lesdoto;": "",
      "&lesdotor;": "",
      "&lesg;": "",
      "&lesges;": "",
      "&lessapprox;": "",
      "&lessdot;": "",
      "&lesseqgtr;": "",
      "&lesseqqgtr;": "",
      "&lessgtr;": "",
      "&lesssim;": "",
      "&lfisht;": "",
      "&lfloor;": "",
      "&lfr;": "",
      "&lg;": "",
      "&lgE;": "",
      "&lhard;": "",
      "&lharu;": "",
      "&lharul;": "",
      "&lhblk;": "",
      "&ljcy;": "",
      "&ll;": "",
      "&llarr;": "",
      "&llcorner;": "",
      "&llhard;": "",
      "&lltri;": "",
      "&lmidot;": "",
      "&lmoust;": "",
      "&lmoustache;": "",
      "&lnE;": "",
      "&lnap;": "",
      "&lnapprox;": "",
      "&lne;": "",
      "&lneq;": "",
      "&lneqq;": "",
      "&lnsim;": "",
      "&loang;": "",
      "&loarr;": "",
      "&lobrk;": "",
      "&longleftarrow;": "",
      "&longleftrightarrow;": "",
      "&longmapsto;": "",
      "&longrightarrow;": "",
      "&looparrowleft;": "",
      "&looparrowright;": "",
      "&lopar;": "",
      "&lopf;": "",
      "&loplus;": "",
      "&lotimes;": "",
      "&lowast;": "",
      "&lowbar;": "_",
      "&loz;": "",
      "&lozenge;": "",
      "&lozf;": "",
      "&lpar;": "(",
      "&lparlt;": "",
      "&lrarr;": "",
      "&lrcorner;": "",
      "&lrhar;": "",
      "&lrhard;": "",
      "&lrm;": "",
      "&lrtri;": "",
      "&lsaquo;": "",
      "&lscr;": "",
      "&lsh;": "",
      "&lsim;": "",
      "&lsime;": "",
      "&lsimg;": "",
      "&lsqb;": "[",
      "&lsquo;": "",
      "&lsquor;": "",
      "&lstrok;": "",
      "&lt": "<",
      "&lt;": "<",
      "&ltcc;": "",
      "&ltcir;": "",
      "&ltdot;": "",
      "&lthree;": "",
      "&ltimes;": "",
      "&ltlarr;": "",
      "&ltquest;": "",
      "&ltrPar;": "",
      "&ltri;": "",
      "&ltrie;": "",
      "&ltrif;": "",
      "&lurdshar;": "",
      "&luruhar;": "",
      "&lvertneqq;": "",
      "&lvnE;": "",
      "&mDDot;": "",
      "&macr": "",
      "&macr;": "",
      "&male;": "",
      "&malt;": "",
      "&maltese;": "",
      "&map;": "",
      "&mapsto;": "",
      "&mapstodown;": "",
      "&mapstoleft;": "",
      "&mapstoup;": "",
      "&marker;": "",
      "&mcomma;": "",
      "&mcy;": "",
      "&mdash;": "",
      "&measuredangle;": "",
      "&mfr;": "",
      "&mho;": "",
      "&micro": "",
      "&micro;": "",
      "&mid;": "",
      "&midast;": "*",
      "&midcir;": "",
      "&middot": "",
      "&middot;": "",
      "&minus;": "",
      "&minusb;": "",
      "&minusd;": "",
      "&minusdu;": "",
      "&mlcp;": "",
      "&mldr;": "",
      "&mnplus;": "",
      "&models;": "",
      "&mopf;": "",
      "&mp;": "",
      "&mscr;": "",
      "&mstpos;": "",
      "&mu;": "",
      "&multimap;": "",
      "&mumap;": "",
      "&nGg;": "",
      "&nGt;": "",
      "&nGtv;": "",
      "&nLeftarrow;": "",
      "&nLeftrightarrow;": "",
      "&nLl;": "",
      "&nLt;": "",
      "&nLtv;": "",
      "&nRightarrow;": "",
      "&nVDash;": "",
      "&nVdash;": "",
      "&nabla;": "",
      "&nacute;": "",
      "&nang;": "",
      "&nap;": "",
      "&napE;": "",
      "&napid;": "",
      "&napos;": "",
      "&napprox;": "",
      "&natur;": "",
      "&natural;": "",
      "&naturals;": "",
      "&nbsp": "",
      "&nbsp;": "",
      "&nbump;": "",
      "&nbumpe;": "",
      "&ncap;": "",
      "&ncaron;": "",
      "&ncedil;": "",
      "&ncong;": "",
      "&ncongdot;": "",
      "&ncup;": "",
      "&ncy;": "",
      "&ndash;": "",
      "&ne;": "",
      "&neArr;": "",
      "&nearhk;": "",
      "&nearr;": "",
      "&nearrow;": "",
      "&nedot;": "",
      "&nequiv;": "",
      "&nesear;": "",
      "&nesim;": "",
      "&nexist;": "",
      "&nexists;": "",
      "&nfr;": "",
      "&ngE;": "",
      "&nge;": "",
      "&ngeq;": "",
      "&ngeqq;": "",
      "&ngeqslant;": "",
      "&nges;": "",
      "&ngsim;": "",
      "&ngt;": "",
      "&ngtr;": "",
      "&nhArr;": "",
      "&nharr;": "",
      "&nhpar;": "",
      "&ni;": "",
      "&nis;": "",
      "&nisd;": "",
      "&niv;": "",
      "&njcy;": "",
      "&nlArr;": "",
      "&nlE;": "",
      "&nlarr;": "",
      "&nldr;": "",
      "&nle;": "",
      "&nleftarrow;": "",
      "&nleftrightarrow;": "",
      "&nleq;": "",
      "&nleqq;": "",
      "&nleqslant;": "",
      "&nles;": "",
      "&nless;": "",
      "&nlsim;": "",
      "&nlt;": "",
      "&nltri;": "",
      "&nltrie;": "",
      "&nmid;": "",
      "&nopf;": "",
      "&not": "",
      "&not;": "",
      "&notin;": "",
      "&notinE;": "",
      "&notindot;": "",
      "&notinva;": "",
      "&notinvb;": "",
      "&notinvc;": "",
      "&notni;": "",
      "&notniva;": "",
      "&notnivb;": "",
      "&notnivc;": "",
      "&npar;": "",
      "&nparallel;": "",
      "&nparsl;": "",
      "&npart;": "",
      "&npolint;": "",
      "&npr;": "",
      "&nprcue;": "",
      "&npre;": "",
      "&nprec;": "",
      "&npreceq;": "",
      "&nrArr;": "",
      "&nrarr;": "",
      "&nrarrc;": "",
      "&nrarrw;": "",
      "&nrightarrow;": "",
      "&nrtri;": "",
      "&nrtrie;": "",
      "&nsc;": "",
      "&nsccue;": "",
      "&nsce;": "",
      "&nscr;": "",
      "&nshortmid;": "",
      "&nshortparallel;": "",
      "&nsim;": "",
      "&nsime;": "",
      "&nsimeq;": "",
      "&nsmid;": "",
      "&nspar;": "",
      "&nsqsube;": "",
      "&nsqsupe;": "",
      "&nsub;": "",
      "&nsubE;": "",
      "&nsube;": "",
      "&nsubset;": "",
      "&nsubseteq;": "",
      "&nsubseteqq;": "",
      "&nsucc;": "",
      "&nsucceq;": "",
      "&nsup;": "",
      "&nsupE;": "",
      "&nsupe;": "",
      "&nsupset;": "",
      "&nsupseteq;": "",
      "&nsupseteqq;": "",
      "&ntgl;": "",
      "&ntilde": "",
      "&ntilde;": "",
      "&ntlg;": "",
      "&ntriangleleft;": "",
      "&ntrianglelefteq;": "",
      "&ntriangleright;": "",
      "&ntrianglerighteq;": "",
      "&nu;": "",
      "&num;": "#",
      "&numero;": "",
      "&numsp;": "",
      "&nvDash;": "",
      "&nvHarr;": "",
      "&nvap;": "",
      "&nvdash;": "",
      "&nvge;": "",
      "&nvgt;": ">",
      "&nvinfin;": "",
      "&nvlArr;": "",
      "&nvle;": "",
      "&nvlt;": "<",
      "&nvltrie;": "",
      "&nvrArr;": "",
      "&nvrtrie;": "",
      "&nvsim;": "",
      "&nwArr;": "",
      "&nwarhk;": "",
      "&nwarr;": "",
      "&nwarrow;": "",
      "&nwnear;": "",
      "&oS;": "",
      "&oacute": "",
      "&oacute;": "",
      "&oast;": "",
      "&ocir;": "",
      "&ocirc": "",
      "&ocirc;": "",
      "&ocy;": "",
      "&odash;": "",
      "&odblac;": "",
      "&odiv;": "",
      "&odot;": "",
      "&odsold;": "",
      "&oelig;": "",
      "&ofcir;": "",
      "&ofr;": "",
      "&ogon;": "",
      "&ograve": "",
      "&ograve;": "",
      "&ogt;": "",
      "&ohbar;": "",
      "&ohm;": "",
      "&oint;": "",
      "&olarr;": "",
      "&olcir;": "",
      "&olcross;": "",
      "&oline;": "",
      "&olt;": "",
      "&omacr;": "",
      "&omega;": "",
      "&omicron;": "",
      "&omid;": "",
      "&ominus;": "",
      "&oopf;": "",
      "&opar;": "",
      "&operp;": "",
      "&oplus;": "",
      "&or;": "",
      "&orarr;": "",
      "&ord;": "",
      "&order;": "",
      "&orderof;": "",
      "&ordf": "",
      "&ordf;": "",
      "&ordm": "",
      "&ordm;": "",
      "&origof;": "",
      "&oror;": "",
      "&orslope;": "",
      "&orv;": "",
      "&oscr;": "",
      "&oslash": "",
      "&oslash;": "",
      "&osol;": "",
      "&otilde": "",
      "&otilde;": "",
      "&otimes;": "",
      "&otimesas;": "",
      "&ouml": "",
      "&ouml;": "",
      "&ovbar;": "",
      "&par;": "",
      "&para": "",
      "&para;": "",
      "&parallel;": "",
      "&parsim;": "",
      "&parsl;": "",
      "&part;": "",
      "&pcy;": "",
      "&percnt;": "%",
      "&period;": ".",
      "&permil;": "",
      "&perp;": "",
      "&pertenk;": "",
      "&pfr;": "",
      "&phi;": "",
      "&phiv;": "",
      "&phmmat;": "",
      "&phone;": "",
      "&pi;": "",
      "&pitchfork;": "",
      "&piv;": "",
      "&planck;": "",
      "&planckh;": "",
      "&plankv;": "",
      "&plus;": "+",
      "&plusacir;": "",
      "&plusb;": "",
      "&pluscir;": "",
      "&plusdo;": "",
      "&plusdu;": "",
      "&pluse;": "",
      "&plusmn": "",
      "&plusmn;": "",
      "&plussim;": "",
      "&plustwo;": "",
      "&pm;": "",
      "&pointint;": "",
      "&popf;": "",
      "&pound": "",
      "&pound;": "",
      "&pr;": "",
      "&prE;": "",
      "&prap;": "",
      "&prcue;": "",
      "&pre;": "",
      "&prec;": "",
      "&precapprox;": "",
      "&preccurlyeq;": "",
      "&preceq;": "",
      "&precnapprox;": "",
      "&precneqq;": "",
      "&precnsim;": "",
      "&precsim;": "",
      "&prime;": "",
      "&primes;": "",
      "&prnE;": "",
      "&prnap;": "",
      "&prnsim;": "",
      "&prod;": "",
      "&profalar;": "",
      "&profline;": "",
      "&profsurf;": "",
      "&prop;": "",
      "&propto;": "",
      "&prsim;": "",
      "&prurel;": "",
      "&pscr;": "",
      "&psi;": "",
      "&puncsp;": "",
      "&qfr;": "",
      "&qint;": "",
      "&qopf;": "",
      "&qprime;": "",
      "&qscr;": "",
      "&quaternions;": "",
      "&quatint;": "",
      "&quest;": "?",
      "&questeq;": "",
      "&quot": '"',
      "&quot;": '"',
      "&rAarr;": "",
      "&rArr;": "",
      "&rAtail;": "",
      "&rBarr;": "",
      "&rHar;": "",
      "&race;": "",
      "&racute;": "",
      "&radic;": "",
      "&raemptyv;": "",
      "&rang;": "",
      "&rangd;": "",
      "&range;": "",
      "&rangle;": "",
      "&raquo": "",
      "&raquo;": "",
      "&rarr;": "",
      "&rarrap;": "",
      "&rarrb;": "",
      "&rarrbfs;": "",
      "&rarrc;": "",
      "&rarrfs;": "",
      "&rarrhk;": "",
      "&rarrlp;": "",
      "&rarrpl;": "",
      "&rarrsim;": "",
      "&rarrtl;": "",
      "&rarrw;": "",
      "&ratail;": "",
      "&ratio;": "",
      "&rationals;": "",
      "&rbarr;": "",
      "&rbbrk;": "",
      "&rbrace;": "}",
      "&rbrack;": "]",
      "&rbrke;": "",
      "&rbrksld;": "",
      "&rbrkslu;": "",
      "&rcaron;": "",
      "&rcedil;": "",
      "&rceil;": "",
      "&rcub;": "}",
      "&rcy;": "",
      "&rdca;": "",
      "&rdldhar;": "",
      "&rdquo;": "",
      "&rdquor;": "",
      "&rdsh;": "",
      "&real;": "",
      "&realine;": "",
      "&realpart;": "",
      "&reals;": "",
      "&rect;": "",
      "&reg": "",
      "&reg;": "",
      "&rfisht;": "",
      "&rfloor;": "",
      "&rfr;": "",
      "&rhard;": "",
      "&rharu;": "",
      "&rharul;": "",
      "&rho;": "",
      "&rhov;": "",
      "&rightarrow;": "",
      "&rightarrowtail;": "",
      "&rightharpoondown;": "",
      "&rightharpoonup;": "",
      "&rightleftarrows;": "",
      "&rightleftharpoons;": "",
      "&rightrightarrows;": "",
      "&rightsquigarrow;": "",
      "&rightthreetimes;": "",
      "&ring;": "",
      "&risingdotseq;": "",
      "&rlarr;": "",
      "&rlhar;": "",
      "&rlm;": "",
      "&rmoust;": "",
      "&rmoustache;": "",
      "&rnmid;": "",
      "&roang;": "",
      "&roarr;": "",
      "&robrk;": "",
      "&ropar;": "",
      "&ropf;": "",
      "&roplus;": "",
      "&rotimes;": "",
      "&rpar;": ")",
      "&rpargt;": "",
      "&rppolint;": "",
      "&rrarr;": "",
      "&rsaquo;": "",
      "&rscr;": "",
      "&rsh;": "",
      "&rsqb;": "]",
      "&rsquo;": "",
      "&rsquor;": "",
      "&rthree;": "",
      "&rtimes;": "",
      "&rtri;": "",
      "&rtrie;": "",
      "&rtrif;": "",
      "&rtriltri;": "",
      "&ruluhar;": "",
      "&rx;": "",
      "&sacute;": "",
      "&sbquo;": "",
      "&sc;": "",
      "&scE;": "",
      "&scap;": "",
      "&scaron;": "",
      "&sccue;": "",
      "&sce;": "",
      "&scedil;": "",
      "&scirc;": "",
      "&scnE;": "",
      "&scnap;": "",
      "&scnsim;": "",
      "&scpolint;": "",
      "&scsim;": "",
      "&scy;": "",
      "&sdot;": "",
      "&sdotb;": "",
      "&sdote;": "",
      "&seArr;": "",
      "&searhk;": "",
      "&searr;": "",
      "&searrow;": "",
      "&sect": "",
      "&sect;": "",
      "&semi;": ";",
      "&seswar;": "",
      "&setminus;": "",
      "&setmn;": "",
      "&sext;": "",
      "&sfr;": "",
      "&sfrown;": "",
      "&sharp;": "",
      "&shchcy;": "",
      "&shcy;": "",
      "&shortmid;": "",
      "&shortparallel;": "",
      "&shy": "",
      "&shy;": "",
      "&sigma;": "",
      "&sigmaf;": "",
      "&sigmav;": "",
      "&sim;": "",
      "&simdot;": "",
      "&sime;": "",
      "&simeq;": "",
      "&simg;": "",
      "&simgE;": "",
      "&siml;": "",
      "&simlE;": "",
      "&simne;": "",
      "&simplus;": "",
      "&simrarr;": "",
      "&slarr;": "",
      "&smallsetminus;": "",
      "&smashp;": "",
      "&smeparsl;": "",
      "&smid;": "",
      "&smile;": "",
      "&smt;": "",
      "&smte;": "",
      "&smtes;": "",
      "&softcy;": "",
      "&sol;": "/",
      "&solb;": "",
      "&solbar;": "",
      "&sopf;": "",
      "&spades;": "",
      "&spadesuit;": "",
      "&spar;": "",
      "&sqcap;": "",
      "&sqcaps;": "",
      "&sqcup;": "",
      "&sqcups;": "",
      "&sqsub;": "",
      "&sqsube;": "",
      "&sqsubset;": "",
      "&sqsubseteq;": "",
      "&sqsup;": "",
      "&sqsupe;": "",
      "&sqsupset;": "",
      "&sqsupseteq;": "",
      "&squ;": "",
      "&square;": "",
      "&squarf;": "",
      "&squf;": "",
      "&srarr;": "",
      "&sscr;": "",
      "&ssetmn;": "",
      "&ssmile;": "",
      "&sstarf;": "",
      "&star;": "",
      "&starf;": "",
      "&straightepsilon;": "",
      "&straightphi;": "",
      "&strns;": "",
      "&sub;": "",
      "&subE;": "",
      "&subdot;": "",
      "&sube;": "",
      "&subedot;": "",
      "&submult;": "",
      "&subnE;": "",
      "&subne;": "",
      "&subplus;": "",
      "&subrarr;": "",
      "&subset;": "",
      "&subseteq;": "",
      "&subseteqq;": "",
      "&subsetneq;": "",
      "&subsetneqq;": "",
      "&subsim;": "",
      "&subsub;": "",
      "&subsup;": "",
      "&succ;": "",
      "&succapprox;": "",
      "&succcurlyeq;": "",
      "&succeq;": "",
      "&succnapprox;": "",
      "&succneqq;": "",
      "&succnsim;": "",
      "&succsim;": "",
      "&sum;": "",
      "&sung;": "",
      "&sup1": "",
      "&sup1;": "",
      "&sup2": "",
      "&sup2;": "",
      "&sup3": "",
      "&sup3;": "",
      "&sup;": "",
      "&supE;": "",
      "&supdot;": "",
      "&supdsub;": "",
      "&supe;": "",
      "&supedot;": "",
      "&suphsol;": "",
      "&suphsub;": "",
      "&suplarr;": "",
      "&supmult;": "",
      "&supnE;": "",
      "&supne;": "",
      "&supplus;": "",
      "&supset;": "",
      "&supseteq;": "",
      "&supseteqq;": "",
      "&supsetneq;": "",
      "&supsetneqq;": "",
      "&supsim;": "",
      "&supsub;": "",
      "&supsup;": "",
      "&swArr;": "",
      "&swarhk;": "",
      "&swarr;": "",
      "&swarrow;": "",
      "&swnwar;": "",
      "&szlig": "",
      "&szlig;": "",
      "&target;": "",
      "&tau;": "",
      "&tbrk;": "",
      "&tcaron;": "",
      "&tcedil;": "",
      "&tcy;": "",
      "&tdot;": "",
      "&telrec;": "",
      "&tfr;": "",
      "&there4;": "",
      "&therefore;": "",
      "&theta;": "",
      "&thetasym;": "",
      "&thetav;": "",
      "&thickapprox;": "",
      "&thicksim;": "",
      "&thinsp;": "",
      "&thkap;": "",
      "&thksim;": "",
      "&thorn": "",
      "&thorn;": "",
      "&tilde;": "",
      "&times": "",
      "&times;": "",
      "&timesb;": "",
      "&timesbar;": "",
      "&timesd;": "",
      "&tint;": "",
      "&toea;": "",
      "&top;": "",
      "&topbot;": "",
      "&topcir;": "",
      "&topf;": "",
      "&topfork;": "",
      "&tosa;": "",
      "&tprime;": "",
      "&trade;": "",
      "&triangle;": "",
      "&triangledown;": "",
      "&triangleleft;": "",
      "&trianglelefteq;": "",
      "&triangleq;": "",
      "&triangleright;": "",
      "&trianglerighteq;": "",
      "&tridot;": "",
      "&trie;": "",
      "&triminus;": "",
      "&triplus;": "",
      "&trisb;": "",
      "&tritime;": "",
      "&trpezium;": "",
      "&tscr;": "",
      "&tscy;": "",
      "&tshcy;": "",
      "&tstrok;": "",
      "&twixt;": "",
      "&twoheadleftarrow;": "",
      "&twoheadrightarrow;": "",
      "&uArr;": "",
      "&uHar;": "",
      "&uacute": "",
      "&uacute;": "",
      "&uarr;": "",
      "&ubrcy;": "",
      "&ubreve;": "",
      "&ucirc": "",
      "&ucirc;": "",
      "&ucy;": "",
      "&udarr;": "",
      "&udblac;": "",
      "&udhar;": "",
      "&ufisht;": "",
      "&ufr;": "",
      "&ugrave": "",
      "&ugrave;": "",
      "&uharl;": "",
      "&uharr;": "",
      "&uhblk;": "",
      "&ulcorn;": "",
      "&ulcorner;": "",
      "&ulcrop;": "",
      "&ultri;": "",
      "&umacr;": "",
      "&uml": "",
      "&uml;": "",
      "&uogon;": "",
      "&uopf;": "",
      "&uparrow;": "",
      "&updownarrow;": "",
      "&upharpoonleft;": "",
      "&upharpoonright;": "",
      "&uplus;": "",
      "&upsi;": "",
      "&upsih;": "",
      "&upsilon;": "",
      "&upuparrows;": "",
      "&urcorn;": "",
      "&urcorner;": "",
      "&urcrop;": "",
      "&uring;": "",
      "&urtri;": "",
      "&uscr;": "",
      "&utdot;": "",
      "&utilde;": "",
      "&utri;": "",
      "&utrif;": "",
      "&uuarr;": "",
      "&uuml": "",
      "&uuml;": "",
      "&uwangle;": "",
      "&vArr;": "",
      "&vBar;": "",
      "&vBarv;": "",
      "&vDash;": "",
      "&vangrt;": "",
      "&varepsilon;": "",
      "&varkappa;": "",
      "&varnothing;": "",
      "&varphi;": "",
      "&varpi;": "",
      "&varpropto;": "",
      "&varr;": "",
      "&varrho;": "",
      "&varsigma;": "",
      "&varsubsetneq;": "",
      "&varsubsetneqq;": "",
      "&varsupsetneq;": "",
      "&varsupsetneqq;": "",
      "&vartheta;": "",
      "&vartriangleleft;": "",
      "&vartriangleright;": "",
      "&vcy;": "",
      "&vdash;": "",
      "&vee;": "",
      "&veebar;": "",
      "&veeeq;": "",
      "&vellip;": "",
      "&verbar;": "|",
      "&vert;": "|",
      "&vfr;": "",
      "&vltri;": "",
      "&vnsub;": "",
      "&vnsup;": "",
      "&vopf;": "",
      "&vprop;": "",
      "&vrtri;": "",
      "&vscr;": "",
      "&vsubnE;": "",
      "&vsubne;": "",
      "&vsupnE;": "",
      "&vsupne;": "",
      "&vzigzag;": "",
      "&wcirc;": "",
      "&wedbar;": "",
      "&wedge;": "",
      "&wedgeq;": "",
      "&weierp;": "",
      "&wfr;": "",
      "&wopf;": "",
      "&wp;": "",
      "&wr;": "",
      "&wreath;": "",
      "&wscr;": "",
      "&xcap;": "",
      "&xcirc;": "",
      "&xcup;": "",
      "&xdtri;": "",
      "&xfr;": "",
      "&xhArr;": "",
      "&xharr;": "",
      "&xi;": "",
      "&xlArr;": "",
      "&xlarr;": "",
      "&xmap;": "",
      "&xnis;": "",
      "&xodot;": "",
      "&xopf;": "",
      "&xoplus;": "",
      "&xotime;": "",
      "&xrArr;": "",
      "&xrarr;": "",
      "&xscr;": "",
      "&xsqcup;": "",
      "&xuplus;": "",
      "&xutri;": "",
      "&xvee;": "",
      "&xwedge;": "",
      "&yacute": "",
      "&yacute;": "",
      "&yacy;": "",
      "&ycirc;": "",
      "&ycy;": "",
      "&yen": "",
      "&yen;": "",
      "&yfr;": "",
      "&yicy;": "",
      "&yopf;": "",
      "&yscr;": "",
      "&yucy;": "",
      "&yuml": "",
      "&yuml;": "",
      "&zacute;": "",
      "&zcaron;": "",
      "&zcy;": "",
      "&zdot;": "",
      "&zeetrf;": "",
      "&zeta;": "",
      "&zfr;": "",
      "&zhcy;": "",
      "&zigrarr;": "",
      "&zopf;": "",
      "&zscr;": "",
      "&zwj;": "",
      "&zwnj;": ""
    },
    characters: {
      "": "&AElig;",
      "&": "&amp;",
      "": "&Aacute;",
      "": "&Abreve;",
      "": "&Acirc;",
      "": "&Acy;",
      "": "&Afr;",
      "": "&Agrave;",
      "": "&Alpha;",
      "": "&Amacr;",
      "": "&And;",
      "": "&Aogon;",
      "": "&Aopf;",
      "": "&af;",
      "": "&angst;",
      "": "&Ascr;",
      "": "&coloneq;",
      "": "&Atilde;",
      "": "&Auml;",
      "": "&ssetmn;",
      "": "&Barv;",
      "": "&doublebarwedge;",
      "": "&Bcy;",
      "": "&because;",
      "": "&bernou;",
      "": "&Beta;",
      "": "&Bfr;",
      "": "&Bopf;",
      "": "&breve;",
      "": "&bump;",
      "": "&CHcy;",
      "": "&copy;",
      "": "&Cacute;",
      "": "&Cap;",
      "": "&DD;",
      "": "&Cfr;",
      "": "&Ccaron;",
      "": "&Ccedil;",
      "": "&Ccirc;",
      "": "&Cconint;",
      "": "&Cdot;",
      "": "&cedil;",
      "": "&middot;",
      "": "&Chi;",
      "": "&odot;",
      "": "&ominus;",
      "": "&oplus;",
      "": "&otimes;",
      "": "&cwconint;",
      "": "&rdquor;",
      "": "&rsquor;",
      "": "&Proportion;",
      "": "&Colone;",
      "": "&equiv;",
      "": "&DoubleContourIntegral;",
      "": "&oint;",
      "": "&complexes;",
      "": "&coprod;",
      "": "&awconint;",
      "": "&Cross;",
      "": "&Cscr;",
      "": "&Cup;",
      "": "&asympeq;",
      "": "&DDotrahd;",
      "": "&DJcy;",
      "": "&DScy;",
      "": "&DZcy;",
      "": "&ddagger;",
      "": "&Darr;",
      "": "&DoubleLeftTee;",
      "": "&Dcaron;",
      "": "&Dcy;",
      "": "&nabla;",
      "": "&Delta;",
      "": "&Dfr;",
      "": "&acute;",
      "": "&dot;",
      "": "&dblac;",
      "`": "&grave;",
      "": "&tilde;",
      "": "&diamond;",
      "": "&dd;",
      "": "&Dopf;",
      "": "&uml;",
      "": "&DotDot;",
      "": "&esdot;",
      "": "&dArr;",
      "": "&lArr;",
      "": "&iff;",
      "": "&xlArr;",
      "": "&xhArr;",
      "": "&xrArr;",
      "": "&rArr;",
      "": "&vDash;",
      "": "&uArr;",
      "": "&vArr;",
      "": "&spar;",
      "": "&downarrow;",
      "": "&DownArrowBar;",
      "": "&duarr;",
      "": "&DownBreve;",
      "": "&DownLeftRightVector;",
      "": "&DownLeftTeeVector;",
      "": "&lhard;",
      "": "&DownLeftVectorBar;",
      "": "&DownRightTeeVector;",
      "": "&rightharpoondown;",
      "": "&DownRightVectorBar;",
      "": "&top;",
      "": "&mapstodown;",
      "": "&Dscr;",
      "": "&Dstrok;",
      "": "&ENG;",
      "": "&ETH;",
      "": "&Eacute;",
      "": "&Ecaron;",
      "": "&Ecirc;",
      "": "&Ecy;",
      "": "&Edot;",
      "": "&Efr;",
      "": "&Egrave;",
      "": "&isinv;",
      "": "&Emacr;",
      "": "&EmptySmallSquare;",
      "": "&EmptyVerySmallSquare;",
      "": "&Eogon;",
      "": "&Eopf;",
      "": "&Epsilon;",
      "": "&Equal;",
      "": "&esim;",
      "": "&rlhar;",
      "": "&expectation;",
      "": "&Esim;",
      "": "&Eta;",
      "": "&Euml;",
      "": "&exist;",
      "": "&exponentiale;",
      "": "&Fcy;",
      "": "&Ffr;",
      "": "&FilledSmallSquare;",
      "": "&squf;",
      "": "&Fopf;",
      "": "&forall;",
      "": "&Fscr;",
      "": "&GJcy;",
      ">": "&gt;",
      "": "&Gamma;",
      "": "&Gammad;",
      "": "&Gbreve;",
      "": "&Gcedil;",
      "": "&Gcirc;",
      "": "&Gcy;",
      "": "&Gdot;",
      "": "&Gfr;",
      "": "&ggg;",
      "": "&Gopf;",
      "": "&geq;",
      "": "&gtreqless;",
      "": "&geqq;",
      "": "&GreaterGreater;",
      "": "&gtrless;",
      "": "&ges;",
      "": "&gtrsim;",
      "": "&Gscr;",
      "": "&gg;",
      "": "&HARDcy;",
      "": "&caron;",
      "^": "&Hat;",
      "": "&Hcirc;",
      "": "&Poincareplane;",
      "": "&hamilt;",
      "": "&quaternions;",
      "": "&boxh;",
      "": "&Hstrok;",
      "": "&bumpeq;",
      "": "&IEcy;",
      "": "&IJlig;",
      "": "&IOcy;",
      "": "&Iacute;",
      "": "&Icirc;",
      "": "&Icy;",
      "": "&Idot;",
      "": "&imagpart;",
      "": "&Igrave;",
      "": "&Imacr;",
      "": "&ii;",
      "": "&Int;",
      "": "&int;",
      "": "&xcap;",
      "": "&ic;",
      "": "&it;",
      "": "&Iogon;",
      "": "&Iopf;",
      "": "&Iota;",
      "": "&imagline;",
      "": "&Itilde;",
      "": "&Iukcy;",
      "": "&Iuml;",
      "": "&Jcirc;",
      "": "&Jcy;",
      "": "&Jfr;",
      "": "&Jopf;",
      "": "&Jscr;",
      "": "&Jsercy;",
      "": "&Jukcy;",
      "": "&KHcy;",
      "": "&KJcy;",
      "": "&Kappa;",
      "": "&Kcedil;",
      "": "&Kcy;",
      "": "&Kfr;",
      "": "&Kopf;",
      "": "&Kscr;",
      "": "&LJcy;",
      "<": "&lt;",
      "": "&Lacute;",
      "": "&Lambda;",
      "": "&Lang;",
      "": "&lagran;",
      "": "&twoheadleftarrow;",
      "": "&Lcaron;",
      "": "&Lcedil;",
      "": "&Lcy;",
      "": "&langle;",
      "": "&slarr;",
      "": "&larrb;",
      "": "&lrarr;",
      "": "&lceil;",
      "": "&lobrk;",
      "": "&LeftDownTeeVector;",
      "": "&downharpoonleft;",
      "": "&LeftDownVectorBar;",
      "": "&lfloor;",
      "": "&leftrightarrow;",
      "": "&LeftRightVector;",
      "": "&dashv;",
      "": "&mapstoleft;",
      "": "&LeftTeeVector;",
      "": "&vltri;",
      "": "&LeftTriangleBar;",
      "": "&trianglelefteq;",
      "": "&LeftUpDownVector;",
      "": "&LeftUpTeeVector;",
      "": "&upharpoonleft;",
      "": "&LeftUpVectorBar;",
      "": "&lharu;",
      "": "&LeftVectorBar;",
      "": "&lesseqgtr;",
      "": "&leqq;",
      "": "&lg;",
      "": "&LessLess;",
      "": "&les;",
      "": "&lsim;",
      "": "&Lfr;",
      "": "&Ll;",
      "": "&lAarr;",
      "": "&Lmidot;",
      "": "&xlarr;",
      "": "&xharr;",
      "": "&xrarr;",
      "": "&Lopf;",
      "": "&swarrow;",
      "": "&searrow;",
      "": "&lsh;",
      "": "&Lstrok;",
      "": "&ll;",
      "": "&Map;",
      "": "&Mcy;",
      "": "&MediumSpace;",
      "": "&phmmat;",
      "": "&Mfr;",
      "": "&mp;",
      "": "&Mopf;",
      "": "&Mu;",
      "": "&NJcy;",
      "": "&Nacute;",
      "": "&Ncaron;",
      "": "&Ncedil;",
      "": "&Ncy;",
      "": "&ZeroWidthSpace;",
      "\n": "&NewLine;",
      "": "&Nfr;",
      "": "&NoBreak;",
      "": "&nbsp;",
      "": "&naturals;",
      "": "&Not;",
      "": "&nequiv;",
      "": "&NotCupCap;",
      "": "&nspar;",
      "": "&notinva;",
      "": "&ne;",
      "": "&nesim;",
      "": "&nexists;",
      "": "&ngtr;",
      "": "&ngeq;",
      "": "&ngeqq;",
      "": "&nGtv;",
      "": "&ntgl;",
      "": "&nges;",
      "": "&ngsim;",
      "": "&nbump;",
      "": "&nbumpe;",
      "": "&ntriangleleft;",
      "": "&NotLeftTriangleBar;",
      "": "&ntrianglelefteq;",
      "": "&nlt;",
      "": "&nleq;",
      "": "&ntlg;",
      "": "&nLtv;",
      "": "&nles;",
      "": "&nlsim;",
      "": "&NotNestedGreaterGreater;",
      "": "&NotNestedLessLess;",
      "": "&nprec;",
      "": "&npreceq;",
      "": "&nprcue;",
      "": "&notniva;",
      "": "&ntriangleright;",
      "": "&NotRightTriangleBar;",
      "": "&ntrianglerighteq;",
      "": "&NotSquareSubset;",
      "": "&nsqsube;",
      "": "&NotSquareSuperset;",
      "": "&nsqsupe;",
      "": "&vnsub;",
      "": "&nsubseteq;",
      "": "&nsucc;",
      "": "&nsucceq;",
      "": "&nsccue;",
      "": "&NotSucceedsTilde;",
      "": "&vnsup;",
      "": "&nsupseteq;",
      "": "&nsim;",
      "": "&nsimeq;",
      "": "&ncong;",
      "": "&napprox;",
      "": "&nsmid;",
      "": "&Nscr;",
      "": "&Ntilde;",
      "": "&Nu;",
      "": "&OElig;",
      "": "&Oacute;",
      "": "&Ocirc;",
      "": "&Ocy;",
      "": "&Odblac;",
      "": "&Ofr;",
      "": "&Ograve;",
      "": "&Omacr;",
      "": "&ohm;",
      "": "&Omicron;",
      "": "&Oopf;",
      "": "&ldquo;",
      "": "&lsquo;",
      "": "&Or;",
      "": "&Oscr;",
      "": "&Oslash;",
      "": "&Otilde;",
      "": "&Otimes;",
      "": "&Ouml;",
      "": "&oline;",
      "": "&OverBrace;",
      "": "&tbrk;",
      "": "&OverParenthesis;",
      "": "&part;",
      "": "&Pcy;",
      "": "&Pfr;",
      "": "&Phi;",
      "": "&Pi;",
      "": "&pm;",
      "": "&primes;",
      "": "&Pr;",
      "": "&prec;",
      "": "&preceq;",
      "": "&preccurlyeq;",
      "": "&prsim;",
      "": "&Prime;",
      "": "&prod;",
      "": "&vprop;",
      "": "&Pscr;",
      "": "&Psi;",
      '"': "&quot;",
      "": "&Qfr;",
      "": "&rationals;",
      "": "&Qscr;",
      "": "&drbkarow;",
      "": "&reg;",
      "": "&Racute;",
      "": "&Rang;",
      "": "&twoheadrightarrow;",
      "": "&Rarrtl;",
      "": "&Rcaron;",
      "": "&Rcedil;",
      "": "&Rcy;",
      "": "&realpart;",
      "": "&niv;",
      "": "&lrhar;",
      "": "&duhar;",
      "": "&Rho;",
      "": "&rangle;",
      "": "&srarr;",
      "": "&rarrb;",
      "": "&rlarr;",
      "": "&rceil;",
      "": "&robrk;",
      "": "&RightDownTeeVector;",
      "": "&downharpoonright;",
      "": "&RightDownVectorBar;",
      "": "&rfloor;",
      "": "&vdash;",
      "": "&mapsto;",
      "": "&RightTeeVector;",
      "": "&vrtri;",
      "": "&RightTriangleBar;",
      "": "&trianglerighteq;",
      "": "&RightUpDownVector;",
      "": "&RightUpTeeVector;",
      "": "&upharpoonright;",
      "": "&RightUpVectorBar;",
      "": "&rightharpoonup;",
      "": "&RightVectorBar;",
      "": "&reals;",
      "": "&RoundImplies;",
      "": "&rAarr;",
      "": "&realine;",
      "": "&rsh;",
      "": "&RuleDelayed;",
      "": "&SHCHcy;",
      "": "&SHcy;",
      "": "&SOFTcy;",
      "": "&Sacute;",
      "": "&Sc;",
      "": "&Scaron;",
      "": "&Scedil;",
      "": "&Scirc;",
      "": "&Scy;",
      "": "&Sfr;",
      "": "&uparrow;",
      "": "&Sigma;",
      "": "&compfn;",
      "": "&Sopf;",
      "": "&radic;",
      "": "&square;",
      "": "&sqcap;",
      "": "&sqsubset;",
      "": "&sqsubseteq;",
      "": "&sqsupset;",
      "": "&sqsupseteq;",
      "": "&sqcup;",
      "": "&Sscr;",
      "": "&sstarf;",
      "": "&Subset;",
      "": "&subseteq;",
      "": "&succ;",
      "": "&succeq;",
      "": "&succcurlyeq;",
      "": "&succsim;",
      "": "&sum;",
      "": "&Supset;",
      "": "&supset;",
      "": "&supseteq;",
      "": "&THORN;",
      "": "&trade;",
      "": "&TSHcy;",
      "": "&TScy;",
      "\t": "&Tab;",
      "": "&Tau;",
      "": "&Tcaron;",
      "": "&Tcedil;",
      "": "&Tcy;",
      "": "&Tfr;",
      "": "&therefore;",
      "": "&Theta;",
      "": "&ThickSpace;",
      "": "&thinsp;",
      "": "&thksim;",
      "": "&simeq;",
      "": "&cong;",
      "": "&thkap;",
      "": "&Topf;",
      "": "&tdot;",
      "": "&Tscr;",
      "": "&Tstrok;",
      "": "&Uacute;",
      "": "&Uarr;",
      "": "&Uarrocir;",
      "": "&Ubrcy;",
      "": "&Ubreve;",
      "": "&Ucirc;",
      "": "&Ucy;",
      "": "&Udblac;",
      "": "&Ufr;",
      "": "&Ugrave;",
      "": "&Umacr;",
      _: "&lowbar;",
      "": "&UnderBrace;",
      "": "&bbrk;",
      "": "&UnderParenthesis;",
      "": "&xcup;",
      "": "&uplus;",
      "": "&Uogon;",
      "": "&Uopf;",
      "": "&UpArrowBar;",
      "": "&udarr;",
      "": "&varr;",
      "": "&udhar;",
      "": "&perp;",
      "": "&mapstoup;",
      "": "&nwarrow;",
      "": "&nearrow;",
      "": "&upsih;",
      "": "&Upsilon;",
      "": "&Uring;",
      "": "&Uscr;",
      "": "&Utilde;",
      "": "&Uuml;",
      "": "&VDash;",
      "": "&Vbar;",
      "": "&Vcy;",
      "": "&Vdash;",
      "": "&Vdashl;",
      "": "&xvee;",
      "": "&Vert;",
      "": "&smid;",
      "|": "&vert;",
      "": "&VerticalSeparator;",
      "": "&wreath;",
      "": "&hairsp;",
      "": "&Vfr;",
      "": "&Vopf;",
      "": "&Vscr;",
      "": "&Vvdash;",
      "": "&Wcirc;",
      "": "&xwedge;",
      "": "&Wfr;",
      "": "&Wopf;",
      "": "&Wscr;",
      "": "&Xfr;",
      "": "&Xi;",
      "": "&Xopf;",
      "": "&Xscr;",
      "": "&YAcy;",
      "": "&YIcy;",
      "": "&YUcy;",
      "": "&Yacute;",
      "": "&Ycirc;",
      "": "&Ycy;",
      "": "&Yfr;",
      "": "&Yopf;",
      "": "&Yscr;",
      "": "&Yuml;",
      "": "&ZHcy;",
      "": "&Zacute;",
      "": "&Zcaron;",
      "": "&Zcy;",
      "": "&Zdot;",
      "": "&Zeta;",
      "": "&zeetrf;",
      "": "&integers;",
      "": "&Zscr;",
      "": "&aacute;",
      "": "&abreve;",
      "": "&mstpos;",
      "": "&acE;",
      "": "&acd;",
      "": "&acirc;",
      "": "&acy;",
      "": "&aelig;",
      "": "&afr;",
      "": "&agrave;",
      "": "&aleph;",
      "": "&alpha;",
      "": "&amacr;",
      "": "&amalg;",
      "": "&wedge;",
      "": "&andand;",
      "": "&andd;",
      "": "&andslope;",
      "": "&andv;",
      "": "&angle;",
      "": "&ange;",
      "": "&measuredangle;",
      "": "&angmsdaa;",
      "": "&angmsdab;",
      "": "&angmsdac;",
      "": "&angmsdad;",
      "": "&angmsdae;",
      "": "&angmsdaf;",
      "": "&angmsdag;",
      "": "&angmsdah;",
      "": "&angrt;",
      "": "&angrtvb;",
      "": "&angrtvbd;",
      "": "&angsph;",
      "": "&angzarr;",
      "": "&aogon;",
      "": "&aopf;",
      "": "&apE;",
      "": "&apacir;",
      "": "&approxeq;",
      "": "&apid;",
      "'": "&apos;",
      "": "&aring;",
      "": "&ascr;",
      "*": "&midast;",
      "": "&atilde;",
      "": "&auml;",
      "": "&awint;",
      "": "&bNot;",
      "": "&bcong;",
      "": "&bepsi;",
      "": "&bprime;",
      "": "&bsim;",
      "": "&bsime;",
      "": "&barvee;",
      "": "&barwedge;",
      "": "&bbrktbrk;",
      "": "&bcy;",
      "": "&ldquor;",
      "": "&bemptyv;",
      "": "&beta;",
      "": "&beth;",
      "": "&twixt;",
      "": "&bfr;",
      "": "&xcirc;",
      "": "&xodot;",
      "": "&xoplus;",
      "": "&xotime;",
      "": "&xsqcup;",
      "": "&starf;",
      "": "&xdtri;",
      "": "&xutri;",
      "": "&xuplus;",
      "": "&rbarr;",
      "": "&lozf;",
      "": "&utrif;",
      "": "&dtrif;",
      "": "&ltrif;",
      "": "&rtrif;",
      "": "&blank;",
      "": "&blk12;",
      "": "&blk14;",
      "": "&blk34;",
      "": "&block;",
      "=": "&bne;",
      "": "&bnequiv;",
      "": "&bnot;",
      "": "&bopf;",
      "": "&bowtie;",
      "": "&boxDL;",
      "": "&boxDR;",
      "": "&boxDl;",
      "": "&boxDr;",
      "": "&boxH;",
      "": "&boxHD;",
      "": "&boxHU;",
      "": "&boxHd;",
      "": "&boxHu;",
      "": "&boxUL;",
      "": "&boxUR;",
      "": "&boxUl;",
      "": "&boxUr;",
      "": "&boxV;",
      "": "&boxVH;",
      "": "&boxVL;",
      "": "&boxVR;",
      "": "&boxVh;",
      "": "&boxVl;",
      "": "&boxVr;",
      "": "&boxbox;",
      "": "&boxdL;",
      "": "&boxdR;",
      "": "&boxdl;",
      "": "&boxdr;",
      "": "&boxhD;",
      "": "&boxhU;",
      "": "&boxhd;",
      "": "&boxhu;",
      "": "&minusb;",
      "": "&plusb;",
      "": "&timesb;",
      "": "&boxuL;",
      "": "&boxuR;",
      "": "&boxul;",
      "": "&boxur;",
      "": "&boxv;",
      "": "&boxvH;",
      "": "&boxvL;",
      "": "&boxvR;",
      "": "&boxvh;",
      "": "&boxvl;",
      "": "&boxvr;",
      "": "&brvbar;",
      "": "&bscr;",
      "": "&bsemi;",
      "\\": "&bsol;",
      "": "&bsolb;",
      "": "&bsolhsub;",
      "": "&bullet;",
      "": "&bumpE;",
      "": "&cacute;",
      "": "&cap;",
      "": "&capand;",
      "": "&capbrcup;",
      "": "&capcap;",
      "": "&capcup;",
      "": "&capdot;",
      "": "&caps;",
      "": "&caret;",
      "": "&ccaps;",
      "": "&ccaron;",
      "": "&ccedil;",
      "": "&ccirc;",
      "": "&ccups;",
      "": "&ccupssm;",
      "": "&cdot;",
      "": "&cemptyv;",
      "": "&cent;",
      "": "&cfr;",
      "": "&chcy;",
      "": "&checkmark;",
      "": "&chi;",
      "": "&cir;",
      "": "&cirE;",
      "": "&circ;",
      "": "&cire;",
      "": "&olarr;",
      "": "&orarr;",
      "": "&oS;",
      "": "&oast;",
      "": "&ocir;",
      "": "&odash;",
      "": "&cirfnint;",
      "": "&cirmid;",
      "": "&cirscir;",
      "": "&clubsuit;",
      ":": "&colon;",
      ",": "&comma;",
      "@": "&commat;",
      "": "&complement;",
      "": "&congdot;",
      "": "&copf;",
      "": "&copysr;",
      "": "&crarr;",
      "": "&cross;",
      "": "&cscr;",
      "": "&csub;",
      "": "&csube;",
      "": "&csup;",
      "": "&csupe;",
      "": "&ctdot;",
      "": "&cudarrl;",
      "": "&cudarrr;",
      "": "&curlyeqprec;",
      "": "&curlyeqsucc;",
      "": "&curvearrowleft;",
      "": "&cularrp;",
      "": "&cup;",
      "": "&cupbrcap;",
      "": "&cupcap;",
      "": "&cupcup;",
      "": "&cupdot;",
      "": "&cupor;",
      "": "&cups;",
      "": "&curvearrowright;",
      "": "&curarrm;",
      "": "&cuvee;",
      "": "&cuwed;",
      "": "&curren;",
      "": "&cwint;",
      "": "&cylcty;",
      "": "&dHar;",
      "": "&dagger;",
      "": "&daleth;",
      "": "&hyphen;",
      "": "&rBarr;",
      "": "&dcaron;",
      "": "&dcy;",
      "": "&downdownarrows;",
      "": "&eDDot;",
      "": "&deg;",
      "": "&delta;",
      "": "&demptyv;",
      "": "&dfisht;",
      "": "&dfr;",
      "": "&diams;",
      "": "&gammad;",
      "": "&disin;",
      "": "&divide;",
      "": "&divonx;",
      "": "&djcy;",
      "": "&llcorner;",
      "": "&dlcrop;",
      $: "&dollar;",
      "": "&dopf;",
      "": "&eDot;",
      "": "&minusd;",
      "": "&plusdo;",
      "": "&sdotb;",
      "": "&lrcorner;",
      "": "&drcrop;",
      "": "&dscr;",
      "": "&dscy;",
      "": "&dsol;",
      "": "&dstrok;",
      "": "&dtdot;",
      "": "&triangledown;",
      "": "&dwangle;",
      "": "&dzcy;",
      "": "&dzigrarr;",
      "": "&eacute;",
      "": "&easter;",
      "": "&ecaron;",
      "": "&eqcirc;",
      "": "&ecirc;",
      "": "&eqcolon;",
      "": "&ecy;",
      "": "&edot;",
      "": "&fallingdotseq;",
      "": "&efr;",
      "": "&eg;",
      "": "&egrave;",
      "": "&eqslantgtr;",
      "": "&egsdot;",
      "": "&el;",
      "": "&elinters;",
      "": "&ell;",
      "": "&eqslantless;",
      "": "&elsdot;",
      "": "&emacr;",
      "": "&varnothing;",
      "": "&emsp13;",
      "": "&emsp14;",
      "": "&emsp;",
      "": "&eng;",
      "": "&ensp;",
      "": "&eogon;",
      "": "&eopf;",
      "": "&epar;",
      "": "&eparsl;",
      "": "&eplus;",
      "": "&epsilon;",
      "": "&varepsilon;",
      "=": "&equals;",
      "": "&questeq;",
      "": "&equivDD;",
      "": "&eqvparsl;",
      "": "&risingdotseq;",
      "": "&erarr;",
      "": "&escr;",
      "": "&eta;",
      "": "&eth;",
      "": "&euml;",
      "": "&euro;",
      "!": "&excl;",
      "": "&fcy;",
      "": "&female;",
      "": "&ffilig;",
      "": "&fflig;",
      "": "&ffllig;",
      "": "&ffr;",
      "": "&filig;",
      fj: "&fjlig;",
      "": "&flat;",
      "": "&fllig;",
      "": "&fltns;",
      "": "&fnof;",
      "": "&fopf;",
      "": "&pitchfork;",
      "": "&forkv;",
      "": "&fpartint;",
      "": "&half;",
      "": "&frac13;",
      "": "&frac14;",
      "": "&frac15;",
      "": "&frac16;",
      "": "&frac18;",
      "": "&frac23;",
      "": "&frac25;",
      "": "&frac34;",
      "": "&frac35;",
      "": "&frac38;",
      "": "&frac45;",
      "": "&frac56;",
      "": "&frac58;",
      "": "&frac78;",
      "": "&frasl;",
      "": "&sfrown;",
      "": "&fscr;",
      "": "&gtreqqless;",
      "": "&gacute;",
      "": "&gamma;",
      "": "&gtrapprox;",
      "": "&gbreve;",
      "": "&gcirc;",
      "": "&gcy;",
      "": "&gdot;",
      "": "&gescc;",
      "": "&gesdot;",
      "": "&gesdoto;",
      "": "&gesdotol;",
      "": "&gesl;",
      "": "&gesles;",
      "": "&gfr;",
      "": "&gimel;",
      "": "&gjcy;",
      "": "&glE;",
      "": "&gla;",
      "": "&glj;",
      "": "&gneqq;",
      "": "&gnapprox;",
      "": "&gneq;",
      "": "&gnsim;",
      "": "&gopf;",
      "": "&gscr;",
      "": "&gsime;",
      "": "&gsiml;",
      "": "&gtcc;",
      "": "&gtcir;",
      "": "&gtrdot;",
      "": "&gtlPar;",
      "": "&gtquest;",
      "": "&gtrarr;",
      "": "&gvnE;",
      "": "&hardcy;",
      "": "&harrcir;",
      "": "&leftrightsquigarrow;",
      "": "&plankv;",
      "": "&hcirc;",
      "": "&heartsuit;",
      "": "&mldr;",
      "": "&hercon;",
      "": "&hfr;",
      "": "&searhk;",
      "": "&swarhk;",
      "": "&hoarr;",
      "": "&homtht;",
      "": "&larrhk;",
      "": "&rarrhk;",
      "": "&hopf;",
      "": "&horbar;",
      "": "&hscr;",
      "": "&hstrok;",
      "": "&hybull;",
      "": "&iacute;",
      "": "&icirc;",
      "": "&icy;",
      "": "&iecy;",
      "": "&iexcl;",
      "": "&ifr;",
      "": "&igrave;",
      "": "&qint;",
      "": "&tint;",
      "": "&iinfin;",
      "": "&iiota;",
      "": "&ijlig;",
      "": "&imacr;",
      "": "&inodot;",
      "": "&imof;",
      "": "&imped;",
      "": "&incare;",
      "": "&infin;",
      "": "&infintie;",
      "": "&intercal;",
      "": "&intlarhk;",
      "": "&iprod;",
      "": "&iocy;",
      "": "&iogon;",
      "": "&iopf;",
      "": "&iota;",
      "": "&iquest;",
      "": "&iscr;",
      "": "&isinE;",
      "": "&isindot;",
      "": "&isins;",
      "": "&isinsv;",
      "": "&itilde;",
      "": "&iukcy;",
      "": "&iuml;",
      "": "&jcirc;",
      "": "&jcy;",
      "": "&jfr;",
      "": "&jmath;",
      "": "&jopf;",
      "": "&jscr;",
      "": "&jsercy;",
      "": "&jukcy;",
      "": "&kappa;",
      "": "&varkappa;",
      "": "&kcedil;",
      "": "&kcy;",
      "": "&kfr;",
      "": "&kgreen;",
      "": "&khcy;",
      "": "&kjcy;",
      "": "&kopf;",
      "": "&kscr;",
      "": "&lAtail;",
      "": "&lBarr;",
      "": "&lesseqqgtr;",
      "": "&lHar;",
      "": "&lacute;",
      "": "&laemptyv;",
      "": "&lambda;",
      "": "&langd;",
      "": "&lessapprox;",
      "": "&laquo;",
      "": "&larrbfs;",
      "": "&larrfs;",
      "": "&looparrowleft;",
      "": "&larrpl;",
      "": "&larrsim;",
      "": "&leftarrowtail;",
      "": "&lat;",
      "": "&latail;",
      "": "&late;",
      "": "&lates;",
      "": "&lbarr;",
      "": "&lbbrk;",
      "{": "&lcub;",
      "[": "&lsqb;",
      "": "&lbrke;",
      "": "&lbrksld;",
      "": "&lbrkslu;",
      "": "&lcaron;",
      "": "&lcedil;",
      "": "&lcy;",
      "": "&ldca;",
      "": "&ldrdhar;",
      "": "&ldrushar;",
      "": "&ldsh;",
      "": "&leq;",
      "": "&llarr;",
      "": "&lthree;",
      "": "&lescc;",
      "": "&lesdot;",
      "": "&lesdoto;",
      "": "&lesdotor;",
      "": "&lesg;",
      "": "&lesges;",
      "": "&ltdot;",
      "": "&lfisht;",
      "": "&lfr;",
      "": "&lgE;",
      "": "&lharul;",
      "": "&lhblk;",
      "": "&ljcy;",
      "": "&llhard;",
      "": "&lltri;",
      "": "&lmidot;",
      "": "&lmoustache;",
      "": "&lneqq;",
      "": "&lnapprox;",
      "": "&lneq;",
      "": "&lnsim;",
      "": "&loang;",
      "": "&loarr;",
      "": "&xmap;",
      "": "&rarrlp;",
      "": "&lopar;",
      "": "&lopf;",
      "": "&loplus;",
      "": "&lotimes;",
      "": "&lowast;",
      "": "&lozenge;",
      "(": "&lpar;",
      "": "&lparlt;",
      "": "&lrhard;",
      "": "&lrm;",
      "": "&lrtri;",
      "": "&lsaquo;",
      "": "&lscr;",
      "": "&lsime;",
      "": "&lsimg;",
      "": "&sbquo;",
      "": "&lstrok;",
      "": "&ltcc;",
      "": "&ltcir;",
      "": "&ltimes;",
      "": "&ltlarr;",
      "": "&ltquest;",
      "": "&ltrPar;",
      "": "&triangleleft;",
      "": "&lurdshar;",
      "": "&luruhar;",
      "": "&lvnE;",
      "": "&mDDot;",
      "": "&strns;",
      "": "&male;",
      "": "&maltese;",
      "": "&marker;",
      "": "&mcomma;",
      "": "&mcy;",
      "": "&mdash;",
      "": "&mfr;",
      "": "&mho;",
      "": "&micro;",
      "": "&midcir;",
      "": "&minus;",
      "": "&minusdu;",
      "": "&mlcp;",
      "": "&models;",
      "": "&mopf;",
      "": "&mscr;",
      "": "&mu;",
      "": "&mumap;",
      "": "&nGg;",
      "": "&nGt;",
      "": "&nlArr;",
      "": "&nhArr;",
      "": "&nLl;",
      "": "&nLt;",
      "": "&nrArr;",
      "": "&nVDash;",
      "": "&nVdash;",
      "": "&nacute;",
      "": "&nang;",
      "": "&napE;",
      "": "&napid;",
      "": "&napos;",
      "": "&natural;",
      "": "&ncap;",
      "": "&ncaron;",
      "": "&ncedil;",
      "": "&ncongdot;",
      "": "&ncup;",
      "": "&ncy;",
      "": "&ndash;",
      "": "&neArr;",
      "": "&nearhk;",
      "": "&nedot;",
      "": "&toea;",
      "": "&nfr;",
      "": "&nleftrightarrow;",
      "": "&nhpar;",
      "": "&nis;",
      "": "&nisd;",
      "": "&njcy;",
      "": "&nleqq;",
      "": "&nleftarrow;",
      "": "&nldr;",
      "": "&nopf;",
      "": "&not;",
      "": "&notinE;",
      "": "&notindot;",
      "": "&notinvb;",
      "": "&notinvc;",
      "": "&notnivb;",
      "": "&notnivc;",
      "": "&nparsl;",
      "": "&npart;",
      "": "&npolint;",
      "": "&nrightarrow;",
      "": "&nrarrc;",
      "": "&nrarrw;",
      "": "&nscr;",
      "": "&nsub;",
      "": "&nsubseteqq;",
      "": "&nsup;",
      "": "&nsupseteqq;",
      "": "&ntilde;",
      "": "&nu;",
      "#": "&num;",
      "": "&numero;",
      "": "&numsp;",
      "": "&nvDash;",
      "": "&nvHarr;",
      "": "&nvap;",
      "": "&nvdash;",
      "": "&nvge;",
      ">": "&nvgt;",
      "": "&nvinfin;",
      "": "&nvlArr;",
      "": "&nvle;",
      "<": "&nvlt;",
      "": "&nvltrie;",
      "": "&nvrArr;",
      "": "&nvrtrie;",
      "": "&nvsim;",
      "": "&nwArr;",
      "": "&nwarhk;",
      "": "&nwnear;",
      "": "&oacute;",
      "": "&ocirc;",
      "": "&ocy;",
      "": "&odblac;",
      "": "&odiv;",
      "": "&odsold;",
      "": "&oelig;",
      "": "&ofcir;",
      "": "&ofr;",
      "": "&ogon;",
      "": "&ograve;",
      "": "&ogt;",
      "": "&ohbar;",
      "": "&olcir;",
      "": "&olcross;",
      "": "&olt;",
      "": "&omacr;",
      "": "&omega;",
      "": "&omicron;",
      "": "&omid;",
      "": "&oopf;",
      "": "&opar;",
      "": "&operp;",
      "": "&vee;",
      "": "&ord;",
      "": "&oscr;",
      "": "&ordf;",
      "": "&ordm;",
      "": "&origof;",
      "": "&oror;",
      "": "&orslope;",
      "": "&orv;",
      "": "&oslash;",
      "": "&osol;",
      "": "&otilde;",
      "": "&otimesas;",
      "": "&ouml;",
      "": "&ovbar;",
      "": "&para;",
      "": "&parsim;",
      "": "&parsl;",
      "": "&pcy;",
      "%": "&percnt;",
      ".": "&period;",
      "": "&permil;",
      "": "&pertenk;",
      "": "&pfr;",
      "": "&phi;",
      "": "&varphi;",
      "": "&phone;",
      "": "&pi;",
      "": "&varpi;",
      "": "&planckh;",
      "+": "&plus;",
      "": "&plusacir;",
      "": "&pluscir;",
      "": "&plusdu;",
      "": "&pluse;",
      "": "&plussim;",
      "": "&plustwo;",
      "": "&pointint;",
      "": "&popf;",
      "": "&pound;",
      "": "&prE;",
      "": "&precapprox;",
      "": "&prnap;",
      "": "&prnE;",
      "": "&prnsim;",
      "": "&prime;",
      "": "&profalar;",
      "": "&profline;",
      "": "&profsurf;",
      "": "&prurel;",
      "": "&pscr;",
      "": "&psi;",
      "": "&puncsp;",
      "": "&qfr;",
      "": "&qopf;",
      "": "&qprime;",
      "": "&qscr;",
      "": "&quatint;",
      "?": "&quest;",
      "": "&rAtail;",
      "": "&rHar;",
      "": "&race;",
      "": "&racute;",
      "": "&raemptyv;",
      "": "&rangd;",
      "": "&range;",
      "": "&raquo;",
      "": "&rarrap;",
      "": "&rarrbfs;",
      "": "&rarrc;",
      "": "&rarrfs;",
      "": "&rarrpl;",
      "": "&rarrsim;",
      "": "&rightarrowtail;",
      "": "&rightsquigarrow;",
      "": "&ratail;",
      "": "&ratio;",
      "": "&rbbrk;",
      "}": "&rcub;",
      "]": "&rsqb;",
      "": "&rbrke;",
      "": "&rbrksld;",
      "": "&rbrkslu;",
      "": "&rcaron;",
      "": "&rcedil;",
      "": "&rcy;",
      "": "&rdca;",
      "": "&rdldhar;",
      "": "&rdsh;",
      "": "&rect;",
      "": "&rfisht;",
      "": "&rfr;",
      "": "&rharul;",
      "": "&rho;",
      "": "&varrho;",
      "": "&rrarr;",
      "": "&rthree;",
      "": "&ring;",
      "": "&rlm;",
      "": "&rmoustache;",
      "": "&rnmid;",
      "": "&roang;",
      "": "&roarr;",
      "": "&ropar;",
      "": "&ropf;",
      "": "&roplus;",
      "": "&rotimes;",
      ")": "&rpar;",
      "": "&rpargt;",
      "": "&rppolint;",
      "": "&rsaquo;",
      "": "&rscr;",
      "": "&rtimes;",
      "": "&triangleright;",
      "": "&rtriltri;",
      "": "&ruluhar;",
      "": "&rx;",
      "": "&sacute;",
      "": "&scE;",
      "": "&succapprox;",
      "": "&scaron;",
      "": "&scedil;",
      "": "&scirc;",
      "": "&succneqq;",
      "": "&succnapprox;",
      "": "&succnsim;",
      "": "&scpolint;",
      "": "&scy;",
      "": "&sdot;",
      "": "&sdote;",
      "": "&seArr;",
      "": "&sect;",
      ";": "&semi;",
      "": "&tosa;",
      "": "&sext;",
      "": "&sfr;",
      "": "&sharp;",
      "": "&shchcy;",
      "": "&shcy;",
      "": "&shy;",
      "": "&sigma;",
      "": "&varsigma;",
      "": "&simdot;",
      "": "&simg;",
      "": "&simgE;",
      "": "&siml;",
      "": "&simlE;",
      "": "&simne;",
      "": "&simplus;",
      "": "&simrarr;",
      "": "&smashp;",
      "": "&smeparsl;",
      "": "&ssmile;",
      "": "&smt;",
      "": "&smte;",
      "": "&smtes;",
      "": "&softcy;",
      "/": "&sol;",
      "": "&solb;",
      "": "&solbar;",
      "": "&sopf;",
      "": "&spadesuit;",
      "": "&sqcaps;",
      "": "&sqcups;",
      "": "&sscr;",
      "": "&star;",
      "": "&subset;",
      "": "&subseteqq;",
      "": "&subdot;",
      "": "&subedot;",
      "": "&submult;",
      "": "&subsetneqq;",
      "": "&subsetneq;",
      "": "&subplus;",
      "": "&subrarr;",
      "": "&subsim;",
      "": "&subsub;",
      "": "&subsup;",
      "": "&sung;",
      "": "&sup1;",
      "": "&sup2;",
      "": "&sup3;",
      "": "&supseteqq;",
      "": "&supdot;",
      "": "&supdsub;",
      "": "&supedot;",
      "": "&suphsol;",
      "": "&suphsub;",
      "": "&suplarr;",
      "": "&supmult;",
      "": "&supsetneqq;",
      "": "&supsetneq;",
      "": "&supplus;",
      "": "&supsim;",
      "": "&supsub;",
      "": "&supsup;",
      "": "&swArr;",
      "": "&swnwar;",
      "": "&szlig;",
      "": "&target;",
      "": "&tau;",
      "": "&tcaron;",
      "": "&tcedil;",
      "": "&tcy;",
      "": "&telrec;",
      "": "&tfr;",
      "": "&theta;",
      "": "&vartheta;",
      "": "&thorn;",
      "": "&times;",
      "": "&timesbar;",
      "": "&timesd;",
      "": "&topbot;",
      "": "&topcir;",
      "": "&topf;",
      "": "&topfork;",
      "": "&tprime;",
      "": "&utri;",
      "": "&trie;",
      "": "&tridot;",
      "": "&triminus;",
      "": "&triplus;",
      "": "&trisb;",
      "": "&tritime;",
      "": "&trpezium;",
      "": "&tscr;",
      "": "&tscy;",
      "": "&tshcy;",
      "": "&tstrok;",
      "": "&uHar;",
      "": "&uacute;",
      "": "&ubrcy;",
      "": "&ubreve;",
      "": "&ucirc;",
      "": "&ucy;",
      "": "&udblac;",
      "": "&ufisht;",
      "": "&ufr;",
      "": "&ugrave;",
      "": "&uhblk;",
      "": "&ulcorner;",
      "": "&ulcrop;",
      "": "&ultri;",
      "": "&umacr;",
      "": "&uogon;",
      "": "&uopf;",
      "": "&upsilon;",
      "": "&uuarr;",
      "": "&urcorner;",
      "": "&urcrop;",
      "": "&uring;",
      "": "&urtri;",
      "": "&uscr;",
      "": "&utdot;",
      "": "&utilde;",
      "": "&uuml;",
      "": "&uwangle;",
      "": "&vBar;",
      "": "&vBarv;",
      "": "&vangrt;",
      "": "&vsubne;",
      "": "&vsubnE;",
      "": "&vsupne;",
      "": "&vsupnE;",
      "": "&vcy;",
      "": "&veebar;",
      "": "&veeeq;",
      "": "&vellip;",
      "": "&vfr;",
      "": "&vopf;",
      "": "&vscr;",
      "": "&vzigzag;",
      "": "&wcirc;",
      "": "&wedbar;",
      "": "&wedgeq;",
      "": "&wp;",
      "": "&wfr;",
      "": "&wopf;",
      "": "&wscr;",
      "": "&xfr;",
      "": "&xi;",
      "": "&xnis;",
      "": "&xopf;",
      "": "&xscr;",
      "": "&yacute;",
      "": "&yacy;",
      "": "&ycirc;",
      "": "&ycy;",
      "": "&yen;",
      "": "&yfr;",
      "": "&yicy;",
      "": "&yopf;",
      "": "&yscr;",
      "": "&yucy;",
      "": "&yuml;",
      "": "&zacute;",
      "": "&zcaron;",
      "": "&zcy;",
      "": "&zdot;",
      "": "&zeta;",
      "": "&zfr;",
      "": "&zhcy;",
      "": "&zigrarr;",
      "": "&zopf;",
      "": "&zscr;",
      "": "&zwj;",
      "": "&zwnj;"
    }
  }
};

/***/ }),

/***/ "./node_modules/html-entities/lib/numeric-unicode-map.js":
/*!***************************************************************!*\
  !*** ./node_modules/html-entities/lib/numeric-unicode-map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.numericUnicodeMap = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
};

/***/ }),

/***/ "./node_modules/html-entities/lib/surrogate-pairs.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/lib/surrogate-pairs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

exports.fromCodePoint = String.fromCodePoint || function (astralCodePoint) {
  return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
};

exports.getCodePoint = String.prototype.codePointAt ? function (input, position) {
  return input.codePointAt(position);
} : function (input, position) {
  return (input.charCodeAt(position) - 55296) * 1024 + input.charCodeAt(position + 1) - 56320 + 65536;
};
exports.highSurrogateFrom = 55296;
exports.highSurrogateTo = 56319;

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */


var baseEach = createBaseEach(baseForOwn);
module.exports = baseEach;

/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */


function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");
/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */


function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
module.exports = freeGlobal;

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "./node_modules/lodash/each.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/each.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./forEach */ "./node_modules/lodash/forEach.js");

/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */


function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof __webpack_require__.g=='object'&&__webpack_require__.g&&__webpack_require__.g.Object===Object&&__webpack_require__.g;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports= true&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&"object"=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||isBuff&&(key=='offset'||key=='parent')||isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else{iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
// potential command injection attacks.
else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else {}}).call(this);

/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-env browser */

/*
  eslint-disable
  no-console,
  func-names
*/

var normalizeUrl = __webpack_require__(/*! ./normalize-url */ "./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js");

var srcByModuleId = Object.create(null);
var noDocument = typeof document === "undefined";
var forEach = Array.prototype.forEach;

function debounce(fn, time) {
  var timeout = 0;
  return function () {
    var self = this; // eslint-disable-next-line prefer-rest-params

    var args = arguments;

    var functionCall = function functionCall() {
      return fn.apply(self, args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(functionCall, time);
  };
}

function noop() {}

function getCurrentScriptUrl(moduleId) {
  var src = srcByModuleId[moduleId];

  if (!src) {
    if (document.currentScript) {
      src = document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      var lastScriptTag = scripts[scripts.length - 1];

      if (lastScriptTag) {
        src = lastScriptTag.src;
      }
    }

    srcByModuleId[moduleId] = src;
  }

  return function (fileMap) {
    if (!src) {
      return null;
    }

    var splitResult = src.split(/([^\\/]+)\.js$/);
    var filename = splitResult && splitResult[1];

    if (!filename) {
      return [src.replace(".js", ".css")];
    }

    if (!fileMap) {
      return [src.replace(".js", ".css")];
    }

    return fileMap.split(",").map(function (mapRule) {
      var reg = new RegExp("".concat(filename, "\\.js$"), "g");
      return normalizeUrl(src.replace(reg, "".concat(mapRule.replace(/{fileName}/g, filename), ".css")));
    });
  };
}

function updateCss(el, url) {
  if (!url) {
    if (!el.href) {
      return;
    } // eslint-disable-next-line


    url = el.href.split("?")[0];
  }

  if (!isUrlRequest(url)) {
    return;
  }

  if (el.isLoaded === false) {
    // We seem to be about to replace a css link that hasn't loaded yet.
    // We're probably changing the same file more than once.
    return;
  }

  if (!url || !(url.indexOf(".css") > -1)) {
    return;
  } // eslint-disable-next-line no-param-reassign


  el.visited = true;
  var newEl = el.cloneNode();
  newEl.isLoaded = false;
  newEl.addEventListener("load", function () {
    if (newEl.isLoaded) {
      return;
    }

    newEl.isLoaded = true;
    el.parentNode.removeChild(el);
  });
  newEl.addEventListener("error", function () {
    if (newEl.isLoaded) {
      return;
    }

    newEl.isLoaded = true;
    el.parentNode.removeChild(el);
  });
  newEl.href = "".concat(url, "?").concat(Date.now());

  if (el.nextSibling) {
    el.parentNode.insertBefore(newEl, el.nextSibling);
  } else {
    el.parentNode.appendChild(newEl);
  }
}

function getReloadUrl(href, src) {
  var ret; // eslint-disable-next-line no-param-reassign

  href = normalizeUrl(href, {
    stripWWW: false
  }); // eslint-disable-next-line array-callback-return

  src.some(function (url) {
    if (href.indexOf(src) > -1) {
      ret = url;
    }
  });
  return ret;
}

function reloadStyle(src) {
  if (!src) {
    return false;
  }

  var elements = document.querySelectorAll("link");
  var loaded = false;
  forEach.call(elements, function (el) {
    if (!el.href) {
      return;
    }

    var url = getReloadUrl(el.href, src);

    if (!isUrlRequest(url)) {
      return;
    }

    if (el.visited === true) {
      return;
    }

    if (url) {
      updateCss(el, url);
      loaded = true;
    }
  });
  return loaded;
}

function reloadAll() {
  var elements = document.querySelectorAll("link");
  forEach.call(elements, function (el) {
    if (el.visited === true) {
      return;
    }

    updateCss(el);
  });
}

function isUrlRequest(url) {
  // An URL is not an request if
  // It is not http or https
  if (!/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url)) {
    return false;
  }

  return true;
}

module.exports = function (moduleId, options) {
  if (noDocument) {
    console.log("no window.document found, will not HMR CSS");
    return noop;
  }

  var getScriptSrc = getCurrentScriptUrl(moduleId);

  function update() {
    var src = getScriptSrc(options.filename);
    var reloaded = reloadStyle(src);

    if (options.locals) {
      console.log("[HMR] Detected local css modules. Reload all css");
      reloadAll();
      return;
    }

    if (reloaded) {
      console.log("[HMR] css reload %s", src.join(" "));
    } else {
      console.log("[HMR] Reload all css");
      reloadAll();
    }
  }

  return debounce(update, 50);
};

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";

/* eslint-disable */

function normalizeUrl(pathComponents) {
  return pathComponents.reduce(function (accumulator, item) {
    switch (item) {
      case "..":
        accumulator.pop();
        break;

      case ".":
        break;

      default:
        accumulator.push(item);
    }

    return accumulator;
  }, []).join("/");
}

module.exports = function (urlString) {
  urlString = urlString.trim();

  if (/^data:/i.test(urlString)) {
    return urlString;
  }

  var protocol = urlString.indexOf("//") !== -1 ? urlString.split("//")[0] + "//" : "";
  var components = urlString.replace(new RegExp(protocol, "i"), "").split("/");
  var host = components[0].toLowerCase().replace(/\.$/, "");
  components[0] = "";
  var path = normalizeUrl(components);
  return protocol + host + path;
};

/***/ }),

/***/ "./node_modules/prefix/index.js":
/*!**************************************!*\
  !*** ./node_modules/prefix/index.js ***!
  \**************************************/
/***/ ((module) => {

// check document first so it doesn't error in node.js
var style = typeof document != 'undefined' ? document.createElement('p').style : {};
var prefixes = ['O', 'ms', 'Moz', 'Webkit'];
var upper = /([A-Z])/g;
var memo = {};
/**
 * prefix `key`
 *
 *   prefix('transform') // => WebkitTransform
 *
 * @param {String} key
 * @return {String}
 * @api public
 */

function prefix(key) {
  // Camel case
  key = key.replace(/-([a-z])/g, function (_, char) {
    return char.toUpperCase();
  }); // Without prefix

  if (style[key] !== undefined) return key; // With prefix

  var Key = key.charAt(0).toUpperCase() + key.slice(1);
  var i = prefixes.length;

  while (i--) {
    var name = prefixes[i] + Key;
    if (style[name] !== undefined) return name;
  }

  return key;
}
/**
 * Memoized version of `prefix`
 *
 * @param {String} key
 * @return {String}
 * @api public
 */


function prefixMemozied(key) {
  return key in memo ? memo[key] : memo[key] = prefix(key);
}
/**
 * Create a dashed prefix
 *
 * @param {String} key
 * @return {String}
 * @api public
 */


function prefixDashed(key) {
  key = prefix(key);

  if (upper.test(key)) {
    key = '-' + key.replace(upper, '-$1');
    upper.lastIndex = 0;
  }

  return key.toLowerCase();
}

module.exports = prefixMemozied;
module.exports.dash = prefixDashed;

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports =  true && exports && !exports.nodeType && exports;
  var freeModule =  true && module && !module.nodeType && module;
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * http://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.3.2',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");

var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift()));

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function (arg) {
    return typeof arg === 'string';
  },
  isObject: function (arg) {
    return typeof arg === 'object' && arg !== null;
  },
  isNull: function (arg) {
    return arg === null;
  },
  isNullOrUndefined: function (arg) {
    return arg == null;
  }
};

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebSocketClient)
/* harmony export */ });
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}



var WebSocketClient = /*#__PURE__*/function () {
  function WebSocketClient(url) {
    _classCallCheck(this, WebSocketClient);

    this.client = new WebSocket(url);

    this.client.onerror = function (error) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_0__.log.error(error);
    };
  }

  _createClass(WebSocketClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.client.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.client.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.client.onmessage = function (e) {
        f(e.data);
      };
    }
  }]);

  return WebSocketClient;
}();



/***/ }),

/***/ "./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __resourceQuery = "?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/log.js */ "./node_modules/webpack/hot/log.js");
/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/strip-ansi/index.js */ "./node_modules/webpack-dev-server/client/modules/strip-ansi/index.js");
/* harmony import */ var _modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/parseURL.js */ "./node_modules/webpack-dev-server/client/utils/parseURL.js");
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./socket.js */ "./node_modules/webpack-dev-server/client/socket.js");
/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./overlay.js */ "./node_modules/webpack-dev-server/client/overlay.js");
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
/* harmony import */ var _utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/sendMessage.js */ "./node_modules/webpack-dev-server/client/utils/sendMessage.js");
/* harmony import */ var _utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/reloadApp.js */ "./node_modules/webpack-dev-server/client/utils/reloadApp.js");
/* harmony import */ var _utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/createSocketURL.js */ "./node_modules/webpack-dev-server/client/utils/createSocketURL.js");
/* global __resourceQuery, __webpack_hash__ */









var status = {
  isUnloading: false,
  // TODO Workaround for webpack v4, `__webpack_hash__` is not replaced without HotModuleReplacement
  // eslint-disable-next-line camelcase
  currentHash:  true ? __webpack_require__.h() : 0
}; // console.log(__webpack_hash__);

var options = {
  hot: false,
  liveReload: false,
  progress: false,
  overlay: false
};
var parsedResourceQuery = (0,_utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__["default"])(__resourceQuery);

if (parsedResourceQuery.hot === "true") {
  options.hot = true;
  _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Hot Module Replacement enabled.");
}

if (parsedResourceQuery["live-reload"] === "true") {
  options.liveReload = true;
  _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Live Reloading enabled.");
}

if (parsedResourceQuery.logging) {
  options.logging = parsedResourceQuery.logging;
}

function setAllLogLevel(level) {
  // This is needed because the HMR logger operate separately from dev server logger
  webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default().setLogLevel(level === "verbose" || level === "log" ? "info" : level);
  (0,_utils_log_js__WEBPACK_IMPORTED_MODULE_5__.setLogLevel)(level);
}

if (options.logging) {
  setAllLogLevel(options.logging);
}

self.addEventListener("beforeunload", function () {
  status.isUnloading = true;
});
var onSocketMessage = {
  hot: function hot() {
    if (parsedResourceQuery.hot === "false") {
      return;
    }

    options.hot = true;
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Hot Module Replacement enabled.");
  },
  liveReload: function liveReload() {
    if (parsedResourceQuery["live-reload"] === "false") {
      return;
    }

    options.liveReload = true;
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Live Reloading enabled.");
  },
  invalid: function invalid() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("App updated. Recompiling..."); // Fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.overlay) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.hide)();
    }

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Invalid");
  },
  hash: function hash(_hash) {
    status.previousHash = status.currentHash;
    status.currentHash = _hash;
  },
  logging: setAllLogLevel,
  overlay: function overlay(value) {
    if (typeof document === "undefined") {
      return;
    }

    options.overlay = value;
  },
  progress: function progress(_progress) {
    options.progress = _progress;
  },
  "progress-update": function progressUpdate(data) {
    if (options.progress) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(data.pluginName ? "[".concat(data.pluginName, "] ") : "").concat(data.percent, "% - ").concat(data.msg, "."));
    }

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Progress", data);
  },
  "still-ok": function stillOk() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Nothing changed.");

    if (options.overlay) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.hide)();
    }

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("StillOk");
  },
  ok: function ok() {
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Ok");

    if (options.overlay) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.hide)();
    }

    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__["default"])(options, status);
  },
  // TODO: remove in v5 in favor of 'static-changed'
  "content-changed": function contentChanged(file) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(file ? "\"".concat(file, "\"") : "Content", " from static directory was changed. Reloading..."));
    self.location.reload();
  },
  "static-changed": function staticChanged(file) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(file ? "\"".concat(file, "\"") : "Content", " from static directory was changed. Reloading..."));
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn("Warnings while compiling.");

    var strippedWarnings = _warnings.map(function (warning) {
      return _modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1___default()(warning.message ? warning.message : warning);
    });

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Warnings", strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn(strippedWarnings[i]);
    }

    var needShowOverlayForWarnings = typeof options.overlay === "boolean" ? options.overlay : options.overlay && options.overlay.warnings;

    if (needShowOverlayForWarnings) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.show)(_warnings, "warnings");
    }

    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__["default"])(options, status);
  },
  errors: function errors(_errors) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error("Errors while compiling. Reload prevented.");

    var strippedErrors = _errors.map(function (error) {
      return _modules_strip_ansi_index_js__WEBPACK_IMPORTED_MODULE_1___default()(error.message ? error.message : error);
    });

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Errors", strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(strippedErrors[i]);
    }

    var needShowOverlayForErrors = typeof options.overlay === "boolean" ? options.overlay : options.overlay && options.overlay.errors;

    if (needShowOverlayForErrors) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.show)(_errors, "errors");
    }
  },
  error: function error(_error) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(_error);
  },
  close: function close() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Disconnected!");

    if (options.overlay) {
      (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.hide)();
    }

    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Close");
  }
};
var socketURL = (0,_utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__["default"])(parsedResourceQuery);
(0,_socket_js__WEBPACK_IMPORTED_MODULE_3__["default"])(socketURL, onSocketMessage);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/modules/logger/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/modules/logger/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/******/
(function () {
  // webpackBootstrap

  /******/
  "use strict";
  /******/

  var __webpack_modules__ = {
    /***/
    "./client-src/modules/logger/SyncBailHookFake.js": function (module) {
      /**
       * Client stub for tapable SyncBailHook
       */
      module.exports = function clientTapableSyncBailHook() {
        return {
          call: function call() {}
        };
      };
      /***/

    },

    /***/
    "./node_modules/webpack/lib/logging/Logger.js": function (__unused_webpack_module, exports) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      var LogType = Object.freeze({
        error: "error",
        // message, c style arguments
        warn: "warn",
        // message, c style arguments
        info: "info",
        // message, c style arguments
        log: "log",
        // message, c style arguments
        debug: "debug",
        // message, c style arguments
        trace: "trace",
        // no arguments
        group: "group",
        // [label]
        groupCollapsed: "groupCollapsed",
        // [label]
        groupEnd: "groupEnd",
        // [label]
        profile: "profile",
        // [profileName]
        profileEnd: "profileEnd",
        // [profileName]
        time: "time",
        // name, time as [seconds, nanoseconds]
        clear: "clear",
        // no arguments
        status: "status" // message, arguments

      });
      exports.LogType = LogType;
      /** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */

      var LOG_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger raw log method");
      var TIMERS_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger times");
      var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger aggregated times");

      var WebpackLogger = /*#__PURE__*/function () {
        /**
         * @param {function(LogTypeEnum, any[]=): void} log log function
         * @param {function(string | function(): string): WebpackLogger} getChildLogger function to create child logger
         */
        function WebpackLogger(log, getChildLogger) {
          _classCallCheck(this, WebpackLogger);

          this[LOG_SYMBOL] = log;
          this.getChildLogger = getChildLogger;
        }

        _createClass(WebpackLogger, [{
          key: "error",
          value: function error() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            this[LOG_SYMBOL](LogType.error, args);
          }
        }, {
          key: "warn",
          value: function warn() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            this[LOG_SYMBOL](LogType.warn, args);
          }
        }, {
          key: "info",
          value: function info() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            this[LOG_SYMBOL](LogType.info, args);
          }
        }, {
          key: "log",
          value: function log() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }

            this[LOG_SYMBOL](LogType.log, args);
          }
        }, {
          key: "debug",
          value: function debug() {
            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }

            this[LOG_SYMBOL](LogType.debug, args);
          }
        }, {
          key: "assert",
          value: function assert(assertion) {
            if (!assertion) {
              for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
                args[_key6 - 1] = arguments[_key6];
              }

              this[LOG_SYMBOL](LogType.error, args);
            }
          }
        }, {
          key: "trace",
          value: function trace() {
            this[LOG_SYMBOL](LogType.trace, ["Trace"]);
          }
        }, {
          key: "clear",
          value: function clear() {
            this[LOG_SYMBOL](LogType.clear);
          }
        }, {
          key: "status",
          value: function status() {
            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
              args[_key7] = arguments[_key7];
            }

            this[LOG_SYMBOL](LogType.status, args);
          }
        }, {
          key: "group",
          value: function group() {
            for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
              args[_key8] = arguments[_key8];
            }

            this[LOG_SYMBOL](LogType.group, args);
          }
        }, {
          key: "groupCollapsed",
          value: function groupCollapsed() {
            for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
              args[_key9] = arguments[_key9];
            }

            this[LOG_SYMBOL](LogType.groupCollapsed, args);
          }
        }, {
          key: "groupEnd",
          value: function groupEnd() {
            for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
              args[_key10] = arguments[_key10];
            }

            this[LOG_SYMBOL](LogType.groupEnd, args);
          }
        }, {
          key: "profile",
          value: function profile(label) {
            this[LOG_SYMBOL](LogType.profile, [label]);
          }
        }, {
          key: "profileEnd",
          value: function profileEnd(label) {
            this[LOG_SYMBOL](LogType.profileEnd, [label]);
          }
        }, {
          key: "time",
          value: function time(label) {
            this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();
            this[TIMERS_SYMBOL].set(label, process.hrtime());
          }
        }, {
          key: "timeLog",
          value: function timeLog(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);

            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeLog()"));
            }

            var time = process.hrtime(prev);
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }, {
          key: "timeEnd",
          value: function timeEnd(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);

            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeEnd()"));
            }

            var time = process.hrtime(prev);
            this[TIMERS_SYMBOL].delete(label);
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }, {
          key: "timeAggregate",
          value: function timeAggregate(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);

            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeAggregate()"));
            }

            var time = process.hrtime(prev);
            this[TIMERS_SYMBOL].delete(label);
            this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();
            var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);

            if (current !== undefined) {
              if (time[1] + current[1] > 1e9) {
                time[0] += current[0] + 1;
                time[1] = time[1] - 1e9 + current[1];
              } else {
                time[0] += current[0];
                time[1] += current[1];
              }
            }

            this[TIMERS_AGGREGATES_SYMBOL].set(label, time);
          }
        }, {
          key: "timeAggregateEnd",
          value: function timeAggregateEnd(label) {
            if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;
            var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);
            if (time === undefined) return;
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }]);

        return WebpackLogger;
      }();

      exports.Logger = WebpackLogger;
      /***/
    },

    /***/
    "./node_modules/webpack/lib/logging/createConsoleLogger.js": function (module, __unused_webpack_exports, __nested_webpack_require_11389__) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      var _require = __nested_webpack_require_11389__(
      /*! ./Logger */
      "./node_modules/webpack/lib/logging/Logger.js"),
          LogType = _require.LogType;
      /** @typedef {import("../../declarations/WebpackOptions").FilterItemTypes} FilterItemTypes */

      /** @typedef {import("../../declarations/WebpackOptions").FilterTypes} FilterTypes */

      /** @typedef {import("./Logger").LogTypeEnum} LogTypeEnum */

      /** @typedef {function(string): boolean} FilterFunction */

      /**
       * @typedef {Object} LoggerConsole
       * @property {function(): void} clear
       * @property {function(): void} trace
       * @property {(...args: any[]) => void} info
       * @property {(...args: any[]) => void} log
       * @property {(...args: any[]) => void} warn
       * @property {(...args: any[]) => void} error
       * @property {(...args: any[]) => void=} debug
       * @property {(...args: any[]) => void=} group
       * @property {(...args: any[]) => void=} groupCollapsed
       * @property {(...args: any[]) => void=} groupEnd
       * @property {(...args: any[]) => void=} status
       * @property {(...args: any[]) => void=} profile
       * @property {(...args: any[]) => void=} profileEnd
       * @property {(...args: any[]) => void=} logTime
       */

      /**
       * @typedef {Object} LoggerOptions
       * @property {false|true|"none"|"error"|"warn"|"info"|"log"|"verbose"} level loglevel
       * @property {FilterTypes|boolean} debug filter for debug logging
       * @property {LoggerConsole} console the console to log to
       */

      /**
       * @param {FilterItemTypes} item an input item
       * @returns {FilterFunction} filter function
       */


      var filterToFunction = function filterToFunction(item) {
        if (typeof item === "string") {
          var regExp = new RegExp("[\\\\/]".concat(item.replace( // eslint-disable-next-line no-useless-escape
          /[-[\]{}()*+?.\\^$|]/g, "\\$&"), "([\\\\/]|$|!|\\?)"));
          return function (ident) {
            return regExp.test(ident);
          };
        }

        if (item && typeof item === "object" && typeof item.test === "function") {
          return function (ident) {
            return item.test(ident);
          };
        }

        if (typeof item === "function") {
          return item;
        }

        if (typeof item === "boolean") {
          return function () {
            return item;
          };
        }
      };
      /**
       * @enum {number}
       */


      var LogLevel = {
        none: 6,
        false: 6,
        error: 5,
        warn: 4,
        info: 3,
        log: 2,
        true: 2,
        verbose: 1
      };
      /**
       * @param {LoggerOptions} options options object
       * @returns {function(string, LogTypeEnum, any[]): void} logging function
       */

      module.exports = function (_ref) {
        var _ref$level = _ref.level,
            level = _ref$level === void 0 ? "info" : _ref$level,
            _ref$debug = _ref.debug,
            debug = _ref$debug === void 0 ? false : _ref$debug,
            console = _ref.console;
        var debugFilters = typeof debug === "boolean" ? [function () {
          return debug;
        }] :
        /** @type {FilterItemTypes[]} */
        [].concat(debug).map(filterToFunction);
        /** @type {number} */

        var loglevel = LogLevel["".concat(level)] || 0;
        /**
         * @param {string} name name of the logger
         * @param {LogTypeEnum} type type of the log entry
         * @param {any[]} args arguments of the log entry
         * @returns {void}
         */

        var logger = function logger(name, type, args) {
          var labeledArgs = function labeledArgs() {
            if (Array.isArray(args)) {
              if (args.length > 0 && typeof args[0] === "string") {
                return ["[".concat(name, "] ").concat(args[0])].concat(_toConsumableArray(args.slice(1)));
              } else {
                return ["[".concat(name, "]")].concat(_toConsumableArray(args));
              }
            } else {
              return [];
            }
          };

          var debug = debugFilters.some(function (f) {
            return f(name);
          });

          switch (type) {
            case LogType.debug:
              if (!debug) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              if (typeof console.debug === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.debug.apply(console, _toConsumableArray(labeledArgs()));
              } else {
                console.log.apply(console, _toConsumableArray(labeledArgs()));
              }

              break;

            case LogType.log:
              if (!debug && loglevel > LogLevel.log) return;
              console.log.apply(console, _toConsumableArray(labeledArgs()));
              break;

            case LogType.info:
              if (!debug && loglevel > LogLevel.info) return;
              console.info.apply(console, _toConsumableArray(labeledArgs()));
              break;

            case LogType.warn:
              if (!debug && loglevel > LogLevel.warn) return;
              console.warn.apply(console, _toConsumableArray(labeledArgs()));
              break;

            case LogType.error:
              if (!debug && loglevel > LogLevel.error) return;
              console.error.apply(console, _toConsumableArray(labeledArgs()));
              break;

            case LogType.trace:
              if (!debug) return;
              console.trace();
              break;

            case LogType.groupCollapsed:
              if (!debug && loglevel > LogLevel.log) return;

              if (!debug && loglevel > LogLevel.verbose) {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                if (typeof console.groupCollapsed === "function") {
                  // eslint-disable-next-line node/no-unsupported-features/node-builtins
                  console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));
                } else {
                  console.log.apply(console, _toConsumableArray(labeledArgs()));
                }

                break;
              }

            // falls through

            case LogType.group:
              if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              if (typeof console.group === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.group.apply(console, _toConsumableArray(labeledArgs()));
              } else {
                console.log.apply(console, _toConsumableArray(labeledArgs()));
              }

              break;

            case LogType.groupEnd:
              if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              if (typeof console.groupEnd === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.groupEnd();
              }

              break;

            case LogType.time:
              {
                if (!debug && loglevel > LogLevel.log) return;
                var ms = args[1] * 1000 + args[2] / 1000000;
                var msg = "[".concat(name, "] ").concat(args[0], ": ").concat(ms, " ms");

                if (typeof console.logTime === "function") {
                  console.logTime(msg);
                } else {
                  console.log(msg);
                }

                break;
              }

            case LogType.profile:
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.profile === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.profile.apply(console, _toConsumableArray(labeledArgs()));
              }

              break;

            case LogType.profileEnd:
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.profileEnd === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));
              }

              break;

            case LogType.clear:
              if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              if (typeof console.clear === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.clear();
              }

              break;

            case LogType.status:
              if (!debug && loglevel > LogLevel.info) return;

              if (typeof console.status === "function") {
                if (args.length === 0) {
                  console.status();
                } else {
                  console.status.apply(console, _toConsumableArray(labeledArgs()));
                }
              } else {
                if (args.length !== 0) {
                  console.info.apply(console, _toConsumableArray(labeledArgs()));
                }
              }

              break;

            default:
              throw new Error("Unexpected LogType ".concat(type));
          }
        };

        return logger;
      };
      /***/

    },

    /***/
    "./node_modules/webpack/lib/logging/runtime.js": function (__unused_webpack_module, exports, __nested_webpack_require_22851__) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      var SyncBailHook = __nested_webpack_require_22851__(
      /*! tapable/lib/SyncBailHook */
      "./client-src/modules/logger/SyncBailHookFake.js");

      var _require = __nested_webpack_require_22851__(
      /*! ./Logger */
      "./node_modules/webpack/lib/logging/Logger.js"),
          Logger = _require.Logger;

      var createConsoleLogger = __nested_webpack_require_22851__(
      /*! ./createConsoleLogger */
      "./node_modules/webpack/lib/logging/createConsoleLogger.js");
      /** @type {createConsoleLogger.LoggerOptions} */


      var currentDefaultLoggerOptions = {
        level: "info",
        debug: false,
        console: console
      };
      var currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);
      /**
       * @param {string} name name of the logger
       * @returns {Logger} a logger
       */

      exports.getLogger = function (name) {
        return new Logger(function (type, args) {
          if (exports.hooks.log.call(name, type, args) === undefined) {
            currentDefaultLogger(name, type, args);
          }
        }, function (childName) {
          return exports.getLogger("".concat(name, "/").concat(childName));
        });
      };
      /**
       * @param {createConsoleLogger.LoggerOptions} options new options, merge with old options
       * @returns {void}
       */


      exports.configureDefaultLogger = function (options) {
        _extends(currentDefaultLoggerOptions, options);

        currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);
      };

      exports.hooks = {
        log: new SyncBailHook(["origin", "type", "args"])
      };
      /***/
    }
    /******/

  };
  /************************************************************************/

  /******/
  // The module cache

  /******/

  var __webpack_module_cache__ = {};
  /******/

  /******/
  // The require function

  /******/

  function __nested_webpack_require_25353__(moduleId) {
    /******/
    // Check if module is in cache

    /******/
    var cachedModule = __webpack_module_cache__[moduleId];
    /******/

    if (cachedModule !== undefined) {
      /******/
      return cachedModule.exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = __webpack_module_cache__[moduleId] = {
      /******/
      // no module.id needed

      /******/
      // no module.loaded needed

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_25353__);
    /******/

    /******/
    // Return the exports of the module

    /******/


    return module.exports;
    /******/
  }
  /******/

  /************************************************************************/

  /******/

  /* webpack/runtime/define property getters */

  /******/


  !function () {
    /******/
    // define getter functions for harmony exports

    /******/
    __nested_webpack_require_25353__.d = function (exports, definition) {
      /******/
      for (var key in definition) {
        /******/
        if (__nested_webpack_require_25353__.o(definition, key) && !__nested_webpack_require_25353__.o(exports, key)) {
          /******/
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
          /******/
        }
        /******/

      }
      /******/

    };
    /******/

  }();
  /******/

  /******/

  /* webpack/runtime/hasOwnProperty shorthand */

  /******/

  !function () {
    /******/
    __nested_webpack_require_25353__.o = function (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    /******/

  }();
  /******/

  /******/

  /* webpack/runtime/make namespace object */

  /******/

  !function () {
    /******/
    // define __esModule on exports

    /******/
    __nested_webpack_require_25353__.r = function (exports) {
      /******/
      if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/
        Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/


      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/

  }();
  /******/

  /************************************************************************/

  var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.

  !function () {
    /*!********************************************!*\
      !*** ./client-src/modules/logger/index.js ***!
      \********************************************/
    __nested_webpack_require_25353__.r(__webpack_exports__);
    /* harmony export */


    __nested_webpack_require_25353__.d(__webpack_exports__, {
      /* harmony export */
      "default": function () {
        return (
          /* reexport default export from named module */
          webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__
        );
      }
      /* harmony export */

    });
    /* harmony import */


    var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_25353__(
    /*! webpack/lib/logging/runtime.js */
    "./node_modules/webpack/lib/logging/runtime.js");
  }();
  var __webpack_export_target__ = exports;

  for (var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];

  if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", {
    value: true
  });
  /******/
})();

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/modules/strip-ansi/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/modules/strip-ansi/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/******/
(function () {
  // webpackBootstrap

  /******/
  "use strict";
  /******/

  var __webpack_modules__ = {
    /***/
    "./node_modules/strip-ansi/index.js": function (__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_236__) {
      __nested_webpack_require_236__.r(__webpack_exports__);
      /* harmony export */


      __nested_webpack_require_236__.d(__webpack_exports__, {
        /* harmony export */
        "default": function () {
          return (
            /* binding */
            stripAnsi
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var ansi_regex__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_236__(
      /*! ansi-regex */
      "./node_modules/strip-ansi/node_modules/ansi-regex/index.js");

      function stripAnsi(string) {
        if (typeof string !== 'string') {
          throw new TypeError("Expected a `string`, got `".concat(typeof string, "`"));
        }

        return string.replace((0, ansi_regex__WEBPACK_IMPORTED_MODULE_0__["default"])(), '');
      }
      /***/

    },

    /***/
    "./node_modules/strip-ansi/node_modules/ansi-regex/index.js": function (__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_1220__) {
      __nested_webpack_require_1220__.r(__webpack_exports__);
      /* harmony export */


      __nested_webpack_require_1220__.d(__webpack_exports__, {
        /* harmony export */
        "default": function () {
          return (
            /* binding */
            ansiRegex
          );
        }
        /* harmony export */

      });

      function ansiRegex() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$onlyFirst = _ref.onlyFirst,
            onlyFirst = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

        var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
        return new RegExp(pattern, onlyFirst ? undefined : 'g');
      }
      /***/

    }
    /******/

  };
  /************************************************************************/

  /******/
  // The module cache

  /******/

  var __webpack_module_cache__ = {};
  /******/

  /******/
  // The require function

  /******/

  function __nested_webpack_require_2366__(moduleId) {
    /******/
    // Check if module is in cache

    /******/
    var cachedModule = __webpack_module_cache__[moduleId];
    /******/

    if (cachedModule !== undefined) {
      /******/
      return cachedModule.exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = __webpack_module_cache__[moduleId] = {
      /******/
      // no module.id needed

      /******/
      // no module.loaded needed

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_2366__);
    /******/

    /******/
    // Return the exports of the module

    /******/


    return module.exports;
    /******/
  }
  /******/

  /************************************************************************/

  /******/

  /* webpack/runtime/define property getters */

  /******/


  !function () {
    /******/
    // define getter functions for harmony exports

    /******/
    __nested_webpack_require_2366__.d = function (exports, definition) {
      /******/
      for (var key in definition) {
        /******/
        if (__nested_webpack_require_2366__.o(definition, key) && !__nested_webpack_require_2366__.o(exports, key)) {
          /******/
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
          /******/
        }
        /******/

      }
      /******/

    };
    /******/

  }();
  /******/

  /******/

  /* webpack/runtime/hasOwnProperty shorthand */

  /******/

  !function () {
    /******/
    __nested_webpack_require_2366__.o = function (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    /******/

  }();
  /******/

  /******/

  /* webpack/runtime/make namespace object */

  /******/

  !function () {
    /******/
    // define __esModule on exports

    /******/
    __nested_webpack_require_2366__.r = function (exports) {
      /******/
      if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/
        Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/


      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/

  }();
  /******/

  /************************************************************************/

  var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.

  !function () {
    /*!************************************************!*\
      !*** ./client-src/modules/strip-ansi/index.js ***!
      \************************************************/
    __nested_webpack_require_2366__.r(__webpack_exports__);
    /* harmony import */


    var strip_ansi__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_2366__(
    /*! strip-ansi */
    "./node_modules/strip-ansi/index.js");
    /* harmony default export */


    __webpack_exports__["default"] = strip_ansi__WEBPACK_IMPORTED_MODULE_0__["default"];
  }();
  var __webpack_export_target__ = exports;

  for (var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];

  if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", {
    value: true
  });
  /******/
})();

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!***********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "show": () => (/* binding */ show),
/* harmony export */   "hide": () => (/* binding */ hide)
/* harmony export */ });
/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-html-community */ "./node_modules/ansi-html-community/index.js");
/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ansi_html_community__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/lib/index.js");
/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(html_entities__WEBPACK_IMPORTED_MODULE_1__);
// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).


var colors = {
  reset: ["transparent", "transparent"],
  black: "181818",
  red: "E36049",
  green: "B3CB74",
  yellow: "FFD080",
  blue: "7CAFC2",
  magenta: "7FACCA",
  cyan: "C3C2EF",
  lightgrey: "EBE7E3",
  darkgrey: "6D7891"
};
var iframeContainerElement;
var containerElement;
var onLoadQueue = [];
ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default().setColors(colors);

function createContainer() {
  iframeContainerElement = document.createElement("iframe");
  iframeContainerElement.id = "webpack-dev-server-client-overlay";
  iframeContainerElement.src = "about:blank";
  iframeContainerElement.style.position = "fixed";
  iframeContainerElement.style.left = 0;
  iframeContainerElement.style.top = 0;
  iframeContainerElement.style.right = 0;
  iframeContainerElement.style.bottom = 0;
  iframeContainerElement.style.width = "100vw";
  iframeContainerElement.style.height = "100vh";
  iframeContainerElement.style.border = "none";
  iframeContainerElement.style.zIndex = 9999999999;

  iframeContainerElement.onload = function () {
    containerElement = iframeContainerElement.contentDocument.createElement("div");
    containerElement.id = "webpack-dev-server-client-overlay-div";
    containerElement.style.position = "fixed";
    containerElement.style.boxSizing = "border-box";
    containerElement.style.left = 0;
    containerElement.style.top = 0;
    containerElement.style.right = 0;
    containerElement.style.bottom = 0;
    containerElement.style.width = "100vw";
    containerElement.style.height = "100vh";
    containerElement.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
    containerElement.style.color = "#E8E8E8";
    containerElement.style.fontFamily = "Menlo, Consolas, monospace";
    containerElement.style.fontSize = "large";
    containerElement.style.padding = "2rem";
    containerElement.style.lineHeight = "1.2";
    containerElement.style.whiteSpace = "pre-wrap";
    containerElement.style.overflow = "auto";
    var headerElement = document.createElement("span");
    headerElement.innerText = "Compiled with problems:";
    var closeButtonElement = document.createElement("button");
    closeButtonElement.innerText = "X";
    closeButtonElement.style.background = "transparent";
    closeButtonElement.style.border = "none";
    closeButtonElement.style.fontSize = "20px";
    closeButtonElement.style.fontWeight = "bold";
    closeButtonElement.style.color = "white";
    closeButtonElement.style.cursor = "pointer";
    closeButtonElement.style.cssFloat = "right";
    closeButtonElement.style.styleFloat = "right";
    closeButtonElement.addEventListener("click", function () {
      hide();
    });
    containerElement.appendChild(headerElement);
    containerElement.appendChild(closeButtonElement);
    containerElement.appendChild(document.createElement("br"));
    containerElement.appendChild(document.createElement("br"));
    iframeContainerElement.contentDocument.body.appendChild(containerElement);
    onLoadQueue.forEach(function (onLoad) {
      onLoad(containerElement);
    });
    onLoadQueue = [];
    iframeContainerElement.onload = null;
  };

  document.body.appendChild(iframeContainerElement);
}

function ensureOverlayExists(callback) {
  if (containerElement) {
    // Everything is ready, call the callback right away.
    callback(containerElement);
    return;
  }

  onLoadQueue.push(callback);

  if (iframeContainerElement) {
    return;
  }

  createContainer();
} // Successful compilation.


function hide() {
  if (!iframeContainerElement) {
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(iframeContainerElement);
  iframeContainerElement = null;
  containerElement = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function show(messages, type) {
  ensureOverlayExists(function () {
    messages.forEach(function (message) {
      var entryElement = document.createElement("div");
      var typeElement = document.createElement("span");
      typeElement.innerText = type === "warnings" ? "Warning:" : "Error:";
      typeElement.style.color = "#".concat(colors.red); // Make it look similar to our terminal.

      var errorMessage = message.message || messages[0];
      var text = ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default()((0,html_entities__WEBPACK_IMPORTED_MODULE_1__.encode)(errorMessage));
      var messageTextNode = document.createElement("div");
      messageTextNode.innerHTML = text;
      entryElement.appendChild(typeElement);
      entryElement.appendChild(document.createElement("br"));
      entryElement.appendChild(document.createElement("br"));
      entryElement.appendChild(messageTextNode);
      entryElement.appendChild(document.createElement("br"));
      entryElement.appendChild(document.createElement("br"));
      containerElement.appendChild(entryElement);
    });
  });
}



/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/socket.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clients/WebSocketClient.js */ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js");
/* provided dependency */ var __webpack_dev_server_client__ = __webpack_require__(/*! ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js */ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js");
/* global __webpack_dev_server_client__ */
 // this WebsocketClient is here as a default fallback, in case the client is not injected

/* eslint-disable camelcase */

var Client = // eslint-disable-next-line camelcase, no-nested-ternary
typeof __webpack_dev_server_client__ !== "undefined" ? // eslint-disable-next-line camelcase
typeof __webpack_dev_server_client__.default !== "undefined" ? __webpack_dev_server_client__.default : __webpack_dev_server_client__ : _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__["default"];
/* eslint-enable camelcase */

var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var message = JSON.parse(data);

    if (handlers[message.type]) {
      handlers[message.type](message.data);
    }
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (socket);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketURL.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/createSocketURL.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
 // We handle legacy API that is Node.js specific, and a newer API that implements the same WHATWG URL Standard used by web browsers
// Please look at https://nodejs.org/api/url.html#url_url_strings_and_url_objects

function createSocketURL(parsedURL) {
  var hostname = parsedURL.hostname; // Node.js module parses it as `::`
  // `new URL(urlString, [baseURLstring])` parses it as '[::]'

  var isInAddrAny = hostname === "0.0.0.0" || hostname === "::" || hostname === "[::]"; // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384

  if (isInAddrAny && self.location.hostname && self.location.protocol.indexOf("http") === 0) {
    hostname = self.location.hostname;
  }

  var socketURLProtocol = parsedURL.protocol || self.location.protocol; // When https is used in the app, secure web sockets are always necessary because the browser doesn't accept non-secure web sockets.

  if (socketURLProtocol === "auto:" || hostname && isInAddrAny && self.location.protocol === "https:") {
    socketURLProtocol = self.location.protocol;
  }

  socketURLProtocol = socketURLProtocol.replace(/^(?:http|.+-extension|file)/i, "ws");
  var socketURLAuth = ""; // `new URL(urlString, [baseURLstring])` doesn't have `auth` property
  // Parse authentication credentials in case we need them

  if (parsedURL.username) {
    socketURLAuth = parsedURL.username; // Since HTTP basic authentication does not allow empty username,
    // we only include password if the username is not empty.

    if (parsedURL.password) {
      // Result: <username>:<password>
      socketURLAuth = socketURLAuth.concat(":", parsedURL.password);
    }
  } // In case the host is a raw IPv6 address, it can be enclosed in
  // the brackets as the brackets are needed in the final URL string.
  // Need to remove those as url.format blindly adds its own set of brackets
  // if the host string contains colons. That would lead to non-working
  // double brackets (e.g. [[::]]) host
  //
  // All of these web socket url params are optionally passed in through resourceQuery,
  // so we need to fall back to the default if they are not provided


  var socketURLHostname = (hostname || self.location.hostname || "localhost").replace(/^\[(.*)\]$/, "$1");
  var socketURLPort = parsedURL.port;

  if (!socketURLPort || socketURLPort === "0") {
    socketURLPort = self.location.port;
  } // If path is provided it'll be passed in via the resourceQuery as a
  // query param so it has to be parsed out of the querystring in order for the
  // client to open the socket to the correct location.


  var socketURLPathname = "/ws";

  if (parsedURL.pathname && !parsedURL.fromCurrentScript) {
    socketURLPathname = parsedURL.pathname;
  }

  return url__WEBPACK_IMPORTED_MODULE_0__.format({
    protocol: socketURLProtocol,
    auth: socketURLAuth,
    hostname: socketURLHostname,
    port: socketURLPort,
    pathname: socketURLPathname,
    slashes: true
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSocketURL);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!********************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute("src");
  } // Fallback to getting all scripts running in the document.


  var scriptElements = document.scripts || [];
  var scriptElementsWithSrc = Array.prototype.filter.call(scriptElements, function (element) {
    return element.getAttribute("src");
  });

  if (scriptElementsWithSrc.length > 0) {
    var currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];
    return currentScript.getAttribute("src");
  } // Fail as there was no script to use.


  throw new Error("[webpack-dev-server] Failed to get current script source.");
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getCurrentScriptSource);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/log.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "setLogLevel": () => (/* binding */ setLogLevel)
/* harmony export */ });
/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/logger/index.js */ "./node_modules/webpack-dev-server/client/modules/logger/index.js");
/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__);

var name = "webpack-dev-server"; // default level is set on the client side, so it does not need
// to be set by the CLI or API

var defaultLevel = "info";

function setLogLevel(level) {
  _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().configureDefaultLogger({
    level: level
  });
}

setLogLevel(defaultLevel);
var log = _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().getLogger(name);


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/parseURL.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/parseURL.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
/* harmony import */ var _getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCurrentScriptSource.js */ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js");



function parseURL(resourceQuery) {
  var options = {};

  if (typeof resourceQuery === "string" && resourceQuery !== "") {
    var searchParams = resourceQuery.substr(1).split("&");

    for (var i = 0; i < searchParams.length; i++) {
      var pair = searchParams[i].split("=");
      options[pair[0]] = decodeURIComponent(pair[1]);
    }
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptSource = (0,_getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_1__["default"])();

    if (scriptSource) {
      var scriptSourceURL;

      try {
        // The placeholder `baseURL` with `window.location.href`,
        // is to allow parsing of path-relative or protocol-relative URLs,
        // and will have no effect if `scriptSource` is a fully valid URL.
        scriptSourceURL = new URL(scriptSource, self.location.href);
      } catch (error) {// URL parsing failed, do nothing.
        // We will still proceed to see if we can recover using `resourceQuery`
      }

      if (scriptSourceURL) {
        options = scriptSourceURL;
        options.fromCurrentScript = true;
      }
    } else {
      options = url__WEBPACK_IMPORTED_MODULE_0__.parse(self.location.href, true, true);
      options.fromCurrentScript = true;
    }
  }

  return options;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseURL);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/reloadApp.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/emitter.js */ "./node_modules/webpack/hot/emitter.js");
/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
/* global __webpack_hash__ */



function reloadApp(_ref, status) {
  var hot = _ref.hot,
      liveReload = _ref.liveReload;

  if (status.isUnloading) {
    return;
  }

  var currentHash = status.currentHash,
      previousHash = status.previousHash;
  var isInitial = currentHash.indexOf(previousHash) >= 0;

  if (isInitial) {
    return;
  }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info("App updated. Reloading...");
    rootWindow.location.reload();
  }

  var search = self.location.search.toLowerCase();
  var allowToHot = search.indexOf("webpack-dev-server-hot=false") === -1;
  var allowToLiveReload = search.indexOf("webpack-dev-server-live-reload=false") === -1;

  if (hot && allowToHot) {
    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info("App hot update...");
    webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default().emit("webpackHotUpdate", status.currentHash);

    if (typeof self !== "undefined" && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(status.currentHash), "*");
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload && allowToLiveReload) {
    var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

    var intervalId = self.setInterval(function () {
      if (rootWindow.location.protocol !== "about:") {
        // reload immediately if protocol is valid
        applyReload(rootWindow, intervalId);
      } else {
        rootWindow = rootWindow.parent;

        if (rootWindow.parent === rootWindow) {
          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
          applyReload(rootWindow, intervalId);
        }
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reloadApp);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/sendMessage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* global __resourceQuery WorkerGlobalScope */
// Send messages to the outside, so plugins can consume it.
function sendMsg(type, data) {
  if (typeof self !== "undefined" && (typeof WorkerGlobalScope === "undefined" || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, "*");
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sendMsg);

/***/ }),

/***/ "./node_modules/webpack/hot/dev-server.js":
/*!************************************************!*\
  !*** ./node_modules/webpack/hot/dev-server.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

/* globals __webpack_hash__ */
if (true) {
  var lastHash;

  var upToDate = function upToDate() {
    return lastHash.indexOf(__webpack_require__.h()) >= 0;
  };

  var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

  var check = function check() {
    module.hot.check(true).then(function (updatedModules) {
      if (!updatedModules) {
        log("warning", "[HMR] Cannot find update. Need to do a full reload!");
        log("warning", "[HMR] (Probably because of restarting the webpack-dev-server)");
        window.location.reload();
        return;
      }

      if (!upToDate()) {
        check();
      }

      __webpack_require__(/*! ./log-apply-result */ "./node_modules/webpack/hot/log-apply-result.js")(updatedModules, updatedModules);

      if (upToDate()) {
        log("info", "[HMR] App is up to date.");
      }
    }).catch(function (err) {
      var status = module.hot.status();

      if (["abort", "fail"].indexOf(status) >= 0) {
        log("warning", "[HMR] Cannot apply update. Need to do a full reload!");
        log("warning", "[HMR] " + log.formatError(err));
        window.location.reload();
      } else {
        log("warning", "[HMR] Update failed: " + log.formatError(err));
      }
    });
  };

  var hotEmitter = __webpack_require__(/*! ./emitter */ "./node_modules/webpack/hot/emitter.js");

  hotEmitter.on("webpackHotUpdate", function (currentHash) {
    lastHash = currentHash;

    if (!upToDate() && module.hot.status() === "idle") {
      log("info", "[HMR] Checking for updates on the server...");
      check();
    }
  });
  log("info", "[HMR] Waiting for update signal from WDS...");
} else {}

/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!*********************************************!*\
  !*** ./node_modules/webpack/hot/emitter.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

module.exports = new EventEmitter();

/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!******************************************************!*\
  !*** ./node_modules/webpack/hot/log-apply-result.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function (updatedModules, renewedModules) {
  var unacceptedModules = updatedModules.filter(function (moduleId) {
    return renewedModules && renewedModules.indexOf(moduleId) < 0;
  });

  var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

  if (unacceptedModules.length > 0) {
    log("warning", "[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
    unacceptedModules.forEach(function (moduleId) {
      log("warning", "[HMR]  - " + moduleId);
    });
  }

  if (!renewedModules || renewedModules.length === 0) {
    log("info", "[HMR] Nothing hot updated.");
  } else {
    log("info", "[HMR] Updated modules:");
    renewedModules.forEach(function (moduleId) {
      if (typeof moduleId === "string" && moduleId.indexOf("!") !== -1) {
        var parts = moduleId.split("!");
        log.groupCollapsed("info", "[HMR]  - " + parts.pop());
        log("info", "[HMR]  - " + moduleId);
        log.groupEnd("info");
      } else {
        log("info", "[HMR]  - " + moduleId);
      }
    });
    var numberIds = renewedModules.every(function (moduleId) {
      return typeof moduleId === "number";
    });
    if (numberIds) log("info", '[HMR] Consider using the optimization.moduleIds: "named" for module names.');
  }
};

/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
  var shouldLog = logLevel === "info" && level === "info" || ["info", "warning"].indexOf(logLevel) >= 0 && level === "warning" || ["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error";
  return shouldLog;
}

function logGroup(logFn) {
  return function (level, msg) {
    if (shouldLog(level)) {
      logFn(msg);
    }
  };
}

module.exports = function (level, msg) {
  if (shouldLog(level)) {
    if (level === "info") {
      console.log(msg);
    } else if (level === "warning") {
      console.warn(msg);
    } else if (level === "error") {
      console.error(msg);
    }
  }
};
/* eslint-disable node/no-unsupported-features/node-builtins */


var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);
module.exports.groupCollapsed = logGroup(groupCollapsed);
module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function (level) {
  logLevel = level;
};

module.exports.formatError = function (err) {
  var message = err.message;
  var stack = err.stack;

  if (!stack) {
    return message;
  } else if (stack.indexOf(message) < 0) {
    return message + "\n" + stack;
  } else {
    return stack;
  }
};

/***/ }),

/***/ "./styles/index.scss":
/*!***************************!*\
  !*** ./styles/index.scss ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin

    if(true) {
      // 1635988119050
      var cssReload = __webpack_require__(/*! ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js */ "./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js")(module.id, {"publicPath":"","locals":false});
      module.hot.dispose(cssReload);
      module.hot.accept(undefined, cssReload);
    }
  

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("d84d2abc12f8c579d7ab")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "floema:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises;
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 					blockingPromises.push(promise);
/******/ 					waitForBlockingPromises(function () {
/******/ 						return setStatus("ready");
/******/ 					});
/******/ 					return promise;
/******/ 				case "prepare":
/******/ 					blockingPromises.push(promise);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises.length === 0) return fn();
/******/ 			var blocker = blockingPromises;
/******/ 			blockingPromises = [];
/******/ 			return Promise.all(blocker).then(function () {
/******/ 				return waitForBlockingPromises(fn);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						blockingPromises = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error("apply() is only allowed in ready status");
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		var createStylesheet = (chunkId, fullhref, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			document.head.appendChild(linkTag);
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// no chunk loading
/******/ 		
/******/ 		var oldTags = [];
/******/ 		var newTags = [];
/******/ 		var applyHandler = (options) => {
/******/ 			return { dispose: () => {
/******/ 				for(var i = 0; i < oldTags.length; i++) {
/******/ 					var oldTag = oldTags[i];
/******/ 					if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);
/******/ 				}
/******/ 				oldTags.length = 0;
/******/ 			}, apply: () => {
/******/ 				for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";
/******/ 				newTags.length = 0;
/******/ 			} };
/******/ 		}
/******/ 		__webpack_require__.hmrC.miniCss = (chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) => {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			chunkIds.forEach((chunkId) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var oldTag = findStylesheet(href, fullhref);
/******/ 				if(!oldTag) return;
/******/ 				promises.push(new Promise((resolve, reject) => {
/******/ 					var tag = createStylesheet(chunkId, fullhref, () => {
/******/ 						tag.as = "style";
/******/ 						tag.rel = "preload";
/******/ 						resolve();
/******/ 					}, reject);
/******/ 					oldTags.push(oldTag);
/******/ 					newTags.push(tag);
/******/ 				}));
/******/ 			});
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId) {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdatefloema"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						!__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						__webpack_require__.o(installedChunks, chunkId) &&
/******/ 						installedChunks[chunkId] !== undefined
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info");
/******/ 	__webpack_require__("./node_modules/webpack/hot/dev-server.js");
/******/ 	__webpack_require__("./app/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./styles/index.scss");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7V0FDQSxFQUFFO1dBQ0Y7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxtQkFBbUIsMkJBQTJCO1dBQzlDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxLQUFLO1dBQ0w7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBLGtCQUFrQixjQUFjO1dBQ2hDO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQSxjQUFjLE1BQU07V0FDcEI7V0FDQTtXQUNBO1dBQ0EsS0FBSztXQUNMO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxjQUFjLGFBQWE7V0FDM0I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQSxpQkFBaUIsNEJBQTRCO1dBQzdDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxJQUFJO1dBQ0o7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLElBQUk7V0FDSjs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7V0FDQTtXQUNBLGdCQUFnQiw0QkFBNEI7V0FDNUM7V0FDQTtXQUNBOztXQUVBO1dBQ0E7O1dBRUE7V0FDQTs7V0FFQTtXQUNBOztXQUVBO1dBQ0EsZ0JBQWdCLDRCQUE0QjtXQUM1QztXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxrQkFBa0IsdUNBQXVDO1dBQ3pEO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0EsbUJBQW1CLGlDQUFpQztXQUNwRDtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esc0JBQXNCLHVDQUF1QztXQUM3RDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxzQkFBc0Isc0JBQXNCO1dBQzVDO1dBQ0E7V0FDQSxTQUFTO1dBQ1Q7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFdBQVc7V0FDWCxXQUFXO1dBQ1g7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxZQUFZO1dBQ1o7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsVUFBVTtXQUNWO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFdBQVc7V0FDWDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBLG1CQUFtQix3Q0FBd0M7V0FDM0Q7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNO1dBQ047V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFFBQVE7V0FDUixRQUFRO1dBQ1I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsU0FBUztXQUNUO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLE9BQU87V0FDUDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsUUFBUTtXQUNSO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFLElBQUk7V0FDTjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQSxzQ0FBc0M7V0FDdEM7V0FDQTtXQUNBLEVBQUU7V0FDRjs7V0FFQTs7V0FFQTs7Ozs7VUU1ZkE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG9lbWEvLi9hcHAvY2xhc3Nlcy9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vYXBwL2NsYXNzZXMvUGFnZS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9hcHAvY29tcG9uZW50cy9QcmVsb2FkZXIuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vYXBwL2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL2FwcC9wYWdlcy9BYm91dC9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9hcHAvcGFnZXMvSG9tZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9hcHAvdXRpbHMvdGV4dC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sLWNvbW11bml0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2dzYXAvZ3NhcC1jb3JlLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9nc2FwL2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbmFtZWQtcmVmZXJlbmNlcy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbnVtZXJpYy11bmljb2RlLW1hcC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvc3Vycm9nYXRlLXBhaXJzLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lYWNoLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvaG1yL25vcm1hbGl6ZS11cmwuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3ByZWZpeC9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1dlYlNvY2tldENsaWVudC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9tb2R1bGVzL2xvZ2dlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvY3JlYXRlU29ja2V0VVJMLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vZmxvZW1hLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvbG9nLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3BhcnNlVVJMLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3JlbG9hZEFwcC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZGV2LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLWFwcGx5LXJlc3VsdC5qcyIsIndlYnBhY2s6Ly9mbG9lbWEvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzIiwid2VicGFjazovL2Zsb2VtYS8uL3N0eWxlcy9pbmRleC5zY3NzIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IHVwZGF0ZSBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2dldCBtaW5pLWNzcyBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2dldCB1cGRhdGUgbWFuaWZlc3QgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svcnVudGltZS9nZXRGdWxsSGFzaCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2xvYWQgc2NyaXB0Iiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL2Zsb2VtYS93ZWJwYWNrL3J1bnRpbWUvaG90IG1vZHVsZSByZXBsYWNlbWVudCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svcnVudGltZS9jc3MgbG9hZGluZyIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vZmxvZW1hL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9mbG9lbWEvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJ1xuXG5pbXBvcnQgZWFjaCBmcm9tICdsb2Rhc2gvZWFjaCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHsgZWxlbWVudCwgZWxlbWVudHMgfSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuc2VsZWN0b3IgPSBlbGVtZW50XG4gICAgdGhpcy5zZWxlY3RvckNoaWxkcmVuID0ge1xuICAgICAgLi4uZWxlbWVudHNcbiAgICB9XG5cbiAgICB0aGlzLmNyZWF0ZSgpXG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKClcbiAgfVxuXG4gIGNyZWF0ZSAoKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnNlbGVjdG9yKVxuICAgIHRoaXMuZWxlbWVudHMgPSB7fVxuXG4gICAgZWFjaCh0aGlzLnNlbGVjdG9yQ2hpbGRyZW4sIChlbnRyeSwga2V5KSA9PiB7XG4gICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQgfHwgZW50cnkgaW5zdGFuY2VvZiB3aW5kb3cuTm9kZUxpc3QgfHwgQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1trZXldID0gZW50cnlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNba2V5XSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZW50cnkpXG5cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNba2V5XS5sZW5naHQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzW2tleV0gPSBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50c1trZXldLmxlbmdodCA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNba2V5XSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZW50cnkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcnMgKCkge1xuXG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVycyAoKSB7XG5cbiAgfVxufVxuIiwiaW1wb3J0IEdTQVAgZnJvbSAnZ3NhcCdcblxuaW1wb3J0IGVhY2ggZnJvbSAnbG9kYXNoL2VhY2gnXG5cbmltcG9ydCBQcmVmaXggZnJvbSAncHJlZml4J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlIHtcbiAgY29uc3RydWN0b3IgKHsgaWQsIGVsZW1lbnQsIGVsZW1lbnRzIH0pIHtcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLnNlbGVjdG9yID0gZWxlbWVudFxuICAgIHRoaXMuc2VsZWN0b3JDaGlsZHJlbiA9IHtcbiAgICAgIC4uLmVsZW1lbnRzXG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGwgPSB7XG4gICAgICBjdXJyZW50OiAwLFxuICAgICAgdGFyZ2V0OiAwLFxuICAgICAgbGltaXQ6IDQwMDBcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zZm9ybVByZWZpeCA9IFByZWZpeCgnbGVmdCcpXG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKClcblxuICAgIHRoaXMuZ2V0Q3Vyc29yKClcblxuICAgIC8vdGhpcy5vbk1vdXNlV2hlZWwoKVxuXG4gICAgLy8gdGhpcy5vbk1vdXNlV2hlZWxFdmVudCA9IHRoaXMub25Nb3VzZVdoZWVsLmJpbmQodGhpcylcbiAgfVxuXG4gIGNyZWF0ZSAoKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnNlbGVjdG9yKVxuICAgIHRoaXMuZWxlbWVudHMgPSB7fVxuXG4gICAgZWFjaCh0aGlzLnNlbGVjdG9yQ2hpbGRyZW4sIChlbnRyeSwga2V5KSA9PiB7XG5cbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCB8fCBlbnRyeSBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdCB8fCBBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2tleV0gPSBlbnRyeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1trZXldID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbnRyeSlcblxuICAgICAgICBpZiAodGhpcy5lbGVtZW50c1trZXldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNba2V5XSA9IG51bGxcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnRzW2tleV0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50c1trZXldID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbnRyeSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL1RPRE86IGNoZWNrIHRoZSB2aWRlbyB0byBzZWUgaG93IGlzIGhlIHVzaW5nIHRoZSBlbGVtZW50c1trZXldIG91dHNpZGUgdGhpcyBlYWNoIGxvb3BcblxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmVsZW1lbnRzW2tleV0pXG4gICAgfSlcbiAgfVxuICBcbiAgc2hvdyAoKSB7XG4gICAgdGhpcy5hbmltYXRlSW4gPSBHU0FQLnRpbWVsaW5lKClcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIEdTQVAuZnJvbSh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgYXV0b0FscGhhOiAwLFxuICAgICAgICBvbkNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoaWRlICgpIHtcbiAgICB0aGlzLmFuaW1hdGVPdXQgPSBHU0FQLnRpbWVsaW5lKClcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIEdTQVAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIGF1dG9BbHBoYTogMCxcbiAgICAgICAgb25Db21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlICgpIHtcbiAgICB0aGlzLnNjcm9sbC5jdXJyZW50ID0gR1NBUC51dGlscy5pbnRlcnBvbGF0ZSh0aGlzLnNjcm9sbC5jdXJyZW50LCB0aGlzLnNjcm9sbC50YXJnZXQsIDAuMSlcbiAgICB0aGlzLnNjcm9sbC5jdXJyZW50ID0gR1NBUC51dGlscy5jbGFtcCgwLCB0aGlzLnNjcm9sbC5saW1pdCwgdGhpcy5zY3JvbGwuY3VycmVudClcblxuICAgIGVhY2godGhpcy5lbGVtZW50cywgaXRlbSA9PiB7XG4gICAgICBpdGVtLnN0eWxlW3RoaXMudHJhbnNmb3JtUHJlZml4XSA9IGAtJHt0aGlzLnNjcm9sbC5jdXJyZW50fXB4YFxuICAgIH0pXG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVycyAoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgZGVsdGFZIH0gPSBldmVudFxuICAgICAgdGhpcy5zY3JvbGwudGFyZ2V0ICs9IGRlbHRhWVxuICAgIH0pXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gR1NBUC51dGlscy5pbnRlcnBvbGF0ZShcbiAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCwgZXZlbnQuY2xpZW50WCArICdweCcsIDAuMVxuICAgICAgICApXG4gICAgICB0aGlzLmN1cnNvci5zdHlsZS50b3AgPSBHU0FQLnV0aWxzLmludGVycG9sYXRlKFxuICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS50b3AsIGV2ZW50LmNsaWVudFkgKyAncHgnLCAwLjFcbiAgICAgICAgKVxuICAgIH0pXG4gIH1cblxuICBnZXRDdXJzb3IgKCkge1xuICAgIHRoaXMuY3Vyc29yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmN1cnNvcicpICBcbiAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICdjbGFzc2VzL0NvbXBvbmVudCdcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IHsgc3BsaXQgfSBmcm9tICd1dGlscy90ZXh0J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVsb2FkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgZWxlbWVudDogJy5wcmVsb2FkZXInLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgdGl0bGU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcmVsb2FkZXJfX3RleHRfX3RpdGxlJyksXG4gICAgICAgIG51bWJlcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnByZWxvYWRlcl9fbnVtYmVyJyksXG4gICAgICAgIGltYWdlczogZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW1nJylcbiAgICAgIH1cbiAgICB9KVxuICAgIGNvbnNvbGUubG9nKHRoaXMuZWxlbWVudHMudGl0bGUpXG5cbiAgICB0aGlzLmxlbmd0aCA9IDBcblxuICAgIHRoaXMuY3JlYXRlTG9hZGVyKClcblxuICAgIHNwbGl0KHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudHMudGl0bGVcbiAgICB9KVxuXG4gICAgc3BsaXQoe1xuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50cy50aXRsZSxcbiAgICB9KVxuXG4gICAgc3BsaXQoe1xuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50cy50aXRsZSxcbiAgICB9KVxuXG4gICAgdGhpcy5lbGVtZW50cy50aXRsZVNwYW5zID0gdGhpcy5lbGVtZW50cy50aXRsZS5xdWVyeVNlbGVjdG9yQWxsKCdzcGFuIHNwYW4gc3BhbicpXG4gIH1cblxuICBvbkFzc2V0TG9hZGVkIChpbWFnZSkge1xuICAgIHRoaXMubGVuZ3RoICs9IDFcbiAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5yb3VuZCh0aGlzLmxlbmd0aCAvIHRoaXMuZWxlbWVudHMuaW1hZ2VzLmxlbmd0aCAqIDEwMClcblxuICAgIHRoaXMuZWxlbWVudHMubnVtYmVyLmlubmVySFRNTCA9IGAke3BlcmNlbnR9JWBcblxuICAgIGlmIChwZXJjZW50ID09PSAxMDApIHtcbiAgICAgIHRoaXMub25Mb2FkZWQoKVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUxvYWRlciAoKSB7XG4gICAgZWFjaCh0aGlzLmVsZW1lbnRzLmltYWdlcywgZWxlbWVudCA9PiB7XG4gICAgICBlbGVtZW50LnNyYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICAgICAgZWxlbWVudC5vbmxvYWQgPSBfID0+IHRoaXMub25Bc3NldExvYWRlZChlbGVtZW50KVxuICAgIH0pXG4gIH1cblxuICBvbkxvYWRlZCAoKSB7XG5cbiAgICAvLyBUT0RPOiBBREQgVEhFIEFOSU1BVElPTlMgQUZURVIgVEhFIFBBR0UgSVMgTE9BREVEXG5cbiAgICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAvKiAgdGhpcy5hbmltYXRlT3V0LnRvKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBhdXRvQWxwaGE6IDAsXG4gICAgICAgIGRlbGF5OiAyXG4gICAgICB9KSAqL1xuXG4gICAgICB0aGlzLmFuaW1hdGVPdXQgPSBnc2FwLnRpbWVsaW5lKClcblxuICAgICAgdGhpcy5hbmltYXRlT3V0LnRvKHRoaXMuZWxlbWVudHMudGl0bGVTcGFucywge1xuICAgICAgICBzdGFnZ2VyOiAwLjAzLFxuICAgICAgICBkdXJhdGlvbjogMixcbiAgICAgICAgZWFzZTogJ2V4cG8ub3V0JyxcbiAgICAgICAgeTogJy0xMDAlJyxcbiAgICAgICAgZGVsYXk6IDAuNVxuICAgICAgfSlcblxuXG4gICAgICB0aGlzLmFuaW1hdGVPdXQudG8odGhpcy5lbGVtZW50cy5udW1iZXIsIHtcbiAgICAgICAgYXV0b0FscGhhOiAwLFxuICAgICAgICBlYXNlOiAnZXhwby5vdXQnLFxuICAgICAgICBkdXJhdGlvbjogMVxuICAgICAgfSlcblxuICAgICAgdGhpcy5hbmltYXRlT3V0LnRvKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBhdXRvQWxwaGE6IDAsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCcsXG4gICAgICAgIGR1cmF0aW9uOiAxXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpXG4gIH1cbn1cbiIsImltcG9ydCBBYm91dCBmcm9tICcuL3BhZ2VzL0Fib3V0J1xuaW1wb3J0IEhvbWUgZnJvbSAnLi9wYWdlcy9Ib21lJ1xuaW1wb3J0IFByZWxvYWRlciBmcm9tICcuL2NvbXBvbmVudHMvUHJlbG9hZGVyJ1xuXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJ1xuXG5jbGFzcyBBcHAge1xuICBjb25zdHJ1Y3RvciAoKSB7ICBcbiAgICB0aGlzLmNyZWF0ZVByZWxvYWRlcigpICBcbiAgICB0aGlzLmNyZWF0ZUNvbnRlbnQoKVxuICAgIHRoaXMuY3JlYXRlUGFnZXMoKVxuICAgIHRoaXMuYWRkTGlua0xpc3RlbmVycygpXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG5cbiAgb25QcmVsb2FkZWQgKCkge1xuICAgIHRoaXMucHJlbG9hZGVyLmhpZGUoKVxuICAgIHRoaXMucHJlbG9hZGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgY3JlYXRlUHJlbG9hZGVyICgpIHtcbiAgICB0aGlzLnByZWxvYWRlciA9IG5ldyBQcmVsb2FkZXIoKVxuICAgIHRoaXMucHJlbG9hZGVyLm9uY2UoJ2NvbXBsZXRlZCcsIHRoaXMub25QcmVsb2FkZWQuYmluZCh0aGlzKSlcbiAgfVxuXG4gIGNyZWF0ZUNvbnRlbnQgKCkge1xuICAgIHRoaXMuY29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250ZW50JylcbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5jb250ZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10ZW1wbGF0ZScpXG4gIH1cblxuICBjcmVhdGVQYWdlcyAoKSB7XG4gICAgdGhpcy5wYWdlcyA9IHtcbiAgICAgIGhvbWU6IG5ldyBIb21lKCksXG4gICAgICBhYm91dDogbmV3IEFib3V0KCksXG4gICAgfVxuXG4gICAgdGhpcy5wYWdlID0gdGhpcy5wYWdlc1t0aGlzLnRlbXBsYXRlXVxuICAgIHRoaXMucGFnZS5jcmVhdGUoKVxuICAgIHRoaXMucGFnZS5zaG93KClcbiAgfVxuXG4gIGFzeW5jIG9uQ2hhbmdlICh1cmwpIHtcbiAgICB0aGlzLnBhZ2UuaGlkZSgpXG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IHdpbmRvdy5mZXRjaCh1cmwpXG5cbiAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgY29uc3QgbmV4dFBhZ2UgPSBhd2FpdCByZXF1ZXN0LnRleHQoKVxuXG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZGl2LmlubmVySFRNTCA9IG5leHRQYWdlXG5cbiAgICAgIGNvbnN0IGRpdkNvbnRlbnQgPSBkaXYucXVlcnlTZWxlY3RvcignLmNvbnRlbnQnKVxuICAgICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZSgnZGF0YS10ZW1wbGF0ZScsIGRpdkNvbnRlbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRlbXBsYXRlJykpXG4gICAgICB0aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gZGl2Q29udGVudC5pbm5lckhUTUxcblxuICAgICAgdGhpcy5wYWdlLmNyZWF0ZSgpXG4gICAgICB0aGlzLnBhZ2Uuc2hvdygpXG4gICAgICB0aGlzLmFkZExpbmtMaXN0ZW5lcnMoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnRGV1IHBhdSwgYml4byEhJylcbiAgICB9XG4gIH1cblxuICBhZGRMaW5rTGlzdGVuZXJzICgpIHtcbiAgICBjb25zdCBsaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKVxuXG4gICAgZWFjaChsaW5rcywgbGluayA9PiB7XG4gICAgICBsaW5rLm9uY2xpY2sgPSBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICBjb25zdCB7IGhyZWYgfSA9IGxpbmtcbiAgICAgICAgdGhpcy5vbkNoYW5nZShocmVmKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGUgKCkge1xuICAgIGlmICh0aGlzLnBhZ2UgJiYgdGhpcy5wYWdlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5wYWdlLnVwZGF0ZSgpXG4gICAgfVxuICAgIHRoaXMuZnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlLmJpbmQodGhpcykpXG4gIH1cbn1cblxuLyogZXNsaW50IG5vLW5ldzogXCJvZmZcIiAqL1xubmV3IEFwcCgpXG4iLCJpbXBvcnQgUGFnZSBmcm9tICdjbGFzc2VzL1BhZ2UnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFib3V0IGV4dGVuZHMgUGFnZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcih7XG4gICAgICBpZDogJ2Fib3V0JyxcbiAgICAgIGVsZW1lbnQ6ICcuYWJvdXQnLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgd3JhcHBlcjogJy5hYm91dF9fd3JhcHBlcicsXG4gICAgICAgIG5hdmlnYXRpb246ICcubmF2aWdhdGlvbicsXG4gICAgICAgIHRpdGxlOiAnLmFib3V0X190aXRsZSdcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG4iLCJpbXBvcnQgUGFnZSBmcm9tICdjbGFzc2VzL1BhZ2UnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhvbWUgZXh0ZW5kcyBQYWdlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIGlkOiAnaG9tZScsXG4gICAgICBlbGVtZW50OiAnLmhvbWUnLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgLy8gbmF2aWdhdGlvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5hdicpLFxuICAgICAgICB3cmFwcGVyOiAnLmhvbWVfX3RpdGxlc19fd3JhcHBlcicsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNyZWF0ZSAoKSB7XG4gICAgc3VwZXIuY3JlYXRlKClcbiAgfVxufVxuIiwiaW1wb3J0IGVhY2ggZnJvbSAnbG9kYXNoL2VhY2gnXG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdCAoeyBlbGVtZW50LCBleHByZXNzaW9uID0gJyAnLCBhcHBlbmQgPSB0cnVlIH0pIHtcbiAgY29uc3Qgd29yZHMgPSBzcGxpdFRleHQoZWxlbWVudC5pbm5lckhUTUwudG9TdHJpbmcoKS50cmltKCksIGV4cHJlc3Npb24pXG5cbiAgbGV0IGlubmVySFRNTCA9ICcnXG5cbiAgZWFjaCh3b3JkcywgbGluZSA9PiB7XG4gICAgaWYgKGxpbmUuaW5kZXhPZignPGJyPicpID4gLTEpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gbGluZS5zcGxpdCgnPGJyPicpXG5cbiAgICAgIGVhY2gobGluZXMsIChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgICBpbm5lckhUTUwgKz0gKGluZGV4ID4gMCkgPyAnPGJyPicgKyBwYXJzZUxpbmUobGluZSkgOiBwYXJzZUxpbmUobGluZSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGlubmVySFRNTCArPSBwYXJzZUxpbmUobGluZSlcbiAgICB9XG4gIH0pXG5cbiAgZWxlbWVudC5pbm5lckhUTUwgPSBpbm5lckhUTUxcblxuICBjb25zdCBzcGFucyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3BhbicpXG5cbiAgaWYgKGFwcGVuZCkge1xuICAgIGVhY2goc3BhbnMsIHNwYW4gPT4ge1xuICAgICAgY29uc3QgaXNTaW5nbGVMZXR0ZXIgPSBzcGFuLnRleHRDb250ZW50Lmxlbmd0aCA9PT0gMVxuICAgICAgY29uc3QgaXNOb3RFbXB0eSA9IHNwYW4uaW5uZXJIVE1MLnRyaW0oKSAhPT0gJydcbiAgICAgIGNvbnN0IGlzTm90QW5kQ2hhcmFjdGVyID0gc3Bhbi50ZXh0Q29udGVudCAhPT0gJyYnXG4gICAgICBjb25zdCBpc05vdERhc2hDaGFyYWN0ZXIgPSBzcGFuLnRleHRDb250ZW50ICE9PSAnLSdcblxuICAgICAgaWYgKGlzU2luZ2xlTGV0dGVyICYmIGlzTm90RW1wdHkgJiYgaXNOb3RBbmRDaGFyYWN0ZXIgJiYgaXNOb3REYXNoQ2hhcmFjdGVyKSB7XG4gICAgICAgIHNwYW4uaW5uZXJIVE1MID0gYCR7c3Bhbi50ZXh0Q29udGVudH0mbmJzcDtgXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBzcGFuc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlIChzcGFucykge1xuICBjb25zdCBsaW5lcyA9IFtdXG4gIGxldCB3b3JkcyA9IFtdXG5cbiAgbGV0IHBvc2l0aW9uID0gc3BhbnNbMF0ub2Zmc2V0VG9wXG5cbiAgZWFjaChzcGFucywgKHNwYW4sIGluZGV4KSA9PiB7XG4gICAgaWYgKHNwYW4ub2Zmc2V0VG9wID09PSBwb3NpdGlvbikge1xuICAgICAgd29yZHMucHVzaChzcGFuKVxuICAgIH1cblxuICAgIGlmIChzcGFuLm9mZnNldFRvcCAhPT0gcG9zaXRpb24pIHtcbiAgICAgIGxpbmVzLnB1c2god29yZHMpXG5cbiAgICAgIHdvcmRzID0gW11cbiAgICAgIHdvcmRzLnB1c2goc3BhbilcblxuICAgICAgcG9zaXRpb24gPSBzcGFuLm9mZnNldFRvcFxuICAgIH1cblxuICAgIGlmIChpbmRleCArIDEgPT09IHNwYW5zLmxlbmd0aCkge1xuICAgICAgbGluZXMucHVzaCh3b3JkcylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGxpbmVzXG59XG5cbmZ1bmN0aW9uIHNwbGl0VGV4dCAodGV4dCwgZXhwcmVzc2lvbikge1xuICBjb25zdCBzcGxpdHMgPSB0ZXh0LnNwbGl0KCc8YnI+JylcblxuICBsZXQgd29yZHMgPSBbXVxuXG4gIGVhY2goc3BsaXRzLCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICB3b3Jkcy5wdXNoKCc8YnI+JylcbiAgICB9XG5cbiAgICB3b3JkcyA9IHdvcmRzLmNvbmNhdChpdGVtLnNwbGl0KGV4cHJlc3Npb24pKVxuXG4gICAgbGV0IGlzTGluayA9IGZhbHNlXG4gICAgbGV0IGxpbmsgPSAnJ1xuXG4gICAgY29uc3QgaW5uZXJIVE1MID0gW11cblxuICAgIGVhY2god29yZHMsIHdvcmQgPT4ge1xuICAgICAgaWYgKCFpc0xpbmsgJiYgKHdvcmQuaW5jbHVkZXMoJzxhJykgfHwgd29yZC5pbmNsdWRlcygnPHN0cm9uZycpKSkge1xuICAgICAgICBsaW5rID0gJydcblxuICAgICAgICBpc0xpbmsgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xpbmspIHtcbiAgICAgICAgbGluayArPSBgICR7d29yZH1gXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xpbmsgJiYgKHdvcmQuaW5jbHVkZXMoJy9hPicpIHx8IHdvcmQuaW5jbHVkZXMoJy9zdHJvbmc+JykpKSB7XG4gICAgICAgIGlubmVySFRNTC5wdXNoKGxpbmspXG5cbiAgICAgICAgbGluayA9ICcnXG4gICAgICB9XG5cbiAgICAgIGlmICghaXNMaW5rICYmIGxpbmsgPT09ICcnKSB7XG4gICAgICAgIGlubmVySFRNTC5wdXNoKHdvcmQpXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xpbmsgJiYgKHdvcmQuaW5jbHVkZXMoJy9hPicpIHx8IHdvcmQuaW5jbHVkZXMoJy9zdHJvbmc+JykpKSB7XG4gICAgICAgIGlzTGluayA9IGZhbHNlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHdvcmRzID0gaW5uZXJIVE1MXG4gIH0pXG5cbiAgcmV0dXJuIHdvcmRzXG59XG5cbmZ1bmN0aW9uIHBhcnNlTGluZSAobGluZSkge1xuICBpZiAobGluZSA9PT0gJycpIHtcbiAgICByZXR1cm4gbGluZVxuICB9IGVsc2UgaWYgKGxpbmUgPT09ICcgJykge1xuICAgIHJldHVybiAnJm5ic3A7J1xuICB9IGVsc2Uge1xuICAgIGxpbmUgPSBsaW5lLnRyaW0oKVxuXG4gICAgcmV0dXJuIChsaW5lID09PSAnPGJyPicpID8gJzxicj4nIDogYDxzcGFuPiR7bGluZX08L3NwYW4+YCArICgobGluZS5sZW5ndGggPiAxKSA/ICcgJyA6ICcnKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBhbnNpSFRNTFxuXG4vLyBSZWZlcmVuY2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hbnNpLXJlZ2V4XG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS9cblxudmFyIF9kZWZDb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ2ZmZicsICcwMDAnXSwgLy8gW0ZPUkVHUk9VRF9DT0xPUiwgQkFDS0dST1VORF9DT0xPUl1cbiAgYmxhY2s6ICcwMDAnLFxuICByZWQ6ICdmZjAwMDAnLFxuICBncmVlbjogJzIwOTgwNScsXG4gIHllbGxvdzogJ2U4YmYwMycsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgY3lhbjogJzAwZmZlZScsXG4gIGxpZ2h0Z3JleTogJ2YwZjBmMCcsXG4gIGRhcmtncmV5OiAnODg4J1xufVxudmFyIF9zdHlsZXMgPSB7XG4gIDMwOiAnYmxhY2snLFxuICAzMTogJ3JlZCcsXG4gIDMyOiAnZ3JlZW4nLFxuICAzMzogJ3llbGxvdycsXG4gIDM0OiAnYmx1ZScsXG4gIDM1OiAnbWFnZW50YScsXG4gIDM2OiAnY3lhbicsXG4gIDM3OiAnbGlnaHRncmV5J1xufVxudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLCAvLyBkaW1cbiAgJzMnOiAnPGk+JywgLy8gaXRhbGljXG4gICc0JzogJzx1PicsIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJywgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn1cbnZhciBfY2xvc2VUYWdzID0ge1xuICAnMjMnOiAnPC9pPicsIC8vIHJlc2V0IGl0YWxpY1xuICAnMjQnOiAnPC91PicsIC8vIHJlc2V0IHVuZGVyc2NvcmVcbiAgJzI5JzogJzwvZGVsPicgLy8gcmVzZXQgZGVsZXRlXG59XG5cbjtbMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nXG59KVxuXG4vKipcbiAqIENvbnZlcnRzIHRleHQgd2l0aCBBTlNJIGNvbG9yIGNvZGVzIHRvIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBhbnNpSFRNTCAodGV4dCkge1xuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXG4gIGlmICghX3JlZ0FOU0kudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvLyBDYWNoZSBvcGVuZWQgc2VxdWVuY2UuXG4gIHZhciBhbnNpQ29kZXMgPSBbXVxuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKW0vZywgZnVuY3Rpb24gKG1hdGNoLCBzZXEpIHtcbiAgICB2YXIgb3QgPSBfb3BlblRhZ3Nbc2VxXVxuICAgIGlmIChvdCkge1xuICAgICAgLy8gSWYgY3VycmVudCBzZXF1ZW5jZSBoYXMgYmVlbiBvcGVuZWQsIGNsb3NlIGl0LlxuICAgICAgaWYgKCEhfmFuc2lDb2Rlcy5pbmRleE9mKHNlcSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1ib29sZWFuLWNhc3RcbiAgICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICAgIHJldHVybiAnPC9zcGFuPidcbiAgICAgIH1cbiAgICAgIC8vIE9wZW4gdGFnLlxuICAgICAgYW5zaUNvZGVzLnB1c2goc2VxKVxuICAgICAgcmV0dXJuIG90WzBdID09PSAnPCcgPyBvdCA6ICc8c3BhbiBzdHlsZT1cIicgKyBvdCArICc7XCI+J1xuICAgIH1cblxuICAgIHZhciBjdCA9IF9jbG9zZVRhZ3Nbc2VxXVxuICAgIGlmIChjdCkge1xuICAgICAgLy8gUG9wIHNlcXVlbmNlXG4gICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgIHJldHVybiBjdFxuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfSlcblxuICAvLyBNYWtlIHN1cmUgdGFncyBhcmUgY2xvc2VkLlxuICB2YXIgbCA9IGFuc2lDb2Rlcy5sZW5ndGhcbiAgOyhsID4gMCkgJiYgKHJldCArPSBBcnJheShsICsgMSkuam9pbignPC9zcGFuPicpKVxuXG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBDdXN0b21pemUgY29sb3JzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyByZWZlcmVuY2UgdG8gX2RlZkNvbG9yc1xuICovXG5hbnNpSFRNTC5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gIGlmICh0eXBlb2YgY29sb3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignYGNvbG9yc2AgcGFyYW1ldGVyIG11c3QgYmUgYW4gT2JqZWN0LicpXG4gIH1cblxuICB2YXIgX2ZpbmFsQ29sb3JzID0ge31cbiAgZm9yICh2YXIga2V5IGluIF9kZWZDb2xvcnMpIHtcbiAgICB2YXIgaGV4ID0gY29sb3JzLmhhc093blByb3BlcnR5KGtleSkgPyBjb2xvcnNba2V5XSA6IG51bGxcbiAgICBpZiAoIWhleCkge1xuICAgICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICgncmVzZXQnID09PSBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBbaGV4XVxuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhleCkgfHwgaGV4Lmxlbmd0aCA9PT0gMCB8fCBoZXguc29tZShmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGggIT09ICdzdHJpbmcnXG4gICAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYW4gQXJyYXkgYW5kIGVhY2ggaXRlbSBjb3VsZCBvbmx5IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICAgIH1cbiAgICAgIHZhciBkZWZIZXhDb2xvciA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgaWYgKCFoZXhbMF0pIHtcbiAgICAgICAgaGV4WzBdID0gZGVmSGV4Q29sb3JbMF1cbiAgICAgIH1cbiAgICAgIGlmIChoZXgubGVuZ3RoID09PSAxIHx8ICFoZXhbMV0pIHtcbiAgICAgICAgaGV4ID0gW2hleFswXV1cbiAgICAgICAgaGV4LnB1c2goZGVmSGV4Q29sb3JbMV0pXG4gICAgICB9XG5cbiAgICAgIGhleCA9IGhleC5zbGljZSgwLCAyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgfVxuICAgIF9maW5hbENvbG9yc1trZXldID0gaGV4XG4gIH1cbiAgX3NldFRhZ3MoX2ZpbmFsQ29sb3JzKVxufVxuXG4vKipcbiAqIFJlc2V0IGNvbG9ycy5cbiAqL1xuYW5zaUhUTUwucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIF9zZXRUYWdzKF9kZWZDb2xvcnMpXG59XG5cbi8qKlxuICogRXhwb3NlIHRhZ3MsIGluY2x1ZGluZyBvcGVuIGFuZCBjbG9zZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmFuc2lIVE1MLnRhZ3MgPSB7fVxuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnb3BlbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9vcGVuVGFncyB9XG4gIH0pXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnY2xvc2UnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY2xvc2VUYWdzIH1cbiAgfSlcbn0gZWxzZSB7XG4gIGFuc2lIVE1MLnRhZ3Mub3BlbiA9IF9vcGVuVGFnc1xuICBhbnNpSFRNTC50YWdzLmNsb3NlID0gX2Nsb3NlVGFnc1xufVxuXG5mdW5jdGlvbiBfc2V0VGFncyAoY29sb3JzKSB7XG4gIC8vIHJlc2V0IGFsbFxuICBfb3BlblRhZ3NbJzAnXSA9ICdmb250LXdlaWdodDpub3JtYWw7b3BhY2l0eToxO2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzBdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzFdXG4gIC8vIGludmVyc2VcbiAgX29wZW5UYWdzWyc3J10gPSAnY29sb3I6IycgKyBjb2xvcnMucmVzZXRbMV0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMF1cbiAgLy8gZGFyayBncmV5XG4gIF9vcGVuVGFnc1snOTAnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5kYXJrZ3JleVxuXG4gIGZvciAodmFyIGNvZGUgaW4gX3N0eWxlcykge1xuICAgIHZhciBjb2xvciA9IF9zdHlsZXNbY29kZV1cbiAgICB2YXIgb3JpQ29sb3IgPSBjb2xvcnNbY29sb3JdIHx8ICcwMDAnXG4gICAgX29wZW5UYWdzW2NvZGVdID0gJ2NvbG9yOiMnICsgb3JpQ29sb3JcbiAgICBjb2RlID0gcGFyc2VJbnQoY29kZSlcbiAgICBfb3BlblRhZ3NbKGNvZGUgKyAxMCkudG9TdHJpbmcoKV0gPSAnYmFja2dyb3VuZDojJyArIG9yaUNvbG9yXG4gIH1cbn1cblxuYW5zaUhUTUwucmVzZXQoKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8qIVxuICogQ1NTUGx1Z2luIDMuOC4wXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ3NhcCwgX2dldFByb3BlcnR5LCBfbnVtRXhwLCBfbnVtV2l0aFVuaXRFeHAsIGdldFVuaXQsIF9pc1N0cmluZywgX2lzVW5kZWZpbmVkLCBfcmVuZGVyQ29tcGxleFN0cmluZywgX3JlbEV4cCwgX2ZvckVhY2hOYW1lLCBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5LCBfY29sb3JTdHJpbmdGaWx0ZXIsIF9jaGVja1BsdWdpbiwgX3JlcGxhY2VSYW5kb20sIF9wbHVnaW5zLCBHU0NhY2hlLCBQcm9wVHdlZW4sIF9jb25maWcsIF90aWNrZXIsIF9yb3VuZCwgX21pc3NpbmdQbHVnaW4sIF9nZXRTZXR0ZXIsIF9nZXRDYWNoZSwgX2NvbG9yRXhwLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSAvL2ZvciB0aGUgY29tbWVudGVkLW91dCBjbGFzc05hbWUgZmVhdHVyZS5cbn0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5cbnZhciBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX3BsdWdpbkluaXR0ZWQsXG4gICAgX3RlbXBEaXYsXG4gICAgX3RlbXBEaXZTdHlsZXIsXG4gICAgX3JlY2VudFNldHRlclBsdWdpbixcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF90cmFuc2Zvcm1Qcm9wcyA9IHt9LFxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX2F0YW4yID0gTWF0aC5hdGFuMixcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcbiAgICBfaG9yaXpvbnRhbEV4cCA9IC8oPzpsZWZ0fHJpZ2h0fHdpZHRofG1hcmdpbnxwYWRkaW5nfHgpL2ksXG4gICAgX2NvbXBsZXhFeHAgPSAvW1xccyxcXChdXFxTLyxcbiAgICBfcHJvcGVydHlBbGlhc2VzID0ge1xuICBhdXRvQWxwaGE6IFwib3BhY2l0eSx2aXNpYmlsaXR5XCIsXG4gIHNjYWxlOiBcInNjYWxlWCxzY2FsZVlcIixcbiAgYWxwaGE6IFwib3BhY2l0eVwiXG59LFxuICAgIF9yZW5kZXJDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wV2l0aEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJQcm9wV2l0aEVuZChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID09PSAxID8gZGF0YS5lIDogTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmcgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmcocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51IDogZGF0YS5iLCBkYXRhKTtcbn0sXG4gICAgLy9pZiB1bml0cyBjaGFuZ2UsIHdlIG5lZWQgYSB3YXkgdG8gcmVuZGVyIHRoZSBvcmlnaW5hbCB1bml0L3ZhbHVlIHdoZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nIChyYXRpbzowKVxuX3JlbmRlclJvdW5kZWRDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlclJvdW5kZWRDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEucyArIGRhdGEuYyAqIHJhdGlvO1xuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgfn4odmFsdWUgKyAodmFsdWUgPCAwID8gLS41IDogLjUpKSArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyAhPT0gMSA/IGRhdGEuYiA6IGRhdGEuZSwgZGF0YSk7XG59LFxuICAgIF9zZXR0ZXJDU1NTdHlsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NTdHlsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NQcm9wKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbn0sXG4gICAgX3NldHRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlID0gZnVuY3Rpb24gX3NldHRlclNjYWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXAuc2NhbGVYID0gdGFyZ2V0Ll9nc2FwLnNjYWxlWSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclNjYWxlV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICBjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSB2YWx1ZTtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGVbcHJvcGVydHldID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXG4gICAgX3N1cHBvcnRzM0QsXG4gICAgX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCh0eXBlLCBucykge1xuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoKG5zIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKS5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgc2VydmVycyBzd2FwIGluIGh0dHBzIGZvciBodHRwIGluIHRoZSBuYW1lc3BhY2Ugd2hpY2ggY2FuIGJyZWFrIHRoaW5ncywgbWFraW5nIFwic3R5bGVcIiBpbmFjY2Vzc2libGUuXG5cbiAgcmV0dXJuIGUuc3R5bGUgPyBlIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgZW52aXJvbm1lbnRzIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHdoZW4gY3JlYXRlZCB3aXRoIGEgbmFtZXNwYWNlIGluIHdoaWNoIGNhc2Ugd2UgZGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgY3JlYXRlRWxlbWVudCgpIHRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZS4gQWxzbyBub3RlIHRoYXQgd2hlbiBHU0FQIGlzIGVtYmVkZGVkIGRpcmVjdGx5IGluc2lkZSBhbiBTVkcgZmlsZSwgY3JlYXRlRWxlbWVudCgpIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgc3R5bGUgb2JqZWN0IGluIEZpcmVmb3ggKHNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIwMjE1LXByb2JsZW0tdXNpbmctdHdlZW5tYXgtaW4tc3RhbmRhbG9uZS1zZWxmLWNvbnRhaW5pbmctc3ZnLWZpbGUtZXJyLWNhbm5vdC1zZXQtcHJvcGVydHktY3NzdGV4dC1vZi11bmRlZmluZWQvKS5cbn0sXG4gICAgX2dldENvbXB1dGVkUHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBza2lwUHJlZml4RmFsbGJhY2spIHtcbiAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICByZXR1cm4gY3NbcHJvcGVydHldIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSkgfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkgfHwgIXNraXBQcmVmaXhGYWxsYmFjayAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHkpIHx8IHByb3BlcnR5LCAxKSB8fCBcIlwiOyAvL2NzcyB2YXJpYWJsZXMgbWF5IG5vdCBuZWVkIGNhcHMgc3dhcHBlZCBvdXQgZm9yIGRhc2hlcyBhbmQgbG93ZXJjYXNlLlxufSxcbiAgICBfcHJlZml4ZXMgPSBcIk8sTW96LG1zLE1zLFdlYmtpdFwiLnNwbGl0KFwiLFwiKSxcbiAgICBfY2hlY2tQcm9wUHJlZml4ID0gZnVuY3Rpb24gX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSwgZWxlbWVudCwgcHJlZmVyUHJlZml4KSB7XG4gIHZhciBlID0gZWxlbWVudCB8fCBfdGVtcERpdixcbiAgICAgIHMgPSBlLnN0eWxlLFxuICAgICAgaSA9IDU7XG5cbiAgaWYgKHByb3BlcnR5IGluIHMgJiYgIXByZWZlclByZWZpeCkge1xuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIHByb3BlcnR5ID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSk7XG5cbiAgd2hpbGUgKGktLSAmJiAhKF9wcmVmaXhlc1tpXSArIHByb3BlcnR5IGluIHMpKSB7fVxuXG4gIHJldHVybiBpIDwgMCA/IG51bGwgOiAoaSA9PT0gMyA/IFwibXNcIiA6IGkgPj0gMCA/IF9wcmVmaXhlc1tpXSA6IFwiXCIpICsgcHJvcGVydHk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBfd2luLmRvY3VtZW50O1xuICAgIF9kb2NFbGVtZW50ID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSB8fCB7XG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICAgIF90ZW1wRGl2U3R5bGVyID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgX3RyYW5zZm9ybVByb3AgPSBfY2hlY2tQcm9wUHJlZml4KF90cmFuc2Zvcm1Qcm9wKTtcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcbiAgICBfdGVtcERpdi5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXItd2lkdGg6MDtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmc6MFwiOyAvL21ha2Ugc3VyZSB0byBvdmVycmlkZSBjZXJ0YWluIHByb3BlcnRpZXMgdGhhdCBtYXkgY29udGFtaW5hdGUgbWVhc3VyZW1lbnRzLCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBvdmVycmVhY2hpbmcgc3R5bGUgc2hlZXRzLlxuXG4gICAgX3N1cHBvcnRzM0QgPSAhIV9jaGVja1Byb3BQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKTtcbiAgICBfcGx1Z2luSW5pdHRlZCA9IDE7XG4gIH1cbn0sXG4gICAgX2dldEJCb3hIYWNrID0gZnVuY3Rpb24gX2dldEJCb3hIYWNrKHN3YXBJZlBvc3NpYmxlKSB7XG4gIC8vd29ya3MgYXJvdW5kIGlzc3VlcyBpbiBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHRoYXQgZG9uJ3QgY29ycmVjdGx5IHJlcG9ydCBnZXRCQm94KCkgb24gU1ZHIGVsZW1lbnRzIGluc2lkZSBhIDxkZWZzPiBlbGVtZW50IGFuZC9vciA8bWFzaz4uIFdlIHRyeSBjcmVhdGluZyBhbiBTVkcsIGFkZGluZyBpdCB0byB0aGUgZG9jdW1lbnRFbGVtZW50IGFuZCB0b3NzIHRoZSBlbGVtZW50IGluIHRoZXJlIHNvIHRoYXQgaXQncyBkZWZpbml0ZWx5IHBhcnQgb2YgdGhlIHJlbmRlcmluZyB0cmVlLCB0aGVuIGdyYWIgdGhlIGJib3ggYW5kIGlmIGl0IHdvcmtzLCB3ZSBhY3R1YWxseSBzd2FwIG91dCB0aGUgb3JpZ2luYWwgZ2V0QkJveCgpIG1ldGhvZCBmb3Igb3VyIG93biB0aGF0IGRvZXMgdGhlc2UgZXh0cmEgc3RlcHMgd2hlbmV2ZXIgZ2V0QkJveCBpcyBuZWVkZWQuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgcGVyZm9ybWFuY2UgaXMgb3B0aW1hbCAob25seSBkbyBhbGwgdGhlc2UgZXh0cmEgc3RlcHMgd2hlbiBhYnNvbHV0ZWx5IG5lY2Vzc2FyeS4uLm1vc3QgZWxlbWVudHMgZG9uJ3QgbmVlZCBpdCkuXG4gIHZhciBzdmcgPSBfY3JlYXRlRWxlbWVudChcInN2Z1wiLCB0aGlzLm93bmVyU1ZHRWxlbWVudCAmJiB0aGlzLm93bmVyU1ZHRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSB8fCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpLFxuICAgICAgb2xkUGFyZW50ID0gdGhpcy5wYXJlbnROb2RlLFxuICAgICAgb2xkU2libGluZyA9IHRoaXMubmV4dFNpYmxpbmcsXG4gICAgICBvbGRDU1MgPSB0aGlzLnN0eWxlLmNzc1RleHQsXG4gICAgICBiYm94O1xuXG4gIF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHN2Zyk7XG5cbiAgc3ZnLmFwcGVuZENoaWxkKHRoaXMpO1xuICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgaWYgKHN3YXBJZlBvc3NpYmxlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJib3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICAgIHRoaXMuX2dzYXBCQm94ID0gdGhpcy5nZXRCQm94OyAvL3N0b3JlIHRoZSBvcmlnaW5hbFxuXG4gICAgICB0aGlzLmdldEJCb3ggPSBfZ2V0QkJveEhhY2s7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSBlbHNlIGlmICh0aGlzLl9nc2FwQkJveCkge1xuICAgIGJib3ggPSB0aGlzLl9nc2FwQkJveCgpO1xuICB9XG5cbiAgaWYgKG9sZFBhcmVudCkge1xuICAgIGlmIChvbGRTaWJsaW5nKSB7XG4gICAgICBvbGRQYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIG9sZFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgX2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnKTtcblxuICB0aGlzLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gIHJldHVybiBiYm94O1xufSxcbiAgICBfZ2V0QXR0cmlidXRlRmFsbGJhY2tzID0gZnVuY3Rpb24gX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIGF0dHJpYnV0ZXNBcnJheSkge1xuICB2YXIgaSA9IGF0dHJpYnV0ZXNBcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9nZXRCQm94ID0gZnVuY3Rpb24gX2dldEJCb3godGFyZ2V0KSB7XG4gIHZhciBib3VuZHM7XG5cbiAgdHJ5IHtcbiAgICBib3VuZHMgPSB0YXJnZXQuZ2V0QkJveCgpOyAvL0ZpcmVmb3ggdGhyb3dzIGVycm9ycyBpZiB5b3UgdHJ5IGNhbGxpbmcgZ2V0QkJveCgpIG9uIGFuIFNWRyBlbGVtZW50IHRoYXQncyBub3QgcmVuZGVyZWQgKGxpa2UgaW4gYSA8c3ltYm9sPiBvciA8ZGVmcz4pLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MTIxMThcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveEhhY2suY2FsbCh0YXJnZXQsIHRydWUpO1xuICB9XG5cbiAgYm91bmRzICYmIChib3VuZHMud2lkdGggfHwgYm91bmRzLmhlaWdodCkgfHwgdGFyZ2V0LmdldEJCb3ggPT09IF9nZXRCQm94SGFjayB8fCAoYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKSk7IC8vc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSBtaXNyZXBvcnQgdGhlIGJvdW5kcyBpZiB0aGUgZWxlbWVudCBoYXMgemVybyB3aWR0aCBhbmQgaGVpZ2h0IChpdCBqdXN0IGFzc3VtZXMgaXQncyBhdCB4OjAsIHk6MCksIHRodXMgd2UgbmVlZCB0byBtYW51YWxseSBncmFiIHRoZSBwb3NpdGlvbiBpbiB0aGF0IGNhc2UuXG5cbiAgcmV0dXJuIGJvdW5kcyAmJiAhYm91bmRzLndpZHRoICYmICFib3VuZHMueCAmJiAhYm91bmRzLnkgPyB7XG4gICAgeDogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ4XCIsIFwiY3hcIiwgXCJ4MVwiXSkgfHwgMCxcbiAgICB5OiArX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIFtcInlcIiwgXCJjeVwiLCBcInkxXCJdKSB8fCAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9IDogYm91bmRzO1xufSxcbiAgICBfaXNTVkcgPSBmdW5jdGlvbiBfaXNTVkcoZSkge1xuICByZXR1cm4gISEoZS5nZXRDVE0gJiYgKCFlLnBhcmVudE5vZGUgfHwgZS5vd25lclNWR0VsZW1lbnQpICYmIF9nZXRCQm94KGUpKTtcbn0sXG4gICAgLy9yZXBvcnRzIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWRyBvbiB3aGljaCBnZXRCQm94KCkgYWN0dWFsbHkgd29ya3Ncbl9yZW1vdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSkge1xuICAgIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZTtcblxuICAgIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB7XG4gICAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgaWYgKHByb3BlcnR5LnN1YnN0cigwLCAyKSA9PT0gXCJtc1wiIHx8IHByb3BlcnR5LnN1YnN0cigwLCA2KSA9PT0gXCJ3ZWJraXRcIikge1xuICAgICAgICAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHByb3BlcnR5ID0gXCItXCIgKyBwcm9wZXJ0eTtcbiAgICAgIH1cblxuICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQgPSBmdW5jdGlvbiBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGJlZ2lubmluZywgZW5kLCBvbmx5U2V0QXRFbmQpIHtcbiAgdmFyIHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBvbmx5U2V0QXRFbmQgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKTtcbiAgcGx1Z2luLl9wdCA9IHB0O1xuICBwdC5iID0gYmVnaW5uaW5nO1xuICBwdC5lID0gZW5kO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfbm9uQ29udmVydGlibGVVbml0cyA9IHtcbiAgZGVnOiAxLFxuICByYWQ6IDEsXG4gIHR1cm46IDFcbn0sXG4gICAgLy90YWtlcyBhIHNpbmdsZSB2YWx1ZSBsaWtlIDIwcHggYW5kIGNvbnZlcnRzIGl0IHRvIHRoZSB1bml0IHNwZWNpZmllZCwgbGlrZSBcIiVcIiwgcmV0dXJuaW5nIG9ubHkgdGhlIG51bWVyaWMgYW1vdW50LlxuX2NvbnZlcnRUb1VuaXQgPSBmdW5jdGlvbiBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkge1xuICB2YXIgY3VyVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwLFxuICAgICAgY3VyVW5pdCA9ICh2YWx1ZSArIFwiXCIpLnRyaW0oKS5zdWJzdHIoKGN1clZhbHVlICsgXCJcIikubGVuZ3RoKSB8fCBcInB4XCIsXG4gICAgICAvLyBzb21lIGJyb3dzZXJzIGxlYXZlIGV4dHJhIHdoaXRlc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiBDU1MgdmFyaWFibGVzLCBoZW5jZSB0aGUgbmVlZCB0byB0cmltKClcbiAgc3R5bGUgPSBfdGVtcERpdi5zdHlsZSxcbiAgICAgIGhvcml6b250YWwgPSBfaG9yaXpvbnRhbEV4cC50ZXN0KHByb3BlcnR5KSxcbiAgICAgIGlzUm9vdFNWRyA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIsXG4gICAgICBtZWFzdXJlUHJvcGVydHkgPSAoaXNSb290U1ZHID8gXCJjbGllbnRcIiA6IFwib2Zmc2V0XCIpICsgKGhvcml6b250YWwgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiKSxcbiAgICAgIGFtb3VudCA9IDEwMCxcbiAgICAgIHRvUGl4ZWxzID0gdW5pdCA9PT0gXCJweFwiLFxuICAgICAgdG9QZXJjZW50ID0gdW5pdCA9PT0gXCIlXCIsXG4gICAgICBweCxcbiAgICAgIHBhcmVudCxcbiAgICAgIGNhY2hlLFxuICAgICAgaXNTVkc7XG5cbiAgaWYgKHVuaXQgPT09IGN1clVuaXQgfHwgIWN1clZhbHVlIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW3VuaXRdIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW2N1clVuaXRdKSB7XG4gICAgcmV0dXJuIGN1clZhbHVlO1xuICB9XG5cbiAgY3VyVW5pdCAhPT0gXCJweFwiICYmICF0b1BpeGVscyAmJiAoY3VyVmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgXCJweFwiKSk7XG4gIGlzU1ZHID0gdGFyZ2V0LmdldENUTSAmJiBfaXNTVkcodGFyZ2V0KTtcblxuICBpZiAoKHRvUGVyY2VudCB8fCBjdXJVbml0ID09PSBcIiVcIikgJiYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wZXJ0eV0gfHwgfnByb3BlcnR5LmluZGV4T2YoXCJhZGl1c1wiKSkpIHtcbiAgICBweCA9IGlzU1ZHID8gdGFyZ2V0LmdldEJCb3goKVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gOiB0YXJnZXRbbWVhc3VyZVByb3BlcnR5XTtcbiAgICByZXR1cm4gX3JvdW5kKHRvUGVyY2VudCA/IGN1clZhbHVlIC8gcHggKiBhbW91bnQgOiBjdXJWYWx1ZSAvIDEwMCAqIHB4KTtcbiAgfVxuXG4gIHN0eWxlW2hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9IGFtb3VudCArICh0b1BpeGVscyA/IGN1clVuaXQgOiB1bml0KTtcbiAgcGFyZW50ID0gfnByb3BlcnR5LmluZGV4T2YoXCJhZGl1c1wiKSB8fCB1bml0ID09PSBcImVtXCIgJiYgdGFyZ2V0LmFwcGVuZENoaWxkICYmICFpc1Jvb3RTVkcgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZTtcblxuICBpZiAoaXNTVkcpIHtcbiAgICBwYXJlbnQgPSAodGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCB8fCB7fSkucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gX2RvYyB8fCAhcGFyZW50LmFwcGVuZENoaWxkKSB7XG4gICAgcGFyZW50ID0gX2RvYy5ib2R5O1xuICB9XG5cbiAgY2FjaGUgPSBwYXJlbnQuX2dzYXA7XG5cbiAgaWYgKGNhY2hlICYmIHRvUGVyY2VudCAmJiBjYWNoZS53aWR0aCAmJiBob3Jpem9udGFsICYmIGNhY2hlLnRpbWUgPT09IF90aWNrZXIudGltZSkge1xuICAgIHJldHVybiBfcm91bmQoY3VyVmFsdWUgLyBjYWNoZS53aWR0aCAqIGFtb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgKHRvUGVyY2VudCB8fCBjdXJVbml0ID09PSBcIiVcIikgJiYgKHN0eWxlLnBvc2l0aW9uID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcInBvc2l0aW9uXCIpKTtcbiAgICBwYXJlbnQgPT09IHRhcmdldCAmJiAoc3R5bGUucG9zaXRpb24gPSBcInN0YXRpY1wiKTsgLy8gbGlrZSBmb3IgYm9yZGVyUmFkaXVzLCBpZiBpdCdzIGEgJSB3ZSBtdXN0IGhhdmUgaXQgcmVsYXRpdmUgdG8gdGhlIHRhcmdldCBpdHNlbGYgYnV0IHRoYXQgbWF5IG5vdCBoYXZlIHBvc2l0aW9uOiByZWxhdGl2ZSBvciBwb3NpdGlvbjogYWJzb2x1dGUgaW4gd2hpY2ggY2FzZSBpdCdkIGdvIHVwIHRoZSBjaGFpbiB1bnRpbCBpdCBmaW5kcyBpdHMgb2Zmc2V0UGFyZW50IChiYWQpLiBwb3NpdGlvbjogc3RhdGljIHByb3RlY3RzIGFnYWluc3QgdGhhdC5cblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChfdGVtcERpdik7XG4gICAgcHggPSBfdGVtcERpdlttZWFzdXJlUHJvcGVydHldO1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChfdGVtcERpdik7XG4gICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICBpZiAoaG9yaXpvbnRhbCAmJiB0b1BlcmNlbnQpIHtcbiAgICAgIGNhY2hlID0gX2dldENhY2hlKHBhcmVudCk7XG4gICAgICBjYWNoZS50aW1lID0gX3RpY2tlci50aW1lO1xuICAgICAgY2FjaGUud2lkdGggPSBwYXJlbnRbbWVhc3VyZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX3JvdW5kKHRvUGl4ZWxzID8gcHggKiBjdXJWYWx1ZSAvIGFtb3VudCA6IHB4ICYmIGN1clZhbHVlID8gYW1vdW50IC8gcHggKiBjdXJWYWx1ZSA6IDApO1xufSxcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gIHZhciB2YWx1ZTtcbiAgX3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG5cbiAgaWYgKHByb3BlcnR5IGluIF9wcm9wZXJ0eUFsaWFzZXMgJiYgcHJvcGVydHkgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICBwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldO1xuXG4gICAgaWYgKH5wcm9wZXJ0eS5pbmRleE9mKFwiLFwiKSkge1xuICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5zcGxpdChcIixcIilbMF07XG4gICAgfVxuICB9XG5cbiAgaWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wZXJ0eV0gJiYgcHJvcGVydHkgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICB2YWx1ZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHVuY2FjaGUpO1xuICAgIHZhbHVlID0gcHJvcGVydHkgIT09IFwidHJhbnNmb3JtT3JpZ2luXCIgPyB2YWx1ZVtwcm9wZXJ0eV0gOiB2YWx1ZS5zdmcgPyB2YWx1ZS5vcmlnaW4gOiBfZmlyc3RUd29Pbmx5KF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApKSArIFwiIFwiICsgdmFsdWUuek9yaWdpbiArIFwicHhcIjtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV07XG5cbiAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09PSBcImF1dG9cIiB8fCB1bmNhY2hlIHx8IH4odmFsdWUgKyBcIlwiKS5pbmRleE9mKFwiY2FsYyhcIikpIHtcbiAgICAgIHZhbHVlID0gX3NwZWNpYWxQcm9wc1twcm9wZXJ0eV0gJiYgX3NwZWNpYWxQcm9wc1twcm9wZXJ0eV0odGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCkgfHwgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkgfHwgX2dldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IChwcm9wZXJ0eSA9PT0gXCJvcGFjaXR5XCIgPyAxIDogMCk7IC8vIG5vdGU6IHNvbWUgYnJvd3NlcnMsIGxpa2UgRmlyZWZveCwgZG9uJ3QgcmVwb3J0IGJvcmRlclJhZGl1cyBjb3JyZWN0bHkhIEluc3RlYWQsIGl0IG9ubHkgcmVwb3J0cyBldmVyeSBjb3JuZXIgbGlrZSAgYm9yZGVyVG9wTGVmdFJhZGl1c1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bml0ICYmICF+KHZhbHVlICsgXCJcIikudHJpbSgpLmluZGV4T2YoXCIgXCIpID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpICsgdW5pdCA6IHZhbHVlO1xufSxcbiAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nID0gZnVuY3Rpb24gX3R3ZWVuQ29tcGxleENTU1N0cmluZyh0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQpIHtcbiAgLy9ub3RlOiB3ZSBjYWxsIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbChwbHVnaW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0ID09PSBcIm5vbmVcIikge1xuICAgIC8vIHNvbWUgYnJvd3NlcnMgbGlrZSBTYWZhcmkgYWN0dWFsbHkgUFJFRkVSIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBhbmQgbWlzLXJlcG9ydCB0aGUgdW5wcmVmaXhlZCB2YWx1ZSBsaWtlIGNsaXBQYXRoIChCVUcpLiBJbiBvdGhlciB3b3JkcywgZXZlbiB0aG91Z2ggY2xpcFBhdGggZXhpc3RzIGluIHRoZSBzdHlsZSAoXCJjbGlwUGF0aFwiIGluIHRhcmdldC5zdHlsZSkgYW5kIGl0J3Mgc2V0IGluIHRoZSBDU1MgcHJvcGVybHkgKGFsb25nIHdpdGggLXdlYmtpdC1jbGlwLXBhdGgpLCBTYWZhcmkgcmVwb3J0cyBjbGlwUGF0aCBhcyBcIm5vbmVcIiB3aGVyZWFzIFdlYmtpdENsaXBQYXRoIHJlcG9ydHMgYWNjdXJhdGVseSBsaWtlIFwiZWxsaXBzZSgxMDAlIDAlIGF0IDUwJSAwJSlcIiwgc28gaW4gdGhpcyBjYXNlIHdlIG11c3QgU1dJVENIIHRvIHVzaW5nIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8xODMxMC1jbGlwcGF0aC1kb2VzbnQtd29yay1vbi1pb3MvXG4gICAgdmFyIHAgPSBfY2hlY2tQcm9wUHJlZml4KHByb3AsIHRhcmdldCwgMSksXG4gICAgICAgIHMgPSBwICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcCwgMSk7XG5cbiAgICBpZiAocyAmJiBzICE9PSBzdGFydCkge1xuICAgICAgcHJvcCA9IHA7XG4gICAgICBzdGFydCA9IHM7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSBcImJvcmRlckNvbG9yXCIpIHtcbiAgICAgIHN0YXJ0ID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcImJvcmRlclRvcENvbG9yXCIpOyAvLyBGaXJlZm94IGJ1ZzogYWx3YXlzIHJlcG9ydHMgXCJib3JkZXJDb2xvclwiIGFzIFwiXCIsIHNvIHdlIG11c3QgZmFsbCBiYWNrIHRvIGJvcmRlclRvcENvbG9yLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yNDU4My1ob3ctdG8tcmV0dXJuLWNvbG9ycy10aGF0LWktaGFkLWFmdGVyLXJldmVyc2UvXG4gICAgfVxuICB9XG5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LnN0eWxlLCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZyksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIGEsXG4gICAgICByZXN1bHQsXG4gICAgICBzdGFydFZhbHVlcyxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgY29sb3IsXG4gICAgICBzdGFydFZhbHVlLFxuICAgICAgZW5kVmFsdWUsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIGVuZFVuaXQsXG4gICAgICBzdGFydFVuaXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIGVuZFZhbHVlcztcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoZW5kID09PSBcImF1dG9cIikge1xuICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IGVuZDtcbiAgICBlbmQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHx8IGVuZDtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydDtcbiAgfVxuXG4gIGEgPSBbc3RhcnQsIGVuZF07XG5cbiAgX2NvbG9yU3RyaW5nRmlsdGVyKGEpOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuIElmIGNvbG9ycyBhcmUgZm91bmQsIGl0IHJldHVybnMgdHJ1ZSBhbmQgdGhlbiB3ZSBtdXN0IG1hdGNoIHdoZXJlIHRoZSBjb2xvciBzaG93cyB1cCBvcmRlci13aXNlIGJlY2F1c2UgZm9yIHRoaW5ncyBsaWtlIGJveFNoYWRvdywgc29tZXRpbWVzIHRoZSBicm93c2VyIHByb3ZpZGVzIHRoZSBjb21wdXRlZCB2YWx1ZXMgd2l0aCB0aGUgY29sb3IgRklSU1QsIGJ1dCB0aGUgdXNlciBwcm92aWRlcyBpdCB3aXRoIHRoZSBjb2xvciBMQVNULCBzbyBmbGlwIHRoZW0gaWYgbmVjZXNzYXJ5LiBTYW1lIGZvciBkcm9wLXNoYWRvdygpLlxuXG5cbiAgc3RhcnQgPSBhWzBdO1xuICBlbmQgPSBhWzFdO1xuICBzdGFydFZhbHVlcyA9IHN0YXJ0Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gIGVuZFZhbHVlcyA9IGVuZC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuXG4gIGlmIChlbmRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgd2hpbGUgKHJlc3VsdCA9IF9udW1XaXRoVW5pdEV4cC5leGVjKGVuZCkpIHtcbiAgICAgIGVuZFZhbHVlID0gcmVzdWx0WzBdO1xuICAgICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29sb3IgPSAoY29sb3IgKyAxKSAlIDU7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIiB8fCBjaHVuay5zdWJzdHIoLTUpID09PSBcImhzbGEoXCIpIHtcbiAgICAgICAgY29sb3IgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kVmFsdWUgIT09IChzdGFydFZhbHVlID0gc3RhcnRWYWx1ZXNbbWF0Y2hJbmRleCsrXSB8fCBcIlwiKSkge1xuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSkgfHwgMDtcbiAgICAgICAgc3RhcnRVbml0ID0gc3RhcnRWYWx1ZS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgcmVsYXRpdmUgPSBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwO1xuXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIGVuZFVuaXQgPSBlbmRWYWx1ZS5zdWJzdHIoKGVuZE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIGluZGV4ID0gX251bVdpdGhVbml0RXhwLmxhc3RJbmRleCAtIGVuZFVuaXQubGVuZ3RoO1xuXG4gICAgICAgIGlmICghZW5kVW5pdCkge1xuICAgICAgICAgIC8vaWYgc29tZXRoaW5nIGxpa2UgXCJwZXJzcGVjdGl2ZTozMDBcIiBpcyBwYXNzZWQgaW4gYW5kIHdlIG11c3QgYWRkIGEgdW5pdCB0byB0aGUgZW5kXG4gICAgICAgICAgZW5kVW5pdCA9IGVuZFVuaXQgfHwgX2NvbmZpZy51bml0c1twcm9wXSB8fCBzdGFydFVuaXQ7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IGVuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZCArPSBlbmRVbml0O1xuICAgICAgICAgICAgcHQuZSArPSBlbmRVbml0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQpIHtcbiAgICAgICAgICBzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgfHwgMDtcbiAgICAgICAgfSAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cblxuICAgICAgICBwdC5fcHQgPSB7XG4gICAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgICBwOiBjaHVuayB8fCBtYXRjaEluZGV4ID09PSAxID8gY2h1bmsgOiBcIixcIixcbiAgICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgICBjOiByZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICAgICAgbTogY29sb3IgJiYgY29sb3IgPCA0IHx8IHByb3AgPT09IFwiekluZGV4XCIgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcbiAgfSBlbHNlIHtcbiAgICBwdC5yID0gcHJvcCA9PT0gXCJkaXNwbGF5XCIgJiYgZW5kID09PSBcIm5vbmVcIiA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWU7XG4gIH1cblxuICBfcmVsRXhwLnRlc3QoZW5kKSAmJiAocHQuZSA9IDApOyAvL2lmIHRoZSBlbmQgc3RyaW5nIGNvbnRhaW5zIHJlbGF0aXZlIHZhbHVlcyBvciBkeW5hbWljIHJhbmRvbSguLi4pIHZhbHVlcywgZGVsZXRlIHRoZSBlbmQgaXQgc28gdGhhdCBvbiB0aGUgZmluYWwgcmVuZGVyIHdlIGRvbid0IGFjdHVhbGx5IHNldCBpdCB0byB0aGUgc3RyaW5nIHdpdGggKz0gb3IgLT0gY2hhcmFjdGVycyAoZm9yY2VzIGl0IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCB2YWx1ZSkuXG5cbiAgdGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbChwbHVnaW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGFub3RoZXIgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2tleXdvcmRUb1BlcmNlbnQgPSB7XG4gIHRvcDogXCIwJVwiLFxuICBib3R0b206IFwiMTAwJVwiLFxuICBsZWZ0OiBcIjAlXCIsXG4gIHJpZ2h0OiBcIjEwMCVcIixcbiAgY2VudGVyOiBcIjUwJVwiXG59LFxuICAgIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzID0gZnVuY3Rpb24gX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXModmFsdWUpIHtcbiAgdmFyIHNwbGl0ID0gdmFsdWUuc3BsaXQoXCIgXCIpLFxuICAgICAgeCA9IHNwbGl0WzBdLFxuICAgICAgeSA9IHNwbGl0WzFdIHx8IFwiNTAlXCI7XG5cbiAgaWYgKHggPT09IFwidG9wXCIgfHwgeCA9PT0gXCJib3R0b21cIiB8fCB5ID09PSBcImxlZnRcIiB8fCB5ID09PSBcInJpZ2h0XCIpIHtcbiAgICAvL3RoZSB1c2VyIHByb3ZpZGVkIHRoZW0gaW4gdGhlIHdyb25nIG9yZGVyLCBzbyBmbGlwIHRoZW1cbiAgICB2YWx1ZSA9IHg7XG4gICAgeCA9IHk7XG4gICAgeSA9IHZhbHVlO1xuICB9XG5cbiAgc3BsaXRbMF0gPSBfa2V5d29yZFRvUGVyY2VudFt4XSB8fCB4O1xuICBzcGxpdFsxXSA9IF9rZXl3b3JkVG9QZXJjZW50W3ldIHx8IHk7XG4gIHJldHVybiBzcGxpdC5qb2luKFwiIFwiKTtcbn0sXG4gICAgX3JlbmRlckNsZWFyUHJvcHMgPSBmdW5jdGlvbiBfcmVuZGVyQ2xlYXJQcm9wcyhyYXRpbywgZGF0YSkge1xuICBpZiAoZGF0YS50d2VlbiAmJiBkYXRhLnR3ZWVuLl90aW1lID09PSBkYXRhLnR3ZWVuLl9kdXIpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZGF0YS50LFxuICAgICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgICAgcHJvcHMgPSBkYXRhLnUsXG4gICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICAgICAgICBwcm9wLFxuICAgICAgICBjbGVhclRyYW5zZm9ybXMsXG4gICAgICAgIGk7XG5cbiAgICBpZiAocHJvcHMgPT09IFwiYWxsXCIgfHwgcHJvcHMgPT09IHRydWUpIHtcbiAgICAgIHN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMgPSBwcm9wcy5zcGxpdChcIixcIik7XG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICAgIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcF0pIHtcbiAgICAgICAgICBjbGVhclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICAgIHByb3AgPSBwcm9wID09PSBcInRyYW5zZm9ybU9yaWdpblwiID8gX3RyYW5zZm9ybU9yaWdpblByb3AgOiBfdHJhbnNmb3JtUHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGVhclRyYW5zZm9ybXMpIHtcbiAgICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlLnN2ZyAmJiB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXG4gICAgICAgIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpOyAvLyBmb3JjZSBhbGwgdGhlIGNhY2hlZCB2YWx1ZXMgYmFjayB0byBcIm5vcm1hbFwiL2lkZW50aXR5LCBvdGhlcndpc2UgaWYgdGhlcmUncyBhbm90aGVyIHR3ZWVuIHRoYXQncyBhbHJlYWR5IHNldCB0byByZW5kZXIgdHJhbnNmb3JtcyBvbiB0aGlzIGVsZW1lbnQsIGl0IGNvdWxkIGRpc3BsYXkgdGhlIHdyb25nIHZhbHVlcy5cblxuXG4gICAgICAgIGNhY2hlLnVuY2FjaGUgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICAvLyBub3RlOiBzcGVjaWFsUHJvcHMgc2hvdWxkIHJldHVybiAxIGlmIChhbmQgb25seSBpZikgdGhleSBoYXZlIGEgbm9uLXplcm8gcHJpb3JpdHkuIEl0IGluZGljYXRlcyB3ZSBuZWVkIHRvIHNvcnQgdGhlIGxpbmtlZCBsaXN0LlxuX3NwZWNpYWxQcm9wcyA9IHtcbiAgY2xlYXJQcm9wczogZnVuY3Rpb24gY2xlYXJQcm9wcyhwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIGlmICh0d2Vlbi5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIpIHtcbiAgICAgIHZhciBwdCA9IHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDAsIF9yZW5kZXJDbGVhclByb3BzKTtcbiAgICAgIHB0LnUgPSBlbmRWYWx1ZTtcbiAgICAgIHB0LnByID0gLTEwO1xuICAgICAgcHQudHdlZW4gPSB0d2VlbjtcblxuICAgICAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIC8qIGNsYXNzTmFtZSBmZWF0dXJlIChhYm91dCAwLjRrYiBnemlwcGVkKS5cbiAgLCBjbGFzc05hbWUocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgXHRsZXQgX3JlbmRlckNsYXNzTmFtZSA9IChyYXRpbywgZGF0YSkgPT4ge1xuICBcdFx0XHRkYXRhLmNzcy5yZW5kZXIocmF0aW8sIGRhdGEuY3NzKTtcbiAgXHRcdFx0aWYgKCFyYXRpbyB8fCByYXRpbyA9PT0gMSkge1xuICBcdFx0XHRcdGxldCBpbmxpbmUgPSBkYXRhLnJtdixcbiAgXHRcdFx0XHRcdHRhcmdldCA9IGRhdGEudCxcbiAgXHRcdFx0XHRcdHA7XG4gIFx0XHRcdFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iKTtcbiAgXHRcdFx0XHRmb3IgKHAgaW4gaW5saW5lKSB7XG4gIFx0XHRcdFx0XHRfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0sXG4gIFx0XHRfZ2V0QWxsU3R5bGVzID0gKHRhcmdldCkgPT4ge1xuICBcdFx0XHRsZXQgc3R5bGVzID0ge30sXG4gIFx0XHRcdFx0Y29tcHV0ZWQgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCksXG4gIFx0XHRcdFx0cDtcbiAgXHRcdFx0Zm9yIChwIGluIGNvbXB1dGVkKSB7XG4gIFx0XHRcdFx0aWYgKGlzTmFOKHApICYmIHAgIT09IFwiY3NzVGV4dFwiICYmIHAgIT09IFwibGVuZ3RoXCIpIHtcbiAgXHRcdFx0XHRcdHN0eWxlc1twXSA9IGNvbXB1dGVkW3BdO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0XHRfc2V0RGVmYXVsdHMoc3R5bGVzLCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKSk7XG4gIFx0XHRcdHJldHVybiBzdHlsZXM7XG4gIFx0XHR9LFxuICBcdFx0c3RhcnRDbGFzc0xpc3QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIiksXG4gIFx0XHRzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgXHRcdGNzc1RleHQgPSBzdHlsZS5jc3NUZXh0LFxuICBcdFx0Y2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gIFx0XHRjbGFzc1BUID0gY2FjaGUuY2xhc3NQVCxcbiAgXHRcdGlubGluZVRvUmVtb3ZlQXRFbmQgPSB7fSxcbiAgXHRcdGRhdGEgPSB7dDp0YXJnZXQsIHBsdWdpbjpwbHVnaW4sIHJtdjppbmxpbmVUb1JlbW92ZUF0RW5kLCBiOnN0YXJ0Q2xhc3NMaXN0LCBlOihlbmRWYWx1ZS5jaGFyQXQoMSkgIT09IFwiPVwiKSA/IGVuZFZhbHVlIDogc3RhcnRDbGFzc0xpc3QucmVwbGFjZShuZXcgUmVnRXhwKFwiKD86XFxcXHN8XilcIiArIGVuZFZhbHVlLnN1YnN0cigyKSArIFwiKD8hW1xcXFx3LV0pXCIpLCBcIlwiKSArICgoZW5kVmFsdWUuY2hhckF0KDApID09PSBcIitcIikgPyBcIiBcIiArIGVuZFZhbHVlLnN1YnN0cigyKSA6IFwiXCIpfSxcbiAgXHRcdGNoYW5naW5nVmFycyA9IHt9LFxuICBcdFx0c3RhcnRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQpLFxuICBcdFx0dHJhbnNmb3JtUmVsYXRlZCA9IC8odHJhbnNmb3JtfHBlcnNwZWN0aXZlKS9pLFxuICBcdFx0ZW5kVmFycywgcDtcbiAgXHRpZiAoY2xhc3NQVCkge1xuICBcdFx0Y2xhc3NQVC5yKDEsIGNsYXNzUFQuZCk7XG4gIFx0XHRfcmVtb3ZlTGlua2VkTGlzdEl0ZW0oY2xhc3NQVC5kLnBsdWdpbiwgY2xhc3NQVCwgXCJfcHRcIik7XG4gIFx0fVxuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkYXRhLmUpO1xuICBcdGVuZFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCwgdHJ1ZSk7XG4gIFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHN0YXJ0Q2xhc3NMaXN0KTtcbiAgXHRmb3IgKHAgaW4gZW5kVmFycykge1xuICBcdFx0aWYgKGVuZFZhcnNbcF0gIT09IHN0YXJ0VmFyc1twXSAmJiAhdHJhbnNmb3JtUmVsYXRlZC50ZXN0KHApKSB7XG4gIFx0XHRcdGNoYW5naW5nVmFyc1twXSA9IGVuZFZhcnNbcF07XG4gIFx0XHRcdGlmICghc3R5bGVbcF0gJiYgc3R5bGVbcF0gIT09IFwiMFwiKSB7XG4gIFx0XHRcdFx0aW5saW5lVG9SZW1vdmVBdEVuZFtwXSA9IDE7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIFx0Y2FjaGUuY2xhc3NQVCA9IHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgXCJjbGFzc05hbWVcIiwgMCwgMCwgX3JlbmRlckNsYXNzTmFtZSwgZGF0YSwgMCwgLTExKTtcbiAgXHRpZiAoc3R5bGUuY3NzVGV4dCAhPT0gY3NzVGV4dCkgeyAvL29ubHkgYXBwbHkgaWYgdGhpbmdzIGNoYW5nZS4gT3RoZXJ3aXNlLCBpbiBjYXNlcyBsaWtlIGEgYmFja2dyb3VuZC1pbWFnZSB0aGF0J3MgcHVsbGVkIGR5bmFtaWNhbGx5LCBpdCBjb3VsZCBjYXVzZSBhIHJlZnJlc2guIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIwMzY4LXBvc3NpYmxlLWdzYXAtYnVnLXN3aXRjaGluZy1jbGFzc25hbWVzLWluLWNocm9tZS8uXG4gIFx0XHRzdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDsgLy93ZSByZWNvcmRlZCBjc3NUZXh0IGJlZm9yZSB3ZSBzd2FwcGVkIGNsYXNzZXMgYW5kIHJhbiBfZ2V0QWxsU3R5bGVzKCkgYmVjYXVzZSBpbiBjYXNlcyB3aGVuIGEgY2xhc3NOYW1lIHR3ZWVuIGlzIG92ZXJ3cml0dGVuLCB3ZSByZW1vdmUgYWxsIHRoZSByZWxhdGVkIHR3ZWVuaW5nIHByb3BlcnRpZXMgZnJvbSB0aGF0IGNsYXNzIGNoYW5nZSAob3RoZXJ3aXNlIGNsYXNzLXNwZWNpZmljIHN0dWZmIGNhbid0IG92ZXJyaWRlIHByb3BlcnRpZXMgd2UndmUgZGlyZWN0bHkgc2V0IG9uIHRoZSB0YXJnZXQncyBzdHlsZSBvYmplY3QgZHVlIHRvIHNwZWNpZmljaXR5KS5cbiAgXHR9XG4gIFx0X3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdHJ1ZSk7IC8vdG8gY2xlYXIgdGhlIGNhY2hpbmcgb2YgdHJhbnNmb3Jtc1xuICBcdGRhdGEuY3NzID0gbmV3IGdzYXAucGx1Z2lucy5jc3MoKTtcbiAgXHRkYXRhLmNzcy5pbml0KHRhcmdldCwgY2hhbmdpbmdWYXJzLCB0d2Vlbik7XG4gIFx0cGx1Z2luLl9wcm9wcy5wdXNoKC4uLmRhdGEuY3NzLl9wcm9wcyk7XG4gIFx0cmV0dXJuIDE7XG4gIH1cbiAgKi9cblxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUUkFOU0ZPUk1TXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5faWRlbnRpdHkyRE1hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXSxcbiAgICBfcm90YXRpb25hbFByb3BlcnRpZXMgPSB7fSxcbiAgICBfaXNOdWxsVHJhbnNmb3JtID0gZnVuY3Rpb24gX2lzTnVsbFRyYW5zZm9ybSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiIHx8ICF2YWx1ZTtcbn0sXG4gICAgX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSB7XG4gIHZhciBtYXRyaXhTdHJpbmcgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICByZXR1cm4gX2lzTnVsbFRyYW5zZm9ybShtYXRyaXhTdHJpbmcpID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXhTdHJpbmcuc3Vic3RyKDcpLm1hdGNoKF9udW1FeHApLm1hcChfcm91bmQpO1xufSxcbiAgICBfZ2V0TWF0cml4ID0gZnVuY3Rpb24gX2dldE1hdHJpeCh0YXJnZXQsIGZvcmNlMkQpIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IF9nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBtYXRyaXggPSBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCksXG4gICAgICBwYXJlbnQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHRlbXAsXG4gICAgICBhZGRlZFRvRE9NO1xuXG4gIGlmIChjYWNoZS5zdmcgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuICAgIHRlbXAgPSB0YXJnZXQudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKS5tYXRyaXg7IC8vZW5zdXJlcyB0aGF0IGV2ZW4gY29tcGxleCB2YWx1ZXMgbGlrZSBcInRyYW5zbGF0ZSg1MCw2MCkgcm90YXRlKDEzNSwwLDApXCIgYXJlIHBhcnNlZCBiZWNhdXNlIGl0IG1hc2hlcyBpdCBpbnRvIGEgbWF0cml4LlxuXG4gICAgbWF0cml4ID0gW3RlbXAuYSwgdGVtcC5iLCB0ZW1wLmMsIHRlbXAuZCwgdGVtcC5lLCB0ZW1wLmZdO1xuICAgIHJldHVybiBtYXRyaXguam9pbihcIixcIikgPT09IFwiMSwwLDAsMSwwLDBcIiA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4O1xuICB9IGVsc2UgaWYgKG1hdHJpeCA9PT0gX2lkZW50aXR5MkRNYXRyaXggJiYgIXRhcmdldC5vZmZzZXRQYXJlbnQgJiYgdGFyZ2V0ICE9PSBfZG9jRWxlbWVudCAmJiAhY2FjaGUuc3ZnKSB7XG4gICAgLy9ub3RlOiBpZiBvZmZzZXRQYXJlbnQgaXMgbnVsbCwgdGhhdCBtZWFucyB0aGUgZWxlbWVudCBpc24ndCBpbiB0aGUgbm9ybWFsIGRvY3VtZW50IGZsb3csIGxpa2UgaWYgaXQgaGFzIGRpc3BsYXk6bm9uZSBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgZGlzcGxheTpub25lKS4gRmlyZWZveCByZXR1cm5zIG51bGwgZm9yIGdldENvbXB1dGVkU3R5bGUoKSBpZiB0aGUgZWxlbWVudCBpcyBpbiBhbiBpZnJhbWUgdGhhdCBoYXMgZGlzcGxheTpub25lLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgICAvL2Jyb3dzZXJzIGRvbid0IHJlcG9ydCB0cmFuc2Zvcm1zIGFjY3VyYXRlbHkgdW5sZXNzIHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYW5kIGhhcyBhIGRpc3BsYXkgdmFsdWUgdGhhdCdzIG5vdCBcIm5vbmVcIi4gRmlyZWZveCBhbmQgTWljcm9zb2Z0IGJyb3dzZXJzIGhhdmUgYSBwYXJ0aWFsIGJ1ZyB3aGVyZSB0aGV5J2xsIHJlcG9ydCB0cmFuc2Zvcm1zIGV2ZW4gaWYgZGlzcGxheTpub25lIEJVVCBub3QgYW55IHBlcmNlbnRhZ2UtYmFzZWQgdmFsdWVzIGxpa2UgdHJhbnNsYXRlKC01MCUsIDhweCkgd2lsbCBiZSByZXBvcnRlZCBhcyBpZiBpdCdzIHRyYW5zbGF0ZSgwLCA4cHgpLlxuICAgIHRlbXAgPSBzdHlsZS5kaXNwbGF5O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgICBpZiAoIXBhcmVudCB8fCAhdGFyZ2V0Lm9mZnNldFBhcmVudCkge1xuICAgICAgLy8gbm90ZTogaW4gMy4zLjAgd2Ugc3dpdGNoZWQgdGFyZ2V0Lm9mZnNldFBhcmVudCB0byBfZG9jLmJvZHkuY29udGFpbnModGFyZ2V0KSB0byBhdm9pZCBbc29tZXRpbWVzIHVubmVjZXNzYXJ5XSBNdXRhdGlvbk9ic2VydmVyIGNhbGxzIGJ1dCB0aGF0IHdhc24ndCBhZGVxdWF0ZSBiZWNhdXNlIHRoZXJlIGFyZSBlZGdlIGNhc2VzIHdoZXJlIG5lc3RlZCBwb3NpdGlvbjogZml4ZWQgZWxlbWVudHMgbmVlZCB0byBnZXQgcmVwYXJlbnRlZCB0byBhY2N1cmF0ZWx5IHNlbnNlIHRyYW5zZm9ybXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzM4OCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zNzVcbiAgICAgIGFkZGVkVG9ET00gPSAxOyAvL2ZsYWdcblxuICAgICAgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dFNpYmxpbmc7XG5cbiAgICAgIF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHRhcmdldCk7IC8vd2UgbXVzdCBhZGQgaXQgdG8gdGhlIERPTSBpbiBvcmRlciB0byBnZXQgdmFsdWVzIHByb3Blcmx5XG5cbiAgICB9XG5cbiAgICBtYXRyaXggPSBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCk7XG4gICAgdGVtcCA/IHN0eWxlLmRpc3BsYXkgPSB0ZW1wIDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgXCJkaXNwbGF5XCIpO1xuXG4gICAgaWYgKGFkZGVkVG9ET00pIHtcbiAgICAgIG5leHRTaWJsaW5nID8gcGFyZW50Lmluc2VydEJlZm9yZSh0YXJnZXQsIG5leHRTaWJsaW5nKSA6IHBhcmVudCA/IHBhcmVudC5hcHBlbmRDaGlsZCh0YXJnZXQpIDogX2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9yY2UyRCAmJiBtYXRyaXgubGVuZ3RoID4gNiA/IFttYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0sIG1hdHJpeFsxMl0sIG1hdHJpeFsxM11dIDogbWF0cml4O1xufSxcbiAgICBfYXBwbHlTVkdPcmlnaW4gPSBmdW5jdGlvbiBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBvcmlnaW4sIG9yaWdpbklzQWJzb2x1dGUsIHNtb290aCwgbWF0cml4QXJyYXksIHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgIG1hdHJpeCA9IG1hdHJpeEFycmF5IHx8IF9nZXRNYXRyaXgodGFyZ2V0LCB0cnVlKSxcbiAgICAgIHhPcmlnaW5PbGQgPSBjYWNoZS54T3JpZ2luIHx8IDAsXG4gICAgICB5T3JpZ2luT2xkID0gY2FjaGUueU9yaWdpbiB8fCAwLFxuICAgICAgeE9mZnNldE9sZCA9IGNhY2hlLnhPZmZzZXQgfHwgMCxcbiAgICAgIHlPZmZzZXRPbGQgPSBjYWNoZS55T2Zmc2V0IHx8IDAsXG4gICAgICBhID0gbWF0cml4WzBdLFxuICAgICAgYiA9IG1hdHJpeFsxXSxcbiAgICAgIGMgPSBtYXRyaXhbMl0sXG4gICAgICBkID0gbWF0cml4WzNdLFxuICAgICAgdHggPSBtYXRyaXhbNF0sXG4gICAgICB0eSA9IG1hdHJpeFs1XSxcbiAgICAgIG9yaWdpblNwbGl0ID0gb3JpZ2luLnNwbGl0KFwiIFwiKSxcbiAgICAgIHhPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzBdKSB8fCAwLFxuICAgICAgeU9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luU3BsaXRbMV0pIHx8IDAsXG4gICAgICBib3VuZHMsXG4gICAgICBkZXRlcm1pbmFudCxcbiAgICAgIHgsXG4gICAgICB5O1xuXG4gIGlmICghb3JpZ2luSXNBYnNvbHV0ZSkge1xuICAgIGJvdW5kcyA9IF9nZXRCQm94KHRhcmdldCk7XG4gICAgeE9yaWdpbiA9IGJvdW5kcy54ICsgKH5vcmlnaW5TcGxpdFswXS5pbmRleE9mKFwiJVwiKSA/IHhPcmlnaW4gLyAxMDAgKiBib3VuZHMud2lkdGggOiB4T3JpZ2luKTtcbiAgICB5T3JpZ2luID0gYm91bmRzLnkgKyAofihvcmlnaW5TcGxpdFsxXSB8fCBvcmlnaW5TcGxpdFswXSkuaW5kZXhPZihcIiVcIikgPyB5T3JpZ2luIC8gMTAwICogYm91bmRzLmhlaWdodCA6IHlPcmlnaW4pO1xuICB9IGVsc2UgaWYgKG1hdHJpeCAhPT0gX2lkZW50aXR5MkRNYXRyaXggJiYgKGRldGVybWluYW50ID0gYSAqIGQgLSBiICogYykpIHtcbiAgICAvL2lmIGl0J3MgemVybyAobGlrZSBpZiBzY2FsZVggYW5kIHNjYWxlWSBhcmUgemVybyksIHNraXAgaXQgdG8gYXZvaWQgZXJyb3JzIHdpdGggZGl2aWRpbmcgYnkgemVyby5cbiAgICB4ID0geE9yaWdpbiAqIChkIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqICgtYyAvIGRldGVybWluYW50KSArIChjICogdHkgLSBkICogdHgpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgeSA9IHhPcmlnaW4gKiAoLWIgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKGEgLyBkZXRlcm1pbmFudCkgLSAoYSAqIHR5IC0gYiAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHhPcmlnaW4gPSB4O1xuICAgIHlPcmlnaW4gPSB5O1xuICB9XG5cbiAgaWYgKHNtb290aCB8fCBzbW9vdGggIT09IGZhbHNlICYmIGNhY2hlLnNtb290aCkge1xuICAgIHR4ID0geE9yaWdpbiAtIHhPcmlnaW5PbGQ7XG4gICAgdHkgPSB5T3JpZ2luIC0geU9yaWdpbk9sZDtcbiAgICBjYWNoZS54T2Zmc2V0ID0geE9mZnNldE9sZCArICh0eCAqIGEgKyB0eSAqIGMpIC0gdHg7XG4gICAgY2FjaGUueU9mZnNldCA9IHlPZmZzZXRPbGQgKyAodHggKiBiICsgdHkgKiBkKSAtIHR5O1xuICB9IGVsc2Uge1xuICAgIGNhY2hlLnhPZmZzZXQgPSBjYWNoZS55T2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGNhY2hlLnhPcmlnaW4gPSB4T3JpZ2luO1xuICBjYWNoZS55T3JpZ2luID0geU9yaWdpbjtcbiAgY2FjaGUuc21vb3RoID0gISFzbW9vdGg7XG4gIGNhY2hlLm9yaWdpbiA9IG9yaWdpbjtcbiAgY2FjaGUub3JpZ2luSXNBYnNvbHV0ZSA9ICEhb3JpZ2luSXNBYnNvbHV0ZTtcbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiMHB4IDBweFwiOyAvL290aGVyd2lzZSwgaWYgc29tZW9uZSBzZXRzICBhbiBvcmlnaW4gdmlhIENTUywgaXQgd2lsbCBsaWtlbHkgaW50ZXJmZXJlIHdpdGggdGhlIFNWRyB0cmFuc2Zvcm0gYXR0cmlidXRlIG9uZXMgKGJlY2F1c2UgcmVtZW1iZXIsIHdlJ3JlIGJha2luZyB0aGUgb3JpZ2luIGludG8gdGhlIG1hdHJpeCgpIHZhbHVlKS5cblxuICBpZiAocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8pIHtcbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9yaWdpblwiLCB4T3JpZ2luT2xkLCB4T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ5T3JpZ2luXCIsIHlPcmlnaW5PbGQsIHlPcmlnaW4pO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPZmZzZXRcIiwgeE9mZnNldE9sZCwgY2FjaGUueE9mZnNldCk7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9mZnNldFwiLCB5T2Zmc2V0T2xkLCBjYWNoZS55T2Zmc2V0KTtcbiAgfVxuXG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgeE9yaWdpbiArIFwiIFwiICsgeU9yaWdpbik7XG59LFxuICAgIF9wYXJzZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHVuY2FjaGUpIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IG5ldyBHU0NhY2hlKHRhcmdldCk7XG5cbiAgaWYgKFwieFwiIGluIGNhY2hlICYmICF1bmNhY2hlICYmICFjYWNoZS51bmNhY2hlKSB7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgaW52ZXJ0ZWRTY2FsZVggPSBjYWNoZS5zY2FsZVggPCAwLFxuICAgICAgcHggPSBcInB4XCIsXG4gICAgICBkZWcgPSBcImRlZ1wiLFxuICAgICAgb3JpZ2luID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCkgfHwgXCIwXCIsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHosXG4gICAgICBzY2FsZVgsXG4gICAgICBzY2FsZVksXG4gICAgICByb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uWCxcbiAgICAgIHJvdGF0aW9uWSxcbiAgICAgIHNrZXdYLFxuICAgICAgc2tld1ksXG4gICAgICBwZXJzcGVjdGl2ZSxcbiAgICAgIHhPcmlnaW4sXG4gICAgICB5T3JpZ2luLFxuICAgICAgbWF0cml4LFxuICAgICAgYW5nbGUsXG4gICAgICBjb3MsXG4gICAgICBzaW4sXG4gICAgICBhLFxuICAgICAgYixcbiAgICAgIGMsXG4gICAgICBkLFxuICAgICAgYTEyLFxuICAgICAgYTIyLFxuICAgICAgdDEsXG4gICAgICB0MixcbiAgICAgIHQzLFxuICAgICAgYTEzLFxuICAgICAgYTIzLFxuICAgICAgYTMzLFxuICAgICAgYTQyLFxuICAgICAgYTQzLFxuICAgICAgYTMyO1xuICB4ID0geSA9IHogPSByb3RhdGlvbiA9IHJvdGF0aW9uWCA9IHJvdGF0aW9uWSA9IHNrZXdYID0gc2tld1kgPSBwZXJzcGVjdGl2ZSA9IDA7XG4gIHNjYWxlWCA9IHNjYWxlWSA9IDE7XG4gIGNhY2hlLnN2ZyA9ICEhKHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCkpO1xuICBtYXRyaXggPSBfZ2V0TWF0cml4KHRhcmdldCwgY2FjaGUuc3ZnKTtcblxuICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgdDEgPSAoIWNhY2hlLnVuY2FjaGUgfHwgb3JpZ2luID09PSBcIjBweCAwcHhcIikgJiYgIXVuY2FjaGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTsgLy8gaWYgb3JpZ2luIGlzIDAsMCBhbmQgY2FjaGUudW5jYWNoZSBpcyB0cnVlLCBsZXQgdGhlIHJlY29yZGVkIGRhdGEtc3ZnLW9yaWdpbiBzdGF5LiBPdGhlcndpc2UsIHdoZW5ldmVyIHdlIHNldCBjYWNoZS51bmNhY2hlIHRvIHRydWUsIHdlJ2QgbmVlZCB0byBzZXQgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAoY2FjaGUueE9yaWdpbiAtIGJib3gueCkgKyBcInB4IFwiICsgKGNhY2hlLnlPcmlnaW4gLSBiYm94LnkpICsgXCJweFwiLiBSZW1lbWJlciwgdG8gd29yayBhcm91bmQgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMgd2UgYWx3YXlzIGZvcmNlIFNWRyBlbGVtZW50cycgdHJhbnNmb3JtT3JpZ2luIHRvIDAsMCBhbmQgb2Zmc2V0IHRoZSB0cmFuc2xhdGlvbiBhY2NvcmRpbmdseS5cblxuICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIHQxIHx8IG9yaWdpbiwgISF0MSB8fCBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlLCBjYWNoZS5zbW9vdGggIT09IGZhbHNlLCBtYXRyaXgpO1xuICB9XG5cbiAgeE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcbiAgeU9yaWdpbiA9IGNhY2hlLnlPcmlnaW4gfHwgMDtcblxuICBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuICAgIGEgPSBtYXRyaXhbMF07IC8vYTExXG5cbiAgICBiID0gbWF0cml4WzFdOyAvL2EyMVxuXG4gICAgYyA9IG1hdHJpeFsyXTsgLy9hMzFcblxuICAgIGQgPSBtYXRyaXhbM107IC8vYTQxXG5cbiAgICB4ID0gYTEyID0gbWF0cml4WzRdO1xuICAgIHkgPSBhMjIgPSBtYXRyaXhbNV07IC8vMkQgbWF0cml4XG5cbiAgICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgc2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuICAgICAgcm90YXRpb24gPSBhIHx8IGIgPyBfYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cbiAgICAgIHNrZXdYID0gYyB8fCBkID8gX2F0YW4yKGMsIGQpICogX1JBRDJERUcgKyByb3RhdGlvbiA6IDA7XG4gICAgICBza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguYWJzKE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKSk7XG5cbiAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgeCAtPSB4T3JpZ2luIC0gKHhPcmlnaW4gKiBhICsgeU9yaWdpbiAqIGMpO1xuICAgICAgICB5IC09IHlPcmlnaW4gLSAoeE9yaWdpbiAqIGIgKyB5T3JpZ2luICogZCk7XG4gICAgICB9IC8vM0QgbWF0cml4XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYTMyID0gbWF0cml4WzZdO1xuICAgICAgYTQyID0gbWF0cml4WzddO1xuICAgICAgYTEzID0gbWF0cml4WzhdO1xuICAgICAgYTIzID0gbWF0cml4WzldO1xuICAgICAgYTMzID0gbWF0cml4WzEwXTtcbiAgICAgIGE0MyA9IG1hdHJpeFsxMV07XG4gICAgICB4ID0gbWF0cml4WzEyXTtcbiAgICAgIHkgPSBtYXRyaXhbMTNdO1xuICAgICAgeiA9IG1hdHJpeFsxNF07XG4gICAgICBhbmdsZSA9IF9hdGFuMihhMzIsIGEzMyk7XG4gICAgICByb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHOyAvL3JvdGF0aW9uWFxuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICAgICAgdDEgPSBhMTIgKiBjb3MgKyBhMTMgKiBzaW47XG4gICAgICAgIHQyID0gYTIyICogY29zICsgYTIzICogc2luO1xuICAgICAgICB0MyA9IGEzMiAqIGNvcyArIGEzMyAqIHNpbjtcbiAgICAgICAgYTEzID0gYTEyICogLXNpbiArIGExMyAqIGNvcztcbiAgICAgICAgYTIzID0gYTIyICogLXNpbiArIGEyMyAqIGNvcztcbiAgICAgICAgYTMzID0gYTMyICogLXNpbiArIGEzMyAqIGNvcztcbiAgICAgICAgYTQzID0gYTQyICogLXNpbiArIGE0MyAqIGNvcztcbiAgICAgICAgYTEyID0gdDE7XG4gICAgICAgIGEyMiA9IHQyO1xuICAgICAgICBhMzIgPSB0MztcbiAgICAgIH0gLy9yb3RhdGlvbllcblxuXG4gICAgICBhbmdsZSA9IF9hdGFuMigtYywgYTMzKTtcbiAgICAgIHJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGEgKiBjb3MgLSBhMTMgKiBzaW47XG4gICAgICAgIHQyID0gYiAqIGNvcyAtIGEyMyAqIHNpbjtcbiAgICAgICAgdDMgPSBjICogY29zIC0gYTMzICogc2luO1xuICAgICAgICBhNDMgPSBkICogc2luICsgYTQzICogY29zO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGIgPSB0MjtcbiAgICAgICAgYyA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWlxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKGIsIGEpO1xuICAgICAgcm90YXRpb24gPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyArIGIgKiBzaW47XG4gICAgICAgIHQyID0gYTEyICogY29zICsgYTIyICogc2luO1xuICAgICAgICBiID0gYiAqIGNvcyAtIGEgKiBzaW47XG4gICAgICAgIGEyMiA9IGEyMiAqIGNvcyAtIGExMiAqIHNpbjtcbiAgICAgICAgYSA9IHQxO1xuICAgICAgICBhMTIgPSB0MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uWCAmJiBNYXRoLmFicyhyb3RhdGlvblgpICsgTWF0aC5hYnMocm90YXRpb24pID4gMzU5LjkpIHtcbiAgICAgICAgLy93aGVuIHJvdGF0aW9uWSBpcyBzZXQsIGl0IHdpbGwgb2Z0ZW4gYmUgcGFyc2VkIGFzIDE4MCBkZWdyZWVzIGRpZmZlcmVudCB0aGFuIGl0IHNob3VsZCBiZSwgYW5kIHJvdGF0aW9uWCBhbmQgcm90YXRpb24gYm90aCBiZWluZyAxODAgKGl0IGxvb2tzIHRoZSBzYW1lKSwgc28gd2UgYWRqdXN0IGZvciB0aGF0IGhlcmUuXG4gICAgICAgIHJvdGF0aW9uWCA9IHJvdGF0aW9uID0gMDtcbiAgICAgICAgcm90YXRpb25ZID0gMTgwIC0gcm90YXRpb25ZO1xuICAgICAgfVxuXG4gICAgICBzY2FsZVggPSBfcm91bmQoTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYykpO1xuICAgICAgc2NhbGVZID0gX3JvdW5kKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMzIgKiBhMzIpKTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGExMiwgYTIyKTtcbiAgICAgIHNrZXdYID0gTWF0aC5hYnMoYW5nbGUpID4gMC4wMDAyID8gYW5nbGUgKiBfUkFEMkRFRyA6IDA7XG4gICAgICBwZXJzcGVjdGl2ZSA9IGE0MyA/IDEgLyAoYTQzIDwgMCA/IC1hNDMgOiBhNDMpIDogMDtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAvL3NlbnNlIGlmIHRoZXJlIGFyZSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9uIGFuIFNWRyBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UgbXVzdCBvdmVyd3JpdGUgdGhlbSB3aGVuIHJlbmRlcmluZy4gVGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaXMgbW9yZSByZWxpYWJsZSBjcm9zcy1icm93c2VyLCBidXQgd2UgY2FuJ3QganVzdCByZW1vdmUgdGhlIENTUyBvbmVzIGJlY2F1c2UgdGhleSBtYXkgYmUgYXBwbGllZCBpbiBhIENTUyBydWxlIHNvbWV3aGVyZSAobm90IGp1c3QgaW5saW5lKS5cbiAgICAgIHQxID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgIGNhY2hlLmZvcmNlQ1NTID0gdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIlwiKSB8fCAhX2lzTnVsbFRyYW5zZm9ybShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKSk7XG4gICAgICB0MSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHQxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc2tld1gpID4gOTAgJiYgTWF0aC5hYnMoc2tld1gpIDwgMjcwKSB7XG4gICAgaWYgKGludmVydGVkU2NhbGVYKSB7XG4gICAgICBzY2FsZVggKj0gLTE7XG4gICAgICBza2V3WCArPSByb3RhdGlvbiA8PSAwID8gMTgwIDogLTE4MDtcbiAgICAgIHJvdGF0aW9uICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZVkgKj0gLTE7XG4gICAgICBza2V3WCArPSBza2V3WCA8PSAwID8gMTgwIDogLTE4MDtcbiAgICB9XG4gIH1cblxuICBjYWNoZS54ID0geCAtICgoY2FjaGUueFBlcmNlbnQgPSB4ICYmIChjYWNoZS54UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0V2lkdGggLyAyKSA9PT0gTWF0aC5yb3VuZCgteCkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldFdpZHRoICogY2FjaGUueFBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuICBjYWNoZS55ID0geSAtICgoY2FjaGUueVBlcmNlbnQgPSB5ICYmIChjYWNoZS55UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0SGVpZ2h0IC8gMikgPT09IE1hdGgucm91bmQoLXkpID8gLTUwIDogMCkpKSA/IHRhcmdldC5vZmZzZXRIZWlnaHQgKiBjYWNoZS55UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gIGNhY2hlLnogPSB6ICsgcHg7XG4gIGNhY2hlLnNjYWxlWCA9IF9yb3VuZChzY2FsZVgpO1xuICBjYWNoZS5zY2FsZVkgPSBfcm91bmQoc2NhbGVZKTtcbiAgY2FjaGUucm90YXRpb24gPSBfcm91bmQocm90YXRpb24pICsgZGVnO1xuICBjYWNoZS5yb3RhdGlvblggPSBfcm91bmQocm90YXRpb25YKSArIGRlZztcbiAgY2FjaGUucm90YXRpb25ZID0gX3JvdW5kKHJvdGF0aW9uWSkgKyBkZWc7XG4gIGNhY2hlLnNrZXdYID0gc2tld1ggKyBkZWc7XG4gIGNhY2hlLnNrZXdZID0gc2tld1kgKyBkZWc7XG4gIGNhY2hlLnRyYW5zZm9ybVBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmUgKyBweDtcblxuICBpZiAoY2FjaGUuek9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luLnNwbGl0KFwiIFwiKVsyXSkgfHwgMCkge1xuICAgIHN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IF9maXJzdFR3b09ubHkob3JpZ2luKTtcbiAgfVxuXG4gIGNhY2hlLnhPZmZzZXQgPSBjYWNoZS55T2Zmc2V0ID0gMDtcbiAgY2FjaGUuZm9yY2UzRCA9IF9jb25maWcuZm9yY2UzRDtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtID0gY2FjaGUuc3ZnID8gX3JlbmRlclNWR1RyYW5zZm9ybXMgOiBfc3VwcG9ydHMzRCA/IF9yZW5kZXJDU1NUcmFuc2Zvcm1zIDogX3JlbmRlck5vbjNEVHJhbnNmb3JtcztcbiAgY2FjaGUudW5jYWNoZSA9IDA7XG4gIHJldHVybiBjYWNoZTtcbn0sXG4gICAgX2ZpcnN0VHdvT25seSA9IGZ1bmN0aW9uIF9maXJzdFR3b09ubHkodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSA9IHZhbHVlLnNwbGl0KFwiIFwiKSlbMF0gKyBcIiBcIiArIHZhbHVlWzFdO1xufSxcbiAgICAvL2ZvciBoYW5kbGluZyB0cmFuc2Zvcm1PcmlnaW4gdmFsdWVzLCBzdHJpcHBpbmcgb3V0IHRoZSAzcmQgZGltZW5zaW9uXG5fYWRkUHhUcmFuc2xhdGUgPSBmdW5jdGlvbiBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCBzdGFydCwgdmFsdWUpIHtcbiAgdmFyIHVuaXQgPSBnZXRVbml0KHN0YXJ0KTtcbiAgcmV0dXJuIF9yb3VuZChwYXJzZUZsb2F0KHN0YXJ0KSArIHBhcnNlRmxvYXQoX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgdmFsdWUgKyBcInB4XCIsIHVuaXQpKSkgKyB1bml0O1xufSxcbiAgICBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbmRlck5vbjNEVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgY2FjaGUueiA9IFwiMHB4XCI7XG4gIGNhY2hlLnJvdGF0aW9uWSA9IGNhY2hlLnJvdGF0aW9uWCA9IFwiMGRlZ1wiO1xuICBjYWNoZS5mb3JjZTNEID0gMDtcblxuICBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfemVyb0RlZyA9IFwiMGRlZ1wiLFxuICAgIF96ZXJvUHggPSBcIjBweFwiLFxuICAgIF9lbmRQYXJlbnRoZXNpcyA9IFwiKSBcIixcbiAgICBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICB2YXIgX3JlZiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICB4UGVyY2VudCA9IF9yZWYueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYueVBlcmNlbnQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHogPSBfcmVmLnosXG4gICAgICByb3RhdGlvbiA9IF9yZWYucm90YXRpb24sXG4gICAgICByb3RhdGlvblkgPSBfcmVmLnJvdGF0aW9uWSxcbiAgICAgIHJvdGF0aW9uWCA9IF9yZWYucm90YXRpb25YLFxuICAgICAgc2tld1ggPSBfcmVmLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmLnNrZXdZLFxuICAgICAgc2NhbGVYID0gX3JlZi5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmLnNjYWxlWSxcbiAgICAgIHRyYW5zZm9ybVBlcnNwZWN0aXZlID0gX3JlZi50cmFuc2Zvcm1QZXJzcGVjdGl2ZSxcbiAgICAgIGZvcmNlM0QgPSBfcmVmLmZvcmNlM0QsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHpPcmlnaW4gPSBfcmVmLnpPcmlnaW4sXG4gICAgICB0cmFuc2Zvcm1zID0gXCJcIixcbiAgICAgIHVzZTNEID0gZm9yY2UzRCA9PT0gXCJhdXRvXCIgJiYgcmF0aW8gJiYgcmF0aW8gIT09IDEgfHwgZm9yY2UzRCA9PT0gdHJ1ZTsgLy8gU2FmYXJpIGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyBpdCBub3QgdG8gcmVuZGVyIDNEIHRyYW5zZm9ybS1vcmlnaW4gdmFsdWVzIHByb3Blcmx5LCBzbyB3ZSBmb3JjZSB0aGUgeiBvcmlnaW4gdG8gMCwgcmVjb3JkIGl0IGluIHRoZSBjYWNoZSwgYW5kIHRoZW4gZG8gdGhlIG1hdGggaGVyZSB0byBvZmZzZXQgdGhlIHRyYW5zbGF0ZSB2YWx1ZXMgYWNjb3JkaW5nbHkgKGJhc2ljYWxseSBkbyB0aGUgM0QgdHJhbnNmb3JtLW9yaWdpbiBwYXJ0IG1hbnVhbGx5KVxuXG5cbiAgaWYgKHpPcmlnaW4gJiYgKHJvdGF0aW9uWCAhPT0gX3plcm9EZWcgfHwgcm90YXRpb25ZICE9PSBfemVyb0RlZykpIHtcbiAgICB2YXIgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWSkgKiBfREVHMlJBRCxcbiAgICAgICAgYTEzID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICBhMzMgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIGNvcztcblxuICAgIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblgpICogX0RFRzJSQUQ7XG4gICAgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHggPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB4LCBhMTMgKiBjb3MgKiAtek9yaWdpbik7XG4gICAgeSA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHksIC1NYXRoLnNpbihhbmdsZSkgKiAtek9yaWdpbik7XG4gICAgeiA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHosIGEzMyAqIGNvcyAqIC16T3JpZ2luICsgek9yaWdpbik7XG4gIH1cblxuICBpZiAodHJhbnNmb3JtUGVyc3BlY3RpdmUgIT09IF96ZXJvUHgpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicGVyc3BlY3RpdmUoXCIgKyB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmICh4UGVyY2VudCB8fCB5UGVyY2VudCkge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJ0cmFuc2xhdGUoXCIgKyB4UGVyY2VudCArIFwiJSwgXCIgKyB5UGVyY2VudCArIFwiJSkgXCI7XG4gIH1cblxuICBpZiAodXNlM0QgfHwgeCAhPT0gX3plcm9QeCB8fCB5ICE9PSBfemVyb1B4IHx8IHogIT09IF96ZXJvUHgpIHtcbiAgICB0cmFuc2Zvcm1zICs9IHogIT09IF96ZXJvUHggfHwgdXNlM0QgPyBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwiLCBcIiArIHkgKyBcIiwgXCIgKyB6ICsgXCIpIFwiIDogXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIFwiICsgeSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvbiAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlKFwiICsgcm90YXRpb24gKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb25ZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVZKFwiICsgcm90YXRpb25ZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWCAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWChcIiArIHJvdGF0aW9uWCArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChza2V3WCAhPT0gX3plcm9EZWcgfHwgc2tld1kgIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNrZXcoXCIgKyBza2V3WCArIFwiLCBcIiArIHNrZXdZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDEpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwic2NhbGUoXCIgKyBzY2FsZVggKyBcIiwgXCIgKyBzY2FsZVkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICB0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcyB8fCBcInRyYW5zbGF0ZSgwLCAwKVwiO1xufSxcbiAgICBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJTVkdUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICB2YXIgX3JlZjIgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmMi54UGVyY2VudCxcbiAgICAgIHlQZXJjZW50ID0gX3JlZjIueVBlcmNlbnQsXG4gICAgICB4ID0gX3JlZjIueCxcbiAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgcm90YXRpb24gPSBfcmVmMi5yb3RhdGlvbixcbiAgICAgIHNrZXdYID0gX3JlZjIuc2tld1gsXG4gICAgICBza2V3WSA9IF9yZWYyLnNrZXdZLFxuICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZjIuc2NhbGVZLFxuICAgICAgdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgeE9yaWdpbiA9IF9yZWYyLnhPcmlnaW4sXG4gICAgICB5T3JpZ2luID0gX3JlZjIueU9yaWdpbixcbiAgICAgIHhPZmZzZXQgPSBfcmVmMi54T2Zmc2V0LFxuICAgICAgeU9mZnNldCA9IF9yZWYyLnlPZmZzZXQsXG4gICAgICBmb3JjZUNTUyA9IF9yZWYyLmZvcmNlQ1NTLFxuICAgICAgdHggPSBwYXJzZUZsb2F0KHgpLFxuICAgICAgdHkgPSBwYXJzZUZsb2F0KHkpLFxuICAgICAgYTExLFxuICAgICAgYTIxLFxuICAgICAgYTEyLFxuICAgICAgYTIyLFxuICAgICAgdGVtcDtcblxuICByb3RhdGlvbiA9IHBhcnNlRmxvYXQocm90YXRpb24pO1xuICBza2V3WCA9IHBhcnNlRmxvYXQoc2tld1gpO1xuICBza2V3WSA9IHBhcnNlRmxvYXQoc2tld1kpO1xuXG4gIGlmIChza2V3WSkge1xuICAgIC8vZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGNvbWJpbmUgYWxsIHNrZXdpbmcgaW50byB0aGUgc2tld1ggYW5kIHJvdGF0aW9uIHZhbHVlcy4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgZGVncmVlcyBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGRlZ3JlZXMgcGx1cyBhIHNrZXdYIG9mIDEwIGRlZ3JlZXMuXG4gICAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcbiAgICBza2V3WCArPSBza2V3WTtcbiAgICByb3RhdGlvbiArPSBza2V3WTtcbiAgfVxuXG4gIGlmIChyb3RhdGlvbiB8fCBza2V3WCkge1xuICAgIHJvdGF0aW9uICo9IF9ERUcyUkFEO1xuICAgIHNrZXdYICo9IF9ERUcyUkFEO1xuICAgIGExMSA9IE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWDtcbiAgICBhMjEgPSBNYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTEyID0gTWF0aC5zaW4ocm90YXRpb24gLSBza2V3WCkgKiAtc2NhbGVZO1xuICAgIGEyMiA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuXG4gICAgaWYgKHNrZXdYKSB7XG4gICAgICBza2V3WSAqPSBfREVHMlJBRDtcbiAgICAgIHRlbXAgPSBNYXRoLnRhbihza2V3WCAtIHNrZXdZKTtcbiAgICAgIHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcbiAgICAgIGExMiAqPSB0ZW1wO1xuICAgICAgYTIyICo9IHRlbXA7XG5cbiAgICAgIGlmIChza2V3WSkge1xuICAgICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1kpO1xuICAgICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICAgIGExMSAqPSB0ZW1wO1xuICAgICAgICBhMjEgKj0gdGVtcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhMTEgPSBfcm91bmQoYTExKTtcbiAgICBhMjEgPSBfcm91bmQoYTIxKTtcbiAgICBhMTIgPSBfcm91bmQoYTEyKTtcbiAgICBhMjIgPSBfcm91bmQoYTIyKTtcbiAgfSBlbHNlIHtcbiAgICBhMTEgPSBzY2FsZVg7XG4gICAgYTIyID0gc2NhbGVZO1xuICAgIGEyMSA9IGExMiA9IDA7XG4gIH1cblxuICBpZiAodHggJiYgIX4oeCArIFwiXCIpLmluZGV4T2YoXCJweFwiKSB8fCB0eSAmJiAhfih5ICsgXCJcIikuaW5kZXhPZihcInB4XCIpKSB7XG4gICAgdHggPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieFwiLCB4LCBcInB4XCIpO1xuICAgIHR5ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInlcIiwgeSwgXCJweFwiKTtcbiAgfVxuXG4gIGlmICh4T3JpZ2luIHx8IHlPcmlnaW4gfHwgeE9mZnNldCB8fCB5T2Zmc2V0KSB7XG4gICAgdHggPSBfcm91bmQodHggKyB4T3JpZ2luIC0gKHhPcmlnaW4gKiBhMTEgKyB5T3JpZ2luICogYTEyKSArIHhPZmZzZXQpO1xuICAgIHR5ID0gX3JvdW5kKHR5ICsgeU9yaWdpbiAtICh4T3JpZ2luICogYTIxICsgeU9yaWdpbiAqIGEyMikgKyB5T2Zmc2V0KTtcbiAgfVxuXG4gIGlmICh4UGVyY2VudCB8fCB5UGVyY2VudCkge1xuICAgIC8vVGhlIFNWRyBzcGVjIGRvZXNuJ3Qgc3VwcG9ydCBwZXJjZW50YWdlLWJhc2VkIHRyYW5zbGF0aW9uIGluIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgc28gd2UgbWVyZ2UgaXQgaW50byB0aGUgdHJhbnNsYXRpb24gdG8gc2ltdWxhdGUgaXQuXG4gICAgdGVtcCA9IHRhcmdldC5nZXRCQm94KCk7XG4gICAgdHggPSBfcm91bmQodHggKyB4UGVyY2VudCAvIDEwMCAqIHRlbXAud2lkdGgpO1xuICAgIHR5ID0gX3JvdW5kKHR5ICsgeVBlcmNlbnQgLyAxMDAgKiB0ZW1wLmhlaWdodCk7XG4gIH1cblxuICB0ZW1wID0gXCJtYXRyaXgoXCIgKyBhMTEgKyBcIixcIiArIGEyMSArIFwiLFwiICsgYTEyICsgXCIsXCIgKyBhMjIgKyBcIixcIiArIHR4ICsgXCIsXCIgKyB0eSArIFwiKVwiO1xuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRlbXApO1xuICBmb3JjZUNTUyAmJiAodGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRlbXApOyAvL3NvbWUgYnJvd3NlcnMgcHJpb3JpdGl6ZSBDU1MgdHJhbnNmb3JtcyBvdmVyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlLiBXaGVuIHdlIHNlbnNlIHRoYXQgdGhlIHVzZXIgaGFzIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQsIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gdGhpcyB3YXkgKG90aGVyd2lzZSBzb21lIGJyb3dzZXIgc2ltcGx5IHdvbid0IHJlbmRlciB0aGUgIHRyYW5zZm9ybSBhdHRyaWJ1dGUgY2hhbmdlcyEpXG59LFxuICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUsIHJlbGF0aXZlKSB7XG4gIHZhciBjYXAgPSAzNjAsXG4gICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG4gICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKSAqIChpc1N0cmluZyAmJiB+ZW5kVmFsdWUuaW5kZXhPZihcInJhZFwiKSA/IF9SQUQyREVHIDogMSksXG4gICAgICBjaGFuZ2UgPSByZWxhdGl2ZSA/IGVuZE51bSAqIHJlbGF0aXZlIDogZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICBmaW5hbFZhbHVlID0gc3RhcnROdW0gKyBjaGFuZ2UgKyBcImRlZ1wiLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcHQ7XG5cbiAgaWYgKGlzU3RyaW5nKSB7XG4gICAgZGlyZWN0aW9uID0gZW5kVmFsdWUuc3BsaXQoXCJfXCIpWzFdO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJzaG9ydFwiKSB7XG4gICAgICBjaGFuZ2UgJT0gY2FwO1xuXG4gICAgICBpZiAoY2hhbmdlICE9PSBjaGFuZ2UgJSAoY2FwIC8gMikpIHtcbiAgICAgICAgY2hhbmdlICs9IGNoYW5nZSA8IDAgPyBjYXAgOiAtY2FwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiY3dcIiAmJiBjaGFuZ2UgPCAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlICsgY2FwICogX2JpZ051bSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSA+IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgLSBjYXAgKiBfYmlnTnVtKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wdCA9IHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgY2hhbmdlLCBfcmVuZGVyUHJvcFdpdGhFbmQpO1xuICBwdC5lID0gZmluYWxWYWx1ZTtcbiAgcHQudSA9IFwiZGVnXCI7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hc3NpZ24gPSBmdW5jdGlvbiBfYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGRvZXNuJ3QgaGF2ZSBPYmplY3QuYXNzaWduKCksIHNvIHdlIHJlY3JlYXRlIGl0IGhlcmUuXG4gIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgdGFyZ2V0W3BdID0gc291cmNlW3BdO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0sXG4gICAgX2FkZFJhd1RyYW5zZm9ybVBUcyA9IGZ1bmN0aW9uIF9hZGRSYXdUcmFuc2Zvcm1QVHMocGx1Z2luLCB0cmFuc2Zvcm1zLCB0YXJnZXQpIHtcbiAgLy9mb3IgaGFuZGxpbmcgY2FzZXMgd2hlcmUgc29tZW9uZSBwYXNzZXMgaW4gYSB3aG9sZSB0cmFuc2Zvcm0gc3RyaW5nLCBsaWtlIHRyYW5zZm9ybTogXCJzY2FsZSgyLCAzKSByb3RhdGUoMjBkZWcpIHRyYW5zbGF0ZVkoMzBlbSlcIlxuICB2YXIgc3RhcnRDYWNoZSA9IF9hc3NpZ24oe30sIHRhcmdldC5fZ3NhcCksXG4gICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgZW5kQ2FjaGUsXG4gICAgICBwLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgc3RhcnROdW0sXG4gICAgICBlbmROdW0sXG4gICAgICBzdGFydFVuaXQsXG4gICAgICBlbmRVbml0O1xuXG4gIGlmIChzdGFydENhY2hlLnN2Zykge1xuICAgIHN0YXJ0VmFsdWUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIik7XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcztcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuXG4gICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBzdGFydFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1Qcm9wXTtcbiAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuICAgIGVuZENhY2hlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gc3RhcnRWYWx1ZTtcbiAgfVxuXG4gIGZvciAocCBpbiBfdHJhbnNmb3JtUHJvcHMpIHtcbiAgICBzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcbiAgICBlbmRWYWx1ZSA9IGVuZENhY2hlW3BdO1xuXG4gICAgaWYgKHN0YXJ0VmFsdWUgIT09IGVuZFZhbHVlICYmIGV4Y2x1ZGUuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgIC8vdHdlZW5pbmcgdG8gbm8gcGVyc3BlY3RpdmUgZ2l2ZXMgdmVyeSB1bmludHVpdGl2ZSByZXN1bHRzIC0ganVzdCBrZWVwIHRoZSBzYW1lIHBlcnNwZWN0aXZlIGluIHRoYXQgY2FzZS5cbiAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG4gICAgICBzdGFydE51bSA9IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgOiBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCBlbmRDYWNoZSwgcCwgc3RhcnROdW0sIGVuZE51bSAtIHN0YXJ0TnVtLCBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICBwbHVnaW4uX3B0LnUgPSBlbmRVbml0IHx8IDA7XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cblxuICBfYXNzaWduKGVuZENhY2hlLCBzdGFydENhY2hlKTtcbn07IC8vIGhhbmRsZSBzcGxpdHRpbmcgYXBhcnQgcGFkZGluZywgbWFyZ2luLCBib3JkZXJXaWR0aCwgYW5kIGJvcmRlclJhZGl1cyBpbnRvIHRoZWlyIDQgY29tcG9uZW50cy4gRmlyZWZveCwgZm9yIGV4YW1wbGUsIHdvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5IC0gaXQgd2lsbCBvbmx5IGRvIGJvcmRlclRvcExlZnRSYWRpdXMgYW5kIHRoZSBvdGhlciBjb3JuZXJzLiBXZSBhbHNvIHdhbnQgdG8gaGFuZGxlIHBhZGRpbmdUb3AsIG1hcmdpbkxlZnQsIGJvcmRlclJpZ2h0V2lkdGgsIGV0Yy5cblxuXG5fZm9yRWFjaE5hbWUoXCJwYWRkaW5nLG1hcmdpbixXaWR0aCxSYWRpdXNcIiwgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gIHZhciB0ID0gXCJUb3BcIixcbiAgICAgIHIgPSBcIlJpZ2h0XCIsXG4gICAgICBiID0gXCJCb3R0b21cIixcbiAgICAgIGwgPSBcIkxlZnRcIixcbiAgICAgIHByb3BzID0gKGluZGV4IDwgMyA/IFt0LCByLCBiLCBsXSA6IFt0ICsgbCwgdCArIHIsIGIgKyByLCBiICsgbF0pLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBpbmRleCA8IDIgPyBuYW1lICsgc2lkZSA6IFwiYm9yZGVyXCIgKyBzaWRlICsgbmFtZTtcbiAgfSk7XG5cbiAgX3NwZWNpYWxQcm9wc1tpbmRleCA+IDEgPyBcImJvcmRlclwiICsgbmFtZSA6IG5hbWVdID0gZnVuY3Rpb24gKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gICAgdmFyIGEsIHZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcbiAgICAgIC8vIGdldHRlciwgcGFzc2VkIHRhcmdldCwgcHJvcGVydHksIGFuZCB1bml0IChmcm9tIF9nZXQoKSlcbiAgICAgIGEgPSBwcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGx1Z2luLCBwcm9wLCBwcm9wZXJ0eSk7XG4gICAgICB9KTtcbiAgICAgIHZhcnMgPSBhLmpvaW4oXCIgXCIpO1xuICAgICAgcmV0dXJuIHZhcnMuc3BsaXQoYVswXSkubGVuZ3RoID09PSA1ID8gYVswXSA6IHZhcnM7XG4gICAgfVxuXG4gICAgYSA9IChlbmRWYWx1ZSArIFwiXCIpLnNwbGl0KFwiIFwiKTtcbiAgICB2YXJzID0ge307XG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgcmV0dXJuIHZhcnNbcHJvcF0gPSBhW2ldID0gYVtpXSB8fCBhWyhpIC0gMSkgLyAyIHwgMF07XG4gICAgfSk7XG4gICAgcGx1Z2luLmluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbik7XG4gIH07XG59KTtcblxuZXhwb3J0IHZhciBDU1NQbHVnaW4gPSB7XG4gIG5hbWU6IFwiY3NzXCIsXG4gIHJlZ2lzdGVyOiBfaW5pdENvcmUsXG4gIHRhcmdldFRlc3Q6IGZ1bmN0aW9uIHRhcmdldFRlc3QodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5zdHlsZSAmJiB0YXJnZXQubm9kZVR5cGU7XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcyxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHN0YXJ0QXQgPSB0d2Vlbi52YXJzLnN0YXJ0QXQsXG4gICAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICAgIGVuZFZhbHVlLFxuICAgICAgICBlbmROdW0sXG4gICAgICAgIHN0YXJ0TnVtLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzcGVjaWFsUHJvcCxcbiAgICAgICAgcCxcbiAgICAgICAgc3RhcnRVbml0LFxuICAgICAgICBlbmRVbml0LFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkLFxuICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4sXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBzbW9vdGgsXG4gICAgICAgIGhhc1ByaW9yaXR5O1xuICAgIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIGlmIChwID09PSBcImF1dG9Sb3VuZFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbmRWYWx1ZSA9IHZhcnNbcF07XG5cbiAgICAgIGlmIChfcGx1Z2luc1twXSAmJiBfY2hlY2tQbHVnaW4ocCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKSB7XG4gICAgICAgIC8vIHBsdWdpbnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBlbmRWYWx1ZS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcbiAgICAgICAgc3BlY2lhbFByb3AodGhpcywgdGFyZ2V0LCBwLCBlbmRWYWx1ZSwgdHdlZW4pICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXG4gICAgICAgIHN0YXJ0VmFsdWUgPSAoZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUocCkgKyBcIlwiKS50cmltKCk7XG4gICAgICAgIGVuZFZhbHVlICs9IFwiXCI7XG4gICAgICAgIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICghX2NvbG9yRXhwLnRlc3Qoc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBjb2xvcnMgZG9uJ3QgaGF2ZSB1bml0c1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kVW5pdCA/IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnRWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgKyBlbmRVbml0KSA6IHN0YXJ0VW5pdCAmJiAoZW5kVmFsdWUgKz0gc3RhcnRVbml0KTtcbiAgICAgICAgdGhpcy5hZGQoc3R5bGUsIFwic2V0UHJvcGVydHlcIiwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoc3RhcnRBdCAmJiBwIGluIHN0YXJ0QXQpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHNvbWVvbmUgaGFyZC1jb2RlcyBhIGNvbXBsZXggdmFsdWUgYXMgdGhlIHN0YXJ0LCBsaWtlIHRvcDogXCJjYWxjKDJ2aCAvIDIpXCIuIFdpdGhvdXQgdGhpcywgaXQnZCB1c2UgdGhlIGNvbXB1dGVkIHZhbHVlIChhbHdheXMgaW4gcHgpXG4gICAgICAgICAgc3RhcnRWYWx1ZSA9IHR5cGVvZiBzdGFydEF0W3BdID09PSBcImZ1bmN0aW9uXCIgPyBzdGFydEF0W3BdLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogc3RhcnRBdFtwXTtcbiAgICAgICAgICBwIGluIF9jb25maWcudW5pdHMgJiYgIWdldFVuaXQoc3RhcnRWYWx1ZSkgJiYgKHN0YXJ0VmFsdWUgKz0gX2NvbmZpZy51bml0c1twXSk7IC8vIGZvciBjYXNlcyB3aGVuIHNvbWVvbmUgcGFzc2VzIGluIGEgdW5pdGxlc3MgdmFsdWUgbGlrZSB7eDogMTAwfTsgaWYgd2UgdHJ5IHNldHRpbmcgdHJhbnNsYXRlKDEwMCwgMHB4KSBpdCB3b24ndCB3b3JrLlxuXG4gICAgICAgICAgX2lzU3RyaW5nKHN0YXJ0VmFsdWUpICYmIH5zdGFydFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpICYmIChzdGFydFZhbHVlID0gX3JlcGxhY2VSYW5kb20oc3RhcnRWYWx1ZSkpO1xuICAgICAgICAgIChzdGFydFZhbHVlICsgXCJcIikuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKSk7IC8vIGNhbid0IHdvcmsgd2l0aCByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgICByZWxhdGl2ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgJiYgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/ICsoZW5kVmFsdWUuY2hhckF0KDApICsgXCIxXCIpIDogMDtcbiAgICAgICAgcmVsYXRpdmUgJiYgKGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpKTtcbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuICAgICAgICAgIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb250cm9sIHRoZSB2aXNpYmlsaXR5IGFsb25nIHdpdGggb3BhY2l0eS4gV2Ugc3RpbGwgYWxsb3cgdGhlIG9wYWNpdHkgdmFsdWUgdG8gcGFzcyB0aHJvdWdoIGFuZCBnZXQgdHdlZW5lZC5cbiAgICAgICAgICAgIGlmIChzdGFydE51bSA9PT0gMSAmJiBfZ2V0KHRhcmdldCwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiICYmIGVuZE51bSkge1xuICAgICAgICAgICAgICAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuICAgICAgICAgICAgICBzdGFydE51bSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcbiAgICAgICAgICAgIH5wLmluZGV4T2YoXCIsXCIpICYmIChwID0gcC5zcGxpdChcIixcIilbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCA9IHAgaW4gX3RyYW5zZm9ybVByb3BzOyAvLy0tLSBUUkFOU0ZPUk0tUkVMQVRFRCAtLS1cblxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkKSB7XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Qcm9wVHdlZW4pIHtcbiAgICAgICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICAgICAgICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtICYmICF2YXJzLnBhcnNlVHJhbnNmb3JtIHx8IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHZhcnMucGFyc2VUcmFuc2Zvcm0pOyAvLyBpZiwgZm9yIGV4YW1wbGUsIGdzYXAuc2V0KC4uLiB7dHJhbnNmb3JtOlwidHJhbnNsYXRlWCg1MHZ3KVwifSksIHRoZSBfZ2V0KCkgY2FsbCBkb2Vzbid0IHBhcnNlIHRoZSB0cmFuc2Zvcm0sIHRodXMgY2FjaGUucmVuZGVyVHJhbnNmb3JtIHdvbid0IGJlIHNldCB5ZXQgc28gZm9yY2UgdGhlIHBhcnNpbmcgb2YgdGhlIHRyYW5zZm9ybSBoZXJlLlxuXG4gICAgICAgICAgICBzbW9vdGggPSB2YXJzLnNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoO1xuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuID0gdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBzdHlsZSwgX3RyYW5zZm9ybVByb3AsIDAsIDEsIGNhY2hlLnJlbmRlclRyYW5zZm9ybSwgY2FjaGUsIDAsIC0xKTsgLy90aGUgZmlyc3QgdGltZSB0aHJvdWdoLCBjcmVhdGUgdGhlIHJlbmRlcmluZyBQcm9wVHdlZW4gc28gdGhhdCBpdCBydW5zIExBU1QgKGluIHRoZSBsaW5rZWQgbGlzdCwgd2Uga2VlcCBhZGRpbmcgdG8gdGhlIGJlZ2lubmluZylcblxuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7IC8vZmxhZyBpdCBhcyBkZXBlbmRlbnQgc28gdGhhdCBpZiB0aGluZ3MgZ2V0IGtpbGxlZC9vdmVyd3JpdHRlbiBhbmQgdGhpcyBpcyB0aGUgb25seSBQcm9wVHdlZW4gbGVmdCwgd2UgY2FuIHNhZmVseSBraWxsIHRoZSB3aG9sZSB0d2Vlbi5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGNhY2hlLCBcInNjYWxlWVwiLCBjYWNoZS5zY2FsZVksIChyZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gY2FjaGUuc2NhbGVZKSB8fCAwKTtcbiAgICAgICAgICAgIHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XG4gICAgICAgICAgICBwICs9IFwiWFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyhlbmRWYWx1ZSk7IC8vaW4gY2FzZSBzb21ldGhpbmcgbGlrZSBcImxlZnQgdG9wXCIgb3IgXCJib3R0b20gcmlnaHRcIiBpcyBwYXNzZWQgaW4uIENvbnZlcnQgdG8gcGVyY2VudGFnZXMuXG5cbiAgICAgICAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDAsIHNtb290aCwgMCwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmRVbml0ID0gcGFyc2VGbG9hdChlbmRWYWx1ZS5zcGxpdChcIiBcIilbMl0pIHx8IDA7IC8vaGFuZGxlIHRoZSB6T3JpZ2luIHNlcGFyYXRlbHkhXG5cbiAgICAgICAgICAgICAgZW5kVW5pdCAhPT0gY2FjaGUuek9yaWdpbiAmJiBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJ6T3JpZ2luXCIsIGNhY2hlLnpPcmlnaW4sIGVuZFVuaXQpO1xuXG4gICAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBwLCBfZmlyc3RUd29Pbmx5KHN0YXJ0VmFsdWUpLCBfZmlyc3RUd29Pbmx5KGVuZFZhbHVlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzdmdPcmlnaW5cIikge1xuICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDEsIHNtb290aCwgMCwgdGhpcyk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCBpbiBfcm90YXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHRoaXMsIGNhY2hlLCBwLCBzdGFydE51bSwgZW5kVmFsdWUsIHJlbGF0aXZlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInNtb290aE9yaWdpblwiKSB7XG4gICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJzbW9vdGhcIiwgY2FjaGUuc21vb3RoLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJmb3JjZTNEXCIpIHtcbiAgICAgICAgICAgIGNhY2hlW3BdID0gZW5kVmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHModGhpcywgZW5kVmFsdWUsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgcCA9IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKGVuZE51bSB8fCBlbmROdW0gPT09IDApICYmIChzdGFydE51bSB8fCBzdGFydE51bSA9PT0gMCkgJiYgIV9jb21wbGV4RXhwLnRlc3QoZW5kVmFsdWUpICYmIHAgaW4gc3R5bGUpIHtcbiAgICAgICAgICBzdGFydFVuaXQgPSAoc3RhcnRWYWx1ZSArIFwiXCIpLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICAgIGVuZE51bSB8fCAoZW5kTnVtID0gMCk7IC8vIHByb3RlY3QgYWdhaW5zdCBOYU5cblxuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKSB8fCAocCBpbiBfY29uZmlnLnVuaXRzID8gX2NvbmZpZy51bml0c1twXSA6IHN0YXJ0VW5pdCk7XG4gICAgICAgICAgc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkpO1xuICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgaXNUcmFuc2Zvcm1SZWxhdGVkID8gY2FjaGUgOiBzdHlsZSwgcCwgc3RhcnROdW0sIHJlbGF0aXZlID8gcmVsYXRpdmUgKiBlbmROdW0gOiBlbmROdW0gLSBzdGFydE51bSwgIWlzVHJhbnNmb3JtUmVsYXRlZCAmJiAoZW5kVW5pdCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpICYmIHZhcnMuYXV0b1JvdW5kICE9PSBmYWxzZSA/IF9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA6IF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgICAgICB0aGlzLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiBlbmRVbml0ICE9PSBcIiVcIikge1xuICAgICAgICAgICAgLy93aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZywgd2UgbmVlZCB0byByZXZlcnQgaXQgdG8gdGhlIE9MRC9PUklHSU5BTCB2YWx1ZSAod2l0aCB0aG9zZSB1bml0cykuIFdlIHJlY29yZCB0aGF0IGFzIGEgXCJiXCIgKGJlZ2lubmluZykgcHJvcGVydHkgYW5kIHBvaW50IHRvIGEgcmVuZGVyIG1ldGhvZCB0aGF0IGhhbmRsZXMgdGhhdC4gKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcbiAgICAgICAgICAgIHRoaXMuX3B0LmIgPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcHQuciA9IF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuICAgICAgICAgIGlmIChwIGluIHRhcmdldCkge1xuICAgICAgICAgICAgLy9tYXliZSBpdCdzIG5vdCBhIHN0eWxlIC0gaXQgY291bGQgYmUgYSBwcm9wZXJ0eSBhZGRlZCBkaXJlY3RseSB0byBhbiBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UnbGwgdHJ5IHRvIGFuaW1hdGUgdGhhdC5cbiAgICAgICAgICAgIHRoaXMuYWRkKHRhcmdldCwgcCwgc3RhcnRWYWx1ZSB8fCB0YXJnZXRbcF0sIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9taXNzaW5nUGx1Z2luKHAsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbCh0aGlzLCB0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0aGlzKTtcbiAgfSxcbiAgZ2V0OiBfZ2V0LFxuICBhbGlhc2VzOiBfcHJvcGVydHlBbGlhc2VzLFxuICBnZXRTZXR0ZXI6IGZ1bmN0aW9uIGdldFNldHRlcih0YXJnZXQsIHByb3BlcnR5LCBwbHVnaW4pIHtcbiAgICAvL3JldHVybnMgYSBzZXR0ZXIgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRhcmdldCwgcHJvcGVydHksIHZhbHVlIGFuZCBhcHBsaWVzIGl0IGFjY29yZGluZ2x5LiBSZW1lbWJlciwgcHJvcGVydGllcyBsaWtlIFwieFwiIGFyZW4ndCBhcyBzaW1wbGUgYXMgdGFyZ2V0LnN0eWxlLnByb3BlcnR5ID0gdmFsdWUgYmVjYXVzZSB0aGV5J3ZlIGdvdCB0byBiZSBhcHBsaWVkIHRvIGEgcHJveHkgb2JqZWN0IGFuZCB0aGVuIG1lcmdlZCBpbnRvIGEgdHJhbnNmb3JtIHN0cmluZyBpbiBhIHJlbmRlcmVyLlxuICAgIHZhciBwID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XG4gICAgcCAmJiBwLmluZGV4T2YoXCIsXCIpIDwgMCAmJiAocHJvcGVydHkgPSBwKTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGFyZ2V0Ll9nc2FwLnggfHwgX2dldCh0YXJnZXQsIFwieFwiKSkgPyBwbHVnaW4gJiYgX3JlY2VudFNldHRlclBsdWdpbiA9PT0gcGx1Z2luID8gcHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZSA6IF9zZXR0ZXJUcmFuc2Zvcm0gOiAoX3JlY2VudFNldHRlclBsdWdpbiA9IHBsdWdpbiB8fCB7fSkgJiYgKHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIDogX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIpIDogdGFyZ2V0LnN0eWxlICYmICFfaXNVbmRlZmluZWQodGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSkgPyBfc2V0dGVyQ1NTU3R5bGUgOiB+cHJvcGVydHkuaW5kZXhPZihcIi1cIikgPyBfc2V0dGVyQ1NTUHJvcCA6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIH0sXG4gIGNvcmU6IHtcbiAgICBfcmVtb3ZlUHJvcGVydHk6IF9yZW1vdmVQcm9wZXJ0eSxcbiAgICBfZ2V0TWF0cml4OiBfZ2V0TWF0cml4XG4gIH1cbn07XG5nc2FwLnV0aWxzLmNoZWNrUHJlZml4ID0gX2NoZWNrUHJvcFByZWZpeDtcblxuKGZ1bmN0aW9uIChwb3NpdGlvbkFuZFNjYWxlLCByb3RhdGlvbiwgb3RoZXJzLCBhbGlhc2VzKSB7XG4gIHZhciBhbGwgPSBfZm9yRWFjaE5hbWUocG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb24gKyBcIixcIiArIG90aGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfdHJhbnNmb3JtUHJvcHNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfZm9yRWFjaE5hbWUocm90YXRpb24sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwiZGVnXCI7XG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX3Byb3BlcnR5QWxpYXNlc1thbGxbMTNdXSA9IHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uO1xuXG4gIF9mb3JFYWNoTmFtZShhbGlhc2VzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoXCI6XCIpO1xuICAgIF9wcm9wZXJ0eUFsaWFzZXNbc3BsaXRbMV1dID0gYWxsW3NwbGl0WzBdXTtcbiAgfSk7XG59KShcIngseSx6LHNjYWxlLHNjYWxlWCxzY2FsZVkseFBlcmNlbnQseVBlcmNlbnRcIiwgXCJyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHNrZXdYLHNrZXdZXCIsIFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sZm9yY2UzRCxzbW9vdGhPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCIwOnRyYW5zbGF0ZVgsMTp0cmFuc2xhdGVZLDI6dHJhbnNsYXRlWiw4OnJvdGF0ZSw4OnJvdGF0aW9uWiw4OnJvdGF0ZVosOTpyb3RhdGVYLDEwOnJvdGF0ZVlcIik7XG5cbl9mb3JFYWNoTmFtZShcIngseSx6LHRvcCxyaWdodCxib3R0b20sbGVmdCx3aWR0aCxoZWlnaHQsZm9udFNpemUscGFkZGluZyxtYXJnaW4scGVyc3BlY3RpdmVcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwicHhcIjtcbn0pO1xuXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbik7XG5leHBvcnQgeyBDU1NQbHVnaW4gYXMgZGVmYXVsdCwgX2dldEJCb3gsIF9jcmVhdGVFbGVtZW50LCBfY2hlY2tQcm9wUHJlZml4IGFzIGNoZWNrUHJlZml4IH07IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIEdTQVAgMy44LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX2NvbmZpZyA9IHtcbiAgYXV0b1NsZWVwOiAxMjAsXG4gIGZvcmNlM0Q6IFwiYXV0b1wiLFxuICBudWxsVGFyZ2V0V2FybjogMSxcbiAgdW5pdHM6IHtcbiAgICBsaW5lSGVpZ2h0OiBcIlwiXG4gIH1cbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICBkdXJhdGlvbjogLjUsXG4gIG92ZXJ3cml0ZTogZmFsc2UsXG4gIGRlbGF5OiAwXG59LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfdGlueU51bSA9IDEgLyBfYmlnTnVtLFxuICAgIF8yUEkgPSBNYXRoLlBJICogMixcbiAgICBfSEFMRl9QSSA9IF8yUEkgLyA0LFxuICAgIF9nc0lEID0gMCxcbiAgICBfc3FydCA9IE1hdGguc3FydCxcbiAgICBfY29zID0gTWF0aC5jb3MsXG4gICAgX3NpbiA9IE1hdGguc2luLFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2lzTm90RmFsc2UgPSBmdW5jdGlvbiBfaXNOb3RGYWxzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc0Z1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9pc0Z1bmNPclN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpIHx8IF9pc1N0cmluZyh2YWx1ZSk7XG59LFxuICAgIF9pc1R5cGVkQXJyYXkgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgLy8gbm90ZTogSUUxMCBoYXMgQXJyYXlCdWZmZXIsIGJ1dCBOT1QgQXJyYXlCdWZmZXIuaXNWaWV3KCkuXG5faXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgX3N0cmljdE51bUV4cCA9IC8oPzotP1xcLj9cXGR8XFwuKSsvZ2ksXG4gICAgLy9vbmx5IG51bWJlcnMgKGluY2x1ZGluZyBuZWdhdGl2ZXMgYW5kIGRlY2ltYWxzKSBidXQgTk9UIHJlbGF0aXZlIHZhbHVlcy5cbl9udW1FeHAgPSAvWy0rPS5dKlxcZCtbLmVcXC0rXSpcXGQqW2VcXC0rXSpcXGQqL2csXG4gICAgLy9maW5kcyBhbnkgbnVtYmVycywgaW5jbHVkaW5nIG9uZXMgdGhhdCBzdGFydCB3aXRoICs9IG9yIC09LCBuZWdhdGl2ZSBudW1iZXJzLCBhbmQgb25lcyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgMWUtOC5cbl9udW1XaXRoVW5pdEV4cCA9IC9bLSs9Ll0qXFxkK1suZS1dKlxcZCpbYS16JV0qL2csXG4gICAgX2NvbXBsZXhTdHJpbmdOdW1FeHAgPSAvWy0rPS5dKlxcZCtcXC4/XFxkKig/OmUtfGVcXCspP1xcZCovZ2ksXG4gICAgLy9kdXBsaWNhdGUgc28gdGhhdCB3aGlsZSB3ZSdyZSBsb29waW5nIHRocm91Z2ggbWF0Y2hlcyBmcm9tIGV4ZWMoKSwgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgbGFzdEluZGV4IG9mIF9udW1FeHAgd2hpY2ggd2UgdXNlIHRvIHNlYXJjaCBmb3IgY29sb3JzIHRvby5cbl9yZWxFeHAgPSAvWystXT0tP1suXFxkXSsvLFxuICAgIF9kZWxpbWl0ZWRWYWx1ZUV4cCA9IC9bXiwnXCJcXFtcXF1cXHNdKy9naSxcbiAgICAvLyBwcmV2aW91c2x5IC9bI1xcLSsuXSpcXGJbYS16XFxkXFwtPSslLl0rL2dpIGJ1dCBkaWRuJ3QgY2F0Y2ggc3BlY2lhbCBjaGFyYWN0ZXJzLlxuX3VuaXRFeHAgPSAvW1xcZC4rXFwtPV0rKD86ZVstK11cXGQqKSovaSxcbiAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgX3dpbixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2RvYyxcbiAgICBfZ2xvYmFscyA9IHt9LFxuICAgIF9pbnN0YWxsU2NvcGUgPSB7fSxcbiAgICBfY29yZVJlYWR5LFxuICAgIF9pbnN0YWxsID0gZnVuY3Rpb24gX2luc3RhbGwoc2NvcGUpIHtcbiAgcmV0dXJuIChfaW5zdGFsbFNjb3BlID0gX21lcmdlKHNjb3BlLCBfZ2xvYmFscykpICYmIGdzYXA7XG59LFxuICAgIF9taXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gX21pc3NpbmdQbHVnaW4ocHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb3BlcnR5XCIsIHByb3BlcnR5LCBcInNldCB0b1wiLCB2YWx1ZSwgXCJNaXNzaW5nIHBsdWdpbj8gZ3NhcC5yZWdpc3RlclBsdWdpbigpXCIpO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UsIHN1cHByZXNzKSB7XG4gIHJldHVybiAhc3VwcHJlc3MgJiYgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufSxcbiAgICBfYWRkR2xvYmFsID0gZnVuY3Rpb24gX2FkZEdsb2JhbChuYW1lLCBvYmopIHtcbiAgcmV0dXJuIG5hbWUgJiYgKF9nbG9iYWxzW25hbWVdID0gb2JqKSAmJiBfaW5zdGFsbFNjb3BlICYmIChfaW5zdGFsbFNjb3BlW25hbWVdID0gb2JqKSB8fCBfZ2xvYmFscztcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiAwO1xufSxcbiAgICBfcmVzZXJ2ZWRQcm9wcyA9IHt9LFxuICAgIF9sYXp5VHdlZW5zID0gW10sXG4gICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICBfbGFzdFJlbmRlcmVkRnJhbWUsXG4gICAgX3BsdWdpbnMgPSB7fSxcbiAgICBfZWZmZWN0cyA9IHt9LFxuICAgIF9uZXh0R0NGcmFtZSA9IDMwLFxuICAgIF9oYXJuZXNzUGx1Z2lucyA9IFtdLFxuICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICBfaGFybmVzcyA9IGZ1bmN0aW9uIF9oYXJuZXNzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbMF0sXG4gICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgaTtcbiAgX2lzT2JqZWN0KHRhcmdldCkgfHwgX2lzRnVuY3Rpb24odGFyZ2V0KSB8fCAodGFyZ2V0cyA9IFt0YXJnZXRzXSk7XG5cbiAgaWYgKCEoaGFybmVzc1BsdWdpbiA9ICh0YXJnZXQuX2dzYXAgfHwge30pLmhhcm5lc3MpKSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggYSBoYXJuZXNzLiBXZSBhc3N1bWUgdGFyZ2V0cyBwYXNzZWQgaW50byBhbiBhbmltYXRpb24gd2lsbCBiZSBvZiBzaW1pbGFyIHR5cGUsIG1lYW5pbmcgdGhlIHNhbWUga2luZCBvZiBoYXJuZXNzIGNhbiBiZSB1c2VkIGZvciB0aGVtIGFsbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgIGkgPSBfaGFybmVzc1BsdWdpbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgIGhhcm5lc3NQbHVnaW4gPSBfaGFybmVzc1BsdWdpbnNbaV07XG4gIH1cblxuICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHRhcmdldHNbaV0gJiYgKHRhcmdldHNbaV0uX2dzYXAgfHwgKHRhcmdldHNbaV0uX2dzYXAgPSBuZXcgR1NDYWNoZSh0YXJnZXRzW2ldLCBoYXJuZXNzUGx1Z2luKSkpIHx8IHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldHM7XG59LFxuICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0b0FycmF5KHRhcmdldCkpWzBdLl9nc2FwO1xufSxcbiAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xuICByZXR1cm4gKHYgPSB0YXJnZXRbcHJvcGVydHldKSAmJiBfaXNGdW5jdGlvbih2KSA/IHRhcmdldFtwcm9wZXJ0eV0oKSA6IF9pc1VuZGVmaW5lZCh2KSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUocHJvcGVydHkpIHx8IHY7XG59LFxuICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICByZXR1cm4gKG5hbWVzID0gbmFtZXMuc3BsaXQoXCIsXCIpKS5mb3JFYWNoKGZ1bmMpIHx8IG5hbWVzO1xufSxcbiAgICAvL3NwbGl0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgbmFtZXMgaW50byBhbiBhcnJheSwgdGhlbiBydW4gYSBmb3JFYWNoKCkgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgc3BsaXQgYXJyYXkgKHRoaXMgaXMganVzdCBhIHdheSB0byBjb25zb2xpZGF0ZS9zaG9ydGVuIHNvbWUgY29kZSkuXG5fcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwMDApIC8gMTAwMDAwMDAgfHwgMDtcbn0sXG4gICAgLy8gaW5jcmVhc2VkIHByZWNpc2lvbiBtb3N0bHkgZm9yIHRpbWluZyB2YWx1ZXMuXG5fYXJyYXlDb250YWluc0FueSA9IGZ1bmN0aW9uIF9hcnJheUNvbnRhaW5zQW55KHRvU2VhcmNoLCB0b0ZpbmQpIHtcbiAgLy9zZWFyY2hlcyBvbmUgYXJyYXkgdG8gZmluZCBtYXRjaGVzIGZvciBhbnkgb2YgdGhlIGl0ZW1zIGluIHRoZSB0b0ZpbmQgYXJyYXkuIEFzIHNvb24gYXMgb25lIGlzIGZvdW5kLCBpdCByZXR1cm5zIHRydWUuIEl0IGRvZXMgTk9UIHJldHVybiBhbGwgdGhlIG1hdGNoZXM7IGl0J3Mgc2ltcGx5IGEgYm9vbGVhbiBzZWFyY2guXG4gIHZhciBsID0gdG9GaW5kLmxlbmd0aCxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyB0b1NlYXJjaC5pbmRleE9mKHRvRmluZFtpXSkgPCAwICYmICsraSA8IGw7KSB7fVxuXG4gIHJldHVybiBpIDwgbDtcbn0sXG4gICAgX2xhenlSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVJlbmRlcigpIHtcbiAgdmFyIGwgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG4gICAgICBhID0gX2xhenlUd2VlbnMuc2xpY2UoMCksXG4gICAgICBpLFxuICAgICAgdHdlZW47XG5cbiAgX2xhenlMb29rdXAgPSB7fTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdHdlZW4gPSBhW2ldO1xuICAgIHR3ZWVuICYmIHR3ZWVuLl9sYXp5ICYmICh0d2Vlbi5yZW5kZXIodHdlZW4uX2xhenlbMF0sIHR3ZWVuLl9sYXp5WzFdLCB0cnVlKS5fbGF6eSA9IDApO1xuICB9XG59LFxuICAgIF9sYXp5U2FmZVJlbmRlciA9IGZ1bmN0aW9uIF9sYXp5U2FmZVJlbmRlcihhbmltYXRpb24sIHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTtcbiAgYW5pbWF0aW9uLnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIHNvbWVvbmUgY2FsbHMgc2VlaygpIG9yIHRpbWUoKSBvciBwcm9ncmVzcygpLCB0aGV5IGV4cGVjdCBhbiBpbW1lZGlhdGUgcmVuZGVyLlxufSxcbiAgICBfbnVtZXJpY0lmUG9zc2libGUgPSBmdW5jdGlvbiBfbnVtZXJpY0lmUG9zc2libGUodmFsdWUpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgcmV0dXJuIChuIHx8IG4gPT09IDApICYmICh2YWx1ZSArIFwiXCIpLm1hdGNoKF9kZWxpbWl0ZWRWYWx1ZUV4cCkubGVuZ3RoIDwgMiA/IG4gOiBfaXNTdHJpbmcodmFsdWUpID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG59LFxuICAgIF9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uIF9wYXNzVGhyb3VnaChwKSB7XG4gIHJldHVybiBwO1xufSxcbiAgICBfc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0RGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgcCBpbiBvYmogfHwgKG9ialtwXSA9IGRlZmF1bHRzW3BdKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF9zZXRLZXlmcmFtZURlZmF1bHRzID0gZnVuY3Rpb24gX3NldEtleWZyYW1lRGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgcCBpbiBvYmogfHwgcCA9PT0gXCJkdXJhdGlvblwiIHx8IHAgPT09IFwiZWFzZVwiIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cbn0sXG4gICAgX21lcmdlID0gZnVuY3Rpb24gX21lcmdlKGJhc2UsIHRvTWVyZ2UpIHtcbiAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgYmFzZVtwXSA9IHRvTWVyZ2VbcF07XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX21lcmdlRGVlcCA9IGZ1bmN0aW9uIF9tZXJnZURlZXAoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBwICE9PSBcIl9fcHJvdG9fX1wiICYmIHAgIT09IFwiY29uc3RydWN0b3JcIiAmJiBwICE9PSBcInByb3RvdHlwZVwiICYmIChiYXNlW3BdID0gX2lzT2JqZWN0KHRvTWVyZ2VbcF0pID8gX21lcmdlRGVlcChiYXNlW3BdIHx8IChiYXNlW3BdID0ge30pLCB0b01lcmdlW3BdKSA6IHRvTWVyZ2VbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59LFxuICAgIF9jb3B5RXhjbHVkaW5nID0gZnVuY3Rpb24gX2NvcHlFeGNsdWRpbmcob2JqLCBleGNsdWRpbmcpIHtcbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIG9iaikge1xuICAgIHAgaW4gZXhjbHVkaW5nIHx8IChjb3B5W3BdID0gb2JqW3BdKTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfaW5oZXJpdERlZmF1bHRzID0gZnVuY3Rpb24gX2luaGVyaXREZWZhdWx0cyh2YXJzKSB7XG4gIHZhciBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICBmdW5jID0gdmFycy5rZXlmcmFtZXMgPyBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA6IF9zZXREZWZhdWx0cztcblxuICBpZiAoX2lzTm90RmFsc2UodmFycy5pbmhlcml0KSkge1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGZ1bmModmFycywgcGFyZW50LnZhcnMuZGVmYXVsdHMpO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCB8fCBwYXJlbnQuX2RwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YXJzO1xufSxcbiAgICBfYXJyYXlzTWF0Y2ggPSBmdW5jdGlvbiBfYXJyYXlzTWF0Y2goYTEsIGEyKSB7XG4gIHZhciBpID0gYTEubGVuZ3RoLFxuICAgICAgbWF0Y2ggPSBpID09PSBhMi5sZW5ndGg7XG5cbiAgd2hpbGUgKG1hdGNoICYmIGktLSAmJiBhMVtpXSA9PT0gYTJbaV0pIHt9XG5cbiAgcmV0dXJuIGkgPCAwO1xufSxcbiAgICBfYWRkTGlua2VkTGlzdEl0ZW0gPSBmdW5jdGlvbiBfYWRkTGlua2VkTGlzdEl0ZW0ocGFyZW50LCBjaGlsZCwgZmlyc3RQcm9wLCBsYXN0UHJvcCwgc29ydEJ5KSB7XG4gIGlmIChmaXJzdFByb3AgPT09IHZvaWQgMCkge1xuICAgIGZpcnN0UHJvcCA9IFwiX2ZpcnN0XCI7XG4gIH1cblxuICBpZiAobGFzdFByb3AgPT09IHZvaWQgMCkge1xuICAgIGxhc3RQcm9wID0gXCJfbGFzdFwiO1xuICB9XG5cbiAgdmFyIHByZXYgPSBwYXJlbnRbbGFzdFByb3BdLFxuICAgICAgdDtcblxuICBpZiAoc29ydEJ5KSB7XG4gICAgdCA9IGNoaWxkW3NvcnRCeV07XG5cbiAgICB3aGlsZSAocHJldiAmJiBwcmV2W3NvcnRCeV0gPiB0KSB7XG4gICAgICBwcmV2ID0gcHJldi5fcHJldjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIGNoaWxkLl9uZXh0ID0gcHJldi5fbmV4dDtcbiAgICBwcmV2Ll9uZXh0ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGQuX25leHQgPSBwYXJlbnRbZmlyc3RQcm9wXTtcbiAgICBwYXJlbnRbZmlyc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgaWYgKGNoaWxkLl9uZXh0KSB7XG4gICAgY2hpbGQuX25leHQuX3ByZXYgPSBjaGlsZDtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRbbGFzdFByb3BdID0gY2hpbGQ7XG4gIH1cblxuICBjaGlsZC5fcHJldiA9IHByZXY7XG4gIGNoaWxkLnBhcmVudCA9IGNoaWxkLl9kcCA9IHBhcmVudDtcbiAgcmV0dXJuIGNoaWxkO1xufSxcbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0gPSBmdW5jdGlvbiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0ocGFyZW50LCBjaGlsZCwgZmlyc3RQcm9wLCBsYXN0UHJvcCkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gY2hpbGQuX3ByZXYsXG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Ll9uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIGlmIChwYXJlbnRbZmlyc3RQcm9wXSA9PT0gY2hpbGQpIHtcbiAgICBwYXJlbnRbZmlyc3RQcm9wXSA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQuX3ByZXYgPSBwcmV2O1xuICB9IGVsc2UgaWYgKHBhcmVudFtsYXN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IHByZXY7XG4gIH1cblxuICBjaGlsZC5fbmV4dCA9IGNoaWxkLl9wcmV2ID0gY2hpbGQucGFyZW50ID0gbnVsbDsgLy8gZG9uJ3QgZGVsZXRlIHRoZSBfZHAganVzdCBzbyB3ZSBjYW4gcmV2ZXJ0IGlmIG5lY2Vzc2FyeS4gQnV0IHBhcmVudCBzaG91bGQgYmUgbnVsbCB0byBpbmRpY2F0ZSB0aGUgaXRlbSBpc24ndCBpbiBhIGxpbmtlZCBsaXN0LlxufSxcbiAgICBfcmVtb3ZlRnJvbVBhcmVudCA9IGZ1bmN0aW9uIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkLCBvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlKSB7XG4gIGNoaWxkLnBhcmVudCAmJiAoIW9ubHlJZlBhcmVudEhhc0F1dG9SZW1vdmUgfHwgY2hpbGQucGFyZW50LmF1dG9SZW1vdmVDaGlsZHJlbikgJiYgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gIGNoaWxkLl9hY3QgPSAwO1xufSxcbiAgICBfdW5jYWNoZSA9IGZ1bmN0aW9uIF91bmNhY2hlKGFuaW1hdGlvbiwgY2hpbGQpIHtcbiAgaWYgKGFuaW1hdGlvbiAmJiAoIWNoaWxkIHx8IGNoaWxkLl9lbmQgPiBhbmltYXRpb24uX2R1ciB8fCBjaGlsZC5fc3RhcnQgPCAwKSkge1xuICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogaWYgYSBjaGlsZCBhbmltYXRpb24gaXMgcGFzc2VkIGluIHdlIHNob3VsZCBvbmx5IHVuY2FjaGUgaWYgdGhhdCBjaGlsZCBFWFRFTkRTIHRoZSBhbmltYXRpb24gKGl0cyBlbmQgdGltZSBpcyBiZXlvbmQgdGhlIGVuZClcbiAgICB2YXIgYSA9IGFuaW1hdGlvbjtcblxuICAgIHdoaWxlIChhKSB7XG4gICAgICBhLl9kaXJ0eSA9IDE7XG4gICAgICBhID0gYS5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3JlY2FjaGVBbmNlc3RvcnMgPSBmdW5jdGlvbiBfcmVjYWNoZUFuY2VzdG9ycyhhbmltYXRpb24pIHtcbiAgdmFyIHBhcmVudCA9IGFuaW1hdGlvbi5wYXJlbnQ7XG5cbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgLy9zb21ldGltZXMgd2UgbXVzdCBmb3JjZSBhIHJlLXNvcnQgb2YgYWxsIGNoaWxkcmVuIGFuZCB1cGRhdGUgdGhlIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gb2YgYWxsIGFuY2VzdG9yIHRpbWVsaW5lcyBpbW1lZGlhdGVseSBpbiBjYXNlLCBmb3IgZXhhbXBsZSwgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciBsb29wLCBvbmUgdHdlZW4gYWx0ZXJzIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgd2hpY2ggc2hvdmVzIGl0cyBzdGFydFRpbWUgYmVmb3JlIDAsIGZvcmNpbmcgdGhlIHBhcmVudCB0aW1lbGluZSB0byBzaGlmdCBhcm91bmQgYW5kIHNoaWZ0Q2hpbGRyZW4oKSB3aGljaCBjb3VsZCBhZmZlY3QgdGhhdCBuZXh0IHR3ZWVuJ3MgcmVuZGVyIChzdGFydFRpbWUpLiBEb2Vzbid0IG1hdHRlciBmb3IgdGhlIHJvb3QgdGltZWxpbmUgdGhvdWdoLlxuICAgIHBhcmVudC5fZGlydHkgPSAxO1xuICAgIHBhcmVudC50b3RhbER1cmF0aW9uKCk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyA9IGZ1bmN0aW9uIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhhbmltYXRpb24pIHtcbiAgcmV0dXJuICFhbmltYXRpb24gfHwgYW5pbWF0aW9uLl90cyAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uLnBhcmVudCk7XG59LFxuICAgIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbiA9IGZ1bmN0aW9uIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbihhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fcmVwZWF0ID8gX2FuaW1hdGlvbkN5Y2xlKGFuaW1hdGlvbi5fdFRpbWUsIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpICsgYW5pbWF0aW9uLl9yRGVsYXkpICogYW5pbWF0aW9uIDogMDtcbn0sXG4gICAgLy8gZmVlZCBpbiB0aGUgdG90YWxUaW1lIGFuZCBjeWNsZUR1cmF0aW9uIGFuZCBpdCdsbCByZXR1cm4gdGhlIGN5Y2xlIChpdGVyYXRpb24gbWludXMgMSkgYW5kIGlmIHRoZSBwbGF5aGVhZCBpcyBleGFjdGx5IGF0IHRoZSB2ZXJ5IEVORCwgaXQgd2lsbCBOT1QgYnVtcCB1cCB0byB0aGUgbmV4dCBjeWNsZS5cbl9hbmltYXRpb25DeWNsZSA9IGZ1bmN0aW9uIF9hbmltYXRpb25DeWNsZSh0VGltZSwgY3ljbGVEdXJhdGlvbikge1xuICB2YXIgd2hvbGUgPSBNYXRoLmZsb29yKHRUaW1lIC89IGN5Y2xlRHVyYXRpb24pO1xuICByZXR1cm4gdFRpbWUgJiYgd2hvbGUgPT09IHRUaW1lID8gd2hvbGUgLSAxIDogd2hvbGU7XG59LFxuICAgIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lID0gZnVuY3Rpb24gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50VGltZSwgY2hpbGQpIHtcbiAgcmV0dXJuIChwYXJlbnRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyArIChjaGlsZC5fdHMgPj0gMCA/IDAgOiBjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cik7XG59LFxuICAgIF9zZXRFbmQgPSBmdW5jdGlvbiBfc2V0RW5kKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uLl9lbmQgPSBfcm91bmRQcmVjaXNlKGFuaW1hdGlvbi5fc3RhcnQgKyAoYW5pbWF0aW9uLl90RHVyIC8gTWF0aC5hYnMoYW5pbWF0aW9uLl90cyB8fCBhbmltYXRpb24uX3J0cyB8fCBfdGlueU51bSkgfHwgMCkpO1xufSxcbiAgICBfYWxpZ25QbGF5aGVhZCA9IGZ1bmN0aW9uIF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgdG90YWxUaW1lKSB7XG4gIC8vIGFkanVzdHMgdGhlIGFuaW1hdGlvbidzIF9zdGFydCBhbmQgX2VuZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHRvdGFsVGltZSAob25seSBpZiB0aGUgcGFyZW50J3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSBhbmQgdGhlIGFuaW1hdGlvbiBpc24ndCBwYXVzZWQpLiBJdCBkb2Vzbid0IGRvIGFueSByZW5kZXJpbmcgb3IgZm9yY2luZyB0aGluZ3MgYmFjayBpbnRvIHBhcmVudCB0aW1lbGluZXMsIGV0Yy4gLSB0aGF0J3Mgd2hhdCB0b3RhbFRpbWUoKSBpcyBmb3IuXG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24uX2RwO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIGFuaW1hdGlvbi5fdHMpIHtcbiAgICBhbmltYXRpb24uX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShwYXJlbnQuX3RpbWUgLSAoYW5pbWF0aW9uLl90cyA+IDAgPyB0b3RhbFRpbWUgLyBhbmltYXRpb24uX3RzIDogKChhbmltYXRpb24uX2RpcnR5ID8gYW5pbWF0aW9uLnRvdGFsRHVyYXRpb24oKSA6IGFuaW1hdGlvbi5fdER1cikgLSB0b3RhbFRpbWUpIC8gLWFuaW1hdGlvbi5fdHMpKTtcblxuICAgIF9zZXRFbmQoYW5pbWF0aW9uKTtcblxuICAgIHBhcmVudC5fZGlydHkgfHwgX3VuY2FjaGUocGFyZW50LCBhbmltYXRpb24pOyAvL2ZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSWYgdGhlIHBhcmVudCdzIGNhY2hlIGlzIGFscmVhZHkgZGlydHksIGl0IGFscmVhZHkgdG9vayBjYXJlIG9mIG1hcmtpbmcgdGhlIGFuY2VzdG9ycyBhcyBkaXJ0eSB0b28sIHNvIHNraXAgdGhlIGZ1bmN0aW9uIGNhbGwgaGVyZS5cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuXG4vKlxuX3RvdGFsVGltZVRvVGltZSA9IChjbGFtcGVkVG90YWxUaW1lLCBkdXJhdGlvbiwgcmVwZWF0LCByZXBlYXREZWxheSwgeW95bykgPT4ge1xuXHRsZXQgY3ljbGVEdXJhdGlvbiA9IGR1cmF0aW9uICsgcmVwZWF0RGVsYXksXG5cdFx0dGltZSA9IF9yb3VuZChjbGFtcGVkVG90YWxUaW1lICUgY3ljbGVEdXJhdGlvbik7XG5cdGlmICh0aW1lID4gZHVyYXRpb24pIHtcblx0XHR0aW1lID0gZHVyYXRpb247XG5cdH1cblx0cmV0dXJuICh5b3lvICYmICh+fihjbGFtcGVkVG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgJiAxKSkgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xufSxcbiovXG5fcG9zdEFkZENoZWNrcyA9IGZ1bmN0aW9uIF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCkge1xuICB2YXIgdDtcblxuICBpZiAoY2hpbGQuX3RpbWUgfHwgY2hpbGQuX2luaXR0ZWQgJiYgIWNoaWxkLl9kdXIpIHtcbiAgICAvL2luIGNhc2UsIGZvciBleGFtcGxlLCB0aGUgX3N0YXJ0IGlzIG1vdmVkIG9uIGEgdHdlZW4gdGhhdCBoYXMgYWxyZWFkeSByZW5kZXJlZC4gSW1hZ2luZSBpdCdzIGF0IGl0cyBlbmQgc3RhdGUsIHRoZW4gdGhlIHN0YXJ0VGltZSBpcyBtb3ZlZCBXQVkgbGF0ZXIgKGFmdGVyIHRoZSBlbmQgb2YgdGhpcyB0aW1lbGluZSksIGl0IHNob3VsZCByZW5kZXIgYXQgaXRzIGJlZ2lubmluZy5cbiAgICB0ID0gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZWxpbmUucmF3VGltZSgpLCBjaGlsZCk7XG5cbiAgICBpZiAoIWNoaWxkLl9kdXIgfHwgX2NsYW1wKDAsIGNoaWxkLnRvdGFsRHVyYXRpb24oKSwgdCkgLSBjaGlsZC5fdFRpbWUgPiBfdGlueU51bSkge1xuICAgICAgY2hpbGQucmVuZGVyKHQsIHRydWUpO1xuICAgIH1cbiAgfSAvL2lmIHRoZSB0aW1lbGluZSBoYXMgYWxyZWFkeSBlbmRlZCBidXQgdGhlIGluc2VydGVkIHR3ZWVuL3RpbWVsaW5lIGV4dGVuZHMgdGhlIGR1cmF0aW9uLCB3ZSBzaG91bGQgZW5hYmxlIHRoaXMgdGltZWxpbmUgYWdhaW4gc28gdGhhdCBpdCByZW5kZXJzIHByb3Blcmx5LiBXZSBzaG91bGQgYWxzbyBhbGlnbiB0aGUgcGxheWhlYWQgd2l0aCB0aGUgcGFyZW50IHRpbWVsaW5lJ3Mgd2hlbiBhcHByb3ByaWF0ZS5cblxuXG4gIGlmIChfdW5jYWNoZSh0aW1lbGluZSwgY2hpbGQpLl9kcCAmJiB0aW1lbGluZS5faW5pdHRlZCAmJiB0aW1lbGluZS5fdGltZSA+PSB0aW1lbGluZS5fZHVyICYmIHRpbWVsaW5lLl90cykge1xuICAgIC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9ycyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQuLi5cbiAgICBpZiAodGltZWxpbmUuX2R1ciA8IHRpbWVsaW5lLmR1cmF0aW9uKCkpIHtcbiAgICAgIHQgPSB0aW1lbGluZTtcblxuICAgICAgd2hpbGUgKHQuX2RwKSB7XG4gICAgICAgIHQucmF3VGltZSgpID49IDAgJiYgdC50b3RhbFRpbWUodC5fdFRpbWUpOyAvL21vdmVzIHRoZSB0aW1lbGluZSAoc2hpZnRzIGl0cyBzdGFydFRpbWUpIGlmIG5lY2Vzc2FyeSwgYW5kIGFsc28gZW5hYmxlcyBpdC4gSWYgaXQncyBjdXJyZW50bHkgemVybywgdGhvdWdoLCBpdCBtYXkgbm90IGJlIHNjaGVkdWxlZCB0byByZW5kZXIgdW50aWwgbGF0ZXIgc28gdGhlcmUncyBubyBuZWVkIHRvIGZvcmNlIGl0IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgcGxheWhlYWQgcG9zaXRpb24uIE9ubHkgbW92ZSB0byBjYXRjaCB1cCB3aXRoIHRoZSBwbGF5aGVhZC5cblxuICAgICAgICB0ID0gdC5fZHA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGltZWxpbmUuX3pUaW1lID0gLV90aW55TnVtOyAvLyBoZWxwcyBlbnN1cmUgdGhhdCB0aGUgbmV4dCByZW5kZXIoKSB3aWxsIGJlIGZvcmNlZCAoY3Jvc3NpbmdTdGFydCA9IHRydWUgaW4gcmVuZGVyKCkpLCBldmVuIGlmIHRoZSBkdXJhdGlvbiBoYXNuJ3QgY2hhbmdlZCAod2UncmUgYWRkaW5nIGEgY2hpbGQgd2hpY2ggd291bGQgbmVlZCB0byBnZXQgcmVuZGVyZWQpLiBEZWZpbml0ZWx5IGFuIGVkZ2UgY2FzZS4gTm90ZTogd2UgTVVTVCBkbyB0aGlzIEFGVEVSIHRoZSBsb29wIGFib3ZlIHdoZXJlIHRoZSB0b3RhbFRpbWUoKSBtaWdodCB0cmlnZ2VyIGEgcmVuZGVyKCkgYmVjYXVzZSB0aGlzIF9hZGRUb1RpbWVsaW5lKCkgbWV0aG9kIGdldHMgY2FsbGVkIGZyb20gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgQkVGT1JFIHR3ZWVucyBldmVuIHJlY29yZCB0aGVpciB0YXJnZXRzLCBldGMuIHNvIHdlIHdvdWxkbid0IHdhbnQgdGhpbmdzIHRvIGdldCB0cmlnZ2VyZWQgaW4gdGhlIHdyb25nIG9yZGVyLlxuICB9XG59LFxuICAgIF9hZGRUb1RpbWVsaW5lID0gZnVuY3Rpb24gX2FkZFRvVGltZWxpbmUodGltZWxpbmUsIGNoaWxkLCBwb3NpdGlvbiwgc2tpcENoZWNrcykge1xuICBjaGlsZC5wYXJlbnQgJiYgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICBjaGlsZC5fc3RhcnQgPSBfcm91bmRQcmVjaXNlKChfaXNOdW1iZXIocG9zaXRpb24pID8gcG9zaXRpb24gOiBwb3NpdGlvbiB8fCB0aW1lbGluZSAhPT0gX2dsb2JhbFRpbWVsaW5lID8gX3BhcnNlUG9zaXRpb24odGltZWxpbmUsIHBvc2l0aW9uLCBjaGlsZCkgOiB0aW1lbGluZS5fdGltZSkgKyBjaGlsZC5fZGVsYXkpO1xuICBjaGlsZC5fZW5kID0gX3JvdW5kUHJlY2lzZShjaGlsZC5fc3RhcnQgKyAoY2hpbGQudG90YWxEdXJhdGlvbigpIC8gTWF0aC5hYnMoY2hpbGQudGltZVNjYWxlKCkpIHx8IDApKTtcblxuICBfYWRkTGlua2VkTGlzdEl0ZW0odGltZWxpbmUsIGNoaWxkLCBcIl9maXJzdFwiLCBcIl9sYXN0XCIsIHRpbWVsaW5lLl9zb3J0ID8gXCJfc3RhcnRcIiA6IDApO1xuXG4gIF9pc0Zyb21PckZyb21TdGFydChjaGlsZCkgfHwgKHRpbWVsaW5lLl9yZWNlbnQgPSBjaGlsZCk7XG4gIHNraXBDaGVja3MgfHwgX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKTtcbiAgcmV0dXJuIHRpbWVsaW5lO1xufSxcbiAgICBfc2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zY3JvbGxUcmlnZ2VyKGFuaW1hdGlvbiwgdHJpZ2dlcikge1xuICByZXR1cm4gKF9nbG9iYWxzLlNjcm9sbFRyaWdnZXIgfHwgX21pc3NpbmdQbHVnaW4oXCJzY3JvbGxUcmlnZ2VyXCIsIHRyaWdnZXIpKSAmJiBfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSh0cmlnZ2VyLCBhbmltYXRpb24pO1xufSxcbiAgICBfYXR0ZW1wdEluaXRUd2VlbiA9IGZ1bmN0aW9uIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykge1xuICBfaW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUpO1xuXG4gIGlmICghdHdlZW4uX2luaXR0ZWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmICghZm9yY2UgJiYgdHdlZW4uX3B0ICYmICh0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSAhPT0gZmFsc2UgfHwgIXR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5KSAmJiBfbGFzdFJlbmRlcmVkRnJhbWUgIT09IF90aWNrZXIuZnJhbWUpIHtcbiAgICBfbGF6eVR3ZWVucy5wdXNoKHR3ZWVuKTtcblxuICAgIHR3ZWVuLl9sYXp5ID0gW3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHNdO1xuICAgIHJldHVybiAxO1xuICB9XG59LFxuICAgIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQgPSBmdW5jdGlvbiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KF9yZWYpIHtcbiAgdmFyIHBhcmVudCA9IF9yZWYucGFyZW50O1xuICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5fdHMgJiYgcGFyZW50Ll9pbml0dGVkICYmICFwYXJlbnQuX2xvY2sgJiYgKHBhcmVudC5yYXdUaW1lKCkgPCAwIHx8IF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQocGFyZW50KSk7XG59LFxuICAgIC8vIGNoZWNrIHBhcmVudCdzIF9sb2NrIGJlY2F1c2Ugd2hlbiBhIHRpbWVsaW5lIHJlcGVhdHMveW95b3MgYW5kIGRvZXMgaXRzIGFydGlmaWNpYWwgd3JhcHBpbmcsIHdlIHNob3VsZG4ndCBmb3JjZSB0aGUgcmF0aW8gYmFjayB0byAwXG5faXNGcm9tT3JGcm9tU3RhcnQgPSBmdW5jdGlvbiBfaXNGcm9tT3JGcm9tU3RhcnQoX3JlZjIpIHtcbiAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhO1xuICByZXR1cm4gZGF0YSA9PT0gXCJpc0Zyb21TdGFydFwiIHx8IGRhdGEgPT09IFwiaXNTdGFydFwiO1xufSxcbiAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4gPSBmdW5jdGlvbiBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIHZhciBwcmV2UmF0aW8gPSB0d2Vlbi5yYXRpbyxcbiAgICAgIHJhdGlvID0gdG90YWxUaW1lIDwgMCB8fCAhdG90YWxUaW1lICYmICghdHdlZW4uX3N0YXJ0ICYmIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQodHdlZW4pICYmICEoIXR3ZWVuLl9pbml0dGVkICYmIF9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpIHx8ICh0d2Vlbi5fdHMgPCAwIHx8IHR3ZWVuLl9kcC5fdHMgPCAwKSAmJiAhX2lzRnJvbU9yRnJvbVN0YXJ0KHR3ZWVuKSkgPyAwIDogMSxcbiAgICAgIC8vIGlmIHRoZSB0d2VlbiBvciBpdHMgcGFyZW50IGlzIHJldmVyc2VkIGFuZCB0aGUgdG90YWxUaW1lIGlzIDAsIHdlIHNob3VsZCBnbyB0byBhIHJhdGlvIG9mIDAuIEVkZ2UgY2FzZTogaWYgYSBmcm9tKCkgb3IgZnJvbVRvKCkgc3RhZ2dlciB0d2VlbiBpcyBwbGFjZWQgbGF0ZXIgaW4gYSB0aW1lbGluZSwgdGhlIFwic3RhcnRBdFwiIHplcm8tZHVyYXRpb24gdHdlZW4gY291bGQgaW5pdGlhbGx5IHJlbmRlciBhdCBhIHRpbWUgd2hlbiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgaXMgdGVjaG5pY2FsbHkgQkVGT1JFIHdoZXJlIHRoaXMgdHdlZW4gaXMsIHNvIG1ha2Ugc3VyZSB0aGF0IGFueSBcImZyb21cIiBhbmQgXCJmcm9tVG9cIiBzdGFydEF0IHR3ZWVucyBhcmUgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUgYXQgYSByYXRpbyBvZiAxLlxuICByZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG4gICAgICB0VGltZSA9IDAsXG4gICAgICBwdCxcbiAgICAgIGl0ZXJhdGlvbixcbiAgICAgIHByZXZJdGVyYXRpb247XG5cbiAgaWYgKHJlcGVhdERlbGF5ICYmIHR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvLyBpbiBjYXNlIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHRoYXQgaGFzIGEgcmVwZWF0IHdpdGggYSByZXBlYXREZWxheVxuICAgIHRUaW1lID0gX2NsYW1wKDAsIHR3ZWVuLl90RHVyLCB0b3RhbFRpbWUpO1xuICAgIGl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0VGltZSwgcmVwZWF0RGVsYXkpO1xuICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSk7XG4gICAgdHdlZW4uX3lveW8gJiYgaXRlcmF0aW9uICYgMSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuXG4gICAgaWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgcHJldlJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgdHdlZW4udmFycy5yZXBlYXRSZWZyZXNoICYmIHR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmF0aW8gIT09IHByZXZSYXRpbyB8fCBmb3JjZSB8fCB0d2Vlbi5felRpbWUgPT09IF90aW55TnVtIHx8ICF0b3RhbFRpbWUgJiYgdHdlZW4uX3pUaW1lKSB7XG4gICAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG4gICAgICAvLyBpZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJldkl0ZXJhdGlvbiA9IHR3ZWVuLl96VGltZTtcbiAgICB0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWUgfHwgKHN1cHByZXNzRXZlbnRzID8gX3RpbnlOdW0gOiAwKTsgLy8gd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cbiAgICBzdXBwcmVzc0V2ZW50cyB8fCAoc3VwcHJlc3NFdmVudHMgPSB0b3RhbFRpbWUgJiYgIXByZXZJdGVyYXRpb24pOyAvLyBpZiBpdCB3YXMgcmVuZGVyZWQgcHJldmlvdXNseSBhdCBleGFjdGx5IDAgKF96VGltZSkgYW5kIG5vdyB0aGUgcGxheWhlYWQgaXMgbW92aW5nIGF3YXksIERPTidUIGZpcmUgY2FsbGJhY2tzIG90aGVyd2lzZSB0aGV5J2xsIHNlZW0gbGlrZSBkdXBsaWNhdGVzLlxuXG4gICAgdHdlZW4ucmF0aW8gPSByYXRpbztcbiAgICB0d2Vlbi5fZnJvbSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuICAgIHR3ZWVuLl90aW1lID0gMDtcbiAgICB0d2Vlbi5fdFRpbWUgPSB0VGltZTtcbiAgICBwdCA9IHR3ZWVuLl9wdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHR3ZWVuLl9zdGFydEF0ICYmIHRvdGFsVGltZSA8IDAgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgdHdlZW4uX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XG4gICAgdFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50ICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblJlcGVhdFwiKTtcblxuICAgIGlmICgodG90YWxUaW1lID49IHR3ZWVuLl90RHVyIHx8IHRvdGFsVGltZSA8IDApICYmIHR3ZWVuLnJhdGlvID09PSByYXRpbykge1xuICAgICAgcmF0aW8gJiYgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4sIDEpO1xuXG4gICAgICBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIF9jYWxsYmFjayh0d2VlbiwgcmF0aW8gPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdHdlZW4uX3Byb20gJiYgdHdlZW4uX3Byb20oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIXR3ZWVuLl96VGltZSkge1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZTtcbiAgfVxufSxcbiAgICBfZmluZE5leHRQYXVzZVR3ZWVuID0gZnVuY3Rpb24gX2ZpbmROZXh0UGF1c2VUd2VlbihhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSB7XG4gIHZhciBjaGlsZDtcblxuICBpZiAodGltZSA+IHByZXZUaW1lKSB7XG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG4gICAgICBpZiAoIWNoaWxkLl9kdXIgJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblxuICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPj0gdGltZSkge1xuICAgICAgaWYgKCFjaGlsZC5fZHVyICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3NldER1cmF0aW9uID0gZnVuY3Rpb24gX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgZHVyYXRpb24sIHNraXBVbmNhY2hlLCBsZWF2ZVBsYXloZWFkKSB7XG4gIHZhciByZXBlYXQgPSBhbmltYXRpb24uX3JlcGVhdCxcbiAgICAgIGR1ciA9IF9yb3VuZFByZWNpc2UoZHVyYXRpb24pIHx8IDAsXG4gICAgICB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cjtcbiAgdG90YWxQcm9ncmVzcyAmJiAhbGVhdmVQbGF5aGVhZCAmJiAoYW5pbWF0aW9uLl90aW1lICo9IGR1ciAvIGFuaW1hdGlvbi5fZHVyKTtcbiAgYW5pbWF0aW9uLl9kdXIgPSBkdXI7XG4gIGFuaW1hdGlvbi5fdER1ciA9ICFyZXBlYXQgPyBkdXIgOiByZXBlYXQgPCAwID8gMWUxMCA6IF9yb3VuZFByZWNpc2UoZHVyICogKHJlcGVhdCArIDEpICsgYW5pbWF0aW9uLl9yRGVsYXkgKiByZXBlYXQpO1xuICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkID8gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCBhbmltYXRpb24uX3RUaW1lID0gYW5pbWF0aW9uLl90RHVyICogdG90YWxQcm9ncmVzcykgOiBhbmltYXRpb24ucGFyZW50ICYmIF9zZXRFbmQoYW5pbWF0aW9uKTtcbiAgc2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24gaW5zdGFuY2VvZiBUaW1lbGluZSA/IF91bmNhY2hlKGFuaW1hdGlvbikgOiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24uX2R1cik7XG59LFxuICAgIF96ZXJvUG9zaXRpb24gPSB7XG4gIF9zdGFydDogMCxcbiAgZW5kVGltZTogX2VtcHR5RnVuYyxcbiAgdG90YWxEdXJhdGlvbjogX2VtcHR5RnVuY1xufSxcbiAgICBfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24sIHBlcmNlbnRBbmltYXRpb24pIHtcbiAgdmFyIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG4gICAgICByZWNlbnQgPSBhbmltYXRpb24uX3JlY2VudCB8fCBfemVyb1Bvc2l0aW9uLFxuICAgICAgY2xpcHBlZER1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgPj0gX2JpZ051bSA/IHJlY2VudC5lbmRUaW1lKGZhbHNlKSA6IGFuaW1hdGlvbi5fZHVyLFxuICAgICAgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjaGlsZCB0aGF0IGluZmluaXRlbHkgcmVwZWF0cywgdXNlcnMgYWxtb3N0IG5ldmVyIGludGVuZCBmb3IgdGhlIGluc2VydGlvbiBwb2ludCBvZiBhIG5ldyBjaGlsZCB0byBiZSBiYXNlZCBvbiBhIFNVUEVSIGxvbmcgdmFsdWUgbGlrZSB0aGF0IHNvIHdlIGNsaXAgaXQgYW5kIGFzc3VtZSB0aGUgbW9zdCByZWNlbnRseS1hZGRlZCBjaGlsZCdzIGVuZFRpbWUgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgaSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGlzUGVyY2VudDtcblxuICBpZiAoX2lzU3RyaW5nKHBvc2l0aW9uKSAmJiAoaXNOYU4ocG9zaXRpb24pIHx8IHBvc2l0aW9uIGluIGxhYmVscykpIHtcbiAgICAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuICAgIG9mZnNldCA9IHBvc2l0aW9uLmNoYXJBdCgwKTtcbiAgICBpc1BlcmNlbnQgPSBwb3NpdGlvbi5zdWJzdHIoLTEpID09PSBcIiVcIjtcbiAgICBpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XG5cbiAgICBpZiAob2Zmc2V0ID09PSBcIjxcIiB8fCBvZmZzZXQgPT09IFwiPlwiKSB7XG4gICAgICBpID49IDAgJiYgKHBvc2l0aW9uID0gcG9zaXRpb24ucmVwbGFjZSgvPS8sIFwiXCIpKTtcbiAgICAgIHJldHVybiAob2Zmc2V0ID09PSBcIjxcIiA/IHJlY2VudC5fc3RhcnQgOiByZWNlbnQuZW5kVGltZShyZWNlbnQuX3JlcGVhdCA+PSAwKSkgKyAocGFyc2VGbG9hdChwb3NpdGlvbi5zdWJzdHIoMSkpIHx8IDApICogKGlzUGVyY2VudCA/IChpIDwgMCA/IHJlY2VudCA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKSAvIDEwMCA6IDEpO1xuICAgIH1cblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgcG9zaXRpb24gaW4gbGFiZWxzIHx8IChsYWJlbHNbcG9zaXRpb25dID0gY2xpcHBlZER1cmF0aW9uKTtcbiAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuICAgIH1cblxuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGlzUGVyY2VudCAmJiBwZXJjZW50QW5pbWF0aW9uKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgLyAxMDAgKiAoX2lzQXJyYXkocGVyY2VudEFuaW1hdGlvbikgPyBwZXJjZW50QW5pbWF0aW9uWzBdIDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcbn0sXG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSA9IGZ1bmN0aW9uIF9jcmVhdGVUd2VlblR5cGUodHlwZSwgcGFyYW1zLCB0aW1lbGluZSkge1xuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgIHZhcnMgPSBwYXJhbXNbdmFyc0luZGV4XSxcbiAgICAgIGlyVmFycyxcbiAgICAgIHBhcmVudDtcblxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG4gIHZhcnMucGFyZW50ID0gdGltZWxpbmU7XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpclZhcnMgPSB2YXJzO1xuICAgIHBhcmVudCA9IHRpbWVsaW5lO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiAhKFwiaW1tZWRpYXRlUmVuZGVyXCIgaW4gaXJWYXJzKSkge1xuICAgICAgLy8gaW5oZXJpdGFuY2UgaGFzbid0IGhhcHBlbmVkIHlldCwgYnV0IHNvbWVvbmUgbWF5IGhhdmUgc2V0IGEgZGVmYXVsdCBpbiBhbiBhbmNlc3RvciB0aW1lbGluZS4gV2UgY291bGQgZG8gdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlcikgYnV0IHRoYXQnZCBleGFjdCBhIHNsaWdodCBwZXJmb3JtYW5jZSBwZW5hbHR5IGJlY2F1c2UgX2luaGVyaXREZWZhdWx0cygpIGFsc28gcnVucyBpbiB0aGUgVHdlZW4gY29uc3RydWN0b3IuIFdlJ3JlIHBheWluZyBhIHNtYWxsIGtiIHByaWNlIGhlcmUgdG8gZ2FpbiBzcGVlZC5cbiAgICAgIGlyVmFycyA9IHBhcmVudC52YXJzLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgcGFyZW50ID0gX2lzTm90RmFsc2UocGFyZW50LnZhcnMuaW5oZXJpdCkgJiYgcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKGlyVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHR5cGUgPCAyID8gdmFycy5ydW5CYWNrd2FyZHMgPSAxIDogdmFycy5zdGFydEF0ID0gcGFyYW1zW3ZhcnNJbmRleCAtIDFdOyAvLyBcImZyb21cIiB2YXJzXG4gIH1cblxuICByZXR1cm4gbmV3IFR3ZWVuKHBhcmFtc1swXSwgdmFycywgcGFyYW1zW3ZhcnNJbmRleCArIDFdKTtcbn0sXG4gICAgX2NvbmRpdGlvbmFsUmV0dXJuID0gZnVuY3Rpb24gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jKSB7XG4gIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IGZ1bmModmFsdWUpIDogZnVuYztcbn0sXG4gICAgX2NsYW1wID0gZnVuY3Rpb24gX2NsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xufSxcbiAgICBnZXRVbml0ID0gZnVuY3Rpb24gZ2V0VW5pdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICB2YXIgdiA9IF91bml0RXhwLmV4ZWModmFsdWUpO1xuXG4gIHJldHVybiB2ID8gdmFsdWUuc3Vic3RyKHYuaW5kZXggKyB2WzBdLmxlbmd0aCkgOiBcIlwiO1xufSxcbiAgICAvLyBub3RlOiBwcm90ZWN0IGFnYWluc3QgcGFkZGVkIG51bWJlcnMgYXMgc3RyaW5ncywgbGlrZSBcIjEwMC4xMDBcIi4gVGhhdCBzaG91bGRuJ3QgcmV0dXJuIFwiMDBcIiBhcyB0aGUgdW5pdC4gSWYgaXQncyBudW1lcmljLCByZXR1cm4gbm8gdW5pdC5cbmNsYW1wID0gZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIF9jbGFtcChtaW4sIG1heCwgdik7XG4gIH0pO1xufSxcbiAgICBfc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfaXNBcnJheUxpa2UgPSBmdW5jdGlvbiBfaXNBcnJheUxpa2UodmFsdWUsIG5vbkVtcHR5KSB7XG4gIHJldHVybiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWUpICYmIFwibGVuZ3RoXCIgaW4gdmFsdWUgJiYgKCFub25FbXB0eSAmJiAhdmFsdWUubGVuZ3RoIHx8IHZhbHVlLmxlbmd0aCAtIDEgaW4gdmFsdWUgJiYgX2lzT2JqZWN0KHZhbHVlWzBdKSkgJiYgIXZhbHVlLm5vZGVUeXBlICYmIHZhbHVlICE9PSBfd2luO1xufSxcbiAgICBfZmxhdHRlbiA9IGZ1bmN0aW9uIF9mbGF0dGVuKGFyLCBsZWF2ZVN0cmluZ3MsIGFjY3VtdWxhdG9yKSB7XG4gIGlmIChhY2N1bXVsYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBhci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBfYWNjdW11bGF0b3I7XG5cbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzIHx8IF9pc0FycmF5TGlrZSh2YWx1ZSwgMSkgPyAoX2FjY3VtdWxhdG9yID0gYWNjdW11bGF0b3IpLnB1c2guYXBwbHkoX2FjY3VtdWxhdG9yLCB0b0FycmF5KHZhbHVlKSkgOiBhY2N1bXVsYXRvci5wdXNoKHZhbHVlKTtcbiAgfSkgfHwgYWNjdW11bGF0b3I7XG59LFxuICAgIC8vdGFrZXMgYW55IHZhbHVlIGFuZCByZXR1cm5zIGFuIGFycmF5LiBJZiBpdCdzIGEgc3RyaW5nIChhbmQgbGVhdmVTdHJpbmdzIGlzbid0IHRydWUpLCBpdCdsbCB1c2UgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpIGFuZCBjb252ZXJ0IHRoYXQgdG8gYW4gYXJyYXkuIEl0J2xsIGFsc28gYWNjZXB0IGl0ZXJhYmxlcyBsaWtlIGpRdWVyeSBvYmplY3RzLlxudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUsIHNjb3BlLCBsZWF2ZVN0cmluZ3MpIHtcbiAgcmV0dXJuIF9pc1N0cmluZyh2YWx1ZSkgJiYgIWxlYXZlU3RyaW5ncyAmJiAoX2NvcmVJbml0dGVkIHx8ICFfd2FrZSgpKSA/IF9zbGljZS5jYWxsKChzY29wZSB8fCBfZG9jKS5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSwgMCkgOiBfaXNBcnJheSh2YWx1ZSkgPyBfZmxhdHRlbih2YWx1ZSwgbGVhdmVTdHJpbmdzKSA6IF9pc0FycmF5TGlrZSh2YWx1ZSkgPyBfc2xpY2UuY2FsbCh2YWx1ZSwgMCkgOiB2YWx1ZSA/IFt2YWx1ZV0gOiBbXTtcbn0sXG4gICAgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3Rvcih2YWx1ZSkge1xuICB2YWx1ZSA9IHRvQXJyYXkodmFsdWUpWzBdIHx8IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGVsID0gdmFsdWUuY3VycmVudCB8fCB2YWx1ZS5uYXRpdmVFbGVtZW50IHx8IHZhbHVlO1xuICAgIHJldHVybiB0b0FycmF5KHYsIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgPyBlbCA6IGVsID09PSB2YWx1ZSA/IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiB2YWx1ZSk7XG4gIH07XG59LFxuICAgIHNodWZmbGUgPSBmdW5jdGlvbiBzaHVmZmxlKGEpIHtcbiAgcmV0dXJuIGEuc29ydChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIC41IC0gTWF0aC5yYW5kb20oKTtcbiAgfSk7XG59LFxuICAgIC8vIGFsdGVybmF0aXZlIHRoYXQncyBhIGJpdCBmYXN0ZXIgYW5kIG1vcmUgcmVsaWFibHkgZGl2ZXJzZSBidXQgYmlnZ2VyOiAgIGZvciAobGV0IGosIHYsIGkgPSBhLmxlbmd0aDsgaTsgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGkpLCB2ID0gYVstLWldLCBhW2ldID0gYVtqXSwgYVtqXSA9IHYpOyByZXR1cm4gYTtcbi8vZm9yIGRpc3RyaWJ1dGluZyB2YWx1ZXMgYWNyb3NzIGFuIGFycmF5LiBDYW4gYWNjZXB0IGEgbnVtYmVyLCBhIGZ1bmN0aW9uIG9yIChtb3N0IGNvbW1vbmx5KSBhIGZ1bmN0aW9uIHdoaWNoIGNhbiBjb250YWluIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoge2Jhc2UsIGFtb3VudCwgZnJvbSwgZWFzZSwgZ3JpZCwgYXhpcywgbGVuZ3RoLCBlYWNofS4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6IGluZGV4LCB0YXJnZXQsIGFycmF5LiBSZWNvZ25pemVzIHRoZSBmb2xsb3dpbmdcbmRpc3RyaWJ1dGUgPSBmdW5jdGlvbiBkaXN0cmlidXRlKHYpIHtcbiAgaWYgKF9pc0Z1bmN0aW9uKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICB2YXIgdmFycyA9IF9pc09iamVjdCh2KSA/IHYgOiB7XG4gICAgZWFjaDogdlxuICB9LFxuICAgICAgLy9uOjEgaXMganVzdCB0byBpbmRpY2F0ZSB2IHdhcyBhIG51bWJlcjsgd2UgbGV2ZXJhZ2UgdGhhdCBsYXRlciB0byBzZXQgdiBhY2NvcmRpbmcgdG8gdGhlIGxlbmd0aCB3ZSBnZXQuIElmIGEgbnVtYmVyIGlzIHBhc3NlZCBpbiwgd2UgdHJlYXQgaXQgbGlrZSB0aGUgb2xkIHN0YWdnZXIgdmFsdWUgd2hlcmUgMC4xLCBmb3IgZXhhbXBsZSwgd291bGQgbWVhbiB0aGF0IHRoaW5ncyB3b3VsZCBiZSBkaXN0cmlidXRlZCB3aXRoIDAuMSBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgcmF0aGVyIHRoYW4gYSB0b3RhbCBcImFtb3VudFwiIHRoYXQncyBjaHVua2VkIG91dCBhbW9uZyB0aGVtIGFsbC5cbiAgZWFzZSA9IF9wYXJzZUVhc2UodmFycy5lYXNlKSxcbiAgICAgIGZyb20gPSB2YXJzLmZyb20gfHwgMCxcbiAgICAgIGJhc2UgPSBwYXJzZUZsb2F0KHZhcnMuYmFzZSkgfHwgMCxcbiAgICAgIGNhY2hlID0ge30sXG4gICAgICBpc0RlY2ltYWwgPSBmcm9tID4gMCAmJiBmcm9tIDwgMSxcbiAgICAgIHJhdGlvcyA9IGlzTmFOKGZyb20pIHx8IGlzRGVjaW1hbCxcbiAgICAgIGF4aXMgPSB2YXJzLmF4aXMsXG4gICAgICByYXRpb1ggPSBmcm9tLFxuICAgICAgcmF0aW9ZID0gZnJvbTtcblxuICBpZiAoX2lzU3RyaW5nKGZyb20pKSB7XG4gICAgcmF0aW9YID0gcmF0aW9ZID0ge1xuICAgICAgY2VudGVyOiAuNSxcbiAgICAgIGVkZ2VzOiAuNSxcbiAgICAgIGVuZDogMVxuICAgIH1bZnJvbV0gfHwgMDtcbiAgfSBlbHNlIGlmICghaXNEZWNpbWFsICYmIHJhdGlvcykge1xuICAgIHJhdGlvWCA9IGZyb21bMF07XG4gICAgcmF0aW9ZID0gZnJvbVsxXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaSwgdGFyZ2V0LCBhKSB7XG4gICAgdmFyIGwgPSAoYSB8fCB2YXJzKS5sZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdLFxuICAgICAgICBvcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBkLFxuICAgICAgICBqLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1pbixcbiAgICAgICAgd3JhcEF0O1xuXG4gICAgaWYgKCFkaXN0YW5jZXMpIHtcbiAgICAgIHdyYXBBdCA9IHZhcnMuZ3JpZCA9PT0gXCJhdXRvXCIgPyAwIDogKHZhcnMuZ3JpZCB8fCBbMSwgX2JpZ051bV0pWzFdO1xuXG4gICAgICBpZiAoIXdyYXBBdCkge1xuICAgICAgICBtYXggPSAtX2JpZ051bTtcblxuICAgICAgICB3aGlsZSAobWF4IDwgKG1heCA9IGFbd3JhcEF0KytdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICYmIHdyYXBBdCA8IGwpIHt9XG5cbiAgICAgICAgd3JhcEF0LS07XG4gICAgICB9XG5cbiAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdID0gW107XG4gICAgICBvcmlnaW5YID0gcmF0aW9zID8gTWF0aC5taW4od3JhcEF0LCBsKSAqIHJhdGlvWCAtIC41IDogZnJvbSAlIHdyYXBBdDtcbiAgICAgIG9yaWdpblkgPSByYXRpb3MgPyBsICogcmF0aW9ZIC8gd3JhcEF0IC0gLjUgOiBmcm9tIC8gd3JhcEF0IHwgMDtcbiAgICAgIG1heCA9IDA7XG4gICAgICBtaW4gPSBfYmlnTnVtO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIHggPSBqICUgd3JhcEF0IC0gb3JpZ2luWDtcbiAgICAgICAgeSA9IG9yaWdpblkgLSAoaiAvIHdyYXBBdCB8IDApO1xuICAgICAgICBkaXN0YW5jZXNbal0gPSBkID0gIWF4aXMgPyBfc3FydCh4ICogeCArIHkgKiB5KSA6IE1hdGguYWJzKGF4aXMgPT09IFwieVwiID8geSA6IHgpO1xuICAgICAgICBkID4gbWF4ICYmIChtYXggPSBkKTtcbiAgICAgICAgZCA8IG1pbiAmJiAobWluID0gZCk7XG4gICAgICB9XG5cbiAgICAgIGZyb20gPT09IFwicmFuZG9tXCIgJiYgc2h1ZmZsZShkaXN0YW5jZXMpO1xuICAgICAgZGlzdGFuY2VzLm1heCA9IG1heCAtIG1pbjtcbiAgICAgIGRpc3RhbmNlcy5taW4gPSBtaW47XG4gICAgICBkaXN0YW5jZXMudiA9IGwgPSAocGFyc2VGbG9hdCh2YXJzLmFtb3VudCkgfHwgcGFyc2VGbG9hdCh2YXJzLmVhY2gpICogKHdyYXBBdCA+IGwgPyBsIC0gMSA6ICFheGlzID8gTWF0aC5tYXgod3JhcEF0LCBsIC8gd3JhcEF0KSA6IGF4aXMgPT09IFwieVwiID8gbCAvIHdyYXBBdCA6IHdyYXBBdCkgfHwgMCkgKiAoZnJvbSA9PT0gXCJlZGdlc1wiID8gLTEgOiAxKTtcbiAgICAgIGRpc3RhbmNlcy5iID0gbCA8IDAgPyBiYXNlIC0gbCA6IGJhc2U7XG4gICAgICBkaXN0YW5jZXMudSA9IGdldFVuaXQodmFycy5hbW91bnQgfHwgdmFycy5lYWNoKSB8fCAwOyAvL3VuaXRcblxuICAgICAgZWFzZSA9IGVhc2UgJiYgbCA8IDAgPyBfaW52ZXJ0RWFzZShlYXNlKSA6IGVhc2U7XG4gICAgfVxuXG4gICAgbCA9IChkaXN0YW5jZXNbaV0gLSBkaXN0YW5jZXMubWluKSAvIGRpc3RhbmNlcy5tYXggfHwgMDtcbiAgICByZXR1cm4gX3JvdW5kUHJlY2lzZShkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gTWF0aC5wb3coMTAsICgodiArIFwiXCIpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGgpOyAvL3RvIGF2b2lkIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChsaWtlIDI0ICogMC4xID09IDIuNDAwMDAwMDAwMDAwMDAwNCksIHdlIGNob3Agb2ZmIGF0IGEgc3BlY2lmaWMgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIChtdWNoIGZhc3RlciB0aGFuIHRvRml4ZWQoKSlcblxuICByZXR1cm4gZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciBuID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHJhdykgLyB2KSAqIHYgKiBwO1xuICAgIHJldHVybiAobiAtIG4gJSAxKSAvIHAgKyAoX2lzTnVtYmVyKHJhdykgPyAwIDogZ2V0VW5pdChyYXcpKTsgLy8gbiAtIG4gJSAxIHJlcGxhY2VzIE1hdGguZmxvb3IoKSBpbiBvcmRlciB0byBoYW5kbGUgbmVnYXRpdmUgdmFsdWVzIHByb3Blcmx5LiBGb3IgZXhhbXBsZSwgTWF0aC5mbG9vcigtMTUwLjAwMDAwMDAwMDAwMDAzKSBpcyAxNTEhXG4gIH07XG59LFxuICAgIHNuYXAgPSBmdW5jdGlvbiBzbmFwKHNuYXBUbywgdmFsdWUpIHtcbiAgdmFyIGlzQXJyYXkgPSBfaXNBcnJheShzbmFwVG8pLFxuICAgICAgcmFkaXVzLFxuICAgICAgaXMyRDtcblxuICBpZiAoIWlzQXJyYXkgJiYgX2lzT2JqZWN0KHNuYXBUbykpIHtcbiAgICByYWRpdXMgPSBpc0FycmF5ID0gc25hcFRvLnJhZGl1cyB8fCBfYmlnTnVtO1xuXG4gICAgaWYgKHNuYXBUby52YWx1ZXMpIHtcbiAgICAgIHNuYXBUbyA9IHRvQXJyYXkoc25hcFRvLnZhbHVlcyk7XG5cbiAgICAgIGlmIChpczJEID0gIV9pc051bWJlcihzbmFwVG9bMF0pKSB7XG4gICAgICAgIHJhZGl1cyAqPSByYWRpdXM7IC8vcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHNvIHdlIGRvbid0IGhhdmUgdG8gTWF0aC5zcXJ0KCkgaW4gdGhlIGxvb3AuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNuYXBUbyA9IF9yb3VuZE1vZGlmaWVyKHNuYXBUby5pbmNyZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsICFpc0FycmF5ID8gX3JvdW5kTW9kaWZpZXIoc25hcFRvKSA6IF9pc0Z1bmN0aW9uKHNuYXBUbykgPyBmdW5jdGlvbiAocmF3KSB7XG4gICAgaXMyRCA9IHNuYXBUbyhyYXcpO1xuICAgIHJldHVybiBNYXRoLmFicyhpczJEIC0gcmF3KSA8PSByYWRpdXMgPyBpczJEIDogcmF3O1xuICB9IDogZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciB4ID0gcGFyc2VGbG9hdChpczJEID8gcmF3LnggOiByYXcpLFxuICAgICAgICB5ID0gcGFyc2VGbG9hdChpczJEID8gcmF3LnkgOiAwKSxcbiAgICAgICAgbWluID0gX2JpZ051bSxcbiAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgIGkgPSBzbmFwVG8ubGVuZ3RoLFxuICAgICAgICBkeCxcbiAgICAgICAgZHk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoaXMyRCkge1xuICAgICAgICBkeCA9IHNuYXBUb1tpXS54IC0geDtcbiAgICAgICAgZHkgPSBzbmFwVG9baV0ueSAtIHk7XG4gICAgICAgIGR4ID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IE1hdGguYWJzKHNuYXBUb1tpXSAtIHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZHggPCBtaW4pIHtcbiAgICAgICAgbWluID0gZHg7XG4gICAgICAgIGNsb3Nlc3QgPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsb3Nlc3QgPSAhcmFkaXVzIHx8IG1pbiA8PSByYWRpdXMgPyBzbmFwVG9bY2xvc2VzdF0gOiByYXc7XG4gICAgcmV0dXJuIGlzMkQgfHwgY2xvc2VzdCA9PT0gcmF3IHx8IF9pc051bWJlcihyYXcpID8gY2xvc2VzdCA6IGNsb3Nlc3QgKyBnZXRVbml0KHJhdyk7XG4gIH0pO1xufSxcbiAgICByYW5kb20gPSBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIHJvdW5kaW5nSW5jcmVtZW50LCByZXR1cm5GdW5jdGlvbikge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKF9pc0FycmF5KG1pbikgPyAhbWF4IDogcm91bmRpbmdJbmNyZW1lbnQgPT09IHRydWUgPyAhIShyb3VuZGluZ0luY3JlbWVudCA9IDApIDogIXJldHVybkZ1bmN0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBtaW5bfn4oTWF0aC5yYW5kb20oKSAqIG1pbi5sZW5ndGgpXSA6IChyb3VuZGluZ0luY3JlbWVudCA9IHJvdW5kaW5nSW5jcmVtZW50IHx8IDFlLTUpICYmIChyZXR1cm5GdW5jdGlvbiA9IHJvdW5kaW5nSW5jcmVtZW50IDwgMSA/IE1hdGgucG93KDEwLCAocm91bmRpbmdJbmNyZW1lbnQgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDEpICYmIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgobWluIC0gcm91bmRpbmdJbmNyZW1lbnQgLyAyICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyByb3VuZGluZ0luY3JlbWVudCAqIC45OSkpIC8gcm91bmRpbmdJbmNyZW1lbnQpICogcm91bmRpbmdJbmNyZW1lbnQgKiByZXR1cm5GdW5jdGlvbikgLyByZXR1cm5GdW5jdGlvbjtcbiAgfSk7XG59LFxuICAgIHBpcGUgPSBmdW5jdGlvbiBwaXBlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3Rpb25zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmN0aW9uc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAodiwgZikge1xuICAgICAgcmV0dXJuIGYodik7XG4gICAgfSwgdmFsdWUpO1xuICB9O1xufSxcbiAgICB1bml0aXplID0gZnVuY3Rpb24gdW5pdGl6ZShmdW5jLCB1bml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyhwYXJzZUZsb2F0KHZhbHVlKSkgKyAodW5pdCB8fCBnZXRVbml0KHZhbHVlKSk7XG4gIH07XG59LFxuICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIG1hcFJhbmdlKG1pbiwgbWF4LCAwLCAxLCB2YWx1ZSk7XG59LFxuICAgIF93cmFwQXJyYXkgPSBmdW5jdGlvbiBfd3JhcEFycmF5KGEsIHdyYXBwZXIsIHZhbHVlKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBhW35+d3JhcHBlcihpbmRleCldO1xuICB9KTtcbn0sXG4gICAgd3JhcCA9IGZ1bmN0aW9uIHdyYXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIC8vIE5PVEU6IHdyYXAoKSBDQU5OT1QgYmUgYW4gYXJyb3cgZnVuY3Rpb24hIEEgdmVyeSBvZGQgY29tcGlsaW5nIGJ1ZyBjYXVzZXMgcHJvYmxlbXMgKHVucmVsYXRlZCB0byBHU0FQKS5cbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwKDAsIG1pbi5sZW5ndGgpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKHJhbmdlICsgKHZhbHVlIC0gbWluKSAlIHJhbmdlKSAlIHJhbmdlICsgbWluO1xuICB9KTtcbn0sXG4gICAgd3JhcFlveW8gPSBmdW5jdGlvbiB3cmFwWW95byhtaW4sIG1heCwgdmFsdWUpIHtcbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluLFxuICAgICAgdG90YWwgPSByYW5nZSAqIDI7XG4gIHJldHVybiBfaXNBcnJheShtaW4pID8gX3dyYXBBcnJheShtaW4sIHdyYXBZb3lvKDAsIG1pbi5sZW5ndGggLSAxKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSAodG90YWwgKyAodmFsdWUgLSBtaW4pICUgdG90YWwpICUgdG90YWwgfHwgMDtcbiAgICByZXR1cm4gbWluICsgKHZhbHVlID4gcmFuZ2UgPyB0b3RhbCAtIHZhbHVlIDogdmFsdWUpO1xuICB9KTtcbn0sXG4gICAgX3JlcGxhY2VSYW5kb20gPSBmdW5jdGlvbiBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkge1xuICAvL3JlcGxhY2VzIGFsbCBvY2N1cnJlbmNlcyBvZiByYW5kb20oLi4uKSBpbiBhIHN0cmluZyB3aXRoIHRoZSBjYWxjdWxhdGVkIHJhbmRvbSB2YWx1ZS4gY2FuIGJlIGEgcmFuZ2UgbGlrZSByYW5kb20oLTEwMCwgMTAwLCA1KSBvciBhbiBhcnJheSBsaWtlIHJhbmRvbShbMCwgMTAwLCA1MDBdKVxuICB2YXIgcHJldiA9IDAsXG4gICAgICBzID0gXCJcIixcbiAgICAgIGksXG4gICAgICBudW1zLFxuICAgICAgZW5kLFxuICAgICAgaXNBcnJheTtcblxuICB3aGlsZSAofihpID0gdmFsdWUuaW5kZXhPZihcInJhbmRvbShcIiwgcHJldikpKSB7XG4gICAgZW5kID0gdmFsdWUuaW5kZXhPZihcIilcIiwgaSk7XG4gICAgaXNBcnJheSA9IHZhbHVlLmNoYXJBdChpICsgNykgPT09IFwiW1wiO1xuICAgIG51bXMgPSB2YWx1ZS5zdWJzdHIoaSArIDcsIGVuZCAtIGkgLSA3KS5tYXRjaChpc0FycmF5ID8gX2RlbGltaXRlZFZhbHVlRXhwIDogX3N0cmljdE51bUV4cCk7XG4gICAgcyArPSB2YWx1ZS5zdWJzdHIocHJldiwgaSAtIHByZXYpICsgcmFuZG9tKGlzQXJyYXkgPyBudW1zIDogK251bXNbMF0sIGlzQXJyYXkgPyAwIDogK251bXNbMV0sICtudW1zWzJdIHx8IDFlLTUpO1xuICAgIHByZXYgPSBlbmQgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHMgKyB2YWx1ZS5zdWJzdHIocHJldiwgdmFsdWUubGVuZ3RoIC0gcHJldik7XG59LFxuICAgIG1hcFJhbmdlID0gZnVuY3Rpb24gbWFwUmFuZ2UoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCwgdmFsdWUpIHtcbiAgdmFyIGluUmFuZ2UgPSBpbk1heCAtIGluTWluLFxuICAgICAgb3V0UmFuZ2UgPSBvdXRNYXggLSBvdXRNaW47XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBvdXRNaW4gKyAoKHZhbHVlIC0gaW5NaW4pIC8gaW5SYW5nZSAqIG91dFJhbmdlIHx8IDApO1xuICB9KTtcbn0sXG4gICAgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBwcm9ncmVzcywgbXV0YXRlKSB7XG4gIHZhciBmdW5jID0gaXNOYU4oc3RhcnQgKyBlbmQpID8gMCA6IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuICgxIC0gcCkgKiBzdGFydCArIHAgKiBlbmQ7XG4gIH07XG5cbiAgaWYgKCFmdW5jKSB7XG4gICAgdmFyIGlzU3RyaW5nID0gX2lzU3RyaW5nKHN0YXJ0KSxcbiAgICAgICAgbWFzdGVyID0ge30sXG4gICAgICAgIHAsXG4gICAgICAgIGksXG4gICAgICAgIGludGVycG9sYXRvcnMsXG4gICAgICAgIGwsXG4gICAgICAgIGlsO1xuXG4gICAgcHJvZ3Jlc3MgPT09IHRydWUgJiYgKG11dGF0ZSA9IDEpICYmIChwcm9ncmVzcyA9IG51bGwpO1xuXG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgcDogc3RhcnRcbiAgICAgIH07XG4gICAgICBlbmQgPSB7XG4gICAgICAgIHA6IGVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pc0FycmF5KHN0YXJ0KSAmJiAhX2lzQXJyYXkoZW5kKSkge1xuICAgICAgaW50ZXJwb2xhdG9ycyA9IFtdO1xuICAgICAgbCA9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgIGlsID0gbCAtIDI7XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW50ZXJwb2xhdG9ycy5wdXNoKGludGVycG9sYXRlKHN0YXJ0W2kgLSAxXSwgc3RhcnRbaV0pKTsgLy9idWlsZCB0aGUgaW50ZXJwb2xhdG9ycyB1cCBmcm9udCBhcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB0aGF0IHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBtYW55IHRpbWVzLCBpdCBjYW4ganVzdCByZXVzZSB0aGVtLlxuICAgICAgfVxuXG4gICAgICBsLS07XG5cbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgcCAqPSBsO1xuICAgICAgICB2YXIgaSA9IE1hdGgubWluKGlsLCB+fnApO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdG9yc1tpXShwIC0gaSk7XG4gICAgICB9O1xuXG4gICAgICBwcm9ncmVzcyA9IGVuZDtcbiAgICB9IGVsc2UgaWYgKCFtdXRhdGUpIHtcbiAgICAgIHN0YXJ0ID0gX21lcmdlKF9pc0FycmF5KHN0YXJ0KSA/IFtdIDoge30sIHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoIWludGVycG9sYXRvcnMpIHtcbiAgICAgIGZvciAocCBpbiBlbmQpIHtcbiAgICAgICAgX2FkZFByb3BUd2Vlbi5jYWxsKG1hc3Rlciwgc3RhcnQsIHAsIFwiZ2V0XCIsIGVuZFtwXSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgcmV0dXJuIF9yZW5kZXJQcm9wVHdlZW5zKHAsIG1hc3RlcikgfHwgKGlzU3RyaW5nID8gc3RhcnQucCA6IHN0YXJ0KTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihwcm9ncmVzcywgZnVuYyk7XG59LFxuICAgIF9nZXRMYWJlbEluRGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsSW5EaXJlY3Rpb24odGltZWxpbmUsIGZyb21UaW1lLCBiYWNrd2FyZCkge1xuICAvL3VzZWQgZm9yIG5leHRMYWJlbCgpIGFuZCBwcmV2aW91c0xhYmVsKClcbiAgdmFyIGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcbiAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICBwLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBsYWJlbDtcblxuICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgZGlzdGFuY2UgPSBsYWJlbHNbcF0gLSBmcm9tVGltZTtcblxuICAgIGlmIChkaXN0YW5jZSA8IDAgPT09ICEhYmFja3dhcmQgJiYgZGlzdGFuY2UgJiYgbWluID4gKGRpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpKSkge1xuICAgICAgbGFiZWwgPSBwO1xuICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVsO1xufSxcbiAgICBfY2FsbGJhY2sgPSBmdW5jdGlvbiBfY2FsbGJhY2soYW5pbWF0aW9uLCB0eXBlLCBleGVjdXRlTGF6eUZpcnN0KSB7XG4gIHZhciB2ID0gYW5pbWF0aW9uLnZhcnMsXG4gICAgICBjYWxsYmFjayA9IHZbdHlwZV0sXG4gICAgICBwYXJhbXMsXG4gICAgICBzY29wZTtcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcGFyYW1zID0gdlt0eXBlICsgXCJQYXJhbXNcIl07XG4gIHNjb3BlID0gdi5jYWxsYmFja1Njb3BlIHx8IGFuaW1hdGlvbjtcbiAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cbiAgcmV0dXJuIHBhcmFtcyA/IGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBwYXJhbXMpIDogY2FsbGJhY2suY2FsbChzY29wZSk7XG59LFxuICAgIF9pbnRlcnJ1cHQgPSBmdW5jdGlvbiBfaW50ZXJydXB0KGFuaW1hdGlvbikge1xuICBfcmVtb3ZlRnJvbVBhcmVudChhbmltYXRpb24pO1xuXG4gIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyICYmIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmtpbGwoZmFsc2UpO1xuICBhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3F1aWNrVHdlZW4sXG4gICAgX2NyZWF0ZVBsdWdpbiA9IGZ1bmN0aW9uIF9jcmVhdGVQbHVnaW4oY29uZmlnKSB7XG4gIGNvbmZpZyA9ICFjb25maWcubmFtZSAmJiBjb25maWdbXCJkZWZhdWx0XCJdIHx8IGNvbmZpZzsgLy9VTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXG5cbiAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcbiAgICAgIGlzRnVuYyA9IF9pc0Z1bmN0aW9uKGNvbmZpZyksXG4gICAgICBQbHVnaW4gPSBuYW1lICYmICFpc0Z1bmMgJiYgY29uZmlnLmluaXQgPyBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJvcHMgPSBbXTtcbiAgfSA6IGNvbmZpZyxcbiAgICAgIC8vaW4gY2FzZSBzb21lb25lIHBhc3NlcyBpbiBhbiBvYmplY3QgdGhhdCdzIG5vdCBhIHBsdWdpbiwgbGlrZSBDdXN0b21FYXNlXG4gIGluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgaW5pdDogX2VtcHR5RnVuYyxcbiAgICByZW5kZXI6IF9yZW5kZXJQcm9wVHdlZW5zLFxuICAgIGFkZDogX2FkZFByb3BUd2VlbixcbiAgICBraWxsOiBfa2lsbFByb3BUd2VlbnNPZixcbiAgICBtb2RpZmllcjogX2FkZFBsdWdpbk1vZGlmaWVyLFxuICAgIHJhd1ZhcnM6IDBcbiAgfSxcbiAgICAgIHN0YXRpY3MgPSB7XG4gICAgdGFyZ2V0VGVzdDogMCxcbiAgICBnZXQ6IDAsXG4gICAgZ2V0U2V0dGVyOiBfZ2V0U2V0dGVyLFxuICAgIGFsaWFzZXM6IHt9LFxuICAgIHJlZ2lzdGVyOiAwXG4gIH07XG5cbiAgX3dha2UoKTtcblxuICBpZiAoY29uZmlnICE9PSBQbHVnaW4pIHtcbiAgICBpZiAoX3BsdWdpbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfc2V0RGVmYXVsdHMoUGx1Z2luLCBfc2V0RGVmYXVsdHMoX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBpbnN0YW5jZURlZmF1bHRzKSwgc3RhdGljcykpOyAvL3N0YXRpYyBtZXRob2RzXG5cblxuICAgIF9tZXJnZShQbHVnaW4ucHJvdG90eXBlLCBfbWVyZ2UoaW5zdGFuY2VEZWZhdWx0cywgX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBzdGF0aWNzKSkpOyAvL2luc3RhbmNlIG1ldGhvZHNcblxuXG4gICAgX3BsdWdpbnNbUGx1Z2luLnByb3AgPSBuYW1lXSA9IFBsdWdpbjtcblxuICAgIGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xuICAgICAgX2hhcm5lc3NQbHVnaW5zLnB1c2goUGx1Z2luKTtcblxuICAgICAgX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xuICAgIH1cblxuICAgIG5hbWUgPSAobmFtZSA9PT0gXCJjc3NcIiA/IFwiQ1NTXCIgOiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkpICsgXCJQbHVnaW5cIjsgLy9mb3IgdGhlIGdsb2JhbCBuYW1lLiBcIm1vdGlvblBhdGhcIiBzaG91bGQgYmVjb21lIE1vdGlvblBhdGhQbHVnaW5cbiAgfVxuXG4gIF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcblxuICBjb25maWcucmVnaXN0ZXIgJiYgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ09MT1JTXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fMjU1ID0gMjU1LFxuICAgIF9jb2xvckxvb2t1cCA9IHtcbiAgYXF1YTogWzAsIF8yNTUsIF8yNTVdLFxuICBsaW1lOiBbMCwgXzI1NSwgMF0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICBibHVlOiBbMCwgMCwgXzI1NV0sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICB3aGl0ZTogW18yNTUsIF8yNTUsIF8yNTVdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgeWVsbG93OiBbXzI1NSwgXzI1NSwgMF0sXG4gIG9yYW5nZTogW18yNTUsIDE2NSwgMF0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIHJlZDogW18yNTUsIDAsIDBdLFxuICBwaW5rOiBbXzI1NSwgMTkyLCAyMDNdLFxuICBjeWFuOiBbMCwgXzI1NSwgXzI1NV0sXG4gIHRyYW5zcGFyZW50OiBbXzI1NSwgXzI1NSwgXzI1NSwgMF1cbn0sXG4gICAgX2h1ZSA9IGZ1bmN0aW9uIF9odWUoaCwgbTEsIG0yKSB7XG4gIGggPSBoIDwgMCA/IGggKyAxIDogaCA+IDEgPyBoIC0gMSA6IGg7XG4gIHJldHVybiAoaCAqIDYgPCAxID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IGggPCAuNSA/IG0yIDogaCAqIDMgPCAyID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiBfMjU1ICsgLjUgfCAwO1xufSxcbiAgICBzcGxpdENvbG9yID0gZnVuY3Rpb24gc3BsaXRDb2xvcih2LCB0b0hTTCwgZm9yY2VBbHBoYSkge1xuICB2YXIgYSA9ICF2ID8gX2NvbG9yTG9va3VwLmJsYWNrIDogX2lzTnVtYmVyKHYpID8gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XSA6IDAsXG4gICAgICByLFxuICAgICAgZyxcbiAgICAgIGIsXG4gICAgICBoLFxuICAgICAgcyxcbiAgICAgIGwsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBkLFxuICAgICAgd2FzSFNMO1xuXG4gIGlmICghYSkge1xuICAgIGlmICh2LnN1YnN0cigtMSkgPT09IFwiLFwiKSB7XG4gICAgICAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1hIGlzIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY2hvcCBpdCBvZmYgKHR5cGljYWxseSBmcm9tIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIGxpa2UgYSB0ZXh0U2hhZG93OlwiMnB4IDJweCAycHggYmx1ZSwgNXB4IDVweCA1cHggcmdiKDI1NSwwLDApXCIgLSBpbiB0aGlzIGV4YW1wbGUgXCJibHVlLFwiIGhhcyBhIHRyYWlsaW5nIGNvbW1hLiBXZSBjb3VsZCBzdHJpcCBpdCBvdXQgaW5zaWRlIHBhcnNlQ29tcGxleCgpIGJ1dCB3ZSdkIG5lZWQgdG8gZG8gaXQgdG8gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBwbHVzIGl0IHdvdWxkbid0IHByb3ZpZGUgcHJvdGVjdGlvbiBmcm9tIG90aGVyIHBvdGVudGlhbCBzY2VuYXJpb3MgbGlrZSBpZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBzaW1pbGFyIHZhbHVlLlxuICAgICAgdiA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKF9jb2xvckxvb2t1cFt2XSkge1xuICAgICAgYSA9IF9jb2xvckxvb2t1cFt2XTtcbiAgICB9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgaWYgKHYubGVuZ3RoIDwgNikge1xuICAgICAgICAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwIG9yICM5RjBGIChjb3VsZCBoYXZlIGFscGhhKVxuICAgICAgICByID0gdi5jaGFyQXQoMSk7XG4gICAgICAgIGcgPSB2LmNoYXJBdCgyKTtcbiAgICAgICAgYiA9IHYuY2hhckF0KDMpO1xuICAgICAgICB2ID0gXCIjXCIgKyByICsgciArIGcgKyBnICsgYiArIGIgKyAodi5sZW5ndGggPT09IDUgPyB2LmNoYXJBdCg0KSArIHYuY2hhckF0KDQpIDogXCJcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAvLyBoZXggd2l0aCBhbHBoYSwgbGlrZSAjZmQ1ZTUzZmZcbiAgICAgICAgYSA9IHBhcnNlSW50KHYuc3Vic3RyKDEsIDYpLCAxNik7XG4gICAgICAgIHJldHVybiBbYSA+PiAxNiwgYSA+PiA4ICYgXzI1NSwgYSAmIF8yNTUsIHBhcnNlSW50KHYuc3Vic3RyKDcpLCAxNikgLyAyNTVdO1xuICAgICAgfVxuXG4gICAgICB2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcbiAgICAgIGEgPSBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdO1xuICAgIH0gZWxzZSBpZiAodi5zdWJzdHIoMCwgMykgPT09IFwiaHNsXCIpIHtcbiAgICAgIGEgPSB3YXNIU0wgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApO1xuXG4gICAgICBpZiAoIXRvSFNMKSB7XG4gICAgICAgIGggPSArYVswXSAlIDM2MCAvIDM2MDtcbiAgICAgICAgcyA9ICthWzFdIC8gMTAwO1xuICAgICAgICBsID0gK2FbMl0gLyAxMDA7XG4gICAgICAgIGcgPSBsIDw9IC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICByID0gbCAqIDIgLSBnO1xuICAgICAgICBhLmxlbmd0aCA+IDMgJiYgKGFbM10gKj0gMSk7IC8vY2FzdCBhcyBudW1iZXJcblxuICAgICAgICBhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuICAgICAgICBhWzFdID0gX2h1ZShoLCByLCBnKTtcbiAgICAgICAgYVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcbiAgICAgIH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHtcbiAgICAgICAgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG4gICAgICAgIGEgPSB2Lm1hdGNoKF9udW1FeHApO1xuICAgICAgICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IHYubWF0Y2goX3N0cmljdE51bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIGEgPSBhLm1hcChOdW1iZXIpO1xuICB9XG5cbiAgaWYgKHRvSFNMICYmICF3YXNIU0wpIHtcbiAgICByID0gYVswXSAvIF8yNTU7XG4gICAgZyA9IGFbMV0gLyBfMjU1O1xuICAgIGIgPSBhWzJdIC8gXzI1NTtcbiAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBtYXggLSBtaW47XG4gICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICBoID0gbWF4ID09PSByID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiBtYXggPT09IGcgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH1cblxuICAgIGFbMF0gPSB+fihoICsgLjUpO1xuICAgIGFbMV0gPSB+fihzICogMTAwICsgLjUpO1xuICAgIGFbMl0gPSB+fihsICogMTAwICsgLjUpO1xuICB9XG5cbiAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgcmV0dXJuIGE7XG59LFxuICAgIF9jb2xvck9yZGVyRGF0YSA9IGZ1bmN0aW9uIF9jb2xvck9yZGVyRGF0YSh2KSB7XG4gIC8vIHN0cmlwcyBvdXQgdGhlIGNvbG9ycyBmcm9tIHRoZSBzdHJpbmcsIGZpbmRzIGFsbCB0aGUgbnVtZXJpYyBzbG90cyAod2l0aCB1bml0cykgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UuIFRoZSBBcnJheSBhbHNvIGhhcyBhIFwiY1wiIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5IG9mIHRoZSBpbmRleCB2YWx1ZXMgd2hlcmUgdGhlIGNvbG9ycyBiZWxvbmcuIFRoaXMgaXMgdG8gaGVscCB3b3JrIGFyb3VuZCBpc3N1ZXMgd2hlcmUgdGhlcmUncyBhIG1pcy1tYXRjaGVkIG9yZGVyIG9mIGNvbG9yL251bWVyaWMgZGF0YSBsaWtlIGRyb3Atc2hhZG93KCNmMDAgMHB4IDFweCAycHgpIGFuZCBkcm9wLXNoYWRvdygweCAxcHggMnB4ICNmMDApLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhlbHBlciBmdW5jdGlvbiB1c2VkIGluIF9mb3JtYXRDb2xvcnMoKVxuICB2YXIgdmFsdWVzID0gW10sXG4gICAgICBjID0gW10sXG4gICAgICBpID0gLTE7XG4gIHYuc3BsaXQoX2NvbG9yRXhwKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGEgPSB2Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBhKTtcbiAgICBjLnB1c2goaSArPSBhLmxlbmd0aCArIDEpO1xuICB9KTtcbiAgdmFsdWVzLmMgPSBjO1xuICByZXR1cm4gdmFsdWVzO1xufSxcbiAgICBfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24gX2Zvcm1hdENvbG9ycyhzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICBjb2xvcnMgPSAocyArIHJlc3VsdCkubWF0Y2goX2NvbG9yRXhwKSxcbiAgICAgIHR5cGUgPSB0b0hTTCA/IFwiaHNsYShcIiA6IFwicmdiYShcIixcbiAgICAgIGkgPSAwLFxuICAgICAgYyxcbiAgICAgIHNoZWxsLFxuICAgICAgZCxcbiAgICAgIGw7XG5cbiAgaWYgKCFjb2xvcnMpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuIChjb2xvciA9IHNwbGl0Q29sb3IoY29sb3IsIHRvSFNMLCAxKSkgJiYgdHlwZSArICh0b0hTTCA/IGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiJSxcIiArIGNvbG9yWzJdICsgXCIlLFwiICsgY29sb3JbM10gOiBjb2xvci5qb2luKFwiLFwiKSkgKyBcIilcIjtcbiAgfSk7XG5cbiAgaWYgKG9yZGVyTWF0Y2hEYXRhKSB7XG4gICAgZCA9IF9jb2xvck9yZGVyRGF0YShzKTtcbiAgICBjID0gb3JkZXJNYXRjaERhdGEuYztcblxuICAgIGlmIChjLmpvaW4ocmVzdWx0KSAhPT0gZC5jLmpvaW4ocmVzdWx0KSkge1xuICAgICAgc2hlbGwgPSBzLnJlcGxhY2UoX2NvbG9yRXhwLCBcIjFcIikuc3BsaXQoX251bVdpdGhVbml0RXhwKTtcbiAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyAofmMuaW5kZXhPZihpKSA/IGNvbG9ycy5zaGlmdCgpIHx8IHR5cGUgKyBcIjAsMCwwLDApXCIgOiAoZC5sZW5ndGggPyBkIDogY29sb3JzLmxlbmd0aCA/IGNvbG9ycyA6IG9yZGVyTWF0Y2hEYXRhKS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNoZWxsKSB7XG4gICAgc2hlbGwgPSBzLnNwbGl0KF9jb2xvckV4cCk7XG4gICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgY29sb3JzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzaGVsbFtsXTtcbn0sXG4gICAgX2NvbG9yRXhwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcyA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszLDR9KXsxLDJ9XFxcXGJcIixcbiAgICAgIC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy4sXG4gIHA7XG5cbiAgZm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuICAgIHMgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocyArIFwiKVwiLCBcImdpXCIpO1xufSgpLFxuICAgIF9oc2xFeHAgPSAvaHNsW2FdP1xcKC8sXG4gICAgX2NvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24gX2NvbG9yU3RyaW5nRmlsdGVyKGEpIHtcbiAgdmFyIGNvbWJpbmVkID0gYS5qb2luKFwiIFwiKSxcbiAgICAgIHRvSFNMO1xuICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICBpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XG4gICAgdG9IU0wgPSBfaHNsRXhwLnRlc3QoY29tYmluZWQpO1xuICAgIGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcbiAgICBhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCwgX2NvbG9yT3JkZXJEYXRhKGFbMV0pKTsgLy8gbWFrZSBzdXJlIHRoZSBvcmRlciBvZiBudW1iZXJzL2NvbG9ycyBtYXRjaCB3aXRoIHRoZSBFTkQgdmFsdWUuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSUNLRVJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbl90aWNrZXJBY3RpdmUsXG4gICAgX3RpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgICBfbGFnVGhyZXNob2xkID0gNTAwLFxuICAgICAgX2FkanVzdGVkTGFnID0gMzMsXG4gICAgICBfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcbiAgICAgIF9sYXN0VXBkYXRlID0gX3N0YXJ0VGltZSxcbiAgICAgIF9nYXAgPSAxMDAwIC8gMjQwLFxuICAgICAgX25leHRUaW1lID0gX2dhcCxcbiAgICAgIF9saXN0ZW5lcnMgPSBbXSxcbiAgICAgIF9pZCxcbiAgICAgIF9yZXEsXG4gICAgICBfcmFmLFxuICAgICAgX3NlbGYsXG4gICAgICBfZGVsdGEsXG4gICAgICBfaSxcbiAgICAgIF90aWNrID0gZnVuY3Rpb24gX3RpY2sodikge1xuICAgIHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuICAgICAgICBtYW51YWwgPSB2ID09PSB0cnVlLFxuICAgICAgICBvdmVybGFwLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgdGltZSxcbiAgICAgICAgZnJhbWU7XG5cbiAgICBlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCAmJiAoX3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnKTtcbiAgICBfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuICAgIHRpbWUgPSBfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWU7XG4gICAgb3ZlcmxhcCA9IHRpbWUgLSBfbmV4dFRpbWU7XG5cbiAgICBpZiAob3ZlcmxhcCA+IDAgfHwgbWFudWFsKSB7XG4gICAgICBmcmFtZSA9ICsrX3NlbGYuZnJhbWU7XG4gICAgICBfZGVsdGEgPSB0aW1lIC0gX3NlbGYudGltZSAqIDEwMDA7XG4gICAgICBfc2VsZi50aW1lID0gdGltZSA9IHRpbWUgLyAxMDAwO1xuICAgICAgX25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gNCA6IF9nYXAgLSBvdmVybGFwKTtcbiAgICAgIGRpc3BhdGNoID0gMTtcbiAgICB9XG5cbiAgICBtYW51YWwgfHwgKF9pZCA9IF9yZXEoX3RpY2spKTsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZm9yIChfaSA9IDA7IF9pIDwgX2xpc3RlbmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgLy8gdXNlIF9pIGFuZCBjaGVjayBfbGlzdGVuZXJzLmxlbmd0aCBpbnN0ZWFkIG9mIGEgdmFyaWFibGUgYmVjYXVzZSBhIGxpc3RlbmVyIGNvdWxkIGdldCByZW1vdmVkIGR1cmluZyB0aGUgbG9vcCwgYW5kIGlmIHRoYXQgaGFwcGVucyB0byBhbiBlbGVtZW50IGxlc3MgdGhhbiB0aGUgY3VycmVudCBpbmRleCwgaXQnZCB0aHJvdyB0aGluZ3Mgb2ZmIGluIHRoZSBsb29wLlxuICAgICAgICBfbGlzdGVuZXJzW19pXSh0aW1lLCBfZGVsdGEsIGZyYW1lLCB2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3NlbGYgPSB7XG4gICAgdGltZTogMCxcbiAgICBmcmFtZTogMCxcbiAgICB0aWNrOiBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgX3RpY2sodHJ1ZSk7XG4gICAgfSxcbiAgICBkZWx0YVJhdGlvOiBmdW5jdGlvbiBkZWx0YVJhdGlvKGZwcykge1xuICAgICAgcmV0dXJuIF9kZWx0YSAvICgxMDAwIC8gKGZwcyB8fCA2MCkpO1xuICAgIH0sXG4gICAgd2FrZTogZnVuY3Rpb24gd2FrZSgpIHtcbiAgICAgIGlmIChfY29yZVJlYWR5KSB7XG4gICAgICAgIGlmICghX2NvcmVJbml0dGVkICYmIF93aW5kb3dFeGlzdHMoKSkge1xuICAgICAgICAgIF93aW4gPSBfY29yZUluaXR0ZWQgPSB3aW5kb3c7XG4gICAgICAgICAgX2RvYyA9IF93aW4uZG9jdW1lbnQgfHwge307XG4gICAgICAgICAgX2dsb2JhbHMuZ3NhcCA9IGdzYXA7XG4gICAgICAgICAgKF93aW4uZ3NhcFZlcnNpb25zIHx8IChfd2luLmdzYXBWZXJzaW9ucyA9IFtdKSkucHVzaChnc2FwLnZlcnNpb24pO1xuXG4gICAgICAgICAgX2luc3RhbGwoX2luc3RhbGxTY29wZSB8fCBfd2luLkdyZWVuU29ja0dsb2JhbHMgfHwgIV93aW4uZ3NhcCAmJiBfd2luIHx8IHt9KTtcblxuICAgICAgICAgIF9yYWYgPSBfd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pZCAmJiBfc2VsZi5zbGVlcCgpO1xuXG4gICAgICAgIF9yZXEgPSBfcmFmIHx8IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgX25leHRUaW1lIC0gX3NlbGYudGltZSAqIDEwMDAgKyAxIHwgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RpY2tlckFjdGl2ZSA9IDE7XG5cbiAgICAgICAgX3RpY2soMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzbGVlcDogZnVuY3Rpb24gc2xlZXAoKSB7XG4gICAgICAoX3JhZiA/IF93aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhclRpbWVvdXQpKF9pZCk7XG4gICAgICBfdGlja2VyQWN0aXZlID0gMDtcbiAgICAgIF9yZXEgPSBfZW1wdHlGdW5jO1xuICAgIH0sXG4gICAgbGFnU21vb3RoaW5nOiBmdW5jdGlvbiBsYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuICAgICAgX2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxIC8gX3RpbnlOdW07IC8vemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXG4gICAgICBfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZywgX2xhZ1RocmVzaG9sZCwgMCk7XG4gICAgfSxcbiAgICBmcHM6IGZ1bmN0aW9uIGZwcyhfZnBzKSB7XG4gICAgICBfZ2FwID0gMTAwMCAvIChfZnBzIHx8IDI0MCk7XG4gICAgICBfbmV4dFRpbWUgPSBfc2VsZi50aW1lICogMTAwMCArIF9nYXA7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChjYWxsYmFjaykge1xuICAgICAgX2xpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSA8IDAgJiYgX2xpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgX3dha2UoKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIH4oaSA9IF9saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykpICYmIF9saXN0ZW5lcnMuc3BsaWNlKGksIDEpICYmIF9pID49IGkgJiYgX2ktLTtcbiAgICB9LFxuICAgIF9saXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIF9zZWxmO1xufSgpLFxuICAgIF93YWtlID0gZnVuY3Rpb24gX3dha2UoKSB7XG4gIHJldHVybiAhX3RpY2tlckFjdGl2ZSAmJiBfdGlja2VyLndha2UoKTtcbn0sXG4gICAgLy9hbHNvIGVuc3VyZXMgdGhlIGNvcmUgY2xhc3NlcyBhcmUgaW5pdGlhbGl6ZWQuXG5cbi8qXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogRUFTSU5HXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG5fZWFzZU1hcCA9IHt9LFxuICAgIF9jdXN0b21FYXNlRXhwID0gL15bXFxkLlxcLU1dW1xcZC5cXC0sXFxzXS8sXG4gICAgX3F1b3Rlc0V4cCA9IC9bXCInXS9nLFxuICAgIF9wYXJzZU9iamVjdEluU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlT2JqZWN0SW5TdHJpbmcodmFsdWUpIHtcbiAgLy90YWtlcyBhIHN0cmluZyBsaWtlIFwie3dpZ2dsZXM6MTAsIHR5cGU6YW50aWNpcGF0ZX0pXCIgYW5kIHR1cm5zIGl0IGludG8gYSByZWFsIG9iamVjdC4gTm90aWNlIGl0IGVuZHMgaW4gXCIpXCIgYW5kIGluY2x1ZGVzIHRoZSB7fSB3cmFwcGVycy4gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yIHBhcnNpbmcgZWFzZSBjb25maWdzIGFuZCBwcmlvcml0aXplZCBvcHRpbWl6YXRpb24gcmF0aGVyIHRoYW4gcmV1c2FiaWxpdHkuXG4gIHZhciBvYmogPSB7fSxcbiAgICAgIHNwbGl0ID0gdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDMpLnNwbGl0KFwiOlwiKSxcbiAgICAgIGtleSA9IHNwbGl0WzBdLFxuICAgICAgaSA9IDEsXG4gICAgICBsID0gc3BsaXQubGVuZ3RoLFxuICAgICAgaW5kZXgsXG4gICAgICB2YWwsXG4gICAgICBwYXJzZWRWYWw7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICB2YWwgPSBzcGxpdFtpXTtcbiAgICBpbmRleCA9IGkgIT09IGwgLSAxID8gdmFsLmxhc3RJbmRleE9mKFwiLFwiKSA6IHZhbC5sZW5ndGg7XG4gICAgcGFyc2VkVmFsID0gdmFsLnN1YnN0cigwLCBpbmRleCk7XG4gICAgb2JqW2tleV0gPSBpc05hTihwYXJzZWRWYWwpID8gcGFyc2VkVmFsLnJlcGxhY2UoX3F1b3Rlc0V4cCwgXCJcIikudHJpbSgpIDogK3BhcnNlZFZhbDtcbiAgICBrZXkgPSB2YWwuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX3ZhbHVlSW5QYXJlbnRoZXNlcyA9IGZ1bmN0aW9uIF92YWx1ZUluUGFyZW50aGVzZXModmFsdWUpIHtcbiAgdmFyIG9wZW4gPSB2YWx1ZS5pbmRleE9mKFwiKFwiKSArIDEsXG4gICAgICBjbG9zZSA9IHZhbHVlLmluZGV4T2YoXCIpXCIpLFxuICAgICAgbmVzdGVkID0gdmFsdWUuaW5kZXhPZihcIihcIiwgb3Blbik7XG4gIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcob3Blbiwgfm5lc3RlZCAmJiBuZXN0ZWQgPCBjbG9zZSA/IHZhbHVlLmluZGV4T2YoXCIpXCIsIGNsb3NlICsgMSkgOiBjbG9zZSk7XG59LFxuICAgIF9jb25maWdFYXNlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIF9jb25maWdFYXNlRnJvbVN0cmluZyhuYW1lKSB7XG4gIC8vbmFtZSBjYW4gYmUgYSBzdHJpbmcgbGlrZSBcImVsYXN0aWMub3V0KDEsMC41KVwiLCBhbmQgcGFzcyBpbiBfZWFzZU1hcCBhcyBvYmogYW5kIGl0J2xsIHBhcnNlIGl0IG91dCBhbmQgY2FsbCB0aGUgYWN0dWFsIGZ1bmN0aW9uIGxpa2UgX2Vhc2VNYXAuRWxhc3RpYy5lYXNlT3V0LmNvbmZpZygxLDAuNSkuIEl0IHdpbGwgYWxzbyBwYXJzZSBjdXN0b20gZWFzZSBzdHJpbmdzIGFzIGxvbmcgYXMgQ3VzdG9tRWFzZSBpcyBsb2FkZWQgYW5kIHJlZ2lzdGVyZWQgKGludGVybmFsbHkgYXMgX2Vhc2VNYXAuX0NFKS5cbiAgdmFyIHNwbGl0ID0gKG5hbWUgKyBcIlwiKS5zcGxpdChcIihcIiksXG4gICAgICBlYXNlID0gX2Vhc2VNYXBbc3BsaXRbMF1dO1xuICByZXR1cm4gZWFzZSAmJiBzcGxpdC5sZW5ndGggPiAxICYmIGVhc2UuY29uZmlnID8gZWFzZS5jb25maWcuYXBwbHkobnVsbCwgfm5hbWUuaW5kZXhPZihcIntcIikgPyBbX3BhcnNlT2JqZWN0SW5TdHJpbmcoc3BsaXRbMV0pXSA6IF92YWx1ZUluUGFyZW50aGVzZXMobmFtZSkuc3BsaXQoXCIsXCIpLm1hcChfbnVtZXJpY0lmUG9zc2libGUpKSA6IF9lYXNlTWFwLl9DRSAmJiBfY3VzdG9tRWFzZUV4cC50ZXN0KG5hbWUpID8gX2Vhc2VNYXAuX0NFKFwiXCIsIG5hbWUpIDogZWFzZTtcbn0sXG4gICAgX2ludmVydEVhc2UgPSBmdW5jdGlvbiBfaW52ZXJ0RWFzZShlYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZSgxIC0gcCk7XG4gIH07XG59LFxuICAgIC8vIGFsbG93IHlveW9FYXNlIHRvIGJlIHNldCBpbiBjaGlsZHJlbiBhbmQgaGF2ZSB0aG9zZSBhZmZlY3RlZCB3aGVuIHRoZSBwYXJlbnQvYW5jZXN0b3IgdGltZWxpbmUgeW95b3MuXG5fcHJvcGFnYXRlWW95b0Vhc2UgPSBmdW5jdGlvbiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95bykge1xuICB2YXIgY2hpbGQgPSB0aW1lbGluZS5fZmlyc3QsXG4gICAgICBlYXNlO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XG4gICAgICBfcHJvcGFnYXRlWW95b0Vhc2UoY2hpbGQsIGlzWW95byk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC52YXJzLnlveW9FYXNlICYmICghY2hpbGQuX3lveW8gfHwgIWNoaWxkLl9yZXBlYXQpICYmIGNoaWxkLl95b3lvICE9PSBpc1lveW8pIHtcbiAgICAgIGlmIChjaGlsZC50aW1lbGluZSkge1xuICAgICAgICBfcHJvcGFnYXRlWW95b0Vhc2UoY2hpbGQudGltZWxpbmUsIGlzWW95byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYXNlID0gY2hpbGQuX2Vhc2U7XG4gICAgICAgIGNoaWxkLl9lYXNlID0gY2hpbGQuX3lFYXNlO1xuICAgICAgICBjaGlsZC5feUVhc2UgPSBlYXNlO1xuICAgICAgICBjaGlsZC5feW95byA9IGlzWW95bztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICB9XG59LFxuICAgIF9wYXJzZUVhc2UgPSBmdW5jdGlvbiBfcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSB7XG4gIHJldHVybiAhZWFzZSA/IGRlZmF1bHRFYXNlIDogKF9pc0Z1bmN0aW9uKGVhc2UpID8gZWFzZSA6IF9lYXNlTWFwW2Vhc2VdIHx8IF9jb25maWdFYXNlRnJvbVN0cmluZyhlYXNlKSkgfHwgZGVmYXVsdEVhc2U7XG59LFxuICAgIF9pbnNlcnRFYXNlID0gZnVuY3Rpb24gX2luc2VydEVhc2UobmFtZXMsIGVhc2VJbiwgZWFzZU91dCwgZWFzZUluT3V0KSB7XG4gIGlmIChlYXNlT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICByZXR1cm4gMSAtIGVhc2VJbigxIC0gcCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChlYXNlSW5PdXQgPT09IHZvaWQgMCkge1xuICAgIGVhc2VJbk91dCA9IGZ1bmN0aW9uIGVhc2VJbk91dChwKSB7XG4gICAgICByZXR1cm4gcCA8IC41ID8gZWFzZUluKHAgKiAyKSAvIDIgOiAxIC0gZWFzZUluKCgxIC0gcCkgKiAyKSAvIDI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBlYXNlID0ge1xuICAgIGVhc2VJbjogZWFzZUluLFxuICAgIGVhc2VPdXQ6IGVhc2VPdXQsXG4gICAgZWFzZUluT3V0OiBlYXNlSW5PdXRcbiAgfSxcbiAgICAgIGxvd2VyY2FzZU5hbWU7XG5cbiAgX2ZvckVhY2hOYW1lKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF9lYXNlTWFwW25hbWVdID0gX2dsb2JhbHNbbmFtZV0gPSBlYXNlO1xuICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCldID0gZWFzZU91dDtcblxuICAgIGZvciAodmFyIHAgaW4gZWFzZSkge1xuICAgICAgX2Vhc2VNYXBbbG93ZXJjYXNlTmFtZSArIChwID09PSBcImVhc2VJblwiID8gXCIuaW5cIiA6IHAgPT09IFwiZWFzZU91dFwiID8gXCIub3V0XCIgOiBcIi5pbk91dFwiKV0gPSBfZWFzZU1hcFtuYW1lICsgXCIuXCIgKyBwXSA9IGVhc2VbcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2Vhc2VJbk91dEZyb21PdXQgPSBmdW5jdGlvbiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwIDwgLjUgPyAoMSAtIGVhc2VPdXQoMSAtIHAgKiAyKSkgLyAyIDogLjUgKyBlYXNlT3V0KChwIC0gLjUpICogMikgLyAyO1xuICB9O1xufSxcbiAgICBfY29uZmlnRWxhc3RpYyA9IGZ1bmN0aW9uIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gIHZhciBwMSA9IGFtcGxpdHVkZSA+PSAxID8gYW1wbGl0dWRlIDogMSxcbiAgICAgIC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG4gIHAyID0gKHBlcmlvZCB8fCAodHlwZSA/IC4zIDogLjQ1KSkgLyAoYW1wbGl0dWRlIDwgMSA/IGFtcGxpdHVkZSA6IDEpLFxuICAgICAgcDMgPSBwMiAvIF8yUEkgKiAoTWF0aC5hc2luKDEgLyBwMSkgfHwgMCksXG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPT09IDEgPyAxIDogcDEgKiBNYXRoLnBvdygyLCAtMTAgKiBwKSAqIF9zaW4oKHAgLSBwMykgKiBwMikgKyAxO1xuICB9LFxuICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9IDogX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCk7XG5cbiAgcDIgPSBfMlBJIC8gcDI7IC8vcHJlY2FsY3VsYXRlIHRvIG9wdGltaXplXG5cbiAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0VsYXN0aWModHlwZSwgYW1wbGl0dWRlLCBwZXJpb2QpO1xuICB9O1xuXG4gIHJldHVybiBlYXNlO1xufSxcbiAgICBfY29uZmlnQmFjayA9IGZ1bmN0aW9uIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCkge1xuICBpZiAob3ZlcnNob290ID09PSB2b2lkIDApIHtcbiAgICBvdmVyc2hvb3QgPSAxLjcwMTU4O1xuICB9XG5cbiAgdmFyIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICByZXR1cm4gcCA/IC0tcCAqIHAgKiAoKG92ZXJzaG9vdCArIDEpICogcCArIG92ZXJzaG9vdCkgKyAxIDogMDtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKG92ZXJzaG9vdCkge1xuICAgIHJldHVybiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpO1xuICB9O1xuXG4gIHJldHVybiBlYXNlO1xufTsgLy8gYSBjaGVhcGVyIChrYiBhbmQgY3B1KSBidXQgbW9yZSBtaWxkIHdheSB0byBnZXQgYSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgYnkgZmVlZGluZyBpbiBhIHZhbHVlIGJldHdlZW4gLTEgKGVhc2VJbikgYW5kIDEgKGVhc2VPdXQpIHdoZXJlIDAgaXMgbGluZWFyLlxuLy8gX3dlaWdodGVkRWFzZSA9IHJhdGlvID0+IHtcbi8vIFx0bGV0IHkgPSAwLjUgKyByYXRpbyAvIDI7XG4vLyBcdHJldHVybiBwID0+ICgyICogKDEgLSBwKSAqIHAgKiB5ICsgcCAqIHApO1xuLy8gfSxcbi8vIGEgc3Ryb25nZXIgKGJ1dCBtb3JlIGV4cGVuc2l2ZSBrYi9jcHUpIHBhcmFtZXRlcml6ZWQgd2VpZ2h0ZWQgZWFzZSB0aGF0IGxldHMgeW91IGZlZWQgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2VTdHJvbmcgPSByYXRpbyA9PiB7XG4vLyBcdHJhdGlvID0gLjUgKyByYXRpbyAvIDI7XG4vLyBcdGxldCBvID0gMSAvIDMgKiAocmF0aW8gPCAuNSA/IHJhdGlvIDogMSAtIHJhdGlvKSxcbi8vIFx0XHRiID0gcmF0aW8gLSBvLFxuLy8gXHRcdGMgPSByYXRpbyArIG87XG4vLyBcdHJldHVybiBwID0+IHAgPT09IDEgPyBwIDogMyAqIGIgKiAoMSAtIHApICogKDEgLSBwKSAqIHAgKyAzICogYyAqICgxIC0gcCkgKiBwICogcCArIHAgKiBwICogcDtcbi8vIH07XG5cblxuX2ZvckVhY2hOYW1lKFwiTGluZWFyLFF1YWQsQ3ViaWMsUXVhcnQsUXVpbnQsU3Ryb25nXCIsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gIHZhciBwb3dlciA9IGkgPCA1ID8gaSArIDEgOiBpO1xuXG4gIF9pbnNlcnRFYXNlKG5hbWUgKyBcIixQb3dlclwiICsgKHBvd2VyIC0gMSksIGkgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhwLCBwb3dlcik7XG4gIH0gOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwO1xuICB9LCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHAsIHBvd2VyKTtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gTWF0aC5wb3cocCAqIDIsIHBvd2VyKSAvIDIgOiAxIC0gTWF0aC5wb3coKDEgLSBwKSAqIDIsIHBvd2VyKSAvIDI7XG4gIH0pO1xufSk7XG5cbl9lYXNlTWFwLkxpbmVhci5lYXNlTm9uZSA9IF9lYXNlTWFwLm5vbmUgPSBfZWFzZU1hcC5MaW5lYXIuZWFzZUluO1xuXG5faW5zZXJ0RWFzZShcIkVsYXN0aWNcIiwgX2NvbmZpZ0VsYXN0aWMoXCJpblwiKSwgX2NvbmZpZ0VsYXN0aWMoXCJvdXRcIiksIF9jb25maWdFbGFzdGljKCkpO1xuXG4oZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIG4xID0gMSAvIGMsXG4gICAgICBuMiA9IDIgKiBuMSxcbiAgICAgIG4zID0gMi41ICogbjEsXG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPCBuMSA/IG4gKiBwICogcCA6IHAgPCBuMiA/IG4gKiBNYXRoLnBvdyhwIC0gMS41IC8gYywgMikgKyAuNzUgOiBwIDwgbjMgPyBuICogKHAgLT0gMi4yNSAvIGMpICogcCArIC45Mzc1IDogbiAqIE1hdGgucG93KHAgLSAyLjYyNSAvIGMsIDIpICsgLjk4NDM3NTtcbiAgfTtcblxuICBfaW5zZXJ0RWFzZShcIkJvdW5jZVwiLCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0sIGVhc2VPdXQpO1xufSkoNy41NjI1LCAyLjc1KTtcblxuX2luc2VydEVhc2UoXCJFeHBvXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID8gTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSA6IDA7XG59KTtcblxuX2luc2VydEVhc2UoXCJDaXJjXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiAtKF9zcXJ0KDEgLSBwICogcCkgLSAxKTtcbn0pO1xuXG5faW5zZXJ0RWFzZShcIlNpbmVcIiwgZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAgPT09IDEgPyAxIDogLV9jb3MocCAqIF9IQUxGX1BJKSArIDE7XG59KTtcblxuX2luc2VydEVhc2UoXCJCYWNrXCIsIF9jb25maWdCYWNrKFwiaW5cIiksIF9jb25maWdCYWNrKFwib3V0XCIpLCBfY29uZmlnQmFjaygpKTtcblxuX2Vhc2VNYXAuU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5zdGVwcyA9IF9nbG9iYWxzLlN0ZXBwZWRFYXNlID0ge1xuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyhzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcbiAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkge1xuICAgICAgc3RlcHMgPSAxO1xuICAgIH1cblxuICAgIHZhciBwMSA9IDEgLyBzdGVwcyxcbiAgICAgICAgcDIgPSBzdGVwcyArIChpbW1lZGlhdGVTdGFydCA/IDAgOiAxKSxcbiAgICAgICAgcDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwLFxuICAgICAgICBtYXggPSAxIC0gX3RpbnlOdW07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gKChwMiAqIF9jbGFtcCgwLCBtYXgsIHApIHwgMCkgKyBwMykgKiBwMTtcbiAgICB9O1xuICB9XG59O1xuX2RlZmF1bHRzLmVhc2UgPSBfZWFzZU1hcFtcInF1YWQub3V0XCJdO1xuXG5fZm9yRWFjaE5hbWUoXCJvbkNvbXBsZXRlLG9uVXBkYXRlLG9uU3RhcnQsb25SZXBlYXQsb25SZXZlcnNlQ29tcGxldGUsb25JbnRlcnJ1cHRcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9jYWxsYmFja05hbWVzICs9IG5hbWUgKyBcIixcIiArIG5hbWUgKyBcIlBhcmFtcyxcIjtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDQUNIRVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR1NDYWNoZSA9IGZ1bmN0aW9uIEdTQ2FjaGUodGFyZ2V0LCBoYXJuZXNzKSB7XG4gIHRoaXMuaWQgPSBfZ3NJRCsrO1xuICB0YXJnZXQuX2dzYXAgPSB0aGlzO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5oYXJuZXNzID0gaGFybmVzcztcbiAgdGhpcy5nZXQgPSBoYXJuZXNzID8gaGFybmVzcy5nZXQgOiBfZ2V0UHJvcGVydHk7XG4gIHRoaXMuc2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0U2V0dGVyIDogX2dldFNldHRlcjtcbn07XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEFOSU1BVElPTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5leHBvcnQgdmFyIEFuaW1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbih2YXJzKSB7XG4gICAgdGhpcy52YXJzID0gdmFycztcbiAgICB0aGlzLl9kZWxheSA9ICt2YXJzLmRlbGF5IHx8IDA7XG5cbiAgICBpZiAodGhpcy5fcmVwZWF0ID0gdmFycy5yZXBlYXQgPT09IEluZmluaXR5ID8gLTIgOiB2YXJzLnJlcGVhdCB8fCAwKSB7XG4gICAgICAvLyBUT0RPOiByZXBlYXQ6IEluZmluaXR5IG9uIGEgdGltZWxpbmUncyBjaGlsZHJlbiBtdXN0IGZsYWcgdGhhdCB0aW1lbGluZSBpbnRlcm5hbGx5IGFuZCBhZmZlY3QgaXRzIHRvdGFsRHVyYXRpb24sIG90aGVyd2lzZSBpdCdsbCBzdG9wIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gd2hlbiByZWFjaGluZyB0aGUgc3RhcnQuXG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YXJzLnJlcGVhdERlbGF5IHx8IDA7XG4gICAgICB0aGlzLl95b3lvID0gISF2YXJzLnlveW8gfHwgISF2YXJzLnlveW9FYXNlO1xuICAgIH1cblxuICAgIHRoaXMuX3RzID0gMTtcblxuICAgIF9zZXREdXJhdGlvbih0aGlzLCArdmFycy5kdXJhdGlvbiwgMSwgMSk7XG5cbiAgICB0aGlzLmRhdGEgPSB2YXJzLmRhdGE7XG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBbmltYXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLnN0YXJ0VGltZSh0aGlzLl9zdGFydCArIHZhbHVlIC0gdGhpcy5fZGVsYXkpO1xuICAgICAgdGhpcy5fZGVsYXkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kZWxheTtcbiAgfTtcblxuICBfcHJvdG8uZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbER1cmF0aW9uKHRoaXMuX3JlcGVhdCA+IDAgPyB2YWx1ZSArICh2YWx1ZSArIHRoaXMuX3JEZWxheSkgKiB0aGlzLl9yZXBlYXQgOiB2YWx1ZSkgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSAmJiB0aGlzLl9kdXI7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiB0b3RhbER1cmF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdER1cjtcbiAgICB9XG5cbiAgICB0aGlzLl9kaXJ0eSA9IDA7XG4gICAgcmV0dXJuIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9yZXBlYXQgPCAwID8gdmFsdWUgOiAodmFsdWUgLSB0aGlzLl9yZXBlYXQgKiB0aGlzLl9yRGVsYXkpIC8gKHRoaXMuX3JlcGVhdCArIDEpKTtcbiAgfTtcblxuICBfcHJvdG8udG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgX3dha2UoKTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLl9kcDtcblxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuX3RzKSB7XG4gICAgICBfYWxpZ25QbGF5aGVhZCh0aGlzLCBfdG90YWxUaW1lKTtcblxuICAgICAgIXBhcmVudC5fZHAgfHwgcGFyZW50LnBhcmVudCB8fCBfcG9zdEFkZENoZWNrcyhwYXJlbnQsIHRoaXMpOyAvLyBlZGdlIGNhc2U6IGlmIHRoaXMgaXMgYSBjaGlsZCBvZiBhIHRpbWVsaW5lIHRoYXQgYWxyZWFkeSBjb21wbGV0ZWQsIGZvciBleGFtcGxlLCB3ZSBtdXN0IHJlLWFjdGl2YXRlIHRoZSBwYXJlbnQuXG4gICAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnQgb2YgdGhhdCBjaGlsZCB3b3VsZCBnZXQgcHVzaGVkIG91dCwgYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIG1heSBoYXZlIGNvbXBsZXRlZC5cblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQucGFyZW50Ll90aW1lICE9PSBwYXJlbnQuX3N0YXJ0ICsgKHBhcmVudC5fdHMgPj0gMCA/IHBhcmVudC5fdFRpbWUgLyBwYXJlbnQuX3RzIDogKHBhcmVudC50b3RhbER1cmF0aW9uKCkgLSBwYXJlbnQuX3RUaW1lKSAvIC1wYXJlbnQuX3RzKSkge1xuICAgICAgICAgIHBhcmVudC50b3RhbFRpbWUocGFyZW50Ll90VGltZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMuX2RwLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiAodGhpcy5fdHMgPiAwICYmIF90b3RhbFRpbWUgPCB0aGlzLl90RHVyIHx8IHRoaXMuX3RzIDwgMCAmJiBfdG90YWxUaW1lID4gMCB8fCAhdGhpcy5fdER1ciAmJiAhX3RvdGFsVGltZSkpIHtcbiAgICAgICAgLy9pZiB0aGUgYW5pbWF0aW9uIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgcHV0IGl0IGJhY2sgaW50byBpdHMgbGFzdCBwYXJlbnQgKHJlY29yZGVkIGFzIF9kcCBmb3IgZXhhY3RseSBjYXNlcyBsaWtlIHRoaXMpLiBMaW1pdCB0byBwYXJlbnRzIHdpdGggYXV0b1JlbW92ZUNoaWxkcmVuIChsaWtlIGdsb2JhbFRpbWVsaW5lKSBzbyB0aGF0IGlmIHRoZSB1c2VyIG1hbnVhbGx5IHJlbW92ZXMgYW4gYW5pbWF0aW9uIGZyb20gYSB0aW1lbGluZSBhbmQgdGhlbiBhbHRlcnMgaXRzIHBsYXloZWFkLCBpdCBkb2Vzbid0IGdldCBhZGRlZCBiYWNrIGluLlxuICAgICAgICBfYWRkVG9UaW1lbGluZSh0aGlzLl9kcCwgdGhpcywgdGhpcy5fc3RhcnQgLSB0aGlzLl9kZWxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RUaW1lICE9PSBfdG90YWxUaW1lIHx8ICF0aGlzLl9kdXIgJiYgIXN1cHByZXNzRXZlbnRzIHx8IHRoaXMuX2luaXR0ZWQgJiYgTWF0aC5hYnModGhpcy5felRpbWUpID09PSBfdGlueU51bSB8fCAhX3RvdGFsVGltZSAmJiAhdGhpcy5faW5pdHRlZCAmJiAodGhpcy5hZGQgfHwgdGhpcy5fcHRMb29rdXApKSB7XG4gICAgICAvLyBjaGVjayBmb3IgX3B0TG9va3VwIG9uIGEgVHdlZW4gaW5zdGFuY2UgdG8gZW5zdXJlIGl0IGhhcyBhY3R1YWxseSBmaW5pc2hlZCBiZWluZyBpbnN0YW50aWF0ZWQsIG90aGVyd2lzZSBpZiB0aGlzLnJldmVyc2UoKSBnZXRzIGNhbGxlZCBpbiB0aGUgQW5pbWF0aW9uIGNvbnN0cnVjdG9yLCBpdCBjb3VsZCB0cmlnZ2VyIGEgcmVuZGVyKCkgaGVyZSBldmVuIHRob3VnaCB0aGUgX3RhcmdldHMgd2VyZW4ndCBwb3B1bGF0ZWQsIHRodXMgd2hlbiBfaW5pdCgpIGlzIGNhbGxlZCB0aGVyZSB3b24ndCBiZSBhbnkgUHJvcFR3ZWVucyAoaXQnbGwgYWN0IGxpa2UgdGhlIHR3ZWVuIGlzIG5vbi1mdW5jdGlvbmFsKVxuICAgICAgdGhpcy5fdHMgfHwgKHRoaXMuX3BUaW1lID0gX3RvdGFsVGltZSk7IC8vIG90aGVyd2lzZSwgaWYgYW4gYW5pbWF0aW9uIGlzIHBhdXNlZCwgdGhlbiB0aGUgcGxheWhlYWQgaXMgbW92ZWQgYmFjayB0byB6ZXJvLCB0aGVuIHJlc3VtZWQsIGl0J2QgcmV2ZXJ0IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHRpbWUgYXQgdGhlIHBhdXNlXG4gICAgICAvL2lmICghdGhpcy5fbG9jaykgeyAvLyBhdm9pZCBlbmRsZXNzIHJlY3Vyc2lvbiAobm90IHN1cmUgd2UgbmVlZCB0aGlzIHlldCBvciBpZiBpdCdzIHdvcnRoIHRoZSBwZXJmb3JtYW5jZSBoaXQpXG4gICAgICAvLyAgIHRoaXMuX2xvY2sgPSAxO1xuXG4gICAgICBfbGF6eVNhZmVSZW5kZXIodGhpcywgX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpOyAvLyAgIHRoaXMuX2xvY2sgPSAwO1xuICAgICAgLy99XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udGltZSA9IGZ1bmN0aW9uIHRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZShNYXRoLm1pbih0aGlzLnRvdGFsRHVyYXRpb24oKSwgdmFsdWUgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcykpICUgKHRoaXMuX2R1ciArIHRoaXMuX3JEZWxheSkgfHwgKHZhbHVlID8gdGhpcy5fZHVyIDogMCksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3RpbWU7IC8vIG5vdGU6IGlmIHRoZSBtb2R1bHVzIHJlc3VsdHMgaW4gMCwgdGhlIHBsYXloZWFkIGNvdWxkIGJlIGV4YWN0bHkgYXQgdGhlIGVuZCBvciB0aGUgYmVnaW5uaW5nLCBhbmQgd2UgYWx3YXlzIGRlZmVyIHRvIHRoZSBFTkQgd2l0aCBhIG5vbi16ZXJvIHZhbHVlLCBvdGhlcndpc2UgaWYgeW91IHNldCB0aGUgdGltZSgpIHRvIHRoZSB2ZXJ5IGVuZCAoZHVyYXRpb24oKSksIGl0IHdvdWxkIHJlbmRlciBhdCB0aGUgU1RBUlQhXG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbiB0b3RhbFByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy50b3RhbER1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgPyBNYXRoLm1pbigxLCB0aGlzLl90VGltZSAvIHRoaXMuX3REdXIpIDogdGhpcy5yYXRpbztcbiAgfTtcblxuICBfcHJvdG8ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBwcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuZHVyYXRpb24oKSAqICh0aGlzLl95b3lvICYmICEodGhpcy5pdGVyYXRpb24oKSAmIDEpID8gMSAtIHZhbHVlIDogdmFsdWUpICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLmR1cmF0aW9uKCkgPyBNYXRoLm1pbigxLCB0aGlzLl90aW1lIC8gdGhpcy5fZHVyKSA6IHRoaXMucmF0aW87XG4gIH07XG5cbiAgX3Byb3RvLml0ZXJhdGlvbiA9IGZ1bmN0aW9uIGl0ZXJhdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICB2YXIgY3ljbGVEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSArIHRoaXMuX3JEZWxheTtcblxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5fdGltZSArICh2YWx1ZSAtIDEpICogY3ljbGVEdXJhdGlvbiwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fcmVwZWF0ID8gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKSArIDEgOiAxO1xuICB9IC8vIHBvdGVudGlhbCBmdXR1cmUgYWRkaXRpb246XG4gIC8vIGlzUGxheWluZ0JhY2t3YXJkcygpIHtcbiAgLy8gXHRsZXQgYW5pbWF0aW9uID0gdGhpcyxcbiAgLy8gXHRcdG9yaWVudGF0aW9uID0gMTsgLy8gMSA9IGZvcndhcmQsIC0xID0gYmFja3dhcmRcbiAgLy8gXHR3aGlsZSAoYW5pbWF0aW9uKSB7XG4gIC8vIFx0XHRvcmllbnRhdGlvbiAqPSBhbmltYXRpb24ucmV2ZXJzZWQoKSB8fCAoYW5pbWF0aW9uLnJlcGVhdCgpICYmICEoYW5pbWF0aW9uLml0ZXJhdGlvbigpICYgMSkpID8gLTEgOiAxO1xuICAvLyBcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhcmVudDtcbiAgLy8gXHR9XG4gIC8vIFx0cmV0dXJuIG9yaWVudGF0aW9uIDwgMDtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvLnRpbWVTY2FsZSA9IGZ1bmN0aW9uIHRpbWVTY2FsZSh2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J0cyA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gcmVjb3JkZWQgdGltZVNjYWxlLiBTcGVjaWFsIGNhc2U6IGlmIHNvbWVvbmUgY2FsbHMgcmV2ZXJzZSgpIG9uIGFuIGFuaW1hdGlvbiB3aXRoIHRpbWVTY2FsZSBvZiAwLCB3ZSBhc3NpZ24gaXQgLV90aW55TnVtIHRvIHJlbWVtYmVyIGl0J3MgcmV2ZXJzZWQuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3J0cyA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB0VGltZSA9IHRoaXMucGFyZW50ICYmIHRoaXMuX3RzID8gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGhpcy5wYXJlbnQuX3RpbWUsIHRoaXMpIDogdGhpcy5fdFRpbWU7IC8vIG1ha2Ugc3VyZSB0byBkbyB0aGUgcGFyZW50VG9DaGlsZFRvdGFsVGltZSgpIEJFRk9SRSBzZXR0aW5nIHRoZSBuZXcgX3RzIGJlY2F1c2UgdGhlIG9sZCBvbmUgbXVzdCBiZSB1c2VkIGluIHRoYXQgY2FsY3VsYXRpb24uXG4gICAgLy8gZnV0dXJlIGFkZGl0aW9uPyBVcCBzaWRlOiBmYXN0IGFuZCBtaW5pbWFsIGZpbGUgc2l6ZS4gRG93biBzaWRlOiBvbmx5IHdvcmtzIG9uIHRoaXMgYW5pbWF0aW9uOyBpZiBhIHRpbWVsaW5lIGlzIHJldmVyc2VkLCBmb3IgZXhhbXBsZSwgaXRzIGNoaWxkcmVucycgb25SZXZlcnNlIHdvdWxkbid0IGdldCBjYWxsZWQuXG4gICAgLy8oK3ZhbHVlIDwgMCAmJiB0aGlzLl9ydHMgPj0gMCkgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXZlcnNlXCIsIHRydWUpO1xuICAgIC8vIHByaW9yaXRpemUgcmVuZGVyaW5nIHdoZXJlIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBsaW5lcyB1cCBpbnN0ZWFkIG9mIHRoaXMuX3RUaW1lIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgYSB0d2VlbiB0aGF0J3MgYW5pbWF0aW5nIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgaW4gdGhlIHNhbWUgcmVuZGVyaW5nIGxvb3AgKHNhbWUgcGFyZW50KSwgdGh1cyBpZiB0aGUgdGltZVNjYWxlIHR3ZWVuIHJlbmRlcnMgZmlyc3QsIGl0IHdvdWxkIGFsdGVyIF9zdGFydCBCRUZPUkUgX3RUaW1lIHdhcyBzZXQgb24gdGhhdCB0aWNrIChpbiB0aGUgcmVuZGVyaW5nIGxvb3ApLCBlZmZlY3RpdmVseSBmcmVlemluZyBpdCB1bnRpbCB0aGUgdGltZVNjYWxlIHR3ZWVuIGZpbmlzaGVzLlxuXG4gICAgdGhpcy5fcnRzID0gK3ZhbHVlIHx8IDA7XG4gICAgdGhpcy5fdHMgPSB0aGlzLl9wcyB8fCB2YWx1ZSA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSB3aGljaCB3b3VsZCBiZSAwIGlmIHRoZSBhbmltYXRpb24gaXMgcGF1c2VkLlxuXG4gICAgX3JlY2FjaGVBbmNlc3RvcnModGhpcy50b3RhbFRpbWUoX2NsYW1wKC10aGlzLl9kZWxheSwgdGhpcy5fdER1ciwgdFRpbWUpLCB0cnVlKSk7XG5cbiAgICBfc2V0RW5kKHRoaXMpOyAvLyBpZiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgd2FzIGZhbHNlLCB0aGUgZW5kIHRpbWUgZGlkbid0IGdldCB1cGRhdGVkIGluIHRoZSBfYWxpZ25QbGF5aGVhZCgpIG1ldGhvZCwgc28gZG8gaXQgaGVyZS5cblxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnBhdXNlZCA9IGZ1bmN0aW9uIHBhdXNlZCh2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3BzID0gdmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wVGltZSA9IHRoaXMuX3RUaW1lIHx8IE1hdGgubWF4KC10aGlzLl9kZWxheSwgdGhpcy5yYXdUaW1lKCkpOyAvLyBpZiB0aGUgcGF1c2Ugb2NjdXJzIGR1cmluZyB0aGUgZGVsYXkgcGhhc2UsIG1ha2Ugc3VyZSB0aGF0J3MgZmFjdG9yZWQgaW4gd2hlbiByZXN1bWluZy5cblxuICAgICAgICB0aGlzLl90cyA9IHRoaXMuX2FjdCA9IDA7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUsIHNvIGEgcGF1c2VkIHR3ZWVuIHdvdWxkIGVmZmVjdGl2ZWx5IGhhdmUgYSB0aW1lU2NhbGUgb2YgMC4gV2UgcmVjb3JkIHRoZSBcInJlYWxcIiB0aW1lU2NhbGUgYXMgX3J0cyAocmVjb3JkZWQgdGltZSBzY2FsZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF93YWtlKCk7XG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9ydHM7IC8vb25seSBkZWZlciB0byBfcFRpbWUgKHBhdXNlVGltZSkgaWYgdFRpbWUgaXMgemVyby4gUmVtZW1iZXIsIHNvbWVvbmUgY291bGQgcGF1c2UoKSBhbiBhbmltYXRpb24sIHRoZW4gc2NydWIgdGhlIHBsYXloZWFkIGFuZCByZXN1bWUoKS4gSWYgdGhlIHBhcmVudCBkb2Vzbid0IGhhdmUgc21vb3RoQ2hpbGRUaW1pbmcsIHdlIHJlbmRlciBhdCB0aGUgcmF3VGltZSgpIGJlY2F1c2UgdGhlIHN0YXJ0VGltZSB3b24ndCBnZXQgdXBkYXRlZC5cblxuICAgICAgICB0aGlzLnRvdGFsVGltZSh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgPyB0aGlzLnJhd1RpbWUoKSA6IHRoaXMuX3RUaW1lIHx8IHRoaXMuX3BUaW1lLCB0aGlzLnByb2dyZXNzKCkgPT09IDEgJiYgTWF0aC5hYnModGhpcy5felRpbWUpICE9PSBfdGlueU51bSAmJiAodGhpcy5fdFRpbWUgLT0gX3RpbnlOdW0pKTsgLy8gZWRnZSBjYXNlOiBhbmltYXRpb24ucHJvZ3Jlc3MoMSkucGF1c2UoKS5wbGF5KCkgd291bGRuJ3QgcmVuZGVyIGFnYWluIGJlY2F1c2UgdGhlIHBsYXloZWFkIGlzIGFscmVhZHkgYXQgdGhlIGVuZCwgYnV0IHRoZSBjYWxsIHRvIHRvdGFsVGltZSgpIGJlbG93IHdpbGwgYWRkIGl0IGJhY2sgdG8gaXRzIHBhcmVudC4uLmFuZCBub3QgcmVtb3ZlIGl0IGFnYWluIChzaW5jZSByZW1vdmluZyBvbmx5IGhhcHBlbnMgdXBvbiByZW5kZXJpbmcgYXQgYSBuZXcgdGltZSkuIE9mZnNldHRpbmcgdGhlIF90VGltZSBzbGlnaHRseSBpcyBkb25lIHNpbXBseSB0byBjYXVzZSB0aGUgZmluYWwgcmVuZGVyIGluIHRvdGFsVGltZSgpIHRoYXQnbGwgcG9wIGl0IG9mZiBpdHMgdGltZWxpbmUgKGlmIGF1dG9SZW1vdmVDaGlsZHJlbiBpcyB0cnVlLCBvZiBjb3Vyc2UpLiBDaGVjayB0byBtYWtlIHN1cmUgX3pUaW1lIGlzbid0IC1fdGlueU51bSB0byBhdm9pZCBhbiBlZGdlIGNhc2Ugd2hlcmUgdGhlIHBsYXloZWFkIGlzIHB1c2hlZCB0byB0aGUgZW5kIGJ1dCBJTlNJREUgYSB0d2Vlbi9jYWxsYmFjaywgdGhlIHRpbWVsaW5lIGl0c2VsZiBpcyBwYXVzZWQgdGh1cyBoYWx0aW5nIHJlbmRlcmluZyBhbmQgbGVhdmluZyBhIGZldyB1bnJlbmRlcmVkLiBXaGVuIHJlc3VtaW5nLCBpdCB3b3VsZG4ndCByZW5kZXIgdGhvc2Ugb3RoZXJ3aXNlLlxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5zdGFydFRpbWUgPSBmdW5jdGlvbiBzdGFydFRpbWUodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc3RhcnQgPSB2YWx1ZTtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDtcbiAgICAgIHBhcmVudCAmJiAocGFyZW50Ll9zb3J0IHx8ICF0aGlzLnBhcmVudCkgJiYgX2FkZFRvVGltZWxpbmUocGFyZW50LCB0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdGFydDtcbiAgfTtcblxuICBfcHJvdG8uZW5kVGltZSA9IGZ1bmN0aW9uIGVuZFRpbWUoaW5jbHVkZVJlcGVhdHMpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnQgKyAoX2lzTm90RmFsc2UoaW5jbHVkZVJlcGVhdHMpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gTWF0aC5hYnModGhpcy5fdHMgfHwgMSk7XG4gIH07XG5cbiAgX3Byb3RvLnJhd1RpbWUgPSBmdW5jdGlvbiByYXdUaW1lKHdyYXBSZXBlYXRzKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwOyAvLyBfZHAgPSBkZXRhY2hlZCBwYXJlbnRcblxuICAgIHJldHVybiAhcGFyZW50ID8gdGhpcy5fdFRpbWUgOiB3cmFwUmVwZWF0cyAmJiAoIXRoaXMuX3RzIHx8IHRoaXMuX3JlcGVhdCAmJiB0aGlzLl90aW1lICYmIHRoaXMudG90YWxQcm9ncmVzcygpIDwgMSkgPyB0aGlzLl90VGltZSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIDogIXRoaXMuX3RzID8gdGhpcy5fdFRpbWUgOiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnQucmF3VGltZSh3cmFwUmVwZWF0cyksIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5nbG9iYWxUaW1lID0gZnVuY3Rpb24gZ2xvYmFsVGltZShyYXdUaW1lKSB7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMsXG4gICAgICAgIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID8gcmF3VGltZSA6IGFuaW1hdGlvbi5yYXdUaW1lKCk7XG5cbiAgICB3aGlsZSAoYW5pbWF0aW9uKSB7XG4gICAgICB0aW1lID0gYW5pbWF0aW9uLl9zdGFydCArIHRpbWUgLyAoYW5pbWF0aW9uLl90cyB8fCAxKTtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5fZHA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWU7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGVhdCA9IGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9yZXBlYXQgPSB2YWx1ZSA9PT0gSW5maW5pdHkgPyAtMiA6IHZhbHVlO1xuICAgICAgcmV0dXJuIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcGVhdCA9PT0gLTIgPyBJbmZpbml0eSA6IHRoaXMuX3JlcGVhdDtcbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiByZXBlYXREZWxheSh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdGltZSA9IHRoaXMuX3RpbWU7XG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YWx1ZTtcblxuICAgICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcblxuICAgICAgcmV0dXJuIHRpbWUgPyB0aGlzLnRpbWUodGltZSkgOiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yRGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLnlveW8gPSBmdW5jdGlvbiB5b3lvKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3lveW8gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl95b3lvO1xuICB9O1xuXG4gIF9wcm90by5zZWVrID0gZnVuY3Rpb24gc2Vlayhwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5yZXN0YXJ0ID0gZnVuY3Rpb24gcmVzdGFydChpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheSgpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5wbGF5ID0gZnVuY3Rpb24gcGxheShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGF0VGltZSAhPSBudWxsICYmIHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlZCA9IGZ1bmN0aW9uIHJldmVyc2VkKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICEhdmFsdWUgIT09IHRoaXMucmV2ZXJzZWQoKSAmJiB0aGlzLnRpbWVTY2FsZSgtdGhpcy5fcnRzIHx8ICh2YWx1ZSA/IC1fdGlueU51bSA6IDApKTsgLy8gaW4gY2FzZSB0aW1lU2NhbGUgaXMgemVybywgcmV2ZXJzaW5nIHdvdWxkIGhhdmUgbm8gZWZmZWN0IHNvIHdlIHVzZSBfdGlueU51bS5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3J0cyA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9hY3QgPSAwO1xuICAgIHRoaXMuX3pUaW1lID0gLV90aW55TnVtO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcCxcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9zdGFydCxcbiAgICAgICAgcmF3VGltZTtcbiAgICByZXR1cm4gISEoIXBhcmVudCB8fCB0aGlzLl90cyAmJiB0aGlzLl9pbml0dGVkICYmIHBhcmVudC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gcGFyZW50LnJhd1RpbWUodHJ1ZSkpID49IHN0YXJ0ICYmIHJhd1RpbWUgPCB0aGlzLmVuZFRpbWUodHJ1ZSkgLSBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiBldmVudENhbGxiYWNrKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMpIHtcbiAgICB2YXIgdmFycyA9IHRoaXMudmFycztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBkZWxldGUgdmFyc1t0eXBlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcnNbdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgcGFyYW1zICYmICh2YXJzW3R5cGUgKyBcIlBhcmFtc1wiXSA9IHBhcmFtcyk7XG4gICAgICAgIHR5cGUgPT09IFwib25VcGRhdGVcIiAmJiAodGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJzW3R5cGVdO1xuICB9O1xuXG4gIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHZhciBmID0gX2lzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiBfcGFzc1Rocm91Z2gsXG4gICAgICAgICAgX3Jlc29sdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZSgpIHtcbiAgICAgICAgdmFyIF90aGVuID0gc2VsZi50aGVuO1xuICAgICAgICBzZWxmLnRoZW4gPSBudWxsOyAvLyB0ZW1wb3JhcmlseSBudWxsIHRoZSB0aGVuKCkgbWV0aG9kIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzMyMilcblxuICAgICAgICBfaXNGdW5jdGlvbihmKSAmJiAoZiA9IGYoc2VsZikpICYmIChmLnRoZW4gfHwgZiA9PT0gc2VsZikgJiYgKHNlbGYudGhlbiA9IF90aGVuKTtcbiAgICAgICAgcmVzb2x2ZShmKTtcbiAgICAgICAgc2VsZi50aGVuID0gX3RoZW47XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VsZi5faW5pdHRlZCAmJiBzZWxmLnRvdGFsUHJvZ3Jlc3MoKSA9PT0gMSAmJiBzZWxmLl90cyA+PSAwIHx8ICFzZWxmLl90VGltZSAmJiBzZWxmLl90cyA8IDApIHtcbiAgICAgICAgX3Jlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3Byb20gPSBfcmVzb2x2ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgX2ludGVycnVwdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gQW5pbWF0aW9uO1xufSgpO1xuXG5fc2V0RGVmYXVsdHMoQW5pbWF0aW9uLnByb3RvdHlwZSwge1xuICBfdGltZTogMCxcbiAgX3N0YXJ0OiAwLFxuICBfZW5kOiAwLFxuICBfdFRpbWU6IDAsXG4gIF90RHVyOiAwLFxuICBfZGlydHk6IDAsXG4gIF9yZXBlYXQ6IDAsXG4gIF95b3lvOiBmYWxzZSxcbiAgcGFyZW50OiBudWxsLFxuICBfaW5pdHRlZDogZmFsc2UsXG4gIF9yRGVsYXk6IDAsXG4gIF90czogMSxcbiAgX2RwOiAwLFxuICByYXRpbzogMCxcbiAgX3pUaW1lOiAtX3RpbnlOdW0sXG4gIF9wcm9tOiAwLFxuICBfcHM6IGZhbHNlLFxuICBfcnRzOiAxXG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSU1FTElORVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBUaW1lbGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0FuaW1hdGlvbikge1xuICBfaW5oZXJpdHNMb29zZShUaW1lbGluZSwgX0FuaW1hdGlvbik7XG5cbiAgZnVuY3Rpb24gVGltZWxpbmUodmFycywgcG9zaXRpb24pIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQW5pbWF0aW9uLmNhbGwodGhpcywgdmFycykgfHwgdGhpcztcbiAgICBfdGhpcy5sYWJlbHMgPSB7fTtcbiAgICBfdGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICEhdmFycy5zbW9vdGhDaGlsZFRpbWluZztcbiAgICBfdGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAhIXZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuO1xuICAgIF90aGlzLl9zb3J0ID0gX2lzTm90RmFsc2UodmFycy5zb3J0Q2hpbGRyZW4pO1xuICAgIF9nbG9iYWxUaW1lbGluZSAmJiBfYWRkVG9UaW1lbGluZSh2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBwb3NpdGlvbik7XG4gICAgdmFycy5yZXZlcnNlZCAmJiBfdGhpcy5yZXZlcnNlKCk7XG4gICAgdmFycy5wYXVzZWQgJiYgX3RoaXMucGF1c2VkKHRydWUpO1xuICAgIHZhcnMuc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFycy5zY3JvbGxUcmlnZ2VyKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFRpbWVsaW5lLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICBfY3JlYXRlVHdlZW5UeXBlKDAsIGFyZ3VtZW50cywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgxLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcbiAgICBfY3JlYXRlVHdlZW5UeXBlKDIsIGFyZ3VtZW50cywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gISF2YXJzLmltbWVkaWF0ZVJlbmRlcjtcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmNhbGwgPSBmdW5jdGlvbiBjYWxsKGNhbGxiYWNrLCBwYXJhbXMsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMpLCBwb3NpdGlvbik7XG4gIH0gLy9PTkxZIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5ISBNYXliZSBkZWxldGU/XG4gIDtcblxuICBfcHJvdG8yLnN0YWdnZXJUbyA9IGZ1bmN0aW9uIHN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdmFycy5zdGFnZ2VyID0gdmFycy5zdGFnZ2VyIHx8IHN0YWdnZXI7XG4gICAgdmFycy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZUFsbDtcbiAgICB2YXJzLm9uQ29tcGxldGVQYXJhbXMgPSBvbkNvbXBsZXRlQWxsUGFyYW1zO1xuICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tID0gZnVuY3Rpb24gc3RhZ2dlckZyb20odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5ydW5CYWNrd2FyZHMgPSAxO1xuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuICB9O1xuXG4gIF9wcm90bzIuc3RhZ2dlckZyb21UbyA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tVG8odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcbiAgICBfaW5oZXJpdERlZmF1bHRzKHRvVmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodG9WYXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl9kaXJ0eSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5fdER1cixcbiAgICAgICAgZHVyID0gdGhpcy5fZHVyLFxuICAgICAgICB0VGltZSA9IHRvdGFsVGltZSA8PSAwID8gMCA6IF9yb3VuZFByZWNpc2UodG90YWxUaW1lKSxcbiAgICAgICAgLy8gaWYgYSBwYXVzZWQgdGltZWxpbmUgaXMgcmVzdW1lZCAob3IgaXRzIF9zdGFydCBpcyB1cGRhdGVkIGZvciBhbm90aGVyIHJlYXNvbi4uLndoaWNoIHJvdW5kcyBpdCksIHRoYXQgY291bGQgcmVzdWx0IGluIHRoZSBwbGF5aGVhZCBzaGlmdGluZyBhICoqdGlueSoqIGFtb3VudCBhbmQgYSB6ZXJvLWR1cmF0aW9uIGNoaWxkIGF0IHRoYXQgc3BvdCBtYXkgZ2V0IHJlbmRlcmVkIGF0IGEgZGlmZmVyZW50IHJhdGlvLCBsaWtlIGl0cyB0b3RhbFRpbWUgaW4gcmVuZGVyKCkgbWF5IGJlIDFlLTE3IGluc3RlYWQgb2YgMCwgZm9yIGV4YW1wbGUuXG4gICAgY3Jvc3NpbmdTdGFydCA9IHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCAmJiAodGhpcy5faW5pdHRlZCB8fCAhZHVyKSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG5leHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldlBhdXNlZCxcbiAgICAgICAgcGF1c2VUd2VlbixcbiAgICAgICAgdGltZVNjYWxlLFxuICAgICAgICBwcmV2U3RhcnQsXG4gICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgIHlveW8sXG4gICAgICAgIGlzWW95bztcbiAgICB0aGlzICE9PSBfZ2xvYmFsVGltZWxpbmUgJiYgdFRpbWUgPiB0RHVyICYmIHRvdGFsVGltZSA+PSAwICYmICh0VGltZSA9IHREdXIpO1xuXG4gICAgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCBmb3JjZSB8fCBjcm9zc2luZ1N0YXJ0KSB7XG4gICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgJiYgZHVyKSB7XG4gICAgICAgIC8vaWYgdG90YWxEdXJhdGlvbigpIGZpbmRzIGEgY2hpbGQgd2l0aCBhIG5lZ2F0aXZlIHN0YXJ0VGltZSBhbmQgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgdGhpbmdzIGdldCBzaGlmdGVkIGFyb3VuZCBpbnRlcm5hbGx5IHNvIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB0aW1lIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgYSB0d2VlbiBzdGFydHMgYXQgLTMwIHdlIG11c3Qgc2hpZnQgRVZFUllUSElORyBmb3J3YXJkIDMwIHNlY29uZHMgYW5kIG1vdmUgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSBiYWNrd2FyZCBieSAzMCBzZWNvbmRzIHNvIHRoYXQgdGhpbmdzIGFsaWduIHdpdGggdGhlIHBsYXloZWFkIChubyBqdW1wKS5cbiAgICAgICAgdFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuICAgICAgICB0b3RhbFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuICAgICAgfVxuXG4gICAgICB0aW1lID0gdFRpbWU7XG4gICAgICBwcmV2U3RhcnQgPSB0aGlzLl9zdGFydDtcbiAgICAgIHRpbWVTY2FsZSA9IHRoaXMuX3RzO1xuICAgICAgcHJldlBhdXNlZCA9ICF0aW1lU2NhbGU7XG5cbiAgICAgIGlmIChjcm9zc2luZ1N0YXJ0KSB7XG4gICAgICAgIGR1ciB8fCAocHJldlRpbWUgPSB0aGlzLl96VGltZSk7IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUsIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cbiAgICAgICAgKHRvdGFsVGltZSB8fCAhc3VwcHJlc3NFdmVudHMpICYmICh0aGlzLl96VGltZSA9IHRvdGFsVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXG4gICAgICAgIHlveW8gPSB0aGlzLl95b3lvO1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0VGltZSA9PT0gdER1cikge1xuICAgICAgICAgIC8vIHRoZSB0RHVyID09PSB0VGltZSBpcyBmb3IgZWRnZSBjYXNlcyB3aGVyZSB0aGVyZSdzIGEgbGVuZ3RoeSBkZWNpbWFsIG9uIHRoZSBkdXJhdGlvbiBhbmQgaXQgbWF5IHJlYWNoIHRoZSB2ZXJ5IGVuZCBidXQgdGhlIHRpbWUgaXMgcmVuZGVyZWQgYXMgbm90LXF1aXRlLXRoZXJlIChyZW1lbWJlciwgdER1ciBpcyByb3VuZGVkIHRvIDQgZGVjaW1hbHMgd2hlcmVhcyBkdXIgaXNuJ3QpXG4gICAgICAgICAgaXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuICAgICAgICAhcHJldlRpbWUgJiYgdGhpcy5fdFRpbWUgJiYgcHJldkl0ZXJhdGlvbiAhPT0gaXRlcmF0aW9uICYmIChwcmV2SXRlcmF0aW9uID0gaXRlcmF0aW9uKTsgLy8gZWRnZSBjYXNlIC0gaWYgc29tZW9uZSBkb2VzIGFkZFBhdXNlKCkgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgcmVwZWF0aW5nIHRpbWVsaW5lLCB0aGF0IHBhdXNlIGlzIHRlY2huaWNhbGx5IGF0IHRoZSBzYW1lIHNwb3QgYXMgdGhlIGVuZCB3aGljaCBjYXVzZXMgdGhpcy5fdGltZSB0byBnZXQgc2V0IHRvIDAgd2hlbiB0aGUgdG90YWxUaW1lIHdvdWxkIG5vcm1hbGx5IHBsYWNlIHRoZSBwbGF5aGVhZCBhdCB0aGUgZW5kLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMzgyMy1jbG9zaW5nLW5hdi1hbmltYXRpb24tbm90LXdvcmtpbmctb24taWUtYW5kLWlwaG9uZS02LW1heWJlLW90aGVyLW9sZGVyLWJyb3dzZXIvP3RhYj1jb21tZW50cyNjb21tZW50LTExMzAwNVxuXG4gICAgICAgIGlmICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpIHtcbiAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcbiAgICAgICAgICBpc1lveW8gPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIG1ha2Ugc3VyZSBjaGlsZHJlbiBhdCB0aGUgZW5kL2JlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUgYXJlIHJlbmRlcmVkIHByb3Blcmx5LiBJZiwgZm9yIGV4YW1wbGUsXG4gICAgICAgIGEgMy1zZWNvbmQgbG9uZyB0aW1lbGluZSByZW5kZXJlZCBhdCAyLjkgc2Vjb25kcyBwcmV2aW91c2x5LCBhbmQgbm93IHJlbmRlcnMgYXQgMy4yIHNlY29uZHMgKHdoaWNoXG4gICAgICAgIHdvdWxkIGdldCB0cmFuc2xhdGVkIHRvIDIuOCBzZWNvbmRzIGlmIHRoZSB0aW1lbGluZSB5b3lvcyBvciAwLjIgc2Vjb25kcyBpZiBpdCBqdXN0IHJlcGVhdHMpLCB0aGVyZVxuICAgICAgICBjb3VsZCBiZSBhIGNhbGxiYWNrIG9yIGEgc2hvcnQgdHdlZW4gdGhhdCdzIGF0IDIuOTUgb3IgMyBzZWNvbmRzIGluIHdoaWNoIHdvdWxkbid0IHJlbmRlci4gU29cbiAgICAgICAgd2UgbmVlZCB0byBwdXNoIHRoZSB0aW1lbGluZSB0byB0aGUgZW5kIChhbmQvb3IgYmVnaW5uaW5nIGRlcGVuZGluZyBvbiBpdHMgeW95byB2YWx1ZSkuIEFsc28gd2UgbXVzdFxuICAgICAgICBlbnN1cmUgdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBUaW1lbGluZSB3b3JrLlxuICAgICAgICAqL1xuXG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbiAmJiAhdGhpcy5fbG9jaykge1xuICAgICAgICAgIHZhciByZXdpbmRpbmcgPSB5b3lvICYmIHByZXZJdGVyYXRpb24gJiAxLFxuICAgICAgICAgICAgICBkb2VzV3JhcCA9IHJld2luZGluZyA9PT0gKHlveW8gJiYgaXRlcmF0aW9uICYgMSk7XG4gICAgICAgICAgaXRlcmF0aW9uIDwgcHJldkl0ZXJhdGlvbiAmJiAocmV3aW5kaW5nID0gIXJld2luZGluZyk7XG4gICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyAwIDogZHVyO1xuICAgICAgICAgIHRoaXMuX2xvY2sgPSAxO1xuICAgICAgICAgIHRoaXMucmVuZGVyKHByZXZUaW1lIHx8IChpc1lveW8gPyAwIDogX3JvdW5kUHJlY2lzZShpdGVyYXRpb24gKiBjeWNsZUR1cmF0aW9uKSksIHN1cHByZXNzRXZlbnRzLCAhZHVyKS5fbG9jayA9IDA7XG4gICAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTsgLy8gaWYgYSB1c2VyIGdldHMgdGhlIGl0ZXJhdGlvbigpIGluc2lkZSB0aGUgb25SZXBlYXQsIGZvciBleGFtcGxlLCBpdCBzaG91bGQgYmUgYWNjdXJhdGUuXG5cbiAgICAgICAgICAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG4gICAgICAgICAgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAodGhpcy5pbnZhbGlkYXRlKCkuX2xvY2sgPSAxKTtcblxuICAgICAgICAgIGlmIChwcmV2VGltZSAmJiBwcmV2VGltZSAhPT0gdGhpcy5fdGltZSB8fCBwcmV2UGF1c2VkICE9PSAhdGhpcy5fdHMgfHwgdGhpcy52YXJzLm9uUmVwZWF0ICYmICF0aGlzLnBhcmVudCAmJiAhdGhpcy5fYWN0KSB7XG4gICAgICAgICAgICAvLyBpZiBwcmV2VGltZSBpcyAwIGFuZCB3ZSByZW5kZXIgYXQgdGhlIHZlcnkgZW5kLCBfdGltZSB3aWxsIGJlIHRoZSBlbmQsIHRodXMgd29uJ3QgbWF0Y2guIFNvIGluIHRoaXMgZWRnZSBjYXNlLCBwcmV2VGltZSB3b24ndCBtYXRjaCBfdGltZSBidXQgdGhhdCdzIG9rYXkuIElmIGl0IGdldHMga2lsbGVkIGluIHRoZSBvblJlcGVhdCwgZWplY3QgYXMgd2VsbC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGR1ciA9IHRoaXMuX2R1cjsgLy8gaW4gY2FzZSB0aGUgZHVyYXRpb24gY2hhbmdlZCBpbiB0aGUgb25SZXBlYXRcblxuICAgICAgICAgIHREdXIgPSB0aGlzLl90RHVyO1xuXG4gICAgICAgICAgaWYgKGRvZXNXcmFwKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NrID0gMjtcbiAgICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gZHVyIDogLTAuMDAwMTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IC8vaW4gb3JkZXIgZm9yIHlveW9FYXNlIHRvIHdvcmsgcHJvcGVybHkgd2hlbiB0aGVyZSdzIGEgc3RhZ2dlciwgd2UgbXVzdCBzd2FwIG91dCB0aGUgZWFzZSBpbiBlYWNoIHN1Yi10d2Vlbi5cblxuXG4gICAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKHRoaXMsIGlzWW95byk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nICYmIHRoaXMuX2xvY2sgPCAyKSB7XG4gICAgICAgIHBhdXNlVHdlZW4gPSBfZmluZE5leHRQYXVzZVR3ZWVuKHRoaXMsIF9yb3VuZFByZWNpc2UocHJldlRpbWUpLCBfcm91bmRQcmVjaXNlKHRpbWUpKTtcblxuICAgICAgICBpZiAocGF1c2VUd2Vlbikge1xuICAgICAgICAgIHRUaW1lIC09IHRpbWUgLSAodGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgICB0aGlzLl9hY3QgPSAhdGltZVNjYWxlOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuICAgICAgICB0aGlzLl9pbml0dGVkID0gMTtcbiAgICAgICAgdGhpcy5felRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICAgIHByZXZUaW1lID0gMDsgLy8gdXBvbiBpbml0LCB0aGUgcGxheWhlYWQgc2hvdWxkIGFsd2F5cyBnbyBmb3J3YXJkOyBzb21lb25lIGNvdWxkIGludmFsaWRhdGUoKSBhIGNvbXBsZXRlZCB0aW1lbGluZSBhbmQgdGhlbiBpZiB0aGV5IHJlc3RhcnQoKSwgdGhhdCB3b3VsZCBtYWtlIGNoaWxkIHR3ZWVucyByZW5kZXIgaW4gcmV2ZXJzZSBvcmRlciB3aGljaCBjb3VsZCBsb2NrIGluIHRoZSB3cm9uZyBzdGFydGluZyB2YWx1ZXMgaWYgdGhleSBidWlsZCBvbiBlYWNoIG90aGVyLCBsaWtlIHRsLnRvKG9iaiwge3g6IDEwMH0pLnRvKG9iaiwge3g6IDB9KS5cbiAgICAgIH1cblxuICAgICAgaWYgKCFwcmV2VGltZSAmJiB0aW1lICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdFRpbWUpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvblN0YXJ0IHRyaWdnZXJlZCBhIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90LCBlamVjdC4gTGlrZSBpZiBzb21lb25lIGRpZCBhbmltYXRpb24ucGF1c2UoMC41KSBvciBzb21ldGhpbmcgaW5zaWRlIHRoZSBvblN0YXJ0LlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lID49IHByZXZUaW1lICYmIHRvdGFsVGltZSA+PSAwKSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gICAgICAgICAgaWYgKChjaGlsZC5fYWN0IHx8IHRpbWUgPj0gY2hpbGQuX3N0YXJ0KSAmJiBjaGlsZC5fdHMgJiYgcGF1c2VUd2VlbiAhPT0gY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgLy8gYW4gZXh0cmVtZSBlZGdlIGNhc2UgLSB0aGUgY2hpbGQncyByZW5kZXIgY291bGQgZG8gc29tZXRoaW5nIGxpa2Uga2lsbCgpIHRoZSBcIm5leHRcIiBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0LCBvciByZXBhcmVudCBpdC4gSW4gdGhhdCBjYXNlIHdlIG11c3QgcmUtaW5pdGlhdGUgdGhlIHdob2xlIHJlbmRlciB0byBiZSBzYWZlLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXIoY2hpbGQuX3RzID4gMCA/ICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lICE9PSB0aGlzLl90aW1lIHx8ICF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG4gICAgICAgICAgICAgIHBhdXNlVHdlZW4gPSAwO1xuICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IC1fdGlueU51bSk7IC8vIGl0IGRpZG4ndCBmaW5pc2ggcmVuZGVyaW5nLCBzbyBmbGFnIHpUaW1lIGFzIG5lZ2F0aXZlIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9sYXN0O1xuICAgICAgICB2YXIgYWRqdXN0ZWRUaW1lID0gdG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6IHRpbWU7IC8vd2hlbiB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBiZXlvbmQgdGhlIHN0YXJ0IG9mIHRoaXMgdGltZWxpbmUsIHdlIG11c3QgcGFzcyB0aGF0IGluZm9ybWF0aW9uIGRvd24gdG8gdGhlIGNoaWxkIGFuaW1hdGlvbnMgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBrbm93IHdoZXRoZXIgdG8gcmVuZGVyIHRoZWlyIHN0YXJ0aW5nIG9yIGVuZGluZyB2YWx1ZXMuXG5cbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgbmV4dCA9IGNoaWxkLl9wcmV2O1xuXG4gICAgICAgICAgaWYgKChjaGlsZC5fYWN0IHx8IGFkanVzdGVkVGltZSA8PSBjaGlsZC5fZW5kKSAmJiBjaGlsZC5fdHMgJiYgcGF1c2VUd2VlbiAhPT0gY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgLy8gYW4gZXh0cmVtZSBlZGdlIGNhc2UgLSB0aGUgY2hpbGQncyByZW5kZXIgY291bGQgZG8gc29tZXRoaW5nIGxpa2Uga2lsbCgpIHRoZSBcIm5leHRcIiBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0LCBvciByZXBhcmVudCBpdC4gSW4gdGhhdCBjYXNlIHdlIG11c3QgcmUtaW5pdGlhdGUgdGhlIHdob2xlIHJlbmRlciB0byBiZSBzYWZlLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXIoY2hpbGQuX3RzID4gMCA/IChhZGp1c3RlZFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArIChhZGp1c3RlZFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSBhZGp1c3RlZFRpbWUgPyAtX3RpbnlOdW0gOiBfdGlueU51bSk7IC8vIGl0IGRpZG4ndCBmaW5pc2ggcmVuZGVyaW5nLCBzbyBhZGp1c3QgelRpbWUgc28gdGhhdCBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgcmVuZGVyKCkgaXMgY2FsbGVkIGl0J2xsIGJlIGZvcmNlZCAodG8gcmVuZGVyIGFueSByZW1haW5pbmcgY2hpbGRyZW4pXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXVzZVR3ZWVuICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIHBhdXNlVHdlZW4ucmVuZGVyKHRpbWUgPj0gcHJldlRpbWUgPyAwIDogLV90aW55TnVtKS5felRpbWUgPSB0aW1lID49IHByZXZUaW1lID8gMSA6IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLl90cykge1xuICAgICAgICAgIC8vdGhlIGNhbGxiYWNrIHJlc3VtZWQgcGxheWJhY2shIFNvIHNpbmNlIHdlIG1heSBoYXZlIGhlbGQgYmFjayB0aGUgcGxheWhlYWQgZHVlIHRvIHdoZXJlIHRoZSBwYXVzZSBpcyBwb3NpdGlvbmVkLCBnbyBhaGVhZCBhbmQganVtcCB0byB3aGVyZSBpdCdzIFNVUFBPU0VEIHRvIGJlIChpZiBubyBwYXVzZSBoYXBwZW5lZCkuXG4gICAgICAgICAgdGhpcy5fc3RhcnQgPSBwcmV2U3RhcnQ7IC8vaWYgdGhlIHBhdXNlIHdhcyBhdCBhbiBlYXJsaWVyIHRpbWUgYW5kIHRoZSB1c2VyIHJlc3VtZWQgaW4gdGhlIGNhbGxiYWNrLCBpdCBjb3VsZCByZXBvc2l0aW9uIHRoZSB0aW1lbGluZSAoY2hhbmdpbmcgaXRzIHN0YXJ0VGltZSksIHRocm93aW5nIHRoaW5ncyBvZmYgc2xpZ2h0bHksIHNvIHdlIG1ha2Ugc3VyZSB0aGUgX3N0YXJ0IGRvZXNuJ3Qgc2hpZnQuXG5cbiAgICAgICAgICBfc2V0RW5kKHRoaXMpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIiwgdHJ1ZSk7XG4gICAgICBpZiAodFRpbWUgPT09IHREdXIgJiYgdER1ciA+PSB0aGlzLnRvdGFsRHVyYXRpb24oKSB8fCAhdFRpbWUgJiYgcHJldlRpbWUpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0IHx8IE1hdGguYWJzKHRpbWVTY2FsZSkgIT09IE1hdGguYWJzKHRoaXMuX3RzKSkgaWYgKCF0aGlzLl9sb2NrKSB7XG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUgfHwgIXREdXIpKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyICYmIHRvdGFsVGltZSA+PSAwID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGQgPSBmdW5jdGlvbiBhZGQoY2hpbGQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xuXG4gICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG4gICAgICBpZiAoX2lzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkKG9iaiwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsKGNoaWxkLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcyAhPT0gY2hpbGQgPyBfYWRkVG9UaW1lbGluZSh0aGlzLCBjaGlsZCwgcG9zaXRpb24pIDogdGhpczsgLy9kb24ndCBhbGxvdyBhIHRpbWVsaW5lIHRvIGJlIGFkZGVkIHRvIGl0c2VsZiBhcyBhIGNoaWxkIVxuICB9O1xuXG4gIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKG5lc3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0d2VlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdHdlZW5zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGltZWxpbmVzID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWVsaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IC1fYmlnTnVtO1xuICAgIH1cblxuICAgIHZhciBhID0gW10sXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICAgIHR3ZWVucyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVsaW5lcyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICAgIG5lc3RlZCAmJiBhLnB1c2guYXBwbHkoYSwgY2hpbGQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0QnlJZCA9IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oMSwgMSwgMSksXG4gICAgICAgIGkgPSBhbmltYXRpb25zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhbmltYXRpb25zW2ldLnZhcnMuaWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCkge1xuICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVMYWJlbChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9pc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMua2lsbFR3ZWVuc09mKGNoaWxkKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgY2hpbGQpO1xuXG4gICAgaWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcbiAgICAgIHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgIH1cblxuICAgIHRoaXMuX2ZvcmNpbmcgPSAxO1xuXG4gICAgaWYgKCF0aGlzLl9kcCAmJiB0aGlzLl90cykge1xuICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cbiAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgIH1cblxuICAgIF9BbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5jYWxsKHRoaXMsIF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cyk7XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgIGRlbGV0ZSB0aGlzLmxhYmVsc1tsYWJlbF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRQYXVzZSA9IGZ1bmN0aW9uIGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgIHRoaXMuX2hhc1BhdXNlID0gMTtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuICAgIGNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICBpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykgJiYgY2hpbGQuZ2xvYmFsVGltZSgwKSA8PSBvbmx5QWN0aXZlICYmIGNoaWxkLmdsb2JhbFRpbWUoY2hpbGQudG90YWxEdXJhdGlvbigpKSA+IG9ubHlBY3RpdmUgOiAhb25seUFjdGl2ZSB8fCBjaGlsZC5pc0FjdGl2ZSgpKSkge1xuICAgICAgICAgIC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlIC0gdGFyZ2V0cygpIG9uIHRpbWVsaW5lc1xuICAvLyB0YXJnZXRzKCkge1xuICAvLyBcdGxldCByZXN1bHQgPSBbXTtcbiAgLy8gXHR0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKHQgPT4gcmVzdWx0LnB1c2goLi4udC50YXJnZXRzKCkpKTtcbiAgLy8gXHRyZXR1cm4gcmVzdWx0LmZpbHRlcigodiwgaSkgPT4gcmVzdWx0LmluZGV4T2YodikgPT09IGkpO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICBvblN0YXJ0UGFyYW1zID0gX3ZhcnMub25TdGFydFBhcmFtcyxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBpbml0dGVkLFxuICAgICAgICB0d2VlbiA9IFR3ZWVuLnRvKHRsLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICBkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpIHx8IF90aW55TnVtLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgdGwucGF1c2UoKTtcblxuICAgICAgICBpZiAoIWluaXR0ZWQpIHtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSk7XG4gICAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBpbml0dGVkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vblN0YXJ0ICYmIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuXG4gICAgcmV0dXJuIGltbWVkaWF0ZVJlbmRlciA/IHR3ZWVuLnJlbmRlcigwKSA6IHR3ZWVuO1xuICB9O1xuXG4gIF9wcm90bzIudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbiB0d2VlbkZyb21Ubyhmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcbiAgICByZXR1cm4gdGhpcy50d2VlblRvKHRvUG9zaXRpb24sIF9zZXREZWZhdWx0cyh7XG4gICAgICBzdGFydEF0OiB7XG4gICAgICAgIHRpbWU6IF9wYXJzZVBvc2l0aW9uKHRoaXMsIGZyb21Qb3NpdGlvbilcbiAgICAgIH1cbiAgICB9LCB2YXJzKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZWNlbnQgPSBmdW5jdGlvbiByZWNlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY2VudDtcbiAgfTtcblxuICBfcHJvdG8yLm5leHRMYWJlbCA9IGZ1bmN0aW9uIG5leHRMYWJlbChhZnRlclRpbWUpIHtcbiAgICBpZiAoYWZ0ZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGFmdGVyVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xuICB9O1xuXG4gIF9wcm90bzIucHJldmlvdXNMYWJlbCA9IGZ1bmN0aW9uIHByZXZpb3VzTGFiZWwoYmVmb3JlVGltZSkge1xuICAgIGlmIChiZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGJlZm9yZVRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBiZWZvcmVUaW1lKSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvMi5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbiBjdXJyZW50TGFiZWwodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8yLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbiBzaGlmdENoaWxkcmVuKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgY2hpbGQuX3N0YXJ0ICs9IGFtb3VudDtcbiAgICAgICAgY2hpbGQuX2VuZCArPSBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdExhYmVscykge1xuICAgICAgZm9yIChwIGluIGxhYmVscykge1xuICAgICAgICBpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLmludmFsaWRhdGUoKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaW5jbHVkZUxhYmVscykge1xuICAgIGlmIChpbmNsdWRlTGFiZWxzID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG4gICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fZHAgJiYgKHRoaXMuX3RpbWUgPSB0aGlzLl90VGltZSA9IHRoaXMuX3BUaW1lID0gMCk7XG4gICAgaW5jbHVkZUxhYmVscyAmJiAodGhpcy5sYWJlbHMgPSB7fSk7XG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNoaWxkID0gc2VsZi5fbGFzdCxcbiAgICAgICAgcHJldlN0YXJ0ID0gX2JpZ051bSxcbiAgICAgICAgcHJldixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHBhcmVudDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VsZi50aW1lU2NhbGUoKHNlbGYuX3JlcGVhdCA8IDAgPyBzZWxmLmR1cmF0aW9uKCkgOiBzZWxmLnRvdGFsRHVyYXRpb24oKSkgLyAoc2VsZi5yZXZlcnNlZCgpID8gLXZhbHVlIDogdmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZGlydHkpIHtcbiAgICAgIHBhcmVudCA9IHNlbGYucGFyZW50O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cbiAgICAgICAgY2hpbGQuX2RpcnR5ICYmIGNoaWxkLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cblxuICAgICAgICBzdGFydCA9IGNoaWxkLl9zdGFydDtcblxuICAgICAgICBpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHtcbiAgICAgICAgICAvL2luIGNhc2Ugb25lIG9mIHRoZSB0d2VlbnMgc2hpZnRlZCBvdXQgb2Ygb3JkZXIsIGl0IG5lZWRzIHRvIGJlIHJlLWluc2VydGVkIGludG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlXG4gICAgICAgICAgc2VsZi5fbG9jayA9IDE7IC8vcHJldmVudCBlbmRsZXNzIHJlY3Vyc2l2ZSBjYWxscyAtIHRoZXJlIGFyZSBtZXRob2RzIHRoYXQgZ2V0IHRyaWdnZXJlZCB0aGF0IGNoZWNrIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gd2hlbiB3ZSBhZGQoKS5cblxuICAgICAgICAgIF9hZGRUb1RpbWVsaW5lKHNlbGYsIGNoaWxkLCBzdGFydCAtIGNoaWxkLl9kZWxheSwgMSkuX2xvY2sgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCAmJiBjaGlsZC5fdHMpIHtcbiAgICAgICAgICAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuICAgICAgICAgIG1heCAtPSBzdGFydDtcblxuICAgICAgICAgIGlmICghcGFyZW50ICYmICFzZWxmLl9kcCB8fCBwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nKSB7XG4gICAgICAgICAgICBzZWxmLl9zdGFydCArPSBzdGFydCAvIHNlbGYuX3RzO1xuICAgICAgICAgICAgc2VsZi5fdGltZSAtPSBzdGFydDtcbiAgICAgICAgICAgIHNlbGYuX3RUaW1lIC09IHN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuc2hpZnRDaGlsZHJlbigtc3RhcnQsIGZhbHNlLCAtMWU5OTkpO1xuICAgICAgICAgIHByZXZTdGFydCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5fZW5kID4gbWF4ICYmIGNoaWxkLl90cyAmJiAobWF4ID0gY2hpbGQuX2VuZCk7XG4gICAgICAgIGNoaWxkID0gcHJldjtcbiAgICAgIH1cblxuICAgICAgX3NldER1cmF0aW9uKHNlbGYsIHNlbGYgPT09IF9nbG9iYWxUaW1lbGluZSAmJiBzZWxmLl90aW1lID4gbWF4ID8gc2VsZi5fdGltZSA6IG1heCwgMSwgMSk7XG5cbiAgICAgIHNlbGYuX2RpcnR5ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5fdER1cjtcbiAgfTtcblxuICBUaW1lbGluZS51cGRhdGVSb290ID0gZnVuY3Rpb24gdXBkYXRlUm9vdCh0aW1lKSB7XG4gICAgaWYgKF9nbG9iYWxUaW1lbGluZS5fdHMpIHtcbiAgICAgIF9sYXp5U2FmZVJlbmRlcihfZ2xvYmFsVGltZWxpbmUsIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWUsIF9nbG9iYWxUaW1lbGluZSkpO1xuXG4gICAgICBfbGFzdFJlbmRlcmVkRnJhbWUgPSBfdGlja2VyLmZyYW1lO1xuICAgIH1cblxuICAgIGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xuICAgICAgX25leHRHQ0ZyYW1lICs9IF9jb25maWcuYXV0b1NsZWVwIHx8IDEyMDtcbiAgICAgIHZhciBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xuICAgICAgICB3aGlsZSAoY2hpbGQgJiYgIWNoaWxkLl90cykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCB8fCBfdGlja2VyLnNsZWVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUaW1lbGluZTtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFRpbWVsaW5lLnByb3RvdHlwZSwge1xuICBfbG9jazogMCxcbiAgX2hhc1BhdXNlOiAwLFxuICBfZm9yY2luZzogMFxufSk7XG5cbnZhciBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICAvL25vdGU6IHdlIGNhbGwgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0d2Vlbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIG51bGwsIHNldHRlciksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YXJ0TnVtcyxcbiAgICAgIGNvbG9yLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBzdGFydE51bSxcbiAgICAgIGhhc1JhbmRvbSxcbiAgICAgIGE7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGhhc1JhbmRvbSA9IH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICB9XG5cbiAgaWYgKHN0cmluZ0ZpbHRlcikge1xuICAgIGEgPSBbc3RhcnQsIGVuZF07XG4gICAgc3RyaW5nRmlsdGVyKGEsIHRhcmdldCwgcHJvcCk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy5cblxuICAgIHN0YXJ0ID0gYVswXTtcbiAgICBlbmQgPSBhWzFdO1xuICB9XG5cbiAgc3RhcnROdW1zID0gc3RhcnQubWF0Y2goX2NvbXBsZXhTdHJpbmdOdW1FeHApIHx8IFtdO1xuXG4gIHdoaWxlIChyZXN1bHQgPSBfY29tcGxleFN0cmluZ051bUV4cC5leGVjKGVuZCkpIHtcbiAgICBlbmROdW0gPSByZXN1bHRbMF07XG4gICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIikge1xuICAgICAgY29sb3IgPSAxO1xuICAgIH1cblxuICAgIGlmIChlbmROdW0gIT09IHN0YXJ0TnVtc1ttYXRjaEluZGV4KytdKSB7XG4gICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnROdW1zW21hdGNoSW5kZXggLSAxXSkgfHwgMDsgLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG4gICAgICBwdC5fcHQgPSB7XG4gICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgIGM6IGVuZE51bS5jaGFyQXQoMSkgPT09IFwiPVwiID8gcGFyc2VGbG9hdChlbmROdW0uc3Vic3RyKDIpKSAqIChlbmROdW0uY2hhckF0KDApID09PSBcIi1cIiA/IC0xIDogMSkgOiBwYXJzZUZsb2F0KGVuZE51bSkgLSBzdGFydE51bSxcbiAgICAgICAgbTogY29sb3IgJiYgY29sb3IgPCA0ID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgIH07XG4gICAgICBpbmRleCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmxhc3RJbmRleDtcbiAgICB9XG4gIH1cblxuICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG5cbiAgcHQuZnAgPSBmdW5jUGFyYW07XG5cbiAgaWYgKF9yZWxFeHAudGVzdChlbmQpIHx8IGhhc1JhbmRvbSkge1xuICAgIHB0LmUgPSAwOyAvL2lmIHRoZSBlbmQgc3RyaW5nIGNvbnRhaW5zIHJlbGF0aXZlIHZhbHVlcyBvciBkeW5hbWljIHJhbmRvbSguLi4pIHZhbHVlcywgZGVsZXRlIHRoZSBlbmQgaXQgc28gdGhhdCBvbiB0aGUgZmluYWwgcmVuZGVyIHdlIGRvbid0IGFjdHVhbGx5IHNldCBpdCB0byB0aGUgc3RyaW5nIHdpdGggKz0gb3IgLT0gY2hhcmFjdGVycyAoZm9yY2VzIGl0IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCB2YWx1ZSkuXG4gIH1cblxuICB0aGlzLl9wdCA9IHB0OyAvL3N0YXJ0IHRoZSBsaW5rZWQgbGlzdCB3aXRoIHRoaXMgbmV3IFByb3BUd2Vlbi4gUmVtZW1iZXIsIHdlIGNhbGwgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0d2Vlbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYWRkUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFByb3BUd2Vlbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIGluZGV4LCB0YXJnZXRzLCBtb2RpZmllciwgc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pIHtcbiAgX2lzRnVuY3Rpb24oZW5kKSAmJiAoZW5kID0gZW5kKGluZGV4IHx8IDAsIHRhcmdldCwgdGFyZ2V0cykpO1xuICB2YXIgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdLFxuICAgICAgcGFyc2VkU3RhcnQgPSBzdGFydCAhPT0gXCJnZXRcIiA/IHN0YXJ0IDogIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUgOiBmdW5jUGFyYW0gPyB0YXJnZXRbcHJvcC5pbmRleE9mKFwic2V0XCIpIHx8ICFfaXNGdW5jdGlvbih0YXJnZXRbXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXSkgPyBwcm9wIDogXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXShmdW5jUGFyYW0pIDogdGFyZ2V0W3Byb3BdKCksXG4gICAgICBzZXR0ZXIgPSAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IF9zZXR0ZXJQbGFpbiA6IGZ1bmNQYXJhbSA/IF9zZXR0ZXJGdW5jV2l0aFBhcmFtIDogX3NldHRlckZ1bmMsXG4gICAgICBwdDtcblxuICBpZiAoX2lzU3RyaW5nKGVuZCkpIHtcbiAgICBpZiAofmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgICAgZW5kID0gX3JlcGxhY2VSYW5kb20oZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcbiAgICAgIHB0ID0gcGFyc2VGbG9hdChwYXJzZWRTdGFydCkgKyBwYXJzZUZsb2F0KGVuZC5zdWJzdHIoMikpICogKGVuZC5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcblxuICAgICAgaWYgKHB0IHx8IHB0ID09PSAwKSB7XG4gICAgICAgIC8vIHRvIGF2b2lkIGlzTmFOLCBsaWtlIGlmIHNvbWVvbmUgcGFzc2VzIGluIGEgdmFsdWUgbGlrZSBcIiE9IHdoYXRldmVyXCJcbiAgICAgICAgZW5kID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFN0YXJ0ICE9PSBlbmQpIHtcbiAgICBpZiAoIWlzTmFOKHBhcnNlZFN0YXJ0ICogZW5kKSAmJiBlbmQgIT09IFwiXCIpIHtcbiAgICAgIC8vIGZ1biBmYWN0OiBhbnkgbnVtYmVyIG11bHRpcGxpZWQgYnkgXCJcIiBpcyBldmFsdWF0ZWQgYXMgdGhlIG51bWJlciAwIVxuICAgICAgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHByb3AsICtwYXJzZWRTdGFydCB8fCAwLCBlbmQgLSAocGFyc2VkU3RhcnQgfHwgMCksIHR5cGVvZiBjdXJyZW50VmFsdWUgPT09IFwiYm9vbGVhblwiID8gX3JlbmRlckJvb2xlYW4gOiBfcmVuZGVyUGxhaW4sIDAsIHNldHRlcik7XG4gICAgICBmdW5jUGFyYW0gJiYgKHB0LmZwID0gZnVuY1BhcmFtKTtcbiAgICAgIG1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0aGlzLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3B0ID0gcHQ7XG4gICAgfVxuXG4gICAgIWN1cnJlbnRWYWx1ZSAmJiAhKHByb3AgaW4gdGFyZ2V0KSAmJiBfbWlzc2luZ1BsdWdpbihwcm9wLCBlbmQpO1xuICAgIHJldHVybiBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHRoaXMsIHRhcmdldCwgcHJvcCwgcGFyc2VkU3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIgfHwgX2NvbmZpZy5zdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSk7XG4gIH1cbn0sXG4gICAgLy9jcmVhdGVzIGEgY29weSBvZiB0aGUgdmFycyBvYmplY3QgYW5kIHByb2Nlc3NlcyBhbnkgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIChwdXR0aW5nIHRoZSByZXN1bHRpbmcgdmFsdWVzIGRpcmVjdGx5IGludG8gdGhlIGNvcHkpIGFzIHdlbGwgYXMgc3RyaW5ncyB3aXRoIFwicmFuZG9tKClcIiBpbiB0aGVtLiBJdCBkb2VzIE5PVCBwcm9jZXNzIHJlbGF0aXZlIHZhbHVlcy5cbl9wcm9jZXNzVmFycyA9IGZ1bmN0aW9uIF9wcm9jZXNzVmFycyh2YXJzLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2Vlbikge1xuICBfaXNGdW5jdGlvbih2YXJzKSAmJiAodmFycyA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpO1xuXG4gIGlmICghX2lzT2JqZWN0KHZhcnMpIHx8IHZhcnMuc3R5bGUgJiYgdmFycy5ub2RlVHlwZSB8fCBfaXNBcnJheSh2YXJzKSB8fCBfaXNUeXBlZEFycmF5KHZhcnMpKSB7XG4gICAgcmV0dXJuIF9pc1N0cmluZyh2YXJzKSA/IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiB2YXJzO1xuICB9XG5cbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIHZhcnMpIHtcbiAgICBjb3B5W3BdID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnNbcF0sIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfY2hlY2tQbHVnaW4gPSBmdW5jdGlvbiBfY2hlY2tQbHVnaW4ocHJvcGVydHksIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIHZhciBwbHVnaW4sIHB0LCBwdExvb2t1cCwgaTtcblxuICBpZiAoX3BsdWdpbnNbcHJvcGVydHldICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcHJvcGVydHldKCkpLmluaXQodGFyZ2V0LCBwbHVnaW4ucmF3VmFycyA/IHZhcnNbcHJvcGVydHldIDogX3Byb2Nlc3NWYXJzKHZhcnNbcHJvcGVydHldLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2VlbiksIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykgIT09IGZhbHNlKSB7XG4gICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgaWYgKHR3ZWVuICE9PSBfcXVpY2tUd2Vlbikge1xuICAgICAgcHRMb29rdXAgPSB0d2Vlbi5fcHRMb29rdXBbdHdlZW4uX3RhcmdldHMuaW5kZXhPZih0YXJnZXQpXTsgLy9ub3RlOiB3ZSBjYW4ndCB1c2UgdHdlZW4uX3B0TG9va3VwW2luZGV4XSBiZWNhdXNlIGZvciBzdGFnZ2VyZWQgdHdlZW5zLCB0aGUgaW5kZXggZnJvbSB0aGUgZnVsbFRhcmdldHMgYXJyYXkgd29uJ3QgbWF0Y2ggd2hhdCBpdCBpcyBpbiBlYWNoIGluZGl2aWR1YWwgdHdlZW4gdGhhdCBzcGF3bnMgZnJvbSB0aGUgc3RhZ2dlci5cblxuICAgICAgaSA9IHBsdWdpbi5fcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHB0TG9va3VwW3BsdWdpbi5fcHJvcHNbaV1dID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0sXG4gICAgX292ZXJ3cml0aW5nVHdlZW4sXG4gICAgLy9zdG9yZSBhIHJlZmVyZW5jZSB0ZW1wb3JhcmlseSBzbyB3ZSBjYW4gYXZvaWQgb3ZlcndyaXRpbmcgaXRzZWxmLlxuX2luaXRUd2VlbiA9IGZ1bmN0aW9uIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpIHtcbiAgdmFyIHZhcnMgPSB0d2Vlbi52YXJzLFxuICAgICAgZWFzZSA9IHZhcnMuZWFzZSxcbiAgICAgIHN0YXJ0QXQgPSB2YXJzLnN0YXJ0QXQsXG4gICAgICBpbW1lZGlhdGVSZW5kZXIgPSB2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgIGxhenkgPSB2YXJzLmxhenksXG4gICAgICBvblVwZGF0ZSA9IHZhcnMub25VcGRhdGUsXG4gICAgICBvblVwZGF0ZVBhcmFtcyA9IHZhcnMub25VcGRhdGVQYXJhbXMsXG4gICAgICBjYWxsYmFja1Njb3BlID0gdmFycy5jYWxsYmFja1Njb3BlLFxuICAgICAgcnVuQmFja3dhcmRzID0gdmFycy5ydW5CYWNrd2FyZHMsXG4gICAgICB5b3lvRWFzZSA9IHZhcnMueW95b0Vhc2UsXG4gICAgICBrZXlmcmFtZXMgPSB2YXJzLmtleWZyYW1lcyxcbiAgICAgIGF1dG9SZXZlcnQgPSB2YXJzLmF1dG9SZXZlcnQsXG4gICAgICBkdXIgPSB0d2Vlbi5fZHVyLFxuICAgICAgcHJldlN0YXJ0QXQgPSB0d2Vlbi5fc3RhcnRBdCxcbiAgICAgIHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcbiAgICAgIHBhcmVudCA9IHR3ZWVuLnBhcmVudCxcbiAgICAgIGZ1bGxUYXJnZXRzID0gcGFyZW50ICYmIHBhcmVudC5kYXRhID09PSBcIm5lc3RlZFwiID8gcGFyZW50LnBhcmVudC5fdGFyZ2V0cyA6IHRhcmdldHMsXG4gICAgICBhdXRvT3ZlcndyaXRlID0gdHdlZW4uX292ZXJ3cml0ZSA9PT0gXCJhdXRvXCIgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgICB0bCA9IHR3ZWVuLnRpbWVsaW5lLFxuICAgICAgY2xlYW5WYXJzLFxuICAgICAgaSxcbiAgICAgIHAsXG4gICAgICBwdCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGhhc1ByaW9yaXR5LFxuICAgICAgZ3NEYXRhLFxuICAgICAgaGFybmVzcyxcbiAgICAgIHBsdWdpbixcbiAgICAgIHB0TG9va3VwLFxuICAgICAgaW5kZXgsXG4gICAgICBoYXJuZXNzVmFycyxcbiAgICAgIG92ZXJ3cml0dGVuO1xuICB0bCAmJiAoIWtleWZyYW1lcyB8fCAhZWFzZSkgJiYgKGVhc2UgPSBcIm5vbmVcIik7XG4gIHR3ZWVuLl9lYXNlID0gX3BhcnNlRWFzZShlYXNlLCBfZGVmYXVsdHMuZWFzZSk7XG4gIHR3ZWVuLl95RWFzZSA9IHlveW9FYXNlID8gX2ludmVydEVhc2UoX3BhcnNlRWFzZSh5b3lvRWFzZSA9PT0gdHJ1ZSA/IGVhc2UgOiB5b3lvRWFzZSwgX2RlZmF1bHRzLmVhc2UpKSA6IDA7XG5cbiAgaWYgKHlveW9FYXNlICYmIHR3ZWVuLl95b3lvICYmICF0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy90aGVyZSBtdXN0IGhhdmUgYmVlbiBhIHBhcmVudCB0aW1lbGluZSB3aXRoIHlveW86dHJ1ZSB0aGF0IGlzIGN1cnJlbnRseSBpbiBpdHMgeW95byBwaGFzZSwgc28gZmxpcCB0aGUgZWFzZXMuXG4gICAgeW95b0Vhc2UgPSB0d2Vlbi5feUVhc2U7XG4gICAgdHdlZW4uX3lFYXNlID0gdHdlZW4uX2Vhc2U7XG4gICAgdHdlZW4uX2Vhc2UgPSB5b3lvRWFzZTtcbiAgfVxuXG4gIHR3ZWVuLl9mcm9tID0gIXRsICYmICEhdmFycy5ydW5CYWNrd2FyZHM7IC8vbmVzdGVkIHRpbWVsaW5lcyBzaG91bGQgbmV2ZXIgcnVuIGJhY2t3YXJkcyAtIHRoZSBiYWNrd2FyZHMtbmVzcyBpcyBpbiB0aGUgY2hpbGQgdHdlZW5zLlxuXG4gIGlmICghdGwpIHtcbiAgICAvL2lmIHRoZXJlJ3MgYW4gaW50ZXJuYWwgdGltZWxpbmUsIHNraXAgYWxsIHRoZSBwYXJzaW5nIGJlY2F1c2Ugd2UgcGFzc2VkIHRoYXQgdGFzayBkb3duIHRoZSBjaGFpbi5cbiAgICBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMDtcbiAgICBoYXJuZXNzVmFycyA9IGhhcm5lc3MgJiYgdmFyc1toYXJuZXNzLnByb3BdOyAvL3NvbWVvbmUgbWF5IG5lZWQgdG8gc3BlY2lmeSBDU1Mtc3BlY2lmaWMgdmFsdWVzIEFORCBub24tQ1NTIHZhbHVlcywgbGlrZSBpZiB0aGUgZWxlbWVudCBoYXMgYW4gXCJ4XCIgcHJvcGVydHkgcGx1cyBpdCdzIGEgc3RhbmRhcmQgRE9NIGVsZW1lbnQuIFdlIGFsbG93IHBlb3BsZSB0byBkaXN0aW5ndWlzaCBieSB3cmFwcGluZyBwbHVnaW4tc3BlY2lmaWMgc3R1ZmYgaW4gYSBjc3M6e30gb2JqZWN0IGZvciBleGFtcGxlLlxuXG4gICAgY2xlYW5WYXJzID0gX2NvcHlFeGNsdWRpbmcodmFycywgX3Jlc2VydmVkUHJvcHMpO1xuICAgIHByZXZTdGFydEF0ICYmIHByZXZTdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSkua2lsbCgpO1xuXG4gICAgaWYgKHN0YXJ0QXQpIHtcbiAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIF9zZXREZWZhdWx0cyh7XG4gICAgICAgIGRhdGE6IFwiaXNTdGFydFwiLFxuICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiB0cnVlLFxuICAgICAgICBsYXp5OiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgc3RhcnRBdDogbnVsbCxcbiAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgIG9uVXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgb25VcGRhdGVQYXJhbXM6IG9uVXBkYXRlUGFyYW1zLFxuICAgICAgICBjYWxsYmFja1Njb3BlOiBjYWxsYmFja1Njb3BlLFxuICAgICAgICBzdGFnZ2VyOiAwXG4gICAgICB9LCBzdGFydEF0KSkpOyAvL2NvcHkgdGhlIHByb3BlcnRpZXMvdmFsdWVzIGludG8gYSBuZXcgb2JqZWN0IHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgdmFyIHRvID0ge3g6MH0sIGZyb20gPSB7eDo1MDB9OyB0aW1lbGluZS5mcm9tVG8oZSwgZnJvbSwgdG8pLmZyb21UbyhlLCB0bywgZnJvbSk7XG5cblxuICAgICAgdGltZSA8IDAgJiYgIWltbWVkaWF0ZVJlbmRlciAmJiAhYXV0b1JldmVydCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpOyAvLyByYXJlIGVkZ2UgY2FzZSwgbGlrZSBpZiBhIHJlbmRlciBpcyBmb3JjZWQgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbiBvZiBhIG5vbi1pbml0dGVkIHR3ZWVuLlxuXG4gICAgICBpZiAoaW1tZWRpYXRlUmVuZGVyKSB7XG4gICAgICAgIHRpbWUgPiAwICYmICFhdXRvUmV2ZXJ0ICYmICh0d2Vlbi5fc3RhcnRBdCA9IDApOyAvL3R3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSAobGlrZSBtb3N0IGZyb20oKSBhbmQgZnJvbVRvKCkgdHdlZW5zKSBzaG91bGRuJ3QgcmV2ZXJ0IHdoZW4gdGhlaXIgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSBzdGFydFRpbWUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgY291bGQgaGF2ZSBoYXBwZW5lZCBhbnl0aW1lIGFuZCBpdCBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgY29ycmVsYXRlZCB0byB0aGlzIHR3ZWVuJ3Mgc3RhcnRUaW1lLiBJbWFnaW5lIHNldHRpbmcgdXAgYSBjb21wbGV4IGFuaW1hdGlvbiB3aGVyZSB0aGUgYmVnaW5uaW5nIHN0YXRlcyBvZiB2YXJpb3VzIG9iamVjdHMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGJ1dCB0aGUgdHdlZW4gZG9lc24ndCBoYXBwZW4gZm9yIHF1aXRlIHNvbWUgdGltZSAtIGlmIHdlIHJldmVydCB0byB0aGUgc3RhcnRpbmcgdmFsdWVzIGFzIHNvb24gYXMgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgdHdlZW4ncyBzdGFydFRpbWUsIGl0IHdpbGwgdGhyb3cgdGhpbmdzIG9mZiB2aXN1YWxseS4gUmV2ZXJzaW9uIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBUaW1lbGluZSBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSBvciB3aGVuIGF1dG9SZXZlcnQgaXMgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZS5cblxuICAgICAgICBpZiAoZHVyICYmIHRpbWUgPD0gMCkge1xuICAgICAgICAgIHRpbWUgJiYgKHR3ZWVuLl96VGltZSA9IHRpbWUpO1xuICAgICAgICAgIHJldHVybjsgLy93ZSBza2lwIGluaXRpYWxpemF0aW9uIGhlcmUgc28gdGhhdCBvdmVyd3JpdGluZyBkb2Vzbid0IG9jY3VyIHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBzZXZlcmFsIGltbWVkaWF0ZVJlbmRlcjp0cnVlIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQvcHJvcGVydGllcyB0byBkcm9wIGludG8gYSBUaW1lbGluZSwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cbiAgICAgICAgfSAvLyBpZiAodGltZSA+IDApIHtcbiAgICAgICAgLy8gXHRhdXRvUmV2ZXJ0IHx8ICh0d2Vlbi5fc3RhcnRBdCA9IDApOyAvL3R3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSAobGlrZSBtb3N0IGZyb20oKSBhbmQgZnJvbVRvKCkgdHdlZW5zKSBzaG91bGRuJ3QgcmV2ZXJ0IHdoZW4gdGhlaXIgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSBzdGFydFRpbWUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgY291bGQgaGF2ZSBoYXBwZW5lZCBhbnl0aW1lIGFuZCBpdCBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgY29ycmVsYXRlZCB0byB0aGlzIHR3ZWVuJ3Mgc3RhcnRUaW1lLiBJbWFnaW5lIHNldHRpbmcgdXAgYSBjb21wbGV4IGFuaW1hdGlvbiB3aGVyZSB0aGUgYmVnaW5uaW5nIHN0YXRlcyBvZiB2YXJpb3VzIG9iamVjdHMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGJ1dCB0aGUgdHdlZW4gZG9lc24ndCBoYXBwZW4gZm9yIHF1aXRlIHNvbWUgdGltZSAtIGlmIHdlIHJldmVydCB0byB0aGUgc3RhcnRpbmcgdmFsdWVzIGFzIHNvb24gYXMgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgdHdlZW4ncyBzdGFydFRpbWUsIGl0IHdpbGwgdGhyb3cgdGhpbmdzIG9mZiB2aXN1YWxseS4gUmV2ZXJzaW9uIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBUaW1lbGluZSBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSBvciB3aGVuIGF1dG9SZXZlcnQgaXMgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgLy8gfSBlbHNlIGlmIChkdXIgJiYgISh0aW1lIDwgMCAmJiBwcmV2U3RhcnRBdCkpIHtcbiAgICAgICAgLy8gXHR0aW1lICYmICh0d2Vlbi5felRpbWUgPSB0aW1lKTtcbiAgICAgICAgLy8gXHRyZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG4gICAgICAgIC8vIH1cblxuICAgICAgfSBlbHNlIGlmIChhdXRvUmV2ZXJ0ID09PSBmYWxzZSkge1xuICAgICAgICB0d2Vlbi5fc3RhcnRBdCA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChydW5CYWNrd2FyZHMgJiYgZHVyKSB7XG4gICAgICAvL2Zyb20oKSB0d2VlbnMgbXVzdCBiZSBoYW5kbGVkIHVuaXF1ZWx5OiB0aGVpciBiZWdpbm5pbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQgYnV0IHdlIGRvbid0IHdhbnQgb3ZlcndyaXRpbmcgdG8gb2NjdXIgeWV0ICh3aGVuIHRpbWUgaXMgc3RpbGwgMCkuIFdhaXQgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucyBiZWZvcmUgZG9pbmcgYWxsIHRoZSByb3V0aW5lcyBsaWtlIG92ZXJ3cml0aW5nLiBBdCB0aGF0IHRpbWUsIHdlIHNob3VsZCByZW5kZXIgYXQgdGhlIEVORCBvZiB0aGUgdHdlZW4gdG8gZW5zdXJlIHRoYXQgdGhpbmdzIGluaXRpYWxpemUgY29ycmVjdGx5IChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBnbyBiYWNrd2FyZHMpXG4gICAgICBpZiAocHJldlN0YXJ0QXQpIHtcbiAgICAgICAgIWF1dG9SZXZlcnQgJiYgKHR3ZWVuLl9zdGFydEF0ID0gMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lICYmIChpbW1lZGlhdGVSZW5kZXIgPSBmYWxzZSk7IC8vaW4gcmFyZSBjYXNlcyAobGlrZSBpZiBhIGZyb20oKSB0d2VlbiBydW5zIGFuZCB0aGVuIGlzIGludmFsaWRhdGUoKS1lZCksIGltbWVkaWF0ZVJlbmRlciBjb3VsZCBiZSB0cnVlIGJ1dCB0aGUgaW5pdGlhbCBmb3JjZWQtcmVuZGVyIGdldHMgc2tpcHBlZCwgc28gdGhlcmUncyBubyBuZWVkIHRvIGZvcmNlIHRoZSByZW5kZXIgaW4gdGhpcyBjb250ZXh0IHdoZW4gdGhlIF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwXG5cbiAgICAgICAgcCA9IF9zZXREZWZhdWx0cyh7XG4gICAgICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgICAgICBkYXRhOiBcImlzRnJvbVN0YXJ0XCIsXG4gICAgICAgICAgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXG4gICAgICAgICAgbGF6eTogaW1tZWRpYXRlUmVuZGVyICYmIF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICAgIGltbWVkaWF0ZVJlbmRlcjogaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICAgIC8vemVyby1kdXJhdGlvbiB0d2VlbnMgcmVuZGVyIGltbWVkaWF0ZWx5IGJ5IGRlZmF1bHQsIGJ1dCBpZiB3ZSdyZSBub3Qgc3BlY2lmaWNhbGx5IGluc3RydWN0ZWQgdG8gcmVuZGVyIHRoaXMgdHdlZW4gaW1tZWRpYXRlbHksIHdlIHNob3VsZCBza2lwIHRoaXMgYW5kIG1lcmVseSBfaW5pdCgpIHRvIHJlY29yZCB0aGUgc3RhcnRpbmcgdmFsdWVzIChyZW5kZXJpbmcgdGhlbSBpbW1lZGlhdGVseSB3b3VsZCBwdXNoIHRoZW0gdG8gY29tcGxldGlvbiB3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGF0IGNhc2UgLSB3ZSdkIGhhdmUgdG8gcmVuZGVyKC0xKSBpbW1lZGlhdGVseSBhZnRlcilcbiAgICAgICAgICBzdGFnZ2VyOiAwLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50IC8vZW5zdXJlcyB0aGF0IG5lc3RlZCB0d2VlbnMgdGhhdCBoYWQgYSBzdGFnZ2VyIGFyZSBoYW5kbGVkIHByb3Blcmx5LCBsaWtlIGdzYXAuZnJvbShcIi5jbGFzc1wiLCB7eTpnc2FwLnV0aWxzLndyYXAoWy0xMDAsMTAwXSl9KVxuXG4gICAgICAgIH0sIGNsZWFuVmFycyk7XG4gICAgICAgIGhhcm5lc3NWYXJzICYmIChwW2hhcm5lc3MucHJvcF0gPSBoYXJuZXNzVmFycyk7IC8vIGluIGNhc2Ugc29tZW9uZSBkb2VzIHNvbWV0aGluZyBsaWtlIC5mcm9tKC4uLiwge2Nzczp7fX0pXG5cbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgcCkpO1xuXG4gICAgICAgIHRpbWUgPCAwICYmIHR3ZWVuLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vIHJhcmUgZWRnZSBjYXNlLCBsaWtlIGlmIGEgcmVuZGVyIGlzIGZvcmNlZCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIG9mIGEgbm9uLWluaXR0ZWQgZnJvbSgpIHR3ZWVuLlxuXG4gICAgICAgIGlmICghaW1tZWRpYXRlUmVuZGVyKSB7XG4gICAgICAgICAgX2luaXRUd2Vlbih0d2Vlbi5fc3RhcnRBdCwgX3RpbnlOdW0pOyAvL2Vuc3VyZXMgdGhhdCB0aGUgaW5pdGlhbCB2YWx1ZXMgYXJlIHJlY29yZGVkXG5cbiAgICAgICAgfSBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHR3ZWVuLl9wdCA9IDA7XG4gICAgbGF6eSA9IGR1ciAmJiBfaXNOb3RGYWxzZShsYXp5KSB8fCBsYXp5ICYmICFkdXI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcbiAgICAgIHR3ZWVuLl9wdExvb2t1cFtpXSA9IHB0TG9va3VwID0ge307XG4gICAgICBfbGF6eUxvb2t1cFtnc0RhdGEuaWRdICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXG4gICAgICBpbmRleCA9IGZ1bGxUYXJnZXRzID09PSB0YXJnZXRzID8gaSA6IGZ1bGxUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgICAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHBsdWdpbi5uYW1lLCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICAgICAgcGx1Z2luLl9wcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcHRMb29rdXBbbmFtZV0gPSBwdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhcm5lc3MgfHwgaGFybmVzc1ZhcnMpIHtcbiAgICAgICAgZm9yIChwIGluIGNsZWFuVmFycykge1xuICAgICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcbiAgICAgICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fb3AgJiYgdHdlZW4uX29wW2ldICYmIHR3ZWVuLmtpbGwodGFyZ2V0LCB0d2Vlbi5fb3BbaV0pO1xuXG4gICAgICBpZiAoYXV0b092ZXJ3cml0ZSAmJiB0d2Vlbi5fcHQpIHtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSB0d2VlbjtcblxuICAgICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldCwgcHRMb29rdXAsIHR3ZWVuLmdsb2JhbFRpbWUodGltZSkpOyAvLyBtYWtlIHN1cmUgdGhlIG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb3ZlcndyaXRlIFRISVMgdHdlZW4hISFcblxuXG4gICAgICAgIG92ZXJ3cml0dGVuID0gIXR3ZWVuLnBhcmVudDtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fcHQgJiYgbGF6eSAmJiAoX2xhenlMb29rdXBbZ3NEYXRhLmlkXSA9IDEpO1xuICAgIH1cblxuICAgIGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodHdlZW4pO1xuICAgIHR3ZWVuLl9vbkluaXQgJiYgdHdlZW4uX29uSW5pdCh0d2Vlbik7IC8vcGx1Z2lucyBsaWtlIFJvdW5kUHJvcHMgbXVzdCB3YWl0IHVudGlsIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyBhcmUgaW5zdGFudGlhdGVkLiBJbiB0aGUgcGx1Z2luJ3MgaW5pdCgpIGZ1bmN0aW9uLCBpdCBzZXRzIHRoZSBfb25Jbml0IG9uIHRoZSB0d2VlbiBpbnN0YW5jZS4gTWF5IG5vdCBiZSBwcmV0dHkvaW50dWl0aXZlLCBidXQgaXQncyBmYXN0IGFuZCBrZWVwcyBmaWxlIHNpemUgZG93bi5cbiAgfVxuXG4gIHR3ZWVuLl9vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICB0d2Vlbi5faW5pdHRlZCA9ICghdHdlZW4uX29wIHx8IHR3ZWVuLl9wdCkgJiYgIW92ZXJ3cml0dGVuOyAvLyBpZiBvdmVyd3JpdHRlblByb3BzIHJlc3VsdGVkIGluIHRoZSBlbnRpcmUgdHdlZW4gYmVpbmcga2lsbGVkLCBkbyBOT1QgZmxhZyBpdCBhcyBpbml0dGVkIG9yIGVsc2UgaXQgbWF5IHJlbmRlciBmb3Igb25lIHRpY2suXG59LFxuICAgIF9hZGRBbGlhc2VzVG9WYXJzID0gZnVuY3Rpb24gX2FkZEFsaWFzZXNUb1ZhcnModGFyZ2V0cywgdmFycykge1xuICB2YXIgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDAsXG4gICAgICBwcm9wZXJ0eUFsaWFzZXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyxcbiAgICAgIGNvcHksXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIGFsaWFzZXM7XG5cbiAgaWYgKCFwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICByZXR1cm4gdmFycztcbiAgfVxuXG4gIGNvcHkgPSBfbWVyZ2Uoe30sIHZhcnMpO1xuXG4gIGZvciAocCBpbiBwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICBpZiAocCBpbiBjb3B5KSB7XG4gICAgICBhbGlhc2VzID0gcHJvcGVydHlBbGlhc2VzW3BdLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSBhbGlhc2VzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb3B5W2FsaWFzZXNbaV1dID0gY29weVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX3BhcnNlRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlRnVuY09yU3RyaW5nKHZhbHVlLCB0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIDogX2lzU3RyaW5nKHZhbHVlKSAmJiB+dmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikgPyBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkgOiB2YWx1ZTtcbn0sXG4gICAgX3N0YWdnZXJUd2VlblByb3BzID0gX2NhbGxiYWNrTmFtZXMgKyBcInJlcGVhdCxyZXBlYXREZWxheSx5b3lvLHJlcGVhdFJlZnJlc2gseW95b0Vhc2VcIixcbiAgICBfc3RhZ2dlclByb3BzVG9Ta2lwID0gKF9zdGFnZ2VyVHdlZW5Qcm9wcyArIFwiLGlkLHN0YWdnZXIsZGVsYXksZHVyYXRpb24scGF1c2VkLHNjcm9sbFRyaWdnZXJcIikuc3BsaXQoXCIsXCIpO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFR3ZWVuLCBfQW5pbWF0aW9uMik7XG5cbiAgZnVuY3Rpb24gVHdlZW4odGFyZ2V0cywgdmFycywgcG9zaXRpb24sIHNraXBJbmhlcml0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIGlmICh0eXBlb2YgdmFycyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcG9zaXRpb24uZHVyYXRpb24gPSB2YXJzO1xuICAgICAgdmFycyA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSkgfHwgdGhpcztcbiAgICB2YXIgX3RoaXMzJHZhcnMgPSBfdGhpczMudmFycyxcbiAgICAgICAgZHVyYXRpb24gPSBfdGhpczMkdmFycy5kdXJhdGlvbixcbiAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3RoaXMzJHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBzdGFnZ2VyID0gX3RoaXMzJHZhcnMuc3RhZ2dlcixcbiAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICBrZXlmcmFtZXMgPSBfdGhpczMkdmFycy5rZXlmcmFtZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMzJHZhcnMuZGVmYXVsdHMsXG4gICAgICAgIHNjcm9sbFRyaWdnZXIgPSBfdGhpczMkdmFycy5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICB5b3lvRWFzZSA9IF90aGlzMyR2YXJzLnlveW9FYXNlLFxuICAgICAgICBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgfHwgX2lzVHlwZWRBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IFwibGVuZ3RoXCIgaW4gdmFycykgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICB0bCxcbiAgICAgICAgaSxcbiAgICAgICAgY29weSxcbiAgICAgICAgbCxcbiAgICAgICAgcCxcbiAgICAgICAgY3VyVGFyZ2V0LFxuICAgICAgICBzdGFnZ2VyRnVuYyxcbiAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlO1xuICAgIF90aGlzMy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9ncmVlbnNvY2suY29tXCIsICFfY29uZmlnLm51bGxUYXJnZXRXYXJuKSB8fCBbXTtcbiAgICBfdGhpczMuX3B0TG9va3VwID0gW107IC8vUHJvcFR3ZWVuIGxvb2t1cC4gQW4gYXJyYXkgY29udGFpbmluZyBhbiBvYmplY3QgZm9yIGVhY2ggdGFyZ2V0LCBoYXZpbmcga2V5cyBmb3IgZWFjaCB0d2VlbmluZyBwcm9wZXJ0eVxuXG4gICAgX3RoaXMzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG5cbiAgICBpZiAoa2V5ZnJhbWVzIHx8IHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG4gICAgICB2YXJzID0gX3RoaXMzLnZhcnM7XG4gICAgICB0bCA9IF90aGlzMy50aW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gICAgICAgIGRhdGE6IFwibmVzdGVkXCIsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyB8fCB7fVxuICAgICAgfSk7XG4gICAgICB0bC5raWxsKCk7XG4gICAgICB0bC5wYXJlbnQgPSB0bC5fZHAgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG4gICAgICB0bC5fc3RhcnQgPSAwO1xuXG4gICAgICBpZiAoa2V5ZnJhbWVzKSB7XG4gICAgICAgIF9pbmhlcml0RGVmYXVsdHMoX3NldERlZmF1bHRzKHRsLnZhcnMuZGVmYXVsdHMsIHtcbiAgICAgICAgICBlYXNlOiBcIm5vbmVcIlxuICAgICAgICB9KSk7XG5cbiAgICAgICAgc3RhZ2dlciA/IHBhcnNlZFRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICAgIHJldHVybiBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUsIGopIHtcbiAgICAgICAgICAgIHJldHVybiB0bC50byh0LCBmcmFtZSwgaiA/IFwiPlwiIDogaSAqIHN0YWdnZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSA6IGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgIHJldHVybiB0bC50byhwYXJzZWRUYXJnZXRzLCBmcmFtZSwgXCI+XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcbiAgICAgICAgc3RhZ2dlckZ1bmMgPSBzdGFnZ2VyID8gZGlzdHJpYnV0ZShzdGFnZ2VyKSA6IF9lbXB0eUZ1bmM7XG5cbiAgICAgICAgaWYgKF9pc09iamVjdChzdGFnZ2VyKSkge1xuICAgICAgICAgIC8vdXNlcnMgY2FuIHBhc3MgaW4gY2FsbGJhY2tzIGxpa2Ugb25TdGFydC9vbkNvbXBsZXRlIGluIHRoZSBzdGFnZ2VyIG9iamVjdC4gVGhlc2Ugc2hvdWxkIGZpcmUgd2l0aCBlYWNoIGluZGl2aWR1YWwgdHdlZW4uXG4gICAgICAgICAgZm9yIChwIGluIHN0YWdnZXIpIHtcbiAgICAgICAgICAgIGlmICh+X3N0YWdnZXJUd2VlblByb3BzLmluZGV4T2YocCkpIHtcbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlIHx8IChzdGFnZ2VyVmFyc1RvTWVyZ2UgPSB7fSk7XG4gICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZVtwXSA9IHN0YWdnZXJbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvcHkgPSB7fTtcblxuICAgICAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgICAgICBpZiAoX3N0YWdnZXJQcm9wc1RvU2tpcC5pbmRleE9mKHApIDwgMCkge1xuICAgICAgICAgICAgICBjb3B5W3BdID0gdmFyc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb3B5LnN0YWdnZXIgPSAwO1xuICAgICAgICAgIHlveW9FYXNlICYmIChjb3B5LnlveW9FYXNlID0geW95b0Vhc2UpO1xuICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSAmJiBfbWVyZ2UoY29weSwgc3RhZ2dlclZhcnNUb01lcmdlKTtcbiAgICAgICAgICBjdXJUYXJnZXQgPSBwYXJzZWRUYXJnZXRzW2ldOyAvL2Rvbid0IGp1c3QgY29weSBkdXJhdGlvbiBvciBkZWxheSBiZWNhdXNlIGlmIHRoZXkncmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24sIHdlJ2QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSBfaXNGdW5jT3JTdHJpbmcoKSB3b3VsZCBldmFsdWF0ZSBhcyB0cnVlIGluIHRoZSBjaGlsZCB0d2VlbnMsIGVudGVyaW5nIHRoaXMgbG9vcCwgZXRjLiBTbyB3ZSBwYXJzZSB0aGUgdmFsdWUgc3RyYWlnaHQgZnJvbSB2YXJzIGFuZCBkZWZhdWx0IHRvIDAuXG5cbiAgICAgICAgICBjb3B5LmR1cmF0aW9uID0gK19wYXJzZUZ1bmNPclN0cmluZyhkdXJhdGlvbiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpO1xuICAgICAgICAgIGNvcHkuZGVsYXkgPSAoK19wYXJzZUZ1bmNPclN0cmluZyhkZWxheSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIHx8IDApIC0gX3RoaXMzLl9kZWxheTtcblxuICAgICAgICAgIGlmICghc3RhZ2dlciAmJiBsID09PSAxICYmIGNvcHkuZGVsYXkpIHtcbiAgICAgICAgICAgIC8vIGlmIHNvbWVvbmUgZG9lcyBkZWxheTpcInJhbmRvbSgxLCA1KVwiLCByZXBlYXQ6LTEsIGZvciBleGFtcGxlLCB0aGUgZGVsYXkgc2hvdWxkbid0IGJlIGluc2lkZSB0aGUgcmVwZWF0LlxuICAgICAgICAgICAgX3RoaXMzLl9kZWxheSA9IGRlbGF5ID0gY29weS5kZWxheTtcbiAgICAgICAgICAgIF90aGlzMy5fc3RhcnQgKz0gZGVsYXk7XG4gICAgICAgICAgICBjb3B5LmRlbGF5ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC50byhjdXJUYXJnZXQsIGNvcHksIHN0YWdnZXJGdW5jKGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGwuZHVyYXRpb24oKSA/IGR1cmF0aW9uID0gZGVsYXkgPSAwIDogX3RoaXMzLnRpbWVsaW5lID0gMDsgLy8gaWYgdGhlIHRpbWVsaW5lJ3MgZHVyYXRpb24gaXMgMCwgd2UgZG9uJ3QgbmVlZCBhIHRpbWVsaW5lIGludGVybmFsbHkhXG4gICAgICB9XG5cbiAgICAgIGR1cmF0aW9uIHx8IF90aGlzMy5kdXJhdGlvbihkdXJhdGlvbiA9IHRsLmR1cmF0aW9uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpczMudGltZWxpbmUgPSAwOyAvL3NwZWVkIG9wdGltaXphdGlvbiwgZmFzdGVyIGxvb2t1cHMgKG5vIGdvaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4pXG4gICAgfVxuXG4gICAgaWYgKG92ZXJ3cml0ZSA9PT0gdHJ1ZSAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcykge1xuICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG5cbiAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YocGFyc2VkVGFyZ2V0cyk7XG5cbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShwYXJlbnQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgcG9zaXRpb24pO1xuXG4gICAgdmFycy5yZXZlcnNlZCAmJiBfdGhpczMucmV2ZXJzZSgpO1xuICAgIHZhcnMucGF1c2VkICYmIF90aGlzMy5wYXVzZWQodHJ1ZSk7XG5cbiAgICBpZiAoaW1tZWRpYXRlUmVuZGVyIHx8ICFkdXJhdGlvbiAmJiAha2V5ZnJhbWVzICYmIF90aGlzMy5fc3RhcnQgPT09IF9yb3VuZFByZWNpc2UocGFyZW50Ll90aW1lKSAmJiBfaXNOb3RGYWxzZShpbW1lZGlhdGVSZW5kZXIpICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMykpICYmIHBhcmVudC5kYXRhICE9PSBcIm5lc3RlZFwiKSB7XG4gICAgICBfdGhpczMuX3RUaW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblxuICAgICAgX3RoaXMzLnJlbmRlcihNYXRoLm1heCgwLCAtZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cbiAgICB9XG5cbiAgICBzY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPiB0RHVyIC0gX3RpbnlOdW0gJiYgdG90YWxUaW1lID49IDAgPyB0RHVyIDogdG90YWxUaW1lIDwgX3RpbnlOdW0gPyAwIDogdG90YWxUaW1lLFxuICAgICAgICB0aW1lLFxuICAgICAgICBwdCxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICBpc1lveW8sXG4gICAgICAgIHJhdGlvLFxuICAgICAgICB0aW1lbGluZSxcbiAgICAgICAgeW95b0Vhc2U7XG5cbiAgICBpZiAoIWR1cikge1xuICAgICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHRoaXMsIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICB9IGVsc2UgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCAhdG90YWxUaW1lIHx8IGZvcmNlIHx8ICF0aGlzLl9pbml0dGVkICYmIHRoaXMuX3RUaW1lIHx8IHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAvL3RoaXMgc2Vuc2VzIGlmIHdlJ3JlIGNyb3NzaW5nIG92ZXIgdGhlIHN0YXJ0IHRpbWUsIGluIHdoaWNoIGNhc2Ugd2UgbXVzdCByZWNvcmQgX3pUaW1lIGFuZCBmb3JjZSB0aGUgcmVuZGVyLCBidXQgd2UgZG8gaXQgaW4gdGhpcyBsZW5ndGh5IGNvbmRpdGlvbmFsIHdheSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAodXN1YWxseSB3ZSBjYW4gc2tpcCB0aGUgY2FsY3VsYXRpb25zKTogdGhpcy5faW5pdHRlZCAmJiAodGhpcy5felRpbWUgPCAwKSAhPT0gKHRvdGFsVGltZSA8IDApXG4gICAgICB0aW1lID0gdFRpbWU7XG4gICAgICB0aW1lbGluZSA9IHRoaXMudGltZWxpbmU7XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cbiAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcbiAgICAgICAgICBpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHRUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNZb3lvID0gdGhpcy5feW95byAmJiBpdGVyYXRpb24gJiAxO1xuXG4gICAgICAgIGlmIChpc1lveW8pIHtcbiAgICAgICAgICB5b3lvRWFzZSA9IHRoaXMuX3lFYXNlO1xuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKHRpbWUgPT09IHByZXZUaW1lICYmICFmb3JjZSAmJiB0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgLy9jb3VsZCBiZSBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IHBhcnQuIE5vIG5lZWQgdG8gcmVuZGVyIGFuZCBmaXJlIGNhbGxiYWNrcy5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7IC8vcmVwZWF0UmVmcmVzaCBmdW5jdGlvbmFsaXR5XG5cbiAgICAgICAgICBpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAhdGhpcy5fbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kUHJlY2lzZShjeWNsZUR1cmF0aW9uICogaXRlcmF0aW9uKSwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIGlmIChfYXR0ZW1wdEluaXRUd2Vlbih0aGlzLCB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSkge1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gMDsgLy8gaW4gY29uc3RydWN0b3IgaWYgaW1tZWRpYXRlUmVuZGVyIGlzIHRydWUsIHdlIHNldCBfdFRpbWUgdG8gLV90aW55TnVtIHRvIGhhdmUgdGhlIHBsYXloZWFkIGNyb3NzIHRoZSBzdGFydGluZyBwb2ludCBidXQgd2UgY2FuJ3QgbGVhdmUgX3RUaW1lIGFzIGEgbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHVyICE9PSB0aGlzLl9kdXIpIHtcbiAgICAgICAgICAvLyB3aGlsZSBpbml0dGluZywgYSBwbHVnaW4gbGlrZSBJbmVydGlhUGx1Z2luIG1pZ2h0IGFsdGVyIHRoZSBkdXJhdGlvbiwgc28gcmVydW4gZnJvbSB0aGUgc3RhcnQgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgcmVuZGVycyBhcyBpdCBzaG91bGQuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG5cbiAgICAgIGlmICghdGhpcy5fYWN0ICYmIHRoaXMuX3RzKSB7XG4gICAgICAgIHRoaXMuX2FjdCA9IDE7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgICAgIHRoaXMuX2xhenkgPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJhdGlvID0gcmF0aW8gPSAoeW95b0Vhc2UgfHwgdGhpcy5fZWFzZSkodGltZSAvIGR1cik7XG5cbiAgICAgIGlmICh0aGlzLl9mcm9tKSB7XG4gICAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9IDEgLSByYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWUgJiYgIXByZXZUaW1lICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdFRpbWUpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvblN0YXJ0IHRyaWdnZXJlZCBhIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90LCBlamVjdC4gTGlrZSBpZiBzb21lb25lIGRpZCBhbmltYXRpb24ucGF1c2UoMC41KSBvciBzb21ldGhpbmcgaW5zaWRlIHRoZSBvblN0YXJ0LlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiAhdGltZSAmJiBpc1lveW8gPyAtX3RpbnlOdW0gOiB0aW1lbGluZS5fZHVyICogcmF0aW8sIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIHRvdGFsVGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblxuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwZWF0ICYmIGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbiAmJiB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgICBpZiAoKHRUaW1lID09PSB0aGlzLl90RHVyIHx8ICF0VGltZSkgJiYgdGhpcy5fdFRpbWUgPT09IHRUaW1lKSB7XG4gICAgICAgIHRvdGFsVGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGhpcy5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHRoaXMuX3REdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgd2UncmUgcmVuZGVyaW5nIGF0IGV4YWN0bHkgYSB0aW1lIG9mIDAsIGFzIHRoZXJlIGNvdWxkIGJlIGF1dG9SZXZlcnQgdmFsdWVzIHRoYXQgc2hvdWxkIGdldCBzZXQgb24gdGhlIG5leHQgdGljayAoaWYgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydFRpbWUsIG5lZ2F0aXZlIHRvdGFsVGltZSkuIERvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lKSkge1xuICAgICAgICAgIC8vIGlmIHByZXZUaW1lIGFuZCB0VGltZSBhcmUgemVybywgd2Ugc2hvdWxkbid0IGZpcmUgdGhlIG9uUmV2ZXJzZUNvbXBsZXRlLiBUaGlzIGNvdWxkIGhhcHBlbiBpZiB5b3UgZ3NhcC50byguLi4ge3BhdXNlZDp0cnVlfSkucGxheSgpO1xuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCB0VGltZSA9PT0gdER1ciA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICAgIHRoaXMuX3Byb20gJiYgISh0VGltZSA8IHREdXIgJiYgdGhpcy50aW1lU2NhbGUoKSA+IDApICYmIHRoaXMuX3Byb20oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzMudGFyZ2V0cyA9IGZ1bmN0aW9uIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldHM7XG4gIH07XG5cbiAgX3Byb3RvMy5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9wdCA9IHRoaXMuX29wID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gdGhpcy5fbGF6eSA9IHRoaXMucmF0aW8gPSAwO1xuICAgIHRoaXMuX3B0TG9va3VwID0gW107XG4gICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4gX0FuaW1hdGlvbjIucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKHRhcmdldHMsIHZhcnMpIHtcbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0gXCJhbGxcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldHMgJiYgKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpKSB7XG4gICAgICB0aGlzLl9sYXp5ID0gdGhpcy5fcHQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gX2ludGVycnVwdCh0aGlzKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZWxpbmUpIHtcbiAgICAgIHZhciB0RHVyID0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCk7XG4gICAgICB0aGlzLnRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCB2YXJzLCBfb3ZlcndyaXRpbmdUd2VlbiAmJiBfb3ZlcndyaXRpbmdUd2Vlbi52YXJzLm92ZXJ3cml0ZSAhPT0gdHJ1ZSkuX2ZpcnN0IHx8IF9pbnRlcnJ1cHQodGhpcyk7IC8vIGlmIG5vdGhpbmcgaXMgbGVmdCB0d2VlbmluZywgaW50ZXJydXB0LlxuXG4gICAgICB0aGlzLnBhcmVudCAmJiB0RHVyICE9PSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKSAmJiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fZHVyICogdGhpcy50aW1lbGluZS5fdER1ciAvIHREdXIsIDAsIDEpOyAvLyBpZiBhIG5lc3RlZCB0d2VlbiBpcyBraWxsZWQgdGhhdCBjaGFuZ2VzIHRoZSBkdXJhdGlvbiwgaXQgc2hvdWxkIGFmZmVjdCB0aGlzIHR3ZWVuJ3MgZHVyYXRpb24uIFdlIG11c3QgdXNlIHRoZSByYXRpbywgdGhvdWdoLCBiZWNhdXNlIHNvbWV0aW1lcyB0aGUgaW50ZXJuYWwgdGltZWxpbmUgaXMgc3RyZXRjaGVkIGxpa2UgZm9yIGtleWZyYW1lcyB3aGVyZSB0aGV5IGRvbid0IGFsbCBhZGQgdXAgdG8gd2hhdGV2ZXIgdGhlIHBhcmVudCB0d2VlbidzIGR1cmF0aW9uIHdhcyBzZXQgdG8uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRUYXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAga2lsbGluZ1RhcmdldHMgPSB0YXJnZXRzID8gdG9BcnJheSh0YXJnZXRzKSA6IHBhcnNlZFRhcmdldHMsXG4gICAgICAgIHByb3BUd2Vlbkxvb2t1cCA9IHRoaXMuX3B0TG9va3VwLFxuICAgICAgICBmaXJzdFBUID0gdGhpcy5fcHQsXG4gICAgICAgIG92ZXJ3cml0dGVuUHJvcHMsXG4gICAgICAgIGN1ckxvb2t1cCxcbiAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBwLFxuICAgICAgICBwdCxcbiAgICAgICAgaTtcblxuICAgIGlmICgoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikgJiYgX2FycmF5c01hdGNoKHBhcnNlZFRhcmdldHMsIGtpbGxpbmdUYXJnZXRzKSkge1xuICAgICAgdmFycyA9PT0gXCJhbGxcIiAmJiAodGhpcy5fcHQgPSAwKTtcbiAgICAgIHJldHVybiBfaW50ZXJydXB0KHRoaXMpO1xuICAgIH1cblxuICAgIG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vcCA9IHRoaXMuX29wIHx8IFtdO1xuXG4gICAgaWYgKHZhcnMgIT09IFwiYWxsXCIpIHtcbiAgICAgIC8vc28gcGVvcGxlIGNhbiBwYXNzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgcCA9IHt9O1xuXG4gICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBwW25hbWVdID0gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFycyA9IHA7XG4gICAgICB9XG5cbiAgICAgIHZhcnMgPSBfYWRkQWxpYXNlc1RvVmFycyhwYXJzZWRUYXJnZXRzLCB2YXJzKTtcbiAgICB9XG5cbiAgICBpID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAofmtpbGxpbmdUYXJnZXRzLmluZGV4T2YocGFyc2VkVGFyZ2V0c1tpXSkpIHtcbiAgICAgICAgY3VyTG9va3VwID0gcHJvcFR3ZWVuTG9va3VwW2ldO1xuXG4gICAgICAgIGlmICh2YXJzID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IHZhcnM7XG4gICAgICAgICAgcHJvcHMgPSBjdXJMb29rdXA7XG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gPSBvdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9O1xuICAgICAgICAgIHByb3BzID0gdmFycztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocCBpbiBwcm9wcykge1xuICAgICAgICAgIHB0ID0gY3VyTG9va3VwICYmIGN1ckxvb2t1cFtwXTtcblxuICAgICAgICAgIGlmIChwdCkge1xuICAgICAgICAgICAgaWYgKCEoXCJraWxsXCIgaW4gcHQuZCkgfHwgcHQuZC5raWxsKHApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjdXJMb29rdXBbcF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1ck92ZXJ3cml0ZVByb3BzICE9PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wc1twXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdHRlZCAmJiAhdGhpcy5fcHQgJiYgZmlyc3RQVCAmJiBfaW50ZXJydXB0KHRoaXMpOyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFR3ZWVuLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycykge1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgYXJndW1lbnRzWzJdKTtcbiAgfTtcblxuICBUd2Vlbi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBUd2Vlbi5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uIGRlbGF5ZWRDYWxsKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuICAgIHJldHVybiBuZXcgVHdlZW4oY2FsbGJhY2ssIDAsIHtcbiAgICAgIGltbWVkaWF0ZVJlbmRlcjogZmFsc2UsXG4gICAgICBsYXp5OiBmYWxzZSxcbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICBkZWxheTogZGVsYXksXG4gICAgICBvbkNvbXBsZXRlOiBjYWxsYmFjayxcbiAgICAgIG9uUmV2ZXJzZUNvbXBsZXRlOiBjYWxsYmFjayxcbiAgICAgIG9uQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOiBwYXJhbXMsXG4gICAgICBjYWxsYmFja1Njb3BlOiBzY29wZVxuICAgIH0pO1xuICB9O1xuXG4gIFR3ZWVuLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBUd2Vlbi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycykge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzKTtcbiAgfTtcblxuICBUd2Vlbi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFR3ZWVuO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVHdlZW4ucHJvdG90eXBlLCB7XG4gIF90YXJnZXRzOiBbXSxcbiAgX2xhenk6IDAsXG4gIF9zdGFydEF0OiAwLFxuICBfb3A6IDAsXG4gIF9vbkluaXQ6IDBcbn0pOyAvL2FkZCB0aGUgcGVydGluZW50IHRpbWVsaW5lIG1ldGhvZHMgdG8gVHdlZW4gaW5zdGFuY2VzIHNvIHRoYXQgdXNlcnMgY2FuIGNoYWluIGNvbnZlbmllbnRseSBhbmQgY3JlYXRlIGEgdGltZWxpbmUgYXV0b21hdGljYWxseS4gKHJlbW92ZWQgZHVlIHRvIGNvbmNlcm5zIHRoYXQgaXQnZCB1bHRpbWF0ZWx5IGFkZCB0byBtb3JlIGNvbmZ1c2lvbiBlc3BlY2lhbGx5IGZvciBiZWdpbm5lcnMpXG4vLyBfZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxzZXQsY2FsbCxhZGQsYWRkTGFiZWwsYWRkUGF1c2VcIiwgbmFtZSA9PiB7XG4vLyBcdFR3ZWVuLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuLy8gXHRcdGxldCB0bCA9IG5ldyBUaW1lbGluZSgpO1xuLy8gXHRcdHJldHVybiBfYWRkVG9UaW1lbGluZSh0bCwgdGhpcylbbmFtZV0uYXBwbHkodGwsIHRvQXJyYXkoYXJndW1lbnRzKSk7XG4vLyBcdH1cbi8vIH0pO1xuLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gTGV2ZXJhZ2UgdGhlIHRpbWVsaW5lIGNhbGxzLlxuXG5cbl9mb3JFYWNoTmFtZShcInN0YWdnZXJUbyxzdGFnZ2VyRnJvbSxzdGFnZ2VyRnJvbVRvXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFR3ZWVuW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0bCA9IG5ldyBUaW1lbGluZSgpLFxuICAgICAgICBwYXJhbXMgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcGFyYW1zLnNwbGljZShuYW1lID09PSBcInN0YWdnZXJGcm9tVG9cIiA/IDUgOiA0LCAwLCAwKTtcbiAgICByZXR1cm4gdGxbbmFtZV0uYXBwbHkodGwsIHBhcmFtcyk7XG4gIH07XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUFJPUFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxudmFyIF9zZXR0ZXJQbGFpbiA9IGZ1bmN0aW9uIF9zZXR0ZXJQbGFpbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyRnVuYyA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKHZhbHVlKTtcbn0sXG4gICAgX3NldHRlckZ1bmNXaXRoUGFyYW0gPSBmdW5jdGlvbiBfc2V0dGVyRnVuY1dpdGhQYXJhbSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XShkYXRhLmZwLCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfc2V0dGVyQXR0cmlidXRlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9nZXRTZXR0ZXIgPSBmdW5jdGlvbiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHRhcmdldFtwcm9wZXJ0eV0pID8gX3NldHRlckZ1bmMgOiBfaXNVbmRlZmluZWQodGFyZ2V0W3Byb3BlcnR5XSkgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZSA/IF9zZXR0ZXJBdHRyaWJ1dGUgOiBfc2V0dGVyUGxhaW47XG59LFxuICAgIF9yZW5kZXJQbGFpbiA9IGZ1bmN0aW9uIF9yZW5kZXJQbGFpbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwMDApIC8gMTAwMDAwMCwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJCb29sZWFuID0gZnVuY3Rpb24gX3JlbmRlckJvb2xlYW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCAhIShkYXRhLnMgKyBkYXRhLmMgKiByYXRpbyksIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ29tcGxleFN0cmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDb21wbGV4U3RyaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgcyA9IFwiXCI7XG5cbiAgaWYgKCFyYXRpbyAmJiBkYXRhLmIpIHtcbiAgICAvL2IgPSBiZWdpbm5pbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuYjtcbiAgfSBlbHNlIGlmIChyYXRpbyA9PT0gMSAmJiBkYXRhLmUpIHtcbiAgICAvL2UgPSBlbmRpbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuZTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHMgPSBwdC5wICsgKHB0Lm0gPyBwdC5tKHB0LnMgKyBwdC5jICogcmF0aW8pIDogTWF0aC5yb3VuZCgocHQucyArIHB0LmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCkgKyBzOyAvL3dlIHVzZSB0aGUgXCJwXCIgcHJvcGVydHkgZm9yIHRoZSB0ZXh0IGluYmV0d2VlbiAobGlrZSBhIHN1ZmZpeCkuIEFuZCBpbiB0aGUgY29udGV4dCBvZiBhIGNvbXBsZXggc3RyaW5nLCB0aGUgbW9kaWZpZXIgKG0pIGlzIHR5cGljYWxseSBqdXN0IE1hdGgucm91bmQoKSwgbGlrZSBmb3IgUkdCIGNvbG9ycy5cblxuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICBzICs9IGRhdGEuYzsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIGNodW5rIG9mIG5vbi1udW1lcmljIHRleHQuXG4gIH1cblxuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcywgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wVHdlZW5zID0gZnVuY3Rpb24gX3JlbmRlclByb3BUd2VlbnMocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxufSxcbiAgICBfYWRkUGx1Z2luTW9kaWZpZXIgPSBmdW5jdGlvbiBfYWRkUGx1Z2luTW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgcHQucCA9PT0gcHJvcGVydHkgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQpO1xuICAgIHB0ID0gbmV4dDtcbiAgfVxufSxcbiAgICBfa2lsbFByb3BUd2VlbnNPZiA9IGZ1bmN0aW9uIF9raWxsUHJvcFR3ZWVuc09mKHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nLFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICBpZiAocHQucCA9PT0gcHJvcGVydHkgJiYgIXB0Lm9wIHx8IHB0Lm9wID09PSBwcm9wZXJ0eSkge1xuICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICB9IGVsc2UgaWYgKCFwdC5kZXApIHtcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyA9IDE7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcmV0dXJuICFoYXNOb25EZXBlbmRlbnRSZW1haW5pbmc7XG59LFxuICAgIF9zZXR0ZXJXaXRoTW9kaWZpZXIgPSBmdW5jdGlvbiBfc2V0dGVyV2l0aE1vZGlmaWVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSB7XG4gIGRhdGEubVNldCh0YXJnZXQsIHByb3BlcnR5LCBkYXRhLm0uY2FsbChkYXRhLnR3ZWVuLCB2YWx1ZSwgZGF0YS5tdCksIGRhdGEpO1xufSxcbiAgICBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5ID0gZnVuY3Rpb24gX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eShwYXJlbnQpIHtcbiAgdmFyIHB0ID0gcGFyZW50Ll9wdCxcbiAgICAgIG5leHQsXG4gICAgICBwdDIsXG4gICAgICBmaXJzdCxcbiAgICAgIGxhc3Q7IC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIGRvIHRoZWlyIHdvcmsgYWZ0ZXIgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIHdlcmUgY3JlYXRlZCAobGlrZSBSb3VuZFByb3BzUGx1Z2luIGFuZCBNb2RpZmllcnNQbHVnaW4pXG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgIHB0MiA9IGZpcnN0O1xuXG4gICAgd2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuICAgICAgcHQyID0gcHQyLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpIHtcbiAgICAgIHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0ID0gcHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9uZXh0ID0gcHQyKSB7XG4gICAgICBwdDIuX3ByZXYgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHB0O1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHBhcmVudC5fcHQgPSBmaXJzdDtcbn07IC8vUHJvcFR3ZWVuIGtleTogdCA9IHRhcmdldCwgcCA9IHByb3AsIHIgPSByZW5kZXJlciwgZCA9IGRhdGEsIHMgPSBzdGFydCwgYyA9IGNoYW5nZSwgb3AgPSBvdmVyd3JpdGVQcm9wZXJ0eSAoT05MWSBwb3B1bGF0ZWQgd2hlbiBpdCdzIGRpZmZlcmVudCB0aGFuIHApLCBwciA9IHByaW9yaXR5LCBfbmV4dC9fcHJldiBmb3IgdGhlIGxpbmtlZCBsaXN0IHNpYmxpbmdzLCBzZXQgPSBzZXR0ZXIsIG0gPSBtb2RpZmllciwgbVNldCA9IG1vZGlmaWVyU2V0dGVyICh0aGUgb3JpZ2luYWwgc2V0dGVyLCBiZWZvcmUgYSBtb2RpZmllciB3YXMgYWRkZWQpXG5cblxuZXhwb3J0IHZhciBQcm9wVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9wVHdlZW4obmV4dCwgdGFyZ2V0LCBwcm9wLCBzdGFydCwgY2hhbmdlLCByZW5kZXJlciwgZGF0YSwgc2V0dGVyLCBwcmlvcml0eSkge1xuICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICB0aGlzLnMgPSBzdGFydDtcbiAgICB0aGlzLmMgPSBjaGFuZ2U7XG4gICAgdGhpcy5wID0gcHJvcDtcbiAgICB0aGlzLnIgPSByZW5kZXJlciB8fCBfcmVuZGVyUGxhaW47XG4gICAgdGhpcy5kID0gZGF0YSB8fCB0aGlzO1xuICAgIHRoaXMuc2V0ID0gc2V0dGVyIHx8IF9zZXR0ZXJQbGFpbjtcbiAgICB0aGlzLnByID0gcHJpb3JpdHkgfHwgMDtcbiAgICB0aGlzLl9uZXh0ID0gbmV4dDtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICBuZXh0Ll9wcmV2ID0gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IFByb3BUd2Vlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5tb2RpZmllciA9IGZ1bmN0aW9uIG1vZGlmaWVyKGZ1bmMsIHR3ZWVuLCB0YXJnZXQpIHtcbiAgICB0aGlzLm1TZXQgPSB0aGlzLm1TZXQgfHwgdGhpcy5zZXQ7IC8vaW4gY2FzZSBpdCB3YXMgYWxyZWFkeSBzZXQgKGEgUHJvcFR3ZWVuIGNhbiBvbmx5IGhhdmUgb25lIG1vZGlmaWVyKVxuXG4gICAgdGhpcy5zZXQgPSBfc2V0dGVyV2l0aE1vZGlmaWVyO1xuICAgIHRoaXMubSA9IGZ1bmM7XG4gICAgdGhpcy5tdCA9IHRhcmdldDsgLy9tb2RpZmllciB0YXJnZXRcblxuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgfTtcblxuICByZXR1cm4gUHJvcFR3ZWVuO1xufSgpOyAvL0luaXRpYWxpemF0aW9uIHRhc2tzXG5cbl9mb3JFYWNoTmFtZShfY2FsbGJhY2tOYW1lcyArIFwicGFyZW50LGR1cmF0aW9uLGVhc2UsZGVsYXksb3ZlcndyaXRlLHJ1bkJhY2t3YXJkcyxzdGFydEF0LHlveW8saW1tZWRpYXRlUmVuZGVyLHJlcGVhdCxyZXBlYXREZWxheSxkYXRhLHBhdXNlZCxyZXZlcnNlZCxsYXp5LGNhbGxiYWNrU2NvcGUsc3RyaW5nRmlsdGVyLGlkLHlveW9FYXNlLHN0YWdnZXIsaW5oZXJpdCxyZXBlYXRSZWZyZXNoLGtleWZyYW1lcyxhdXRvUmV2ZXJ0LHNjcm9sbFRyaWdnZXJcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcbn0pO1xuXG5fZ2xvYmFscy5Ud2Vlbk1heCA9IF9nbG9iYWxzLlR3ZWVuTGl0ZSA9IFR3ZWVuO1xuX2dsb2JhbHMuVGltZWxpbmVMaXRlID0gX2dsb2JhbHMuVGltZWxpbmVNYXggPSBUaW1lbGluZTtcbl9nbG9iYWxUaW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gIHNvcnRDaGlsZHJlbjogZmFsc2UsXG4gIGRlZmF1bHRzOiBfZGVmYXVsdHMsXG4gIGF1dG9SZW1vdmVDaGlsZHJlbjogdHJ1ZSxcbiAgaWQ6IFwicm9vdFwiLFxuICBzbW9vdGhDaGlsZFRpbWluZzogdHJ1ZVxufSk7XG5fY29uZmlnLnN0cmluZ0ZpbHRlciA9IF9jb2xvclN0cmluZ0ZpbHRlcjtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogR1NBUFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgX2dzYXAgPSB7XG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgcmV0dXJuIF9jcmVhdGVQbHVnaW4oY29uZmlnKTtcbiAgICB9KTtcbiAgfSxcbiAgdGltZWxpbmU6IGZ1bmN0aW9uIHRpbWVsaW5lKHZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVsaW5lKHZhcnMpO1xuICB9LFxuICBnZXRUd2VlbnNPZjogZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSk7XG4gIH0sXG4gIGdldFByb3BlcnR5OiBmdW5jdGlvbiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgX2lzU3RyaW5nKHRhcmdldCkgJiYgKHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KVswXSk7IC8vaW4gY2FzZSBzZWxlY3RvciB0ZXh0IG9yIGFuIGFycmF5IGlzIHBhc3NlZCBpblxuXG4gICAgdmFyIGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcbiAgICAgICAgZm9ybWF0ID0gdW5pdCA/IF9wYXNzVGhyb3VnaCA6IF9udW1lcmljSWZQb3NzaWJsZTtcblxuICAgIHVuaXQgPT09IFwibmF0aXZlXCIgJiYgKHVuaXQgPSBcIlwiKTtcbiAgICByZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgICAgcmV0dXJuIGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gICAgfSA6IGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gIH0sXG4gIHF1aWNrU2V0dGVyOiBmdW5jdGlvbiBxdWlja1NldHRlcih0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB7XG4gICAgdGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpO1xuXG4gICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgc2V0dGVycyA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGdzYXAucXVpY2tTZXR0ZXIodCwgcHJvcGVydHksIHVuaXQpO1xuICAgICAgfSksXG4gICAgICAgICAgbCA9IHNldHRlcnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IGw7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHNldHRlcnNbaV0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblxuICAgIHZhciBQbHVnaW4gPSBfcGx1Z2luc1twcm9wZXJ0eV0sXG4gICAgICAgIGNhY2hlID0gX2dldENhY2hlKHRhcmdldCksXG4gICAgICAgIHAgPSBjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eSxcbiAgICAgICAgLy8gaW4gY2FzZSBpdCdzIGFuIGFsaWFzLCBsaWtlIFwicm90YXRlXCIgZm9yIFwicm90YXRpb25cIi5cbiAgICBzZXR0ZXIgPSBQbHVnaW4gPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBwID0gbmV3IFBsdWdpbigpO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ID0gMDtcbiAgICAgIHAuaW5pdCh0YXJnZXQsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgX3F1aWNrVHdlZW4sIDAsIFt0YXJnZXRdKTtcbiAgICAgIHAucmVuZGVyKDEsIHApO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ICYmIF9yZW5kZXJQcm9wVHdlZW5zKDEsIF9xdWlja1R3ZWVuKTtcbiAgICB9IDogY2FjaGUuc2V0KHRhcmdldCwgcCk7XG5cbiAgICByZXR1cm4gUGx1Z2luID8gc2V0dGVyIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gc2V0dGVyKHRhcmdldCwgcCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBjYWNoZSwgMSk7XG4gICAgfTtcbiAgfSxcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcbiAgICB2YWx1ZSAmJiB2YWx1ZS5lYXNlICYmICh2YWx1ZS5lYXNlID0gX3BhcnNlRWFzZSh2YWx1ZS5lYXNlLCBfZGVmYXVsdHMuZWFzZSkpO1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICB9LFxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyh2YWx1ZSkge1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgcmVnaXN0ZXJFZmZlY3Q6IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KF9yZWYzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3QsXG4gICAgICAgIHBsdWdpbnMgPSBfcmVmMy5wbHVnaW5zLFxuICAgICAgICBkZWZhdWx0cyA9IF9yZWYzLmRlZmF1bHRzLFxuICAgICAgICBleHRlbmRUaW1lbGluZSA9IF9yZWYzLmV4dGVuZFRpbWVsaW5lO1xuICAgIChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICB9KTtcblxuICAgIF9lZmZlY3RzW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHRsKSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICB9O1xuXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XG4gICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICB9LFxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gIH0sXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0O1xuICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICBfZ2xvYmFsVGltZWxpbmUucmVtb3ZlKHRsKTtcblxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXG4gICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgIGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgIHJldHVybiB0bDtcbiAgfSxcbiAgdXRpbHM6IHtcbiAgICB3cmFwOiB3cmFwLFxuICAgIHdyYXBZb3lvOiB3cmFwWW95byxcbiAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIHNuYXA6IHNuYXAsXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZ2V0VW5pdDogZ2V0VW5pdCxcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXG4gICAgcGlwZTogcGlwZSxcbiAgICB1bml0aXplOiB1bml0aXplLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICBzaHVmZmxlOiBzaHVmZmxlXG4gIH0sXG4gIGluc3RhbGw6IF9pbnN0YWxsLFxuICBlZmZlY3RzOiBfZWZmZWN0cyxcbiAgdGlja2VyOiBfdGlja2VyLFxuICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuICBwbHVnaW5zOiBfcGx1Z2lucyxcbiAgZ2xvYmFsVGltZWxpbmU6IF9nbG9iYWxUaW1lbGluZSxcbiAgY29yZToge1xuICAgIFByb3BUd2VlbjogUHJvcFR3ZWVuLFxuICAgIGdsb2JhbHM6IF9hZGRHbG9iYWwsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFRpbWVsaW5lOiBUaW1lbGluZSxcbiAgICBBbmltYXRpb246IEFuaW1hdGlvbixcbiAgICBnZXRDYWNoZTogX2dldENhY2hlLFxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbTogX3JlbW92ZUxpbmtlZExpc3RJdGVtLFxuICAgIHN1cHByZXNzT3ZlcndyaXRlczogZnVuY3Rpb24gc3VwcHJlc3NPdmVyd3JpdGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX3N1cHByZXNzT3ZlcndyaXRlcyA9IHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sZGVsYXllZENhbGwsc2V0LGtpbGxUd2VlbnNPZlwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXTtcbn0pO1xuXG5fdGlja2VyLmFkZChUaW1lbGluZS51cGRhdGVSb290KTtcblxuX3F1aWNrVHdlZW4gPSBfZ3NhcC50byh7fSwge1xuICBkdXJhdGlvbjogMFxufSk7IC8vIC0tLS0gRVhUUkEgUExVR0lOUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgX2dldFBsdWdpblByb3BUd2VlbiA9IGZ1bmN0aW9uIF9nZXRQbHVnaW5Qcm9wVHdlZW4ocGx1Z2luLCBwcm9wKSB7XG4gIHZhciBwdCA9IHBsdWdpbi5fcHQ7XG5cbiAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYWRkTW9kaWZpZXJzID0gZnVuY3Rpb24gX2FkZE1vZGlmaWVycyh0d2VlbiwgbW9kaWZpZXJzKSB7XG4gIHZhciB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIHB0O1xuXG4gIGZvciAocCBpbiBtb2RpZmllcnMpIHtcbiAgICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwdCA9IHR3ZWVuLl9wdExvb2t1cFtpXVtwXTtcblxuICAgICAgaWYgKHB0ICYmIChwdCA9IHB0LmQpKSB7XG4gICAgICAgIGlmIChwdC5fcHQpIHtcbiAgICAgICAgICAvLyBpcyBhIHBsdWdpblxuICAgICAgICAgIHB0ID0gX2dldFBsdWdpblByb3BUd2VlbihwdCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBwdCAmJiBwdC5tb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllcnNbcF0sIHR3ZWVuLCB0YXJnZXRzW2ldLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2J1aWxkTW9kaWZpZXJQbHVnaW4gPSBmdW5jdGlvbiBfYnVpbGRNb2RpZmllclBsdWdpbihuYW1lLCBtb2RpZmllcikge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3VmFyczogMSxcbiAgICAvL2Rvbid0IHByZS1wcm9jZXNzIGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBvciBcInJhbmRvbSgpXCIgc3RyaW5ncy5cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4pIHtcbiAgICAgIHR3ZWVuLl9vbkluaXQgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdmFyIHRlbXAsIHA7XG5cbiAgICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBbbmFtZV0gPSAxO1xuICAgICAgICAgIH0pOyAvL2lmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHRvIHJvdW5kUHJvcHMsIGxpa2UgXCJ4LHlcIiwgd2Ugcm91bmQgdG8gd2hvbGUgbnVtYmVycy5cblxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgdGVtcFtwXSA9IG1vZGlmaWVyKHZhcnNbcF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vcmVnaXN0ZXIgY29yZSBwbHVnaW5zXG5cblxuZXhwb3J0IHZhciBnc2FwID0gX2dzYXAucmVnaXN0ZXJQbHVnaW4oe1xuICBuYW1lOiBcImF0dHJcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBwLCBwdDtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgKHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICBwdCAmJiAocHQub3AgPSBwKTtcblxuICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogXCJlbmRBcnJheVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldKTtcbiAgICB9XG4gIH1cbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjguMFwiO1xuX2NvcmVSZWFkeSA9IDE7XG5fd2luZG93RXhpc3RzKCkgJiYgX3dha2UoKTtcbnZhciBQb3dlcjAgPSBfZWFzZU1hcC5Qb3dlcjAsXG4gICAgUG93ZXIxID0gX2Vhc2VNYXAuUG93ZXIxLFxuICAgIFBvd2VyMiA9IF9lYXNlTWFwLlBvd2VyMixcbiAgICBQb3dlcjMgPSBfZWFzZU1hcC5Qb3dlcjMsXG4gICAgUG93ZXI0ID0gX2Vhc2VNYXAuUG93ZXI0LFxuICAgIExpbmVhciA9IF9lYXNlTWFwLkxpbmVhcixcbiAgICBRdWFkID0gX2Vhc2VNYXAuUXVhZCxcbiAgICBDdWJpYyA9IF9lYXNlTWFwLkN1YmljLFxuICAgIFF1YXJ0ID0gX2Vhc2VNYXAuUXVhcnQsXG4gICAgUXVpbnQgPSBfZWFzZU1hcC5RdWludCxcbiAgICBTdHJvbmcgPSBfZWFzZU1hcC5TdHJvbmcsXG4gICAgRWxhc3RpYyA9IF9lYXNlTWFwLkVsYXN0aWMsXG4gICAgQmFjayA9IF9lYXNlTWFwLkJhY2ssXG4gICAgU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5TdGVwcGVkRWFzZSxcbiAgICBCb3VuY2UgPSBfZWFzZU1hcC5Cb3VuY2UsXG4gICAgU2luZSA9IF9lYXNlTWFwLlNpbmUsXG4gICAgRXhwbyA9IF9lYXNlTWFwLkV4cG8sXG4gICAgQ2lyYyA9IF9lYXNlTWFwLkNpcmM7XG5leHBvcnQgeyBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTtcbmV4cG9ydCB7IFR3ZWVuIGFzIFR3ZWVuTWF4LCBUd2VlbiBhcyBUd2VlbkxpdGUsIFRpbWVsaW5lIGFzIFRpbWVsaW5lTWF4LCBUaW1lbGluZSBhcyBUaW1lbGluZUxpdGUsIGdzYXAgYXMgZGVmYXVsdCwgd3JhcCwgd3JhcFlveW8sIGRpc3RyaWJ1dGUsIHJhbmRvbSwgc25hcCwgbm9ybWFsaXplLCBnZXRVbml0LCBjbGFtcCwgc3BsaXRDb2xvciwgdG9BcnJheSwgc2VsZWN0b3IsIG1hcFJhbmdlLCBwaXBlLCB1bml0aXplLCBpbnRlcnBvbGF0ZSwgc2h1ZmZsZSB9OyAvL2V4cG9ydCBzb21lIGludGVybmFsIG1ldGhvZHMvb3JvamVjdHMgZm9yIHVzZSBpbiBDU1NQbHVnaW4gc28gdGhhdCB3ZSBjYW4gZXh0ZXJuYWxpemUgdGhhdCBmaWxlIGFuZCBhbGxvdyBjdXN0b20gYnVpbGRzIHRoYXQgZXhjbHVkZSBpdC5cblxuZXhwb3J0IHsgX2dldFByb3BlcnR5LCBfbnVtRXhwLCBfbnVtV2l0aFVuaXRFeHAsIF9pc1N0cmluZywgX2lzVW5kZWZpbmVkLCBfcmVuZGVyQ29tcGxleFN0cmluZywgX3JlbEV4cCwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfcmVwbGFjZVJhbmRvbSwgX2NoZWNrUGx1Z2luLCBfcGx1Z2lucywgX3RpY2tlciwgX2NvbmZpZywgX3JvdW5kTW9kaWZpZXIsIF9yb3VuZCwgX21pc3NpbmdQbHVnaW4sIF9nZXRTZXR0ZXIsIF9nZXRDYWNoZSwgX2NvbG9yRXhwIH07IiwiaW1wb3J0IHsgZ3NhcCwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjLCBUd2VlbkxpdGUsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXggfSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcbmltcG9ydCB7IENTU1BsdWdpbiB9IGZyb20gXCIuL0NTU1BsdWdpbi5qc1wiO1xudmFyIGdzYXBXaXRoQ1NTID0gZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pIHx8IGdzYXAsXG4gICAgLy8gdG8gcHJvdGVjdCBmcm9tIHRyZWUgc2hha2luZ1xuVHdlZW5NYXhXaXRoQ1NTID0gZ3NhcFdpdGhDU1MuY29yZS5Ud2VlbjtcbmV4cG9ydCB7IGdzYXBXaXRoQ1NTIGFzIGdzYXAsIGdzYXBXaXRoQ1NTIGFzIGRlZmF1bHQsIENTU1BsdWdpbiwgVHdlZW5NYXhXaXRoQ1NTIGFzIFR3ZWVuTWF4LCBUd2VlbkxpdGUsIFRpbWVsaW5lTWF4LCBUaW1lbGluZUxpdGUsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYyB9OyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lZF9yZWZlcmVuY2VzXzEgPSByZXF1aXJlKFwiLi9uYW1lZC1yZWZlcmVuY2VzXCIpO1xudmFyIG51bWVyaWNfdW5pY29kZV9tYXBfMSA9IHJlcXVpcmUoXCIuL251bWVyaWMtdW5pY29kZS1tYXBcIik7XG52YXIgc3Vycm9nYXRlX3BhaXJzXzEgPSByZXF1aXJlKFwiLi9zdXJyb2dhdGUtcGFpcnNcIik7XG52YXIgYWxsTmFtZWRSZWZlcmVuY2VzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG5hbWVkX3JlZmVyZW5jZXNfMS5uYW1lZFJlZmVyZW5jZXMpLCB7IGFsbDogbmFtZWRfcmVmZXJlbmNlc18xLm5hbWVkUmVmZXJlbmNlcy5odG1sNSB9KTtcbnZhciBlbmNvZGVSZWdFeHBzID0ge1xuICAgIHNwZWNpYWxDaGFyczogL1s8PidcIiZdL2csXG4gICAgbm9uQXNjaWk6IC8oPzpbPD4nXCImXFx1MDA4MC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS9nLFxuICAgIG5vbkFzY2lpUHJpbnRhYmxlOiAvKD86Wzw+J1wiJlxceDAxLVxceDA4XFx4MTEtXFx4MTVcXHgxNy1cXHgxRlxceDdmLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pL2csXG4gICAgZXh0ZW5zaXZlOiAvKD86W1xceDAxLVxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHgyY1xceDJlLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdkXFx4N2YtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZ1xufTtcbnZhciBkZWZhdWx0RW5jb2RlT3B0aW9ucyA9IHtcbiAgICBtb2RlOiAnc3BlY2lhbENoYXJzJyxcbiAgICBsZXZlbDogJ2FsbCcsXG4gICAgbnVtZXJpYzogJ2RlY2ltYWwnXG59O1xuLyoqIEVuY29kZXMgYWxsIHRoZSBuZWNlc3NhcnkgKHNwZWNpZmllZCBieSBgbGV2ZWxgKSBjaGFyYWN0ZXJzIGluIHRoZSB0ZXh0ICovXG5mdW5jdGlvbiBlbmNvZGUodGV4dCwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8gZGVmYXVsdEVuY29kZU9wdGlvbnMgOiBfYSwgX2MgPSBfYi5tb2RlLCBtb2RlID0gX2MgPT09IHZvaWQgMCA/ICdzcGVjaWFsQ2hhcnMnIDogX2MsIF9kID0gX2IubnVtZXJpYywgbnVtZXJpYyA9IF9kID09PSB2b2lkIDAgPyAnZGVjaW1hbCcgOiBfZCwgX2UgPSBfYi5sZXZlbCwgbGV2ZWwgPSBfZSA9PT0gdm9pZCAwID8gJ2FsbCcgOiBfZTtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgZW5jb2RlUmVnRXhwID0gZW5jb2RlUmVnRXhwc1ttb2RlXTtcbiAgICB2YXIgcmVmZXJlbmNlcyA9IGFsbE5hbWVkUmVmZXJlbmNlc1tsZXZlbF0uY2hhcmFjdGVycztcbiAgICB2YXIgaXNIZXggPSBudW1lcmljID09PSAnaGV4YWRlY2ltYWwnO1xuICAgIGVuY29kZVJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBfYiA9IGVuY29kZVJlZ0V4cC5leGVjKHRleHQpO1xuICAgIHZhciBfYztcbiAgICBpZiAoX2IpIHtcbiAgICAgICAgX2MgPSAnJztcbiAgICAgICAgdmFyIF9kID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKF9kICE9PSBfYi5pbmRleCkge1xuICAgICAgICAgICAgICAgIF9jICs9IHRleHQuc3Vic3RyaW5nKF9kLCBfYi5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2UgPSBfYlswXTtcbiAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IHJlZmVyZW5jZXNbX2VdO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHRfMSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlXzEgPSBfZS5sZW5ndGggPiAxID8gc3Vycm9nYXRlX3BhaXJzXzEuZ2V0Q29kZVBvaW50KF9lLCAwKSA6IF9lLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0XzEgPSAoaXNIZXggPyAnJiN4JyArIGNvZGVfMS50b1N0cmluZygxNikgOiAnJiMnICsgY29kZV8xKSArICc7JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jICs9IHJlc3VsdF8xO1xuICAgICAgICAgICAgX2QgPSBfYi5pbmRleCArIF9lLmxlbmd0aDtcbiAgICAgICAgfSB3aGlsZSAoKF9iID0gZW5jb2RlUmVnRXhwLmV4ZWModGV4dCkpKTtcbiAgICAgICAgaWYgKF9kICE9PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgX2MgKz0gdGV4dC5zdWJzdHJpbmcoX2QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfYyA9XG4gICAgICAgICAgICB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gX2M7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbnZhciBkZWZhdWx0RGVjb2RlT3B0aW9ucyA9IHtcbiAgICBzY29wZTogJ2JvZHknLFxuICAgIGxldmVsOiAnYWxsJ1xufTtcbnZhciBzdHJpY3QgPSAvJig/OiNcXGQrfCNbeFhdW1xcZGEtZkEtRl0rfFswLTlhLXpBLVpdKyk7L2c7XG52YXIgYXR0cmlidXRlID0gLyYoPzojXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspWzs9XT8vZztcbnZhciBiYXNlRGVjb2RlUmVnRXhwcyA9IHtcbiAgICB4bWw6IHtcbiAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlLFxuICAgICAgICBib2R5OiBuYW1lZF9yZWZlcmVuY2VzXzEuYm9keVJlZ0V4cHMueG1sXG4gICAgfSxcbiAgICBodG1sNDoge1xuICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICAgIGJvZHk6IG5hbWVkX3JlZmVyZW5jZXNfMS5ib2R5UmVnRXhwcy5odG1sNFxuICAgIH0sXG4gICAgaHRtbDU6IHtcbiAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlLFxuICAgICAgICBib2R5OiBuYW1lZF9yZWZlcmVuY2VzXzEuYm9keVJlZ0V4cHMuaHRtbDVcbiAgICB9XG59O1xudmFyIGRlY29kZVJlZ0V4cHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYmFzZURlY29kZVJlZ0V4cHMpLCB7IGFsbDogYmFzZURlY29kZVJlZ0V4cHMuaHRtbDUgfSk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBvdXRPZkJvdW5kc0NoYXIgPSBmcm9tQ2hhckNvZGUoNjU1MzMpO1xudmFyIGRlZmF1bHREZWNvZGVFbnRpdHlPcHRpb25zID0ge1xuICAgIGxldmVsOiAnYWxsJ1xufTtcbi8qKiBEZWNvZGVzIGEgc2luZ2xlIGVudGl0eSAqL1xuZnVuY3Rpb24gZGVjb2RlRW50aXR5KGVudGl0eSwgX2EpIHtcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IGRlZmF1bHREZWNvZGVFbnRpdHlPcHRpb25zIDogX2EpLmxldmVsLCBsZXZlbCA9IF9iID09PSB2b2lkIDAgPyAnYWxsJyA6IF9iO1xuICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIF9iID0gZW50aXR5O1xuICAgIHZhciBkZWNvZGVFbnRpdHlMYXN0Q2hhcl8xID0gZW50aXR5W2VudGl0eS5sZW5ndGggLSAxXTtcbiAgICBpZiAoZmFsc2VcbiAgICAgICAgJiYgZGVjb2RlRW50aXR5TGFzdENoYXJfMSA9PT0gJz0nKSB7XG4gICAgICAgIF9iID1cbiAgICAgICAgICAgIGVudGl0eTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmFsc2VcbiAgICAgICAgJiYgZGVjb2RlRW50aXR5TGFzdENoYXJfMSAhPT0gJzsnKSB7XG4gICAgICAgIF9iID1cbiAgICAgICAgICAgIGVudGl0eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZV8xID0gYWxsTmFtZWRSZWZlcmVuY2VzW2xldmVsXS5lbnRpdGllc1tlbnRpdHldO1xuICAgICAgICBpZiAoZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2VfMSkge1xuICAgICAgICAgICAgX2IgPSBkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZV8xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudGl0eVswXSA9PT0gJyYnICYmIGVudGl0eVsxXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgZGVjb2RlU2Vjb25kQ2hhcl8xID0gZW50aXR5WzJdO1xuICAgICAgICAgICAgdmFyIGRlY29kZUNvZGVfMSA9IGRlY29kZVNlY29uZENoYXJfMSA9PSAneCcgfHwgZGVjb2RlU2Vjb25kQ2hhcl8xID09ICdYJ1xuICAgICAgICAgICAgICAgID8gcGFyc2VJbnQoZW50aXR5LnN1YnN0cigzKSwgMTYpXG4gICAgICAgICAgICAgICAgOiBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpKTtcbiAgICAgICAgICAgIF9iID1cbiAgICAgICAgICAgICAgICBkZWNvZGVDb2RlXzEgPj0gMHgxMGZmZmZcbiAgICAgICAgICAgICAgICAgICAgPyBvdXRPZkJvdW5kc0NoYXJcbiAgICAgICAgICAgICAgICAgICAgOiBkZWNvZGVDb2RlXzEgPiA2NTUzNVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdXJyb2dhdGVfcGFpcnNfMS5mcm9tQ29kZVBvaW50KGRlY29kZUNvZGVfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZnJvbUNoYXJDb2RlKG51bWVyaWNfdW5pY29kZV9tYXBfMS5udW1lcmljVW5pY29kZU1hcFtkZWNvZGVDb2RlXzFdIHx8IGRlY29kZUNvZGVfMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9iO1xufVxuZXhwb3J0cy5kZWNvZGVFbnRpdHkgPSBkZWNvZGVFbnRpdHk7XG4vKiogRGVjb2RlcyBhbGwgZW50aXRpZXMgaW4gdGhlIHRleHQgKi9cbmZ1bmN0aW9uIGRlY29kZSh0ZXh0LCBfYSkge1xuICAgIHZhciBkZWNvZGVTZWNvbmRDaGFyXzEgPSBfYSA9PT0gdm9pZCAwID8gZGVmYXVsdERlY29kZU9wdGlvbnMgOiBfYSwgZGVjb2RlQ29kZV8xID0gZGVjb2RlU2Vjb25kQ2hhcl8xLmxldmVsLCBsZXZlbCA9IGRlY29kZUNvZGVfMSA9PT0gdm9pZCAwID8gJ2FsbCcgOiBkZWNvZGVDb2RlXzEsIF9iID0gZGVjb2RlU2Vjb25kQ2hhcl8xLnNjb3BlLCBzY29wZSA9IF9iID09PSB2b2lkIDAgPyBsZXZlbCA9PT0gJ3htbCcgPyAnc3RyaWN0JyA6ICdib2R5JyA6IF9iO1xuICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBkZWNvZGVSZWdFeHAgPSBkZWNvZGVSZWdFeHBzW2xldmVsXVtzY29wZV07XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBhbGxOYW1lZFJlZmVyZW5jZXNbbGV2ZWxdLmVudGl0aWVzO1xuICAgIHZhciBpc0F0dHJpYnV0ZSA9IHNjb3BlID09PSAnYXR0cmlidXRlJztcbiAgICB2YXIgaXNTdHJpY3QgPSBzY29wZSA9PT0gJ3N0cmljdCc7XG4gICAgZGVjb2RlUmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIHJlcGxhY2VNYXRjaF8xID0gZGVjb2RlUmVnRXhwLmV4ZWModGV4dCk7XG4gICAgdmFyIHJlcGxhY2VSZXN1bHRfMTtcbiAgICBpZiAocmVwbGFjZU1hdGNoXzEpIHtcbiAgICAgICAgcmVwbGFjZVJlc3VsdF8xID0gJyc7XG4gICAgICAgIHZhciByZXBsYWNlTGFzdEluZGV4XzEgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAocmVwbGFjZUxhc3RJbmRleF8xICE9PSByZXBsYWNlTWF0Y2hfMS5pbmRleCkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VSZXN1bHRfMSArPSB0ZXh0LnN1YnN0cmluZyhyZXBsYWNlTGFzdEluZGV4XzEsIHJlcGxhY2VNYXRjaF8xLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXBsYWNlSW5wdXRfMSA9IHJlcGxhY2VNYXRjaF8xWzBdO1xuICAgICAgICAgICAgdmFyIGRlY29kZVJlc3VsdF8xID0gcmVwbGFjZUlucHV0XzE7XG4gICAgICAgICAgICB2YXIgZGVjb2RlRW50aXR5TGFzdENoYXJfMiA9IHJlcGxhY2VJbnB1dF8xW3JlcGxhY2VJbnB1dF8xLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGlzQXR0cmlidXRlXG4gICAgICAgICAgICAgICAgJiYgZGVjb2RlRW50aXR5TGFzdENoYXJfMiA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0XzEgPSByZXBsYWNlSW5wdXRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgJiYgZGVjb2RlRW50aXR5TGFzdENoYXJfMiAhPT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0XzEgPSByZXBsYWNlSW5wdXRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZV8yID0gcmVmZXJlbmNlc1tyZXBsYWNlSW5wdXRfMV07XG4gICAgICAgICAgICAgICAgaWYgKGRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlXzIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0XzEgPSBkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZV8yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlSW5wdXRfMVswXSA9PT0gJyYnICYmIHJlcGxhY2VJbnB1dF8xWzFdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29kZVNlY29uZENoYXJfMiA9IHJlcGxhY2VJbnB1dF8xWzJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb2RlQ29kZV8yID0gZGVjb2RlU2Vjb25kQ2hhcl8yID09ICd4JyB8fCBkZWNvZGVTZWNvbmRDaGFyXzIgPT0gJ1gnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlSW50KHJlcGxhY2VJbnB1dF8xLnN1YnN0cigzKSwgMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlSW50KHJlcGxhY2VJbnB1dF8xLnN1YnN0cigyKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVJlc3VsdF8xID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZUNvZGVfMiA+PSAweDEwZmZmZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3V0T2ZCb3VuZHNDaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWNvZGVDb2RlXzIgPiA2NTUzNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHN1cnJvZ2F0ZV9wYWlyc18xLmZyb21Db2RlUG9pbnQoZGVjb2RlQ29kZV8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZyb21DaGFyQ29kZShudW1lcmljX3VuaWNvZGVfbWFwXzEubnVtZXJpY1VuaWNvZGVNYXBbZGVjb2RlQ29kZV8yXSB8fCBkZWNvZGVDb2RlXzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VSZXN1bHRfMSArPSBkZWNvZGVSZXN1bHRfMTtcbiAgICAgICAgICAgIHJlcGxhY2VMYXN0SW5kZXhfMSA9IHJlcGxhY2VNYXRjaF8xLmluZGV4ICsgcmVwbGFjZUlucHV0XzEubGVuZ3RoO1xuICAgICAgICB9IHdoaWxlICgocmVwbGFjZU1hdGNoXzEgPSBkZWNvZGVSZWdFeHAuZXhlYyh0ZXh0KSkpO1xuICAgICAgICBpZiAocmVwbGFjZUxhc3RJbmRleF8xICE9PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVwbGFjZVJlc3VsdF8xICs9IHRleHQuc3Vic3RyaW5nKHJlcGxhY2VMYXN0SW5kZXhfMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcGxhY2VSZXN1bHRfMSA9XG4gICAgICAgICAgICB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZVJlc3VsdF8xO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2V4cG9ydHMuYm9keVJlZ0V4cHM9e3htbDovJig/OiNcXGQrfCNbeFhdW1xcZGEtZkEtRl0rfFswLTlhLXpBLVpdKyk7Py9nLGh0bWw0Oi8mKD86bmJzcHxpZXhjbHxjZW50fHBvdW5kfGN1cnJlbnx5ZW58YnJ2YmFyfHNlY3R8dW1sfGNvcHl8b3JkZnxsYXF1b3xub3R8c2h5fHJlZ3xtYWNyfGRlZ3xwbHVzbW58c3VwMnxzdXAzfGFjdXRlfG1pY3JvfHBhcmF8bWlkZG90fGNlZGlsfHN1cDF8b3JkbXxyYXF1b3xmcmFjMTR8ZnJhYzEyfGZyYWMzNHxpcXVlc3R8QWdyYXZlfEFhY3V0ZXxBY2lyY3xBdGlsZGV8QXVtbHxBcmluZ3xBRWxpZ3xDY2VkaWx8RWdyYXZlfEVhY3V0ZXxFY2lyY3xFdW1sfElncmF2ZXxJYWN1dGV8SWNpcmN8SXVtbHxFVEh8TnRpbGRlfE9ncmF2ZXxPYWN1dGV8T2NpcmN8T3RpbGRlfE91bWx8dGltZXN8T3NsYXNofFVncmF2ZXxVYWN1dGV8VWNpcmN8VXVtbHxZYWN1dGV8VEhPUk58c3psaWd8YWdyYXZlfGFhY3V0ZXxhY2lyY3xhdGlsZGV8YXVtbHxhcmluZ3xhZWxpZ3xjY2VkaWx8ZWdyYXZlfGVhY3V0ZXxlY2lyY3xldW1sfGlncmF2ZXxpYWN1dGV8aWNpcmN8aXVtbHxldGh8bnRpbGRlfG9ncmF2ZXxvYWN1dGV8b2NpcmN8b3RpbGRlfG91bWx8ZGl2aWRlfG9zbGFzaHx1Z3JhdmV8dWFjdXRlfHVjaXJjfHV1bWx8eWFjdXRlfHRob3JufHl1bWx8cXVvdHxhbXB8bHR8Z3R8I1xcZCt8I1t4WF1bXFxkYS1mQS1GXSt8WzAtOWEtekEtWl0rKTs/L2csaHRtbDU6LyYoPzpBRWxpZ3xBTVB8QWFjdXRlfEFjaXJjfEFncmF2ZXxBcmluZ3xBdGlsZGV8QXVtbHxDT1BZfENjZWRpbHxFVEh8RWFjdXRlfEVjaXJjfEVncmF2ZXxFdW1sfEdUfElhY3V0ZXxJY2lyY3xJZ3JhdmV8SXVtbHxMVHxOdGlsZGV8T2FjdXRlfE9jaXJjfE9ncmF2ZXxPc2xhc2h8T3RpbGRlfE91bWx8UVVPVHxSRUd8VEhPUk58VWFjdXRlfFVjaXJjfFVncmF2ZXxVdW1sfFlhY3V0ZXxhYWN1dGV8YWNpcmN8YWN1dGV8YWVsaWd8YWdyYXZlfGFtcHxhcmluZ3xhdGlsZGV8YXVtbHxicnZiYXJ8Y2NlZGlsfGNlZGlsfGNlbnR8Y29weXxjdXJyZW58ZGVnfGRpdmlkZXxlYWN1dGV8ZWNpcmN8ZWdyYXZlfGV0aHxldW1sfGZyYWMxMnxmcmFjMTR8ZnJhYzM0fGd0fGlhY3V0ZXxpY2lyY3xpZXhjbHxpZ3JhdmV8aXF1ZXN0fGl1bWx8bGFxdW98bHR8bWFjcnxtaWNyb3xtaWRkb3R8bmJzcHxub3R8bnRpbGRlfG9hY3V0ZXxvY2lyY3xvZ3JhdmV8b3JkZnxvcmRtfG9zbGFzaHxvdGlsZGV8b3VtbHxwYXJhfHBsdXNtbnxwb3VuZHxxdW90fHJhcXVvfHJlZ3xzZWN0fHNoeXxzdXAxfHN1cDJ8c3VwM3xzemxpZ3x0aG9ybnx0aW1lc3x1YWN1dGV8dWNpcmN8dWdyYXZlfHVtbHx1dW1sfHlhY3V0ZXx5ZW58eXVtbHwjXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspOz8vZ307ZXhwb3J0cy5uYW1lZFJlZmVyZW5jZXM9e3htbDp7ZW50aXRpZXM6e1wiJmx0O1wiOlwiPFwiLFwiJmd0O1wiOlwiPlwiLFwiJnF1b3Q7XCI6J1wiJyxcIiZhcG9zO1wiOlwiJ1wiLFwiJmFtcDtcIjpcIiZcIn0sY2hhcmFjdGVyczp7XCI8XCI6XCImbHQ7XCIsXCI+XCI6XCImZ3Q7XCIsJ1wiJzpcIiZxdW90O1wiLFwiJ1wiOlwiJmFwb3M7XCIsXCImXCI6XCImYW1wO1wifX0saHRtbDQ6e2VudGl0aWVzOntcIiZhcG9zO1wiOlwiJ1wiLFwiJm5ic3BcIjpcIsKgXCIsXCImbmJzcDtcIjpcIsKgXCIsXCImaWV4Y2xcIjpcIsKhXCIsXCImaWV4Y2w7XCI6XCLCoVwiLFwiJmNlbnRcIjpcIsKiXCIsXCImY2VudDtcIjpcIsKiXCIsXCImcG91bmRcIjpcIsKjXCIsXCImcG91bmQ7XCI6XCLCo1wiLFwiJmN1cnJlblwiOlwiwqRcIixcIiZjdXJyZW47XCI6XCLCpFwiLFwiJnllblwiOlwiwqVcIixcIiZ5ZW47XCI6XCLCpVwiLFwiJmJydmJhclwiOlwiwqZcIixcIiZicnZiYXI7XCI6XCLCplwiLFwiJnNlY3RcIjpcIsKnXCIsXCImc2VjdDtcIjpcIsKnXCIsXCImdW1sXCI6XCLCqFwiLFwiJnVtbDtcIjpcIsKoXCIsXCImY29weVwiOlwiwqlcIixcIiZjb3B5O1wiOlwiwqlcIixcIiZvcmRmXCI6XCLCqlwiLFwiJm9yZGY7XCI6XCLCqlwiLFwiJmxhcXVvXCI6XCLCq1wiLFwiJmxhcXVvO1wiOlwiwqtcIixcIiZub3RcIjpcIsKsXCIsXCImbm90O1wiOlwiwqxcIixcIiZzaHlcIjpcIsKtXCIsXCImc2h5O1wiOlwiwq1cIixcIiZyZWdcIjpcIsKuXCIsXCImcmVnO1wiOlwiwq5cIixcIiZtYWNyXCI6XCLCr1wiLFwiJm1hY3I7XCI6XCLCr1wiLFwiJmRlZ1wiOlwiwrBcIixcIiZkZWc7XCI6XCLCsFwiLFwiJnBsdXNtblwiOlwiwrFcIixcIiZwbHVzbW47XCI6XCLCsVwiLFwiJnN1cDJcIjpcIsKyXCIsXCImc3VwMjtcIjpcIsKyXCIsXCImc3VwM1wiOlwiwrNcIixcIiZzdXAzO1wiOlwiwrNcIixcIiZhY3V0ZVwiOlwiwrRcIixcIiZhY3V0ZTtcIjpcIsK0XCIsXCImbWljcm9cIjpcIsK1XCIsXCImbWljcm87XCI6XCLCtVwiLFwiJnBhcmFcIjpcIsK2XCIsXCImcGFyYTtcIjpcIsK2XCIsXCImbWlkZG90XCI6XCLCt1wiLFwiJm1pZGRvdDtcIjpcIsK3XCIsXCImY2VkaWxcIjpcIsK4XCIsXCImY2VkaWw7XCI6XCLCuFwiLFwiJnN1cDFcIjpcIsK5XCIsXCImc3VwMTtcIjpcIsK5XCIsXCImb3JkbVwiOlwiwrpcIixcIiZvcmRtO1wiOlwiwrpcIixcIiZyYXF1b1wiOlwiwrtcIixcIiZyYXF1bztcIjpcIsK7XCIsXCImZnJhYzE0XCI6XCLCvFwiLFwiJmZyYWMxNDtcIjpcIsK8XCIsXCImZnJhYzEyXCI6XCLCvVwiLFwiJmZyYWMxMjtcIjpcIsK9XCIsXCImZnJhYzM0XCI6XCLCvlwiLFwiJmZyYWMzNDtcIjpcIsK+XCIsXCImaXF1ZXN0XCI6XCLCv1wiLFwiJmlxdWVzdDtcIjpcIsK/XCIsXCImQWdyYXZlXCI6XCLDgFwiLFwiJkFncmF2ZTtcIjpcIsOAXCIsXCImQWFjdXRlXCI6XCLDgVwiLFwiJkFhY3V0ZTtcIjpcIsOBXCIsXCImQWNpcmNcIjpcIsOCXCIsXCImQWNpcmM7XCI6XCLDglwiLFwiJkF0aWxkZVwiOlwiw4NcIixcIiZBdGlsZGU7XCI6XCLDg1wiLFwiJkF1bWxcIjpcIsOEXCIsXCImQXVtbDtcIjpcIsOEXCIsXCImQXJpbmdcIjpcIsOFXCIsXCImQXJpbmc7XCI6XCLDhVwiLFwiJkFFbGlnXCI6XCLDhlwiLFwiJkFFbGlnO1wiOlwiw4ZcIixcIiZDY2VkaWxcIjpcIsOHXCIsXCImQ2NlZGlsO1wiOlwiw4dcIixcIiZFZ3JhdmVcIjpcIsOIXCIsXCImRWdyYXZlO1wiOlwiw4hcIixcIiZFYWN1dGVcIjpcIsOJXCIsXCImRWFjdXRlO1wiOlwiw4lcIixcIiZFY2lyY1wiOlwiw4pcIixcIiZFY2lyYztcIjpcIsOKXCIsXCImRXVtbFwiOlwiw4tcIixcIiZFdW1sO1wiOlwiw4tcIixcIiZJZ3JhdmVcIjpcIsOMXCIsXCImSWdyYXZlO1wiOlwiw4xcIixcIiZJYWN1dGVcIjpcIsONXCIsXCImSWFjdXRlO1wiOlwiw41cIixcIiZJY2lyY1wiOlwiw45cIixcIiZJY2lyYztcIjpcIsOOXCIsXCImSXVtbFwiOlwiw49cIixcIiZJdW1sO1wiOlwiw49cIixcIiZFVEhcIjpcIsOQXCIsXCImRVRIO1wiOlwiw5BcIixcIiZOdGlsZGVcIjpcIsORXCIsXCImTnRpbGRlO1wiOlwiw5FcIixcIiZPZ3JhdmVcIjpcIsOSXCIsXCImT2dyYXZlO1wiOlwiw5JcIixcIiZPYWN1dGVcIjpcIsOTXCIsXCImT2FjdXRlO1wiOlwiw5NcIixcIiZPY2lyY1wiOlwiw5RcIixcIiZPY2lyYztcIjpcIsOUXCIsXCImT3RpbGRlXCI6XCLDlVwiLFwiJk90aWxkZTtcIjpcIsOVXCIsXCImT3VtbFwiOlwiw5ZcIixcIiZPdW1sO1wiOlwiw5ZcIixcIiZ0aW1lc1wiOlwiw5dcIixcIiZ0aW1lcztcIjpcIsOXXCIsXCImT3NsYXNoXCI6XCLDmFwiLFwiJk9zbGFzaDtcIjpcIsOYXCIsXCImVWdyYXZlXCI6XCLDmVwiLFwiJlVncmF2ZTtcIjpcIsOZXCIsXCImVWFjdXRlXCI6XCLDmlwiLFwiJlVhY3V0ZTtcIjpcIsOaXCIsXCImVWNpcmNcIjpcIsObXCIsXCImVWNpcmM7XCI6XCLDm1wiLFwiJlV1bWxcIjpcIsOcXCIsXCImVXVtbDtcIjpcIsOcXCIsXCImWWFjdXRlXCI6XCLDnVwiLFwiJllhY3V0ZTtcIjpcIsOdXCIsXCImVEhPUk5cIjpcIsOeXCIsXCImVEhPUk47XCI6XCLDnlwiLFwiJnN6bGlnXCI6XCLDn1wiLFwiJnN6bGlnO1wiOlwiw59cIixcIiZhZ3JhdmVcIjpcIsOgXCIsXCImYWdyYXZlO1wiOlwiw6BcIixcIiZhYWN1dGVcIjpcIsOhXCIsXCImYWFjdXRlO1wiOlwiw6FcIixcIiZhY2lyY1wiOlwiw6JcIixcIiZhY2lyYztcIjpcIsOiXCIsXCImYXRpbGRlXCI6XCLDo1wiLFwiJmF0aWxkZTtcIjpcIsOjXCIsXCImYXVtbFwiOlwiw6RcIixcIiZhdW1sO1wiOlwiw6RcIixcIiZhcmluZ1wiOlwiw6VcIixcIiZhcmluZztcIjpcIsOlXCIsXCImYWVsaWdcIjpcIsOmXCIsXCImYWVsaWc7XCI6XCLDplwiLFwiJmNjZWRpbFwiOlwiw6dcIixcIiZjY2VkaWw7XCI6XCLDp1wiLFwiJmVncmF2ZVwiOlwiw6hcIixcIiZlZ3JhdmU7XCI6XCLDqFwiLFwiJmVhY3V0ZVwiOlwiw6lcIixcIiZlYWN1dGU7XCI6XCLDqVwiLFwiJmVjaXJjXCI6XCLDqlwiLFwiJmVjaXJjO1wiOlwiw6pcIixcIiZldW1sXCI6XCLDq1wiLFwiJmV1bWw7XCI6XCLDq1wiLFwiJmlncmF2ZVwiOlwiw6xcIixcIiZpZ3JhdmU7XCI6XCLDrFwiLFwiJmlhY3V0ZVwiOlwiw61cIixcIiZpYWN1dGU7XCI6XCLDrVwiLFwiJmljaXJjXCI6XCLDrlwiLFwiJmljaXJjO1wiOlwiw65cIixcIiZpdW1sXCI6XCLDr1wiLFwiJml1bWw7XCI6XCLDr1wiLFwiJmV0aFwiOlwiw7BcIixcIiZldGg7XCI6XCLDsFwiLFwiJm50aWxkZVwiOlwiw7FcIixcIiZudGlsZGU7XCI6XCLDsVwiLFwiJm9ncmF2ZVwiOlwiw7JcIixcIiZvZ3JhdmU7XCI6XCLDslwiLFwiJm9hY3V0ZVwiOlwiw7NcIixcIiZvYWN1dGU7XCI6XCLDs1wiLFwiJm9jaXJjXCI6XCLDtFwiLFwiJm9jaXJjO1wiOlwiw7RcIixcIiZvdGlsZGVcIjpcIsO1XCIsXCImb3RpbGRlO1wiOlwiw7VcIixcIiZvdW1sXCI6XCLDtlwiLFwiJm91bWw7XCI6XCLDtlwiLFwiJmRpdmlkZVwiOlwiw7dcIixcIiZkaXZpZGU7XCI6XCLDt1wiLFwiJm9zbGFzaFwiOlwiw7hcIixcIiZvc2xhc2g7XCI6XCLDuFwiLFwiJnVncmF2ZVwiOlwiw7lcIixcIiZ1Z3JhdmU7XCI6XCLDuVwiLFwiJnVhY3V0ZVwiOlwiw7pcIixcIiZ1YWN1dGU7XCI6XCLDulwiLFwiJnVjaXJjXCI6XCLDu1wiLFwiJnVjaXJjO1wiOlwiw7tcIixcIiZ1dW1sXCI6XCLDvFwiLFwiJnV1bWw7XCI6XCLDvFwiLFwiJnlhY3V0ZVwiOlwiw71cIixcIiZ5YWN1dGU7XCI6XCLDvVwiLFwiJnRob3JuXCI6XCLDvlwiLFwiJnRob3JuO1wiOlwiw75cIixcIiZ5dW1sXCI6XCLDv1wiLFwiJnl1bWw7XCI6XCLDv1wiLFwiJnF1b3RcIjonXCInLFwiJnF1b3Q7XCI6J1wiJyxcIiZhbXBcIjpcIiZcIixcIiZhbXA7XCI6XCImXCIsXCImbHRcIjpcIjxcIixcIiZsdDtcIjpcIjxcIixcIiZndFwiOlwiPlwiLFwiJmd0O1wiOlwiPlwiLFwiJk9FbGlnO1wiOlwixZJcIixcIiZvZWxpZztcIjpcIsWTXCIsXCImU2Nhcm9uO1wiOlwixaBcIixcIiZzY2Fyb247XCI6XCLFoVwiLFwiJll1bWw7XCI6XCLFuFwiLFwiJmNpcmM7XCI6XCLLhlwiLFwiJnRpbGRlO1wiOlwiy5xcIixcIiZlbnNwO1wiOlwi4oCCXCIsXCImZW1zcDtcIjpcIuKAg1wiLFwiJnRoaW5zcDtcIjpcIuKAiVwiLFwiJnp3bmo7XCI6XCLigIxcIixcIiZ6d2o7XCI6XCLigI1cIixcIiZscm07XCI6XCLigI5cIixcIiZybG07XCI6XCLigI9cIixcIiZuZGFzaDtcIjpcIuKAk1wiLFwiJm1kYXNoO1wiOlwi4oCUXCIsXCImbHNxdW87XCI6XCLigJhcIixcIiZyc3F1bztcIjpcIuKAmVwiLFwiJnNicXVvO1wiOlwi4oCaXCIsXCImbGRxdW87XCI6XCLigJxcIixcIiZyZHF1bztcIjpcIuKAnVwiLFwiJmJkcXVvO1wiOlwi4oCeXCIsXCImZGFnZ2VyO1wiOlwi4oCgXCIsXCImRGFnZ2VyO1wiOlwi4oChXCIsXCImcGVybWlsO1wiOlwi4oCwXCIsXCImbHNhcXVvO1wiOlwi4oC5XCIsXCImcnNhcXVvO1wiOlwi4oC6XCIsXCImZXVybztcIjpcIuKCrFwiLFwiJmZub2Y7XCI6XCLGklwiLFwiJkFscGhhO1wiOlwizpFcIixcIiZCZXRhO1wiOlwizpJcIixcIiZHYW1tYTtcIjpcIs6TXCIsXCImRGVsdGE7XCI6XCLOlFwiLFwiJkVwc2lsb247XCI6XCLOlVwiLFwiJlpldGE7XCI6XCLOllwiLFwiJkV0YTtcIjpcIs6XXCIsXCImVGhldGE7XCI6XCLOmFwiLFwiJklvdGE7XCI6XCLOmVwiLFwiJkthcHBhO1wiOlwizppcIixcIiZMYW1iZGE7XCI6XCLOm1wiLFwiJk11O1wiOlwizpxcIixcIiZOdTtcIjpcIs6dXCIsXCImWGk7XCI6XCLOnlwiLFwiJk9taWNyb247XCI6XCLOn1wiLFwiJlBpO1wiOlwizqBcIixcIiZSaG87XCI6XCLOoVwiLFwiJlNpZ21hO1wiOlwizqNcIixcIiZUYXU7XCI6XCLOpFwiLFwiJlVwc2lsb247XCI6XCLOpVwiLFwiJlBoaTtcIjpcIs6mXCIsXCImQ2hpO1wiOlwizqdcIixcIiZQc2k7XCI6XCLOqFwiLFwiJk9tZWdhO1wiOlwizqlcIixcIiZhbHBoYTtcIjpcIs6xXCIsXCImYmV0YTtcIjpcIs6yXCIsXCImZ2FtbWE7XCI6XCLOs1wiLFwiJmRlbHRhO1wiOlwizrRcIixcIiZlcHNpbG9uO1wiOlwizrVcIixcIiZ6ZXRhO1wiOlwizrZcIixcIiZldGE7XCI6XCLOt1wiLFwiJnRoZXRhO1wiOlwizrhcIixcIiZpb3RhO1wiOlwizrlcIixcIiZrYXBwYTtcIjpcIs66XCIsXCImbGFtYmRhO1wiOlwizrtcIixcIiZtdTtcIjpcIs68XCIsXCImbnU7XCI6XCLOvVwiLFwiJnhpO1wiOlwizr5cIixcIiZvbWljcm9uO1wiOlwizr9cIixcIiZwaTtcIjpcIs+AXCIsXCImcmhvO1wiOlwiz4FcIixcIiZzaWdtYWY7XCI6XCLPglwiLFwiJnNpZ21hO1wiOlwiz4NcIixcIiZ0YXU7XCI6XCLPhFwiLFwiJnVwc2lsb247XCI6XCLPhVwiLFwiJnBoaTtcIjpcIs+GXCIsXCImY2hpO1wiOlwiz4dcIixcIiZwc2k7XCI6XCLPiFwiLFwiJm9tZWdhO1wiOlwiz4lcIixcIiZ0aGV0YXN5bTtcIjpcIs+RXCIsXCImdXBzaWg7XCI6XCLPklwiLFwiJnBpdjtcIjpcIs+WXCIsXCImYnVsbDtcIjpcIuKAolwiLFwiJmhlbGxpcDtcIjpcIuKAplwiLFwiJnByaW1lO1wiOlwi4oCyXCIsXCImUHJpbWU7XCI6XCLigLNcIixcIiZvbGluZTtcIjpcIuKAvlwiLFwiJmZyYXNsO1wiOlwi4oGEXCIsXCImd2VpZXJwO1wiOlwi4oSYXCIsXCImaW1hZ2U7XCI6XCLihJFcIixcIiZyZWFsO1wiOlwi4oScXCIsXCImdHJhZGU7XCI6XCLihKJcIixcIiZhbGVmc3ltO1wiOlwi4oS1XCIsXCImbGFycjtcIjpcIuKGkFwiLFwiJnVhcnI7XCI6XCLihpFcIixcIiZyYXJyO1wiOlwi4oaSXCIsXCImZGFycjtcIjpcIuKGk1wiLFwiJmhhcnI7XCI6XCLihpRcIixcIiZjcmFycjtcIjpcIuKGtVwiLFwiJmxBcnI7XCI6XCLih5BcIixcIiZ1QXJyO1wiOlwi4oeRXCIsXCImckFycjtcIjpcIuKHklwiLFwiJmRBcnI7XCI6XCLih5NcIixcIiZoQXJyO1wiOlwi4oeUXCIsXCImZm9yYWxsO1wiOlwi4oiAXCIsXCImcGFydDtcIjpcIuKIglwiLFwiJmV4aXN0O1wiOlwi4oiDXCIsXCImZW1wdHk7XCI6XCLiiIVcIixcIiZuYWJsYTtcIjpcIuKIh1wiLFwiJmlzaW47XCI6XCLiiIhcIixcIiZub3RpbjtcIjpcIuKIiVwiLFwiJm5pO1wiOlwi4oiLXCIsXCImcHJvZDtcIjpcIuKIj1wiLFwiJnN1bTtcIjpcIuKIkVwiLFwiJm1pbnVzO1wiOlwi4oiSXCIsXCImbG93YXN0O1wiOlwi4oiXXCIsXCImcmFkaWM7XCI6XCLiiJpcIixcIiZwcm9wO1wiOlwi4oidXCIsXCImaW5maW47XCI6XCLiiJ5cIixcIiZhbmc7XCI6XCLiiKBcIixcIiZhbmQ7XCI6XCLiiKdcIixcIiZvcjtcIjpcIuKIqFwiLFwiJmNhcDtcIjpcIuKIqVwiLFwiJmN1cDtcIjpcIuKIqlwiLFwiJmludDtcIjpcIuKIq1wiLFwiJnRoZXJlNDtcIjpcIuKItFwiLFwiJnNpbTtcIjpcIuKIvFwiLFwiJmNvbmc7XCI6XCLiiYVcIixcIiZhc3ltcDtcIjpcIuKJiFwiLFwiJm5lO1wiOlwi4omgXCIsXCImZXF1aXY7XCI6XCLiiaFcIixcIiZsZTtcIjpcIuKJpFwiLFwiJmdlO1wiOlwi4omlXCIsXCImc3ViO1wiOlwi4oqCXCIsXCImc3VwO1wiOlwi4oqDXCIsXCImbnN1YjtcIjpcIuKKhFwiLFwiJnN1YmU7XCI6XCLiioZcIixcIiZzdXBlO1wiOlwi4oqHXCIsXCImb3BsdXM7XCI6XCLiipVcIixcIiZvdGltZXM7XCI6XCLiipdcIixcIiZwZXJwO1wiOlwi4oqlXCIsXCImc2RvdDtcIjpcIuKLhVwiLFwiJmxjZWlsO1wiOlwi4oyIXCIsXCImcmNlaWw7XCI6XCLijIlcIixcIiZsZmxvb3I7XCI6XCLijIpcIixcIiZyZmxvb3I7XCI6XCLijItcIixcIiZsYW5nO1wiOlwi4oypXCIsXCImcmFuZztcIjpcIuKMqlwiLFwiJmxvejtcIjpcIuKXilwiLFwiJnNwYWRlcztcIjpcIuKZoFwiLFwiJmNsdWJzO1wiOlwi4pmjXCIsXCImaGVhcnRzO1wiOlwi4pmlXCIsXCImZGlhbXM7XCI6XCLimaZcIn0sY2hhcmFjdGVyczp7XCInXCI6XCImYXBvcztcIixcIsKgXCI6XCImbmJzcDtcIixcIsKhXCI6XCImaWV4Y2w7XCIsXCLColwiOlwiJmNlbnQ7XCIsXCLCo1wiOlwiJnBvdW5kO1wiLFwiwqRcIjpcIiZjdXJyZW47XCIsXCLCpVwiOlwiJnllbjtcIixcIsKmXCI6XCImYnJ2YmFyO1wiLFwiwqdcIjpcIiZzZWN0O1wiLFwiwqhcIjpcIiZ1bWw7XCIsXCLCqVwiOlwiJmNvcHk7XCIsXCLCqlwiOlwiJm9yZGY7XCIsXCLCq1wiOlwiJmxhcXVvO1wiLFwiwqxcIjpcIiZub3Q7XCIsXCLCrVwiOlwiJnNoeTtcIixcIsKuXCI6XCImcmVnO1wiLFwiwq9cIjpcIiZtYWNyO1wiLFwiwrBcIjpcIiZkZWc7XCIsXCLCsVwiOlwiJnBsdXNtbjtcIixcIsKyXCI6XCImc3VwMjtcIixcIsKzXCI6XCImc3VwMztcIixcIsK0XCI6XCImYWN1dGU7XCIsXCLCtVwiOlwiJm1pY3JvO1wiLFwiwrZcIjpcIiZwYXJhO1wiLFwiwrdcIjpcIiZtaWRkb3Q7XCIsXCLCuFwiOlwiJmNlZGlsO1wiLFwiwrlcIjpcIiZzdXAxO1wiLFwiwrpcIjpcIiZvcmRtO1wiLFwiwrtcIjpcIiZyYXF1bztcIixcIsK8XCI6XCImZnJhYzE0O1wiLFwiwr1cIjpcIiZmcmFjMTI7XCIsXCLCvlwiOlwiJmZyYWMzNDtcIixcIsK/XCI6XCImaXF1ZXN0O1wiLFwiw4BcIjpcIiZBZ3JhdmU7XCIsXCLDgVwiOlwiJkFhY3V0ZTtcIixcIsOCXCI6XCImQWNpcmM7XCIsXCLDg1wiOlwiJkF0aWxkZTtcIixcIsOEXCI6XCImQXVtbDtcIixcIsOFXCI6XCImQXJpbmc7XCIsXCLDhlwiOlwiJkFFbGlnO1wiLFwiw4dcIjpcIiZDY2VkaWw7XCIsXCLDiFwiOlwiJkVncmF2ZTtcIixcIsOJXCI6XCImRWFjdXRlO1wiLFwiw4pcIjpcIiZFY2lyYztcIixcIsOLXCI6XCImRXVtbDtcIixcIsOMXCI6XCImSWdyYXZlO1wiLFwiw41cIjpcIiZJYWN1dGU7XCIsXCLDjlwiOlwiJkljaXJjO1wiLFwiw49cIjpcIiZJdW1sO1wiLFwiw5BcIjpcIiZFVEg7XCIsXCLDkVwiOlwiJk50aWxkZTtcIixcIsOSXCI6XCImT2dyYXZlO1wiLFwiw5NcIjpcIiZPYWN1dGU7XCIsXCLDlFwiOlwiJk9jaXJjO1wiLFwiw5VcIjpcIiZPdGlsZGU7XCIsXCLDllwiOlwiJk91bWw7XCIsXCLDl1wiOlwiJnRpbWVzO1wiLFwiw5hcIjpcIiZPc2xhc2g7XCIsXCLDmVwiOlwiJlVncmF2ZTtcIixcIsOaXCI6XCImVWFjdXRlO1wiLFwiw5tcIjpcIiZVY2lyYztcIixcIsOcXCI6XCImVXVtbDtcIixcIsOdXCI6XCImWWFjdXRlO1wiLFwiw55cIjpcIiZUSE9STjtcIixcIsOfXCI6XCImc3psaWc7XCIsXCLDoFwiOlwiJmFncmF2ZTtcIixcIsOhXCI6XCImYWFjdXRlO1wiLFwiw6JcIjpcIiZhY2lyYztcIixcIsOjXCI6XCImYXRpbGRlO1wiLFwiw6RcIjpcIiZhdW1sO1wiLFwiw6VcIjpcIiZhcmluZztcIixcIsOmXCI6XCImYWVsaWc7XCIsXCLDp1wiOlwiJmNjZWRpbDtcIixcIsOoXCI6XCImZWdyYXZlO1wiLFwiw6lcIjpcIiZlYWN1dGU7XCIsXCLDqlwiOlwiJmVjaXJjO1wiLFwiw6tcIjpcIiZldW1sO1wiLFwiw6xcIjpcIiZpZ3JhdmU7XCIsXCLDrVwiOlwiJmlhY3V0ZTtcIixcIsOuXCI6XCImaWNpcmM7XCIsXCLDr1wiOlwiJml1bWw7XCIsXCLDsFwiOlwiJmV0aDtcIixcIsOxXCI6XCImbnRpbGRlO1wiLFwiw7JcIjpcIiZvZ3JhdmU7XCIsXCLDs1wiOlwiJm9hY3V0ZTtcIixcIsO0XCI6XCImb2NpcmM7XCIsXCLDtVwiOlwiJm90aWxkZTtcIixcIsO2XCI6XCImb3VtbDtcIixcIsO3XCI6XCImZGl2aWRlO1wiLFwiw7hcIjpcIiZvc2xhc2g7XCIsXCLDuVwiOlwiJnVncmF2ZTtcIixcIsO6XCI6XCImdWFjdXRlO1wiLFwiw7tcIjpcIiZ1Y2lyYztcIixcIsO8XCI6XCImdXVtbDtcIixcIsO9XCI6XCImeWFjdXRlO1wiLFwiw75cIjpcIiZ0aG9ybjtcIixcIsO/XCI6XCImeXVtbDtcIiwnXCInOlwiJnF1b3Q7XCIsXCImXCI6XCImYW1wO1wiLFwiPFwiOlwiJmx0O1wiLFwiPlwiOlwiJmd0O1wiLFwixZJcIjpcIiZPRWxpZztcIixcIsWTXCI6XCImb2VsaWc7XCIsXCLFoFwiOlwiJlNjYXJvbjtcIixcIsWhXCI6XCImc2Nhcm9uO1wiLFwixbhcIjpcIiZZdW1sO1wiLFwiy4ZcIjpcIiZjaXJjO1wiLFwiy5xcIjpcIiZ0aWxkZTtcIixcIuKAglwiOlwiJmVuc3A7XCIsXCLigINcIjpcIiZlbXNwO1wiLFwi4oCJXCI6XCImdGhpbnNwO1wiLFwi4oCMXCI6XCImenduajtcIixcIuKAjVwiOlwiJnp3ajtcIixcIuKAjlwiOlwiJmxybTtcIixcIuKAj1wiOlwiJnJsbTtcIixcIuKAk1wiOlwiJm5kYXNoO1wiLFwi4oCUXCI6XCImbWRhc2g7XCIsXCLigJhcIjpcIiZsc3F1bztcIixcIuKAmVwiOlwiJnJzcXVvO1wiLFwi4oCaXCI6XCImc2JxdW87XCIsXCLigJxcIjpcIiZsZHF1bztcIixcIuKAnVwiOlwiJnJkcXVvO1wiLFwi4oCeXCI6XCImYmRxdW87XCIsXCLigKBcIjpcIiZkYWdnZXI7XCIsXCLigKFcIjpcIiZEYWdnZXI7XCIsXCLigLBcIjpcIiZwZXJtaWw7XCIsXCLigLlcIjpcIiZsc2FxdW87XCIsXCLigLpcIjpcIiZyc2FxdW87XCIsXCLigqxcIjpcIiZldXJvO1wiLFwixpJcIjpcIiZmbm9mO1wiLFwizpFcIjpcIiZBbHBoYTtcIixcIs6SXCI6XCImQmV0YTtcIixcIs6TXCI6XCImR2FtbWE7XCIsXCLOlFwiOlwiJkRlbHRhO1wiLFwizpVcIjpcIiZFcHNpbG9uO1wiLFwizpZcIjpcIiZaZXRhO1wiLFwizpdcIjpcIiZFdGE7XCIsXCLOmFwiOlwiJlRoZXRhO1wiLFwizplcIjpcIiZJb3RhO1wiLFwizppcIjpcIiZLYXBwYTtcIixcIs6bXCI6XCImTGFtYmRhO1wiLFwizpxcIjpcIiZNdTtcIixcIs6dXCI6XCImTnU7XCIsXCLOnlwiOlwiJlhpO1wiLFwizp9cIjpcIiZPbWljcm9uO1wiLFwizqBcIjpcIiZQaTtcIixcIs6hXCI6XCImUmhvO1wiLFwizqNcIjpcIiZTaWdtYTtcIixcIs6kXCI6XCImVGF1O1wiLFwizqVcIjpcIiZVcHNpbG9uO1wiLFwizqZcIjpcIiZQaGk7XCIsXCLOp1wiOlwiJkNoaTtcIixcIs6oXCI6XCImUHNpO1wiLFwizqlcIjpcIiZPbWVnYTtcIixcIs6xXCI6XCImYWxwaGE7XCIsXCLOslwiOlwiJmJldGE7XCIsXCLOs1wiOlwiJmdhbW1hO1wiLFwizrRcIjpcIiZkZWx0YTtcIixcIs61XCI6XCImZXBzaWxvbjtcIixcIs62XCI6XCImemV0YTtcIixcIs63XCI6XCImZXRhO1wiLFwizrhcIjpcIiZ0aGV0YTtcIixcIs65XCI6XCImaW90YTtcIixcIs66XCI6XCIma2FwcGE7XCIsXCLOu1wiOlwiJmxhbWJkYTtcIixcIs68XCI6XCImbXU7XCIsXCLOvVwiOlwiJm51O1wiLFwizr5cIjpcIiZ4aTtcIixcIs6/XCI6XCImb21pY3JvbjtcIixcIs+AXCI6XCImcGk7XCIsXCLPgVwiOlwiJnJobztcIixcIs+CXCI6XCImc2lnbWFmO1wiLFwiz4NcIjpcIiZzaWdtYTtcIixcIs+EXCI6XCImdGF1O1wiLFwiz4VcIjpcIiZ1cHNpbG9uO1wiLFwiz4ZcIjpcIiZwaGk7XCIsXCLPh1wiOlwiJmNoaTtcIixcIs+IXCI6XCImcHNpO1wiLFwiz4lcIjpcIiZvbWVnYTtcIixcIs+RXCI6XCImdGhldGFzeW07XCIsXCLPklwiOlwiJnVwc2loO1wiLFwiz5ZcIjpcIiZwaXY7XCIsXCLigKJcIjpcIiZidWxsO1wiLFwi4oCmXCI6XCImaGVsbGlwO1wiLFwi4oCyXCI6XCImcHJpbWU7XCIsXCLigLNcIjpcIiZQcmltZTtcIixcIuKAvlwiOlwiJm9saW5lO1wiLFwi4oGEXCI6XCImZnJhc2w7XCIsXCLihJhcIjpcIiZ3ZWllcnA7XCIsXCLihJFcIjpcIiZpbWFnZTtcIixcIuKEnFwiOlwiJnJlYWw7XCIsXCLihKJcIjpcIiZ0cmFkZTtcIixcIuKEtVwiOlwiJmFsZWZzeW07XCIsXCLihpBcIjpcIiZsYXJyO1wiLFwi4oaRXCI6XCImdWFycjtcIixcIuKGklwiOlwiJnJhcnI7XCIsXCLihpNcIjpcIiZkYXJyO1wiLFwi4oaUXCI6XCImaGFycjtcIixcIuKGtVwiOlwiJmNyYXJyO1wiLFwi4oeQXCI6XCImbEFycjtcIixcIuKHkVwiOlwiJnVBcnI7XCIsXCLih5JcIjpcIiZyQXJyO1wiLFwi4oeTXCI6XCImZEFycjtcIixcIuKHlFwiOlwiJmhBcnI7XCIsXCLiiIBcIjpcIiZmb3JhbGw7XCIsXCLiiIJcIjpcIiZwYXJ0O1wiLFwi4oiDXCI6XCImZXhpc3Q7XCIsXCLiiIVcIjpcIiZlbXB0eTtcIixcIuKIh1wiOlwiJm5hYmxhO1wiLFwi4oiIXCI6XCImaXNpbjtcIixcIuKIiVwiOlwiJm5vdGluO1wiLFwi4oiLXCI6XCImbmk7XCIsXCLiiI9cIjpcIiZwcm9kO1wiLFwi4oiRXCI6XCImc3VtO1wiLFwi4oiSXCI6XCImbWludXM7XCIsXCLiiJdcIjpcIiZsb3dhc3Q7XCIsXCLiiJpcIjpcIiZyYWRpYztcIixcIuKInVwiOlwiJnByb3A7XCIsXCLiiJ5cIjpcIiZpbmZpbjtcIixcIuKIoFwiOlwiJmFuZztcIixcIuKIp1wiOlwiJmFuZDtcIixcIuKIqFwiOlwiJm9yO1wiLFwi4oipXCI6XCImY2FwO1wiLFwi4oiqXCI6XCImY3VwO1wiLFwi4oirXCI6XCImaW50O1wiLFwi4oi0XCI6XCImdGhlcmU0O1wiLFwi4oi8XCI6XCImc2ltO1wiLFwi4omFXCI6XCImY29uZztcIixcIuKJiFwiOlwiJmFzeW1wO1wiLFwi4omgXCI6XCImbmU7XCIsXCLiiaFcIjpcIiZlcXVpdjtcIixcIuKJpFwiOlwiJmxlO1wiLFwi4omlXCI6XCImZ2U7XCIsXCLiioJcIjpcIiZzdWI7XCIsXCLiioNcIjpcIiZzdXA7XCIsXCLiioRcIjpcIiZuc3ViO1wiLFwi4oqGXCI6XCImc3ViZTtcIixcIuKKh1wiOlwiJnN1cGU7XCIsXCLiipVcIjpcIiZvcGx1cztcIixcIuKKl1wiOlwiJm90aW1lcztcIixcIuKKpVwiOlwiJnBlcnA7XCIsXCLii4VcIjpcIiZzZG90O1wiLFwi4oyIXCI6XCImbGNlaWw7XCIsXCLijIlcIjpcIiZyY2VpbDtcIixcIuKMilwiOlwiJmxmbG9vcjtcIixcIuKMi1wiOlwiJnJmbG9vcjtcIixcIuKMqVwiOlwiJmxhbmc7XCIsXCLijKpcIjpcIiZyYW5nO1wiLFwi4peKXCI6XCImbG96O1wiLFwi4pmgXCI6XCImc3BhZGVzO1wiLFwi4pmjXCI6XCImY2x1YnM7XCIsXCLimaVcIjpcIiZoZWFydHM7XCIsXCLimaZcIjpcIiZkaWFtcztcIn19LGh0bWw1OntlbnRpdGllczp7XCImQUVsaWdcIjpcIsOGXCIsXCImQUVsaWc7XCI6XCLDhlwiLFwiJkFNUFwiOlwiJlwiLFwiJkFNUDtcIjpcIiZcIixcIiZBYWN1dGVcIjpcIsOBXCIsXCImQWFjdXRlO1wiOlwiw4FcIixcIiZBYnJldmU7XCI6XCLEglwiLFwiJkFjaXJjXCI6XCLDglwiLFwiJkFjaXJjO1wiOlwiw4JcIixcIiZBY3k7XCI6XCLQkFwiLFwiJkFmcjtcIjpcIvCdlIRcIixcIiZBZ3JhdmVcIjpcIsOAXCIsXCImQWdyYXZlO1wiOlwiw4BcIixcIiZBbHBoYTtcIjpcIs6RXCIsXCImQW1hY3I7XCI6XCLEgFwiLFwiJkFuZDtcIjpcIuKpk1wiLFwiJkFvZ29uO1wiOlwixIRcIixcIiZBb3BmO1wiOlwi8J2UuFwiLFwiJkFwcGx5RnVuY3Rpb247XCI6XCLigaFcIixcIiZBcmluZ1wiOlwiw4VcIixcIiZBcmluZztcIjpcIsOFXCIsXCImQXNjcjtcIjpcIvCdkpxcIixcIiZBc3NpZ247XCI6XCLiiZRcIixcIiZBdGlsZGVcIjpcIsODXCIsXCImQXRpbGRlO1wiOlwiw4NcIixcIiZBdW1sXCI6XCLDhFwiLFwiJkF1bWw7XCI6XCLDhFwiLFwiJkJhY2tzbGFzaDtcIjpcIuKIllwiLFwiJkJhcnY7XCI6XCLiq6dcIixcIiZCYXJ3ZWQ7XCI6XCLijIZcIixcIiZCY3k7XCI6XCLQkVwiLFwiJkJlY2F1c2U7XCI6XCLiiLVcIixcIiZCZXJub3VsbGlzO1wiOlwi4oSsXCIsXCImQmV0YTtcIjpcIs6SXCIsXCImQmZyO1wiOlwi8J2UhVwiLFwiJkJvcGY7XCI6XCLwnZS5XCIsXCImQnJldmU7XCI6XCLLmFwiLFwiJkJzY3I7XCI6XCLihKxcIixcIiZCdW1wZXE7XCI6XCLiiY5cIixcIiZDSGN5O1wiOlwi0KdcIixcIiZDT1BZXCI6XCLCqVwiLFwiJkNPUFk7XCI6XCLCqVwiLFwiJkNhY3V0ZTtcIjpcIsSGXCIsXCImQ2FwO1wiOlwi4ouSXCIsXCImQ2FwaXRhbERpZmZlcmVudGlhbEQ7XCI6XCLihYVcIixcIiZDYXlsZXlzO1wiOlwi4oStXCIsXCImQ2Nhcm9uO1wiOlwixIxcIixcIiZDY2VkaWxcIjpcIsOHXCIsXCImQ2NlZGlsO1wiOlwiw4dcIixcIiZDY2lyYztcIjpcIsSIXCIsXCImQ2NvbmludDtcIjpcIuKIsFwiLFwiJkNkb3Q7XCI6XCLEilwiLFwiJkNlZGlsbGE7XCI6XCLCuFwiLFwiJkNlbnRlckRvdDtcIjpcIsK3XCIsXCImQ2ZyO1wiOlwi4oStXCIsXCImQ2hpO1wiOlwizqdcIixcIiZDaXJjbGVEb3Q7XCI6XCLiiplcIixcIiZDaXJjbGVNaW51cztcIjpcIuKKllwiLFwiJkNpcmNsZVBsdXM7XCI6XCLiipVcIixcIiZDaXJjbGVUaW1lcztcIjpcIuKKl1wiLFwiJkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDtcIjpcIuKIslwiLFwiJkNsb3NlQ3VybHlEb3VibGVRdW90ZTtcIjpcIuKAnVwiLFwiJkNsb3NlQ3VybHlRdW90ZTtcIjpcIuKAmVwiLFwiJkNvbG9uO1wiOlwi4oi3XCIsXCImQ29sb25lO1wiOlwi4qm0XCIsXCImQ29uZ3J1ZW50O1wiOlwi4omhXCIsXCImQ29uaW50O1wiOlwi4oivXCIsXCImQ29udG91ckludGVncmFsO1wiOlwi4oiuXCIsXCImQ29wZjtcIjpcIuKEglwiLFwiJkNvcHJvZHVjdDtcIjpcIuKIkFwiLFwiJkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCI6XCLiiLNcIixcIiZDcm9zcztcIjpcIuKor1wiLFwiJkNzY3I7XCI6XCLwnZKeXCIsXCImQ3VwO1wiOlwi4ouTXCIsXCImQ3VwQ2FwO1wiOlwi4omNXCIsXCImREQ7XCI6XCLihYVcIixcIiZERG90cmFoZDtcIjpcIuKkkVwiLFwiJkRKY3k7XCI6XCLQglwiLFwiJkRTY3k7XCI6XCLQhVwiLFwiJkRaY3k7XCI6XCLQj1wiLFwiJkRhZ2dlcjtcIjpcIuKAoVwiLFwiJkRhcnI7XCI6XCLihqFcIixcIiZEYXNodjtcIjpcIuKrpFwiLFwiJkRjYXJvbjtcIjpcIsSOXCIsXCImRGN5O1wiOlwi0JRcIixcIiZEZWw7XCI6XCLiiIdcIixcIiZEZWx0YTtcIjpcIs6UXCIsXCImRGZyO1wiOlwi8J2Uh1wiLFwiJkRpYWNyaXRpY2FsQWN1dGU7XCI6XCLCtFwiLFwiJkRpYWNyaXRpY2FsRG90O1wiOlwiy5lcIixcIiZEaWFjcml0aWNhbERvdWJsZUFjdXRlO1wiOlwiy51cIixcIiZEaWFjcml0aWNhbEdyYXZlO1wiOlwiYFwiLFwiJkRpYWNyaXRpY2FsVGlsZGU7XCI6XCLLnFwiLFwiJkRpYW1vbmQ7XCI6XCLii4RcIixcIiZEaWZmZXJlbnRpYWxEO1wiOlwi4oWGXCIsXCImRG9wZjtcIjpcIvCdlLtcIixcIiZEb3Q7XCI6XCLCqFwiLFwiJkRvdERvdDtcIjpcIuKDnFwiLFwiJkRvdEVxdWFsO1wiOlwi4omQXCIsXCImRG91YmxlQ29udG91ckludGVncmFsO1wiOlwi4oivXCIsXCImRG91YmxlRG90O1wiOlwiwqhcIixcIiZEb3VibGVEb3duQXJyb3c7XCI6XCLih5NcIixcIiZEb3VibGVMZWZ0QXJyb3c7XCI6XCLih5BcIixcIiZEb3VibGVMZWZ0UmlnaHRBcnJvdztcIjpcIuKHlFwiLFwiJkRvdWJsZUxlZnRUZWU7XCI6XCLiq6RcIixcIiZEb3VibGVMb25nTGVmdEFycm93O1wiOlwi4p+4XCIsXCImRG91YmxlTG9uZ0xlZnRSaWdodEFycm93O1wiOlwi4p+6XCIsXCImRG91YmxlTG9uZ1JpZ2h0QXJyb3c7XCI6XCLin7lcIixcIiZEb3VibGVSaWdodEFycm93O1wiOlwi4oeSXCIsXCImRG91YmxlUmlnaHRUZWU7XCI6XCLiiqhcIixcIiZEb3VibGVVcEFycm93O1wiOlwi4oeRXCIsXCImRG91YmxlVXBEb3duQXJyb3c7XCI6XCLih5VcIixcIiZEb3VibGVWZXJ0aWNhbEJhcjtcIjpcIuKIpVwiLFwiJkRvd25BcnJvdztcIjpcIuKGk1wiLFwiJkRvd25BcnJvd0JhcjtcIjpcIuKkk1wiLFwiJkRvd25BcnJvd1VwQXJyb3c7XCI6XCLih7VcIixcIiZEb3duQnJldmU7XCI6XCLMkVwiLFwiJkRvd25MZWZ0UmlnaHRWZWN0b3I7XCI6XCLipZBcIixcIiZEb3duTGVmdFRlZVZlY3RvcjtcIjpcIuKlnlwiLFwiJkRvd25MZWZ0VmVjdG9yO1wiOlwi4oa9XCIsXCImRG93bkxlZnRWZWN0b3JCYXI7XCI6XCLipZZcIixcIiZEb3duUmlnaHRUZWVWZWN0b3I7XCI6XCLipZ9cIixcIiZEb3duUmlnaHRWZWN0b3I7XCI6XCLih4FcIixcIiZEb3duUmlnaHRWZWN0b3JCYXI7XCI6XCLipZdcIixcIiZEb3duVGVlO1wiOlwi4oqkXCIsXCImRG93blRlZUFycm93O1wiOlwi4oanXCIsXCImRG93bmFycm93O1wiOlwi4oeTXCIsXCImRHNjcjtcIjpcIvCdkp9cIixcIiZEc3Ryb2s7XCI6XCLEkFwiLFwiJkVORztcIjpcIsWKXCIsXCImRVRIXCI6XCLDkFwiLFwiJkVUSDtcIjpcIsOQXCIsXCImRWFjdXRlXCI6XCLDiVwiLFwiJkVhY3V0ZTtcIjpcIsOJXCIsXCImRWNhcm9uO1wiOlwixJpcIixcIiZFY2lyY1wiOlwiw4pcIixcIiZFY2lyYztcIjpcIsOKXCIsXCImRWN5O1wiOlwi0K1cIixcIiZFZG90O1wiOlwixJZcIixcIiZFZnI7XCI6XCLwnZSIXCIsXCImRWdyYXZlXCI6XCLDiFwiLFwiJkVncmF2ZTtcIjpcIsOIXCIsXCImRWxlbWVudDtcIjpcIuKIiFwiLFwiJkVtYWNyO1wiOlwixJJcIixcIiZFbXB0eVNtYWxsU3F1YXJlO1wiOlwi4pe7XCIsXCImRW1wdHlWZXJ5U21hbGxTcXVhcmU7XCI6XCLilqtcIixcIiZFb2dvbjtcIjpcIsSYXCIsXCImRW9wZjtcIjpcIvCdlLxcIixcIiZFcHNpbG9uO1wiOlwizpVcIixcIiZFcXVhbDtcIjpcIuKptVwiLFwiJkVxdWFsVGlsZGU7XCI6XCLiiYJcIixcIiZFcXVpbGlicml1bTtcIjpcIuKHjFwiLFwiJkVzY3I7XCI6XCLihLBcIixcIiZFc2ltO1wiOlwi4qmzXCIsXCImRXRhO1wiOlwizpdcIixcIiZFdW1sXCI6XCLDi1wiLFwiJkV1bWw7XCI6XCLDi1wiLFwiJkV4aXN0cztcIjpcIuKIg1wiLFwiJkV4cG9uZW50aWFsRTtcIjpcIuKFh1wiLFwiJkZjeTtcIjpcItCkXCIsXCImRmZyO1wiOlwi8J2UiVwiLFwiJkZpbGxlZFNtYWxsU3F1YXJlO1wiOlwi4pe8XCIsXCImRmlsbGVkVmVyeVNtYWxsU3F1YXJlO1wiOlwi4paqXCIsXCImRm9wZjtcIjpcIvCdlL1cIixcIiZGb3JBbGw7XCI6XCLiiIBcIixcIiZGb3VyaWVydHJmO1wiOlwi4oSxXCIsXCImRnNjcjtcIjpcIuKEsVwiLFwiJkdKY3k7XCI6XCLQg1wiLFwiJkdUXCI6XCI+XCIsXCImR1Q7XCI6XCI+XCIsXCImR2FtbWE7XCI6XCLOk1wiLFwiJkdhbW1hZDtcIjpcIs+cXCIsXCImR2JyZXZlO1wiOlwixJ5cIixcIiZHY2VkaWw7XCI6XCLEolwiLFwiJkdjaXJjO1wiOlwixJxcIixcIiZHY3k7XCI6XCLQk1wiLFwiJkdkb3Q7XCI6XCLEoFwiLFwiJkdmcjtcIjpcIvCdlIpcIixcIiZHZztcIjpcIuKLmVwiLFwiJkdvcGY7XCI6XCLwnZS+XCIsXCImR3JlYXRlckVxdWFsO1wiOlwi4omlXCIsXCImR3JlYXRlckVxdWFsTGVzcztcIjpcIuKLm1wiLFwiJkdyZWF0ZXJGdWxsRXF1YWw7XCI6XCLiiadcIixcIiZHcmVhdGVyR3JlYXRlcjtcIjpcIuKqolwiLFwiJkdyZWF0ZXJMZXNzO1wiOlwi4om3XCIsXCImR3JlYXRlclNsYW50RXF1YWw7XCI6XCLiqb5cIixcIiZHcmVhdGVyVGlsZGU7XCI6XCLiibNcIixcIiZHc2NyO1wiOlwi8J2SolwiLFwiJkd0O1wiOlwi4omrXCIsXCImSEFSRGN5O1wiOlwi0KpcIixcIiZIYWNlaztcIjpcIsuHXCIsXCImSGF0O1wiOlwiXlwiLFwiJkhjaXJjO1wiOlwixKRcIixcIiZIZnI7XCI6XCLihIxcIixcIiZIaWxiZXJ0U3BhY2U7XCI6XCLihItcIixcIiZIb3BmO1wiOlwi4oSNXCIsXCImSG9yaXpvbnRhbExpbmU7XCI6XCLilIBcIixcIiZIc2NyO1wiOlwi4oSLXCIsXCImSHN0cm9rO1wiOlwixKZcIixcIiZIdW1wRG93bkh1bXA7XCI6XCLiiY5cIixcIiZIdW1wRXF1YWw7XCI6XCLiiY9cIixcIiZJRWN5O1wiOlwi0JVcIixcIiZJSmxpZztcIjpcIsSyXCIsXCImSU9jeTtcIjpcItCBXCIsXCImSWFjdXRlXCI6XCLDjVwiLFwiJklhY3V0ZTtcIjpcIsONXCIsXCImSWNpcmNcIjpcIsOOXCIsXCImSWNpcmM7XCI6XCLDjlwiLFwiJkljeTtcIjpcItCYXCIsXCImSWRvdDtcIjpcIsSwXCIsXCImSWZyO1wiOlwi4oSRXCIsXCImSWdyYXZlXCI6XCLDjFwiLFwiJklncmF2ZTtcIjpcIsOMXCIsXCImSW07XCI6XCLihJFcIixcIiZJbWFjcjtcIjpcIsSqXCIsXCImSW1hZ2luYXJ5STtcIjpcIuKFiFwiLFwiJkltcGxpZXM7XCI6XCLih5JcIixcIiZJbnQ7XCI6XCLiiKxcIixcIiZJbnRlZ3JhbDtcIjpcIuKIq1wiLFwiJkludGVyc2VjdGlvbjtcIjpcIuKLglwiLFwiJkludmlzaWJsZUNvbW1hO1wiOlwi4oGjXCIsXCImSW52aXNpYmxlVGltZXM7XCI6XCLigaJcIixcIiZJb2dvbjtcIjpcIsSuXCIsXCImSW9wZjtcIjpcIvCdlYBcIixcIiZJb3RhO1wiOlwizplcIixcIiZJc2NyO1wiOlwi4oSQXCIsXCImSXRpbGRlO1wiOlwixKhcIixcIiZJdWtjeTtcIjpcItCGXCIsXCImSXVtbFwiOlwiw49cIixcIiZJdW1sO1wiOlwiw49cIixcIiZKY2lyYztcIjpcIsS0XCIsXCImSmN5O1wiOlwi0JlcIixcIiZKZnI7XCI6XCLwnZSNXCIsXCImSm9wZjtcIjpcIvCdlYFcIixcIiZKc2NyO1wiOlwi8J2SpVwiLFwiJkpzZXJjeTtcIjpcItCIXCIsXCImSnVrY3k7XCI6XCLQhFwiLFwiJktIY3k7XCI6XCLQpVwiLFwiJktKY3k7XCI6XCLQjFwiLFwiJkthcHBhO1wiOlwizppcIixcIiZLY2VkaWw7XCI6XCLEtlwiLFwiJktjeTtcIjpcItCaXCIsXCImS2ZyO1wiOlwi8J2UjlwiLFwiJktvcGY7XCI6XCLwnZWCXCIsXCImS3NjcjtcIjpcIvCdkqZcIixcIiZMSmN5O1wiOlwi0IlcIixcIiZMVFwiOlwiPFwiLFwiJkxUO1wiOlwiPFwiLFwiJkxhY3V0ZTtcIjpcIsS5XCIsXCImTGFtYmRhO1wiOlwizptcIixcIiZMYW5nO1wiOlwi4p+qXCIsXCImTGFwbGFjZXRyZjtcIjpcIuKEklwiLFwiJkxhcnI7XCI6XCLihp5cIixcIiZMY2Fyb247XCI6XCLEvVwiLFwiJkxjZWRpbDtcIjpcIsS7XCIsXCImTGN5O1wiOlwi0JtcIixcIiZMZWZ0QW5nbGVCcmFja2V0O1wiOlwi4p+oXCIsXCImTGVmdEFycm93O1wiOlwi4oaQXCIsXCImTGVmdEFycm93QmFyO1wiOlwi4oekXCIsXCImTGVmdEFycm93UmlnaHRBcnJvdztcIjpcIuKHhlwiLFwiJkxlZnRDZWlsaW5nO1wiOlwi4oyIXCIsXCImTGVmdERvdWJsZUJyYWNrZXQ7XCI6XCLin6ZcIixcIiZMZWZ0RG93blRlZVZlY3RvcjtcIjpcIuKloVwiLFwiJkxlZnREb3duVmVjdG9yO1wiOlwi4oeDXCIsXCImTGVmdERvd25WZWN0b3JCYXI7XCI6XCLipZlcIixcIiZMZWZ0Rmxvb3I7XCI6XCLijIpcIixcIiZMZWZ0UmlnaHRBcnJvdztcIjpcIuKGlFwiLFwiJkxlZnRSaWdodFZlY3RvcjtcIjpcIuKljlwiLFwiJkxlZnRUZWU7XCI6XCLiiqNcIixcIiZMZWZ0VGVlQXJyb3c7XCI6XCLihqRcIixcIiZMZWZ0VGVlVmVjdG9yO1wiOlwi4qWaXCIsXCImTGVmdFRyaWFuZ2xlO1wiOlwi4oqyXCIsXCImTGVmdFRyaWFuZ2xlQmFyO1wiOlwi4qePXCIsXCImTGVmdFRyaWFuZ2xlRXF1YWw7XCI6XCLiirRcIixcIiZMZWZ0VXBEb3duVmVjdG9yO1wiOlwi4qWRXCIsXCImTGVmdFVwVGVlVmVjdG9yO1wiOlwi4qWgXCIsXCImTGVmdFVwVmVjdG9yO1wiOlwi4oa/XCIsXCImTGVmdFVwVmVjdG9yQmFyO1wiOlwi4qWYXCIsXCImTGVmdFZlY3RvcjtcIjpcIuKGvFwiLFwiJkxlZnRWZWN0b3JCYXI7XCI6XCLipZJcIixcIiZMZWZ0YXJyb3c7XCI6XCLih5BcIixcIiZMZWZ0cmlnaHRhcnJvdztcIjpcIuKHlFwiLFwiJkxlc3NFcXVhbEdyZWF0ZXI7XCI6XCLii5pcIixcIiZMZXNzRnVsbEVxdWFsO1wiOlwi4ommXCIsXCImTGVzc0dyZWF0ZXI7XCI6XCLiibZcIixcIiZMZXNzTGVzcztcIjpcIuKqoVwiLFwiJkxlc3NTbGFudEVxdWFsO1wiOlwi4qm9XCIsXCImTGVzc1RpbGRlO1wiOlwi4omyXCIsXCImTGZyO1wiOlwi8J2Uj1wiLFwiJkxsO1wiOlwi4ouYXCIsXCImTGxlZnRhcnJvdztcIjpcIuKHmlwiLFwiJkxtaWRvdDtcIjpcIsS/XCIsXCImTG9uZ0xlZnRBcnJvdztcIjpcIuKftVwiLFwiJkxvbmdMZWZ0UmlnaHRBcnJvdztcIjpcIuKft1wiLFwiJkxvbmdSaWdodEFycm93O1wiOlwi4p+2XCIsXCImTG9uZ2xlZnRhcnJvdztcIjpcIuKfuFwiLFwiJkxvbmdsZWZ0cmlnaHRhcnJvdztcIjpcIuKfulwiLFwiJkxvbmdyaWdodGFycm93O1wiOlwi4p+5XCIsXCImTG9wZjtcIjpcIvCdlYNcIixcIiZMb3dlckxlZnRBcnJvdztcIjpcIuKGmVwiLFwiJkxvd2VyUmlnaHRBcnJvdztcIjpcIuKGmFwiLFwiJkxzY3I7XCI6XCLihJJcIixcIiZMc2g7XCI6XCLihrBcIixcIiZMc3Ryb2s7XCI6XCLFgVwiLFwiJkx0O1wiOlwi4omqXCIsXCImTWFwO1wiOlwi4qSFXCIsXCImTWN5O1wiOlwi0JxcIixcIiZNZWRpdW1TcGFjZTtcIjpcIuKBn1wiLFwiJk1lbGxpbnRyZjtcIjpcIuKEs1wiLFwiJk1mcjtcIjpcIvCdlJBcIixcIiZNaW51c1BsdXM7XCI6XCLiiJNcIixcIiZNb3BmO1wiOlwi8J2VhFwiLFwiJk1zY3I7XCI6XCLihLNcIixcIiZNdTtcIjpcIs6cXCIsXCImTkpjeTtcIjpcItCKXCIsXCImTmFjdXRlO1wiOlwixYNcIixcIiZOY2Fyb247XCI6XCLFh1wiLFwiJk5jZWRpbDtcIjpcIsWFXCIsXCImTmN5O1wiOlwi0J1cIixcIiZOZWdhdGl2ZU1lZGl1bVNwYWNlO1wiOlwi4oCLXCIsXCImTmVnYXRpdmVUaGlja1NwYWNlO1wiOlwi4oCLXCIsXCImTmVnYXRpdmVUaGluU3BhY2U7XCI6XCLigItcIixcIiZOZWdhdGl2ZVZlcnlUaGluU3BhY2U7XCI6XCLigItcIixcIiZOZXN0ZWRHcmVhdGVyR3JlYXRlcjtcIjpcIuKJq1wiLFwiJk5lc3RlZExlc3NMZXNzO1wiOlwi4omqXCIsXCImTmV3TGluZTtcIjpcIlxcblwiLFwiJk5mcjtcIjpcIvCdlJFcIixcIiZOb0JyZWFrO1wiOlwi4oGgXCIsXCImTm9uQnJlYWtpbmdTcGFjZTtcIjpcIsKgXCIsXCImTm9wZjtcIjpcIuKElVwiLFwiJk5vdDtcIjpcIuKrrFwiLFwiJk5vdENvbmdydWVudDtcIjpcIuKJolwiLFwiJk5vdEN1cENhcDtcIjpcIuKJrVwiLFwiJk5vdERvdWJsZVZlcnRpY2FsQmFyO1wiOlwi4oimXCIsXCImTm90RWxlbWVudDtcIjpcIuKIiVwiLFwiJk5vdEVxdWFsO1wiOlwi4omgXCIsXCImTm90RXF1YWxUaWxkZTtcIjpcIuKJgsy4XCIsXCImTm90RXhpc3RzO1wiOlwi4oiEXCIsXCImTm90R3JlYXRlcjtcIjpcIuKJr1wiLFwiJk5vdEdyZWF0ZXJFcXVhbDtcIjpcIuKJsVwiLFwiJk5vdEdyZWF0ZXJGdWxsRXF1YWw7XCI6XCLiiafMuFwiLFwiJk5vdEdyZWF0ZXJHcmVhdGVyO1wiOlwi4omrzLhcIixcIiZOb3RHcmVhdGVyTGVzcztcIjpcIuKJuVwiLFwiJk5vdEdyZWF0ZXJTbGFudEVxdWFsO1wiOlwi4qm+zLhcIixcIiZOb3RHcmVhdGVyVGlsZGU7XCI6XCLiibVcIixcIiZOb3RIdW1wRG93bkh1bXA7XCI6XCLiiY7MuFwiLFwiJk5vdEh1bXBFcXVhbDtcIjpcIuKJj8y4XCIsXCImTm90TGVmdFRyaWFuZ2xlO1wiOlwi4ouqXCIsXCImTm90TGVmdFRyaWFuZ2xlQmFyO1wiOlwi4qePzLhcIixcIiZOb3RMZWZ0VHJpYW5nbGVFcXVhbDtcIjpcIuKLrFwiLFwiJk5vdExlc3M7XCI6XCLiia5cIixcIiZOb3RMZXNzRXF1YWw7XCI6XCLiibBcIixcIiZOb3RMZXNzR3JlYXRlcjtcIjpcIuKJuFwiLFwiJk5vdExlc3NMZXNzO1wiOlwi4omqzLhcIixcIiZOb3RMZXNzU2xhbnRFcXVhbDtcIjpcIuKpvcy4XCIsXCImTm90TGVzc1RpbGRlO1wiOlwi4om0XCIsXCImTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI7XCI6XCLiqqLMuFwiLFwiJk5vdE5lc3RlZExlc3NMZXNzO1wiOlwi4qqhzLhcIixcIiZOb3RQcmVjZWRlcztcIjpcIuKKgFwiLFwiJk5vdFByZWNlZGVzRXF1YWw7XCI6XCLiqq/MuFwiLFwiJk5vdFByZWNlZGVzU2xhbnRFcXVhbDtcIjpcIuKLoFwiLFwiJk5vdFJldmVyc2VFbGVtZW50O1wiOlwi4oiMXCIsXCImTm90UmlnaHRUcmlhbmdsZTtcIjpcIuKLq1wiLFwiJk5vdFJpZ2h0VHJpYW5nbGVCYXI7XCI6XCLip5DMuFwiLFwiJk5vdFJpZ2h0VHJpYW5nbGVFcXVhbDtcIjpcIuKLrVwiLFwiJk5vdFNxdWFyZVN1YnNldDtcIjpcIuKKj8y4XCIsXCImTm90U3F1YXJlU3Vic2V0RXF1YWw7XCI6XCLii6JcIixcIiZOb3RTcXVhcmVTdXBlcnNldDtcIjpcIuKKkMy4XCIsXCImTm90U3F1YXJlU3VwZXJzZXRFcXVhbDtcIjpcIuKLo1wiLFwiJk5vdFN1YnNldDtcIjpcIuKKguKDklwiLFwiJk5vdFN1YnNldEVxdWFsO1wiOlwi4oqIXCIsXCImTm90U3VjY2VlZHM7XCI6XCLiioFcIixcIiZOb3RTdWNjZWVkc0VxdWFsO1wiOlwi4qqwzLhcIixcIiZOb3RTdWNjZWVkc1NsYW50RXF1YWw7XCI6XCLii6FcIixcIiZOb3RTdWNjZWVkc1RpbGRlO1wiOlwi4om/zLhcIixcIiZOb3RTdXBlcnNldDtcIjpcIuKKg+KDklwiLFwiJk5vdFN1cGVyc2V0RXF1YWw7XCI6XCLiiolcIixcIiZOb3RUaWxkZTtcIjpcIuKJgVwiLFwiJk5vdFRpbGRlRXF1YWw7XCI6XCLiiYRcIixcIiZOb3RUaWxkZUZ1bGxFcXVhbDtcIjpcIuKJh1wiLFwiJk5vdFRpbGRlVGlsZGU7XCI6XCLiiYlcIixcIiZOb3RWZXJ0aWNhbEJhcjtcIjpcIuKIpFwiLFwiJk5zY3I7XCI6XCLwnZKpXCIsXCImTnRpbGRlXCI6XCLDkVwiLFwiJk50aWxkZTtcIjpcIsORXCIsXCImTnU7XCI6XCLOnVwiLFwiJk9FbGlnO1wiOlwixZJcIixcIiZPYWN1dGVcIjpcIsOTXCIsXCImT2FjdXRlO1wiOlwiw5NcIixcIiZPY2lyY1wiOlwiw5RcIixcIiZPY2lyYztcIjpcIsOUXCIsXCImT2N5O1wiOlwi0J5cIixcIiZPZGJsYWM7XCI6XCLFkFwiLFwiJk9mcjtcIjpcIvCdlJJcIixcIiZPZ3JhdmVcIjpcIsOSXCIsXCImT2dyYXZlO1wiOlwiw5JcIixcIiZPbWFjcjtcIjpcIsWMXCIsXCImT21lZ2E7XCI6XCLOqVwiLFwiJk9taWNyb247XCI6XCLOn1wiLFwiJk9vcGY7XCI6XCLwnZWGXCIsXCImT3BlbkN1cmx5RG91YmxlUXVvdGU7XCI6XCLigJxcIixcIiZPcGVuQ3VybHlRdW90ZTtcIjpcIuKAmFwiLFwiJk9yO1wiOlwi4qmUXCIsXCImT3NjcjtcIjpcIvCdkqpcIixcIiZPc2xhc2hcIjpcIsOYXCIsXCImT3NsYXNoO1wiOlwiw5hcIixcIiZPdGlsZGVcIjpcIsOVXCIsXCImT3RpbGRlO1wiOlwiw5VcIixcIiZPdGltZXM7XCI6XCLiqLdcIixcIiZPdW1sXCI6XCLDllwiLFwiJk91bWw7XCI6XCLDllwiLFwiJk92ZXJCYXI7XCI6XCLigL5cIixcIiZPdmVyQnJhY2U7XCI6XCLij55cIixcIiZPdmVyQnJhY2tldDtcIjpcIuKOtFwiLFwiJk92ZXJQYXJlbnRoZXNpcztcIjpcIuKPnFwiLFwiJlBhcnRpYWxEO1wiOlwi4oiCXCIsXCImUGN5O1wiOlwi0J9cIixcIiZQZnI7XCI6XCLwnZSTXCIsXCImUGhpO1wiOlwizqZcIixcIiZQaTtcIjpcIs6gXCIsXCImUGx1c01pbnVzO1wiOlwiwrFcIixcIiZQb2luY2FyZXBsYW5lO1wiOlwi4oSMXCIsXCImUG9wZjtcIjpcIuKEmVwiLFwiJlByO1wiOlwi4qq7XCIsXCImUHJlY2VkZXM7XCI6XCLiibpcIixcIiZQcmVjZWRlc0VxdWFsO1wiOlwi4qqvXCIsXCImUHJlY2VkZXNTbGFudEVxdWFsO1wiOlwi4om8XCIsXCImUHJlY2VkZXNUaWxkZTtcIjpcIuKJvlwiLFwiJlByaW1lO1wiOlwi4oCzXCIsXCImUHJvZHVjdDtcIjpcIuKIj1wiLFwiJlByb3BvcnRpb247XCI6XCLiiLdcIixcIiZQcm9wb3J0aW9uYWw7XCI6XCLiiJ1cIixcIiZQc2NyO1wiOlwi8J2Sq1wiLFwiJlBzaTtcIjpcIs6oXCIsXCImUVVPVFwiOidcIicsXCImUVVPVDtcIjonXCInLFwiJlFmcjtcIjpcIvCdlJRcIixcIiZRb3BmO1wiOlwi4oSaXCIsXCImUXNjcjtcIjpcIvCdkqxcIixcIiZSQmFycjtcIjpcIuKkkFwiLFwiJlJFR1wiOlwiwq5cIixcIiZSRUc7XCI6XCLCrlwiLFwiJlJhY3V0ZTtcIjpcIsWUXCIsXCImUmFuZztcIjpcIuKfq1wiLFwiJlJhcnI7XCI6XCLihqBcIixcIiZSYXJydGw7XCI6XCLipJZcIixcIiZSY2Fyb247XCI6XCLFmFwiLFwiJlJjZWRpbDtcIjpcIsWWXCIsXCImUmN5O1wiOlwi0KBcIixcIiZSZTtcIjpcIuKEnFwiLFwiJlJldmVyc2VFbGVtZW50O1wiOlwi4oiLXCIsXCImUmV2ZXJzZUVxdWlsaWJyaXVtO1wiOlwi4oeLXCIsXCImUmV2ZXJzZVVwRXF1aWxpYnJpdW07XCI6XCLipa9cIixcIiZSZnI7XCI6XCLihJxcIixcIiZSaG87XCI6XCLOoVwiLFwiJlJpZ2h0QW5nbGVCcmFja2V0O1wiOlwi4p+pXCIsXCImUmlnaHRBcnJvdztcIjpcIuKGklwiLFwiJlJpZ2h0QXJyb3dCYXI7XCI6XCLih6VcIixcIiZSaWdodEFycm93TGVmdEFycm93O1wiOlwi4oeEXCIsXCImUmlnaHRDZWlsaW5nO1wiOlwi4oyJXCIsXCImUmlnaHREb3VibGVCcmFja2V0O1wiOlwi4p+nXCIsXCImUmlnaHREb3duVGVlVmVjdG9yO1wiOlwi4qWdXCIsXCImUmlnaHREb3duVmVjdG9yO1wiOlwi4oeCXCIsXCImUmlnaHREb3duVmVjdG9yQmFyO1wiOlwi4qWVXCIsXCImUmlnaHRGbG9vcjtcIjpcIuKMi1wiLFwiJlJpZ2h0VGVlO1wiOlwi4oqiXCIsXCImUmlnaHRUZWVBcnJvdztcIjpcIuKGplwiLFwiJlJpZ2h0VGVlVmVjdG9yO1wiOlwi4qWbXCIsXCImUmlnaHRUcmlhbmdsZTtcIjpcIuKKs1wiLFwiJlJpZ2h0VHJpYW5nbGVCYXI7XCI6XCLip5BcIixcIiZSaWdodFRyaWFuZ2xlRXF1YWw7XCI6XCLiirVcIixcIiZSaWdodFVwRG93blZlY3RvcjtcIjpcIuKlj1wiLFwiJlJpZ2h0VXBUZWVWZWN0b3I7XCI6XCLipZxcIixcIiZSaWdodFVwVmVjdG9yO1wiOlwi4oa+XCIsXCImUmlnaHRVcFZlY3RvckJhcjtcIjpcIuKllFwiLFwiJlJpZ2h0VmVjdG9yO1wiOlwi4oeAXCIsXCImUmlnaHRWZWN0b3JCYXI7XCI6XCLipZNcIixcIiZSaWdodGFycm93O1wiOlwi4oeSXCIsXCImUm9wZjtcIjpcIuKEnVwiLFwiJlJvdW5kSW1wbGllcztcIjpcIuKlsFwiLFwiJlJyaWdodGFycm93O1wiOlwi4oebXCIsXCImUnNjcjtcIjpcIuKEm1wiLFwiJlJzaDtcIjpcIuKGsVwiLFwiJlJ1bGVEZWxheWVkO1wiOlwi4qe0XCIsXCImU0hDSGN5O1wiOlwi0KlcIixcIiZTSGN5O1wiOlwi0KhcIixcIiZTT0ZUY3k7XCI6XCLQrFwiLFwiJlNhY3V0ZTtcIjpcIsWaXCIsXCImU2M7XCI6XCLiqrxcIixcIiZTY2Fyb247XCI6XCLFoFwiLFwiJlNjZWRpbDtcIjpcIsWeXCIsXCImU2NpcmM7XCI6XCLFnFwiLFwiJlNjeTtcIjpcItChXCIsXCImU2ZyO1wiOlwi8J2UllwiLFwiJlNob3J0RG93bkFycm93O1wiOlwi4oaTXCIsXCImU2hvcnRMZWZ0QXJyb3c7XCI6XCLihpBcIixcIiZTaG9ydFJpZ2h0QXJyb3c7XCI6XCLihpJcIixcIiZTaG9ydFVwQXJyb3c7XCI6XCLihpFcIixcIiZTaWdtYTtcIjpcIs6jXCIsXCImU21hbGxDaXJjbGU7XCI6XCLiiJhcIixcIiZTb3BmO1wiOlwi8J2VilwiLFwiJlNxcnQ7XCI6XCLiiJpcIixcIiZTcXVhcmU7XCI6XCLilqFcIixcIiZTcXVhcmVJbnRlcnNlY3Rpb247XCI6XCLiipNcIixcIiZTcXVhcmVTdWJzZXQ7XCI6XCLiio9cIixcIiZTcXVhcmVTdWJzZXRFcXVhbDtcIjpcIuKKkVwiLFwiJlNxdWFyZVN1cGVyc2V0O1wiOlwi4oqQXCIsXCImU3F1YXJlU3VwZXJzZXRFcXVhbDtcIjpcIuKKklwiLFwiJlNxdWFyZVVuaW9uO1wiOlwi4oqUXCIsXCImU3NjcjtcIjpcIvCdkq5cIixcIiZTdGFyO1wiOlwi4ouGXCIsXCImU3ViO1wiOlwi4ouQXCIsXCImU3Vic2V0O1wiOlwi4ouQXCIsXCImU3Vic2V0RXF1YWw7XCI6XCLiioZcIixcIiZTdWNjZWVkcztcIjpcIuKJu1wiLFwiJlN1Y2NlZWRzRXF1YWw7XCI6XCLiqrBcIixcIiZTdWNjZWVkc1NsYW50RXF1YWw7XCI6XCLiib1cIixcIiZTdWNjZWVkc1RpbGRlO1wiOlwi4om/XCIsXCImU3VjaFRoYXQ7XCI6XCLiiItcIixcIiZTdW07XCI6XCLiiJFcIixcIiZTdXA7XCI6XCLii5FcIixcIiZTdXBlcnNldDtcIjpcIuKKg1wiLFwiJlN1cGVyc2V0RXF1YWw7XCI6XCLiiodcIixcIiZTdXBzZXQ7XCI6XCLii5FcIixcIiZUSE9STlwiOlwiw55cIixcIiZUSE9STjtcIjpcIsOeXCIsXCImVFJBREU7XCI6XCLihKJcIixcIiZUU0hjeTtcIjpcItCLXCIsXCImVFNjeTtcIjpcItCmXCIsXCImVGFiO1wiOlwiXFx0XCIsXCImVGF1O1wiOlwizqRcIixcIiZUY2Fyb247XCI6XCLFpFwiLFwiJlRjZWRpbDtcIjpcIsWiXCIsXCImVGN5O1wiOlwi0KJcIixcIiZUZnI7XCI6XCLwnZSXXCIsXCImVGhlcmVmb3JlO1wiOlwi4oi0XCIsXCImVGhldGE7XCI6XCLOmFwiLFwiJlRoaWNrU3BhY2U7XCI6XCLigZ/igIpcIixcIiZUaGluU3BhY2U7XCI6XCLigIlcIixcIiZUaWxkZTtcIjpcIuKIvFwiLFwiJlRpbGRlRXF1YWw7XCI6XCLiiYNcIixcIiZUaWxkZUZ1bGxFcXVhbDtcIjpcIuKJhVwiLFwiJlRpbGRlVGlsZGU7XCI6XCLiiYhcIixcIiZUb3BmO1wiOlwi8J2Vi1wiLFwiJlRyaXBsZURvdDtcIjpcIuKDm1wiLFwiJlRzY3I7XCI6XCLwnZKvXCIsXCImVHN0cm9rO1wiOlwixaZcIixcIiZVYWN1dGVcIjpcIsOaXCIsXCImVWFjdXRlO1wiOlwiw5pcIixcIiZVYXJyO1wiOlwi4oafXCIsXCImVWFycm9jaXI7XCI6XCLipYlcIixcIiZVYnJjeTtcIjpcItCOXCIsXCImVWJyZXZlO1wiOlwixaxcIixcIiZVY2lyY1wiOlwiw5tcIixcIiZVY2lyYztcIjpcIsObXCIsXCImVWN5O1wiOlwi0KNcIixcIiZVZGJsYWM7XCI6XCLFsFwiLFwiJlVmcjtcIjpcIvCdlJhcIixcIiZVZ3JhdmVcIjpcIsOZXCIsXCImVWdyYXZlO1wiOlwiw5lcIixcIiZVbWFjcjtcIjpcIsWqXCIsXCImVW5kZXJCYXI7XCI6XCJfXCIsXCImVW5kZXJCcmFjZTtcIjpcIuKPn1wiLFwiJlVuZGVyQnJhY2tldDtcIjpcIuKOtVwiLFwiJlVuZGVyUGFyZW50aGVzaXM7XCI6XCLij51cIixcIiZVbmlvbjtcIjpcIuKLg1wiLFwiJlVuaW9uUGx1cztcIjpcIuKKjlwiLFwiJlVvZ29uO1wiOlwixbJcIixcIiZVb3BmO1wiOlwi8J2VjFwiLFwiJlVwQXJyb3c7XCI6XCLihpFcIixcIiZVcEFycm93QmFyO1wiOlwi4qSSXCIsXCImVXBBcnJvd0Rvd25BcnJvdztcIjpcIuKHhVwiLFwiJlVwRG93bkFycm93O1wiOlwi4oaVXCIsXCImVXBFcXVpbGlicml1bTtcIjpcIuKlrlwiLFwiJlVwVGVlO1wiOlwi4oqlXCIsXCImVXBUZWVBcnJvdztcIjpcIuKGpVwiLFwiJlVwYXJyb3c7XCI6XCLih5FcIixcIiZVcGRvd25hcnJvdztcIjpcIuKHlVwiLFwiJlVwcGVyTGVmdEFycm93O1wiOlwi4oaWXCIsXCImVXBwZXJSaWdodEFycm93O1wiOlwi4oaXXCIsXCImVXBzaTtcIjpcIs+SXCIsXCImVXBzaWxvbjtcIjpcIs6lXCIsXCImVXJpbmc7XCI6XCLFrlwiLFwiJlVzY3I7XCI6XCLwnZKwXCIsXCImVXRpbGRlO1wiOlwixahcIixcIiZVdW1sXCI6XCLDnFwiLFwiJlV1bWw7XCI6XCLDnFwiLFwiJlZEYXNoO1wiOlwi4oqrXCIsXCImVmJhcjtcIjpcIuKrq1wiLFwiJlZjeTtcIjpcItCSXCIsXCImVmRhc2g7XCI6XCLiiqlcIixcIiZWZGFzaGw7XCI6XCLiq6ZcIixcIiZWZWU7XCI6XCLii4FcIixcIiZWZXJiYXI7XCI6XCLigJZcIixcIiZWZXJ0O1wiOlwi4oCWXCIsXCImVmVydGljYWxCYXI7XCI6XCLiiKNcIixcIiZWZXJ0aWNhbExpbmU7XCI6XCJ8XCIsXCImVmVydGljYWxTZXBhcmF0b3I7XCI6XCLinZhcIixcIiZWZXJ0aWNhbFRpbGRlO1wiOlwi4omAXCIsXCImVmVyeVRoaW5TcGFjZTtcIjpcIuKAilwiLFwiJlZmcjtcIjpcIvCdlJlcIixcIiZWb3BmO1wiOlwi8J2VjVwiLFwiJlZzY3I7XCI6XCLwnZKxXCIsXCImVnZkYXNoO1wiOlwi4oqqXCIsXCImV2NpcmM7XCI6XCLFtFwiLFwiJldlZGdlO1wiOlwi4ouAXCIsXCImV2ZyO1wiOlwi8J2UmlwiLFwiJldvcGY7XCI6XCLwnZWOXCIsXCImV3NjcjtcIjpcIvCdkrJcIixcIiZYZnI7XCI6XCLwnZSbXCIsXCImWGk7XCI6XCLOnlwiLFwiJlhvcGY7XCI6XCLwnZWPXCIsXCImWHNjcjtcIjpcIvCdkrNcIixcIiZZQWN5O1wiOlwi0K9cIixcIiZZSWN5O1wiOlwi0IdcIixcIiZZVWN5O1wiOlwi0K5cIixcIiZZYWN1dGVcIjpcIsOdXCIsXCImWWFjdXRlO1wiOlwiw51cIixcIiZZY2lyYztcIjpcIsW2XCIsXCImWWN5O1wiOlwi0KtcIixcIiZZZnI7XCI6XCLwnZScXCIsXCImWW9wZjtcIjpcIvCdlZBcIixcIiZZc2NyO1wiOlwi8J2StFwiLFwiJll1bWw7XCI6XCLFuFwiLFwiJlpIY3k7XCI6XCLQllwiLFwiJlphY3V0ZTtcIjpcIsW5XCIsXCImWmNhcm9uO1wiOlwixb1cIixcIiZaY3k7XCI6XCLQl1wiLFwiJlpkb3Q7XCI6XCLFu1wiLFwiJlplcm9XaWR0aFNwYWNlO1wiOlwi4oCLXCIsXCImWmV0YTtcIjpcIs6WXCIsXCImWmZyO1wiOlwi4oSoXCIsXCImWm9wZjtcIjpcIuKEpFwiLFwiJlpzY3I7XCI6XCLwnZK1XCIsXCImYWFjdXRlXCI6XCLDoVwiLFwiJmFhY3V0ZTtcIjpcIsOhXCIsXCImYWJyZXZlO1wiOlwixINcIixcIiZhYztcIjpcIuKIvlwiLFwiJmFjRTtcIjpcIuKIvsyzXCIsXCImYWNkO1wiOlwi4oi/XCIsXCImYWNpcmNcIjpcIsOiXCIsXCImYWNpcmM7XCI6XCLDolwiLFwiJmFjdXRlXCI6XCLCtFwiLFwiJmFjdXRlO1wiOlwiwrRcIixcIiZhY3k7XCI6XCLQsFwiLFwiJmFlbGlnXCI6XCLDplwiLFwiJmFlbGlnO1wiOlwiw6ZcIixcIiZhZjtcIjpcIuKBoVwiLFwiJmFmcjtcIjpcIvCdlJ5cIixcIiZhZ3JhdmVcIjpcIsOgXCIsXCImYWdyYXZlO1wiOlwiw6BcIixcIiZhbGVmc3ltO1wiOlwi4oS1XCIsXCImYWxlcGg7XCI6XCLihLVcIixcIiZhbHBoYTtcIjpcIs6xXCIsXCImYW1hY3I7XCI6XCLEgVwiLFwiJmFtYWxnO1wiOlwi4qi/XCIsXCImYW1wXCI6XCImXCIsXCImYW1wO1wiOlwiJlwiLFwiJmFuZDtcIjpcIuKIp1wiLFwiJmFuZGFuZDtcIjpcIuKplVwiLFwiJmFuZGQ7XCI6XCLiqZxcIixcIiZhbmRzbG9wZTtcIjpcIuKpmFwiLFwiJmFuZHY7XCI6XCLiqZpcIixcIiZhbmc7XCI6XCLiiKBcIixcIiZhbmdlO1wiOlwi4qakXCIsXCImYW5nbGU7XCI6XCLiiKBcIixcIiZhbmdtc2Q7XCI6XCLiiKFcIixcIiZhbmdtc2RhYTtcIjpcIuKmqFwiLFwiJmFuZ21zZGFiO1wiOlwi4qapXCIsXCImYW5nbXNkYWM7XCI6XCLipqpcIixcIiZhbmdtc2RhZDtcIjpcIuKmq1wiLFwiJmFuZ21zZGFlO1wiOlwi4qasXCIsXCImYW5nbXNkYWY7XCI6XCLipq1cIixcIiZhbmdtc2RhZztcIjpcIuKmrlwiLFwiJmFuZ21zZGFoO1wiOlwi4qavXCIsXCImYW5ncnQ7XCI6XCLiiJ9cIixcIiZhbmdydHZiO1wiOlwi4oq+XCIsXCImYW5ncnR2YmQ7XCI6XCLipp1cIixcIiZhbmdzcGg7XCI6XCLiiKJcIixcIiZhbmdzdDtcIjpcIsOFXCIsXCImYW5nemFycjtcIjpcIuKNvFwiLFwiJmFvZ29uO1wiOlwixIVcIixcIiZhb3BmO1wiOlwi8J2VklwiLFwiJmFwO1wiOlwi4omIXCIsXCImYXBFO1wiOlwi4qmwXCIsXCImYXBhY2lyO1wiOlwi4qmvXCIsXCImYXBlO1wiOlwi4omKXCIsXCImYXBpZDtcIjpcIuKJi1wiLFwiJmFwb3M7XCI6XCInXCIsXCImYXBwcm94O1wiOlwi4omIXCIsXCImYXBwcm94ZXE7XCI6XCLiiYpcIixcIiZhcmluZ1wiOlwiw6VcIixcIiZhcmluZztcIjpcIsOlXCIsXCImYXNjcjtcIjpcIvCdkrZcIixcIiZhc3Q7XCI6XCIqXCIsXCImYXN5bXA7XCI6XCLiiYhcIixcIiZhc3ltcGVxO1wiOlwi4omNXCIsXCImYXRpbGRlXCI6XCLDo1wiLFwiJmF0aWxkZTtcIjpcIsOjXCIsXCImYXVtbFwiOlwiw6RcIixcIiZhdW1sO1wiOlwiw6RcIixcIiZhd2NvbmludDtcIjpcIuKIs1wiLFwiJmF3aW50O1wiOlwi4qiRXCIsXCImYk5vdDtcIjpcIuKrrVwiLFwiJmJhY2tjb25nO1wiOlwi4omMXCIsXCImYmFja2Vwc2lsb247XCI6XCLPtlwiLFwiJmJhY2twcmltZTtcIjpcIuKAtVwiLFwiJmJhY2tzaW07XCI6XCLiiL1cIixcIiZiYWNrc2ltZXE7XCI6XCLii41cIixcIiZiYXJ2ZWU7XCI6XCLiir1cIixcIiZiYXJ3ZWQ7XCI6XCLijIVcIixcIiZiYXJ3ZWRnZTtcIjpcIuKMhVwiLFwiJmJicms7XCI6XCLijrVcIixcIiZiYnJrdGJyaztcIjpcIuKOtlwiLFwiJmJjb25nO1wiOlwi4omMXCIsXCImYmN5O1wiOlwi0LFcIixcIiZiZHF1bztcIjpcIuKAnlwiLFwiJmJlY2F1cztcIjpcIuKItVwiLFwiJmJlY2F1c2U7XCI6XCLiiLVcIixcIiZiZW1wdHl2O1wiOlwi4qawXCIsXCImYmVwc2k7XCI6XCLPtlwiLFwiJmJlcm5vdTtcIjpcIuKErFwiLFwiJmJldGE7XCI6XCLOslwiLFwiJmJldGg7XCI6XCLihLZcIixcIiZiZXR3ZWVuO1wiOlwi4omsXCIsXCImYmZyO1wiOlwi8J2Un1wiLFwiJmJpZ2NhcDtcIjpcIuKLglwiLFwiJmJpZ2NpcmM7XCI6XCLil69cIixcIiZiaWdjdXA7XCI6XCLii4NcIixcIiZiaWdvZG90O1wiOlwi4qiAXCIsXCImYmlnb3BsdXM7XCI6XCLiqIFcIixcIiZiaWdvdGltZXM7XCI6XCLiqIJcIixcIiZiaWdzcWN1cDtcIjpcIuKohlwiLFwiJmJpZ3N0YXI7XCI6XCLimIVcIixcIiZiaWd0cmlhbmdsZWRvd247XCI6XCLilr1cIixcIiZiaWd0cmlhbmdsZXVwO1wiOlwi4pazXCIsXCImYmlndXBsdXM7XCI6XCLiqIRcIixcIiZiaWd2ZWU7XCI6XCLii4FcIixcIiZiaWd3ZWRnZTtcIjpcIuKLgFwiLFwiJmJrYXJvdztcIjpcIuKkjVwiLFwiJmJsYWNrbG96ZW5nZTtcIjpcIuKnq1wiLFwiJmJsYWNrc3F1YXJlO1wiOlwi4paqXCIsXCImYmxhY2t0cmlhbmdsZTtcIjpcIuKWtFwiLFwiJmJsYWNrdHJpYW5nbGVkb3duO1wiOlwi4pa+XCIsXCImYmxhY2t0cmlhbmdsZWxlZnQ7XCI6XCLil4JcIixcIiZibGFja3RyaWFuZ2xlcmlnaHQ7XCI6XCLilrhcIixcIiZibGFuaztcIjpcIuKQo1wiLFwiJmJsazEyO1wiOlwi4paSXCIsXCImYmxrMTQ7XCI6XCLilpFcIixcIiZibGszNDtcIjpcIuKWk1wiLFwiJmJsb2NrO1wiOlwi4paIXCIsXCImYm5lO1wiOlwiPeKDpVwiLFwiJmJuZXF1aXY7XCI6XCLiiaHig6VcIixcIiZibm90O1wiOlwi4oyQXCIsXCImYm9wZjtcIjpcIvCdlZNcIixcIiZib3Q7XCI6XCLiiqVcIixcIiZib3R0b207XCI6XCLiiqVcIixcIiZib3d0aWU7XCI6XCLii4hcIixcIiZib3hETDtcIjpcIuKVl1wiLFwiJmJveERSO1wiOlwi4pWUXCIsXCImYm94RGw7XCI6XCLilZZcIixcIiZib3hEcjtcIjpcIuKVk1wiLFwiJmJveEg7XCI6XCLilZBcIixcIiZib3hIRDtcIjpcIuKVplwiLFwiJmJveEhVO1wiOlwi4pWpXCIsXCImYm94SGQ7XCI6XCLilaRcIixcIiZib3hIdTtcIjpcIuKVp1wiLFwiJmJveFVMO1wiOlwi4pWdXCIsXCImYm94VVI7XCI6XCLilZpcIixcIiZib3hVbDtcIjpcIuKVnFwiLFwiJmJveFVyO1wiOlwi4pWZXCIsXCImYm94VjtcIjpcIuKVkVwiLFwiJmJveFZIO1wiOlwi4pWsXCIsXCImYm94Vkw7XCI6XCLilaNcIixcIiZib3hWUjtcIjpcIuKVoFwiLFwiJmJveFZoO1wiOlwi4pWrXCIsXCImYm94Vmw7XCI6XCLilaJcIixcIiZib3hWcjtcIjpcIuKVn1wiLFwiJmJveGJveDtcIjpcIuKniVwiLFwiJmJveGRMO1wiOlwi4pWVXCIsXCImYm94ZFI7XCI6XCLilZJcIixcIiZib3hkbDtcIjpcIuKUkFwiLFwiJmJveGRyO1wiOlwi4pSMXCIsXCImYm94aDtcIjpcIuKUgFwiLFwiJmJveGhEO1wiOlwi4pWlXCIsXCImYm94aFU7XCI6XCLilahcIixcIiZib3hoZDtcIjpcIuKUrFwiLFwiJmJveGh1O1wiOlwi4pS0XCIsXCImYm94bWludXM7XCI6XCLiip9cIixcIiZib3hwbHVzO1wiOlwi4oqeXCIsXCImYm94dGltZXM7XCI6XCLiiqBcIixcIiZib3h1TDtcIjpcIuKVm1wiLFwiJmJveHVSO1wiOlwi4pWYXCIsXCImYm94dWw7XCI6XCLilJhcIixcIiZib3h1cjtcIjpcIuKUlFwiLFwiJmJveHY7XCI6XCLilIJcIixcIiZib3h2SDtcIjpcIuKVqlwiLFwiJmJveHZMO1wiOlwi4pWhXCIsXCImYm94dlI7XCI6XCLilZ5cIixcIiZib3h2aDtcIjpcIuKUvFwiLFwiJmJveHZsO1wiOlwi4pSkXCIsXCImYm94dnI7XCI6XCLilJxcIixcIiZicHJpbWU7XCI6XCLigLVcIixcIiZicmV2ZTtcIjpcIsuYXCIsXCImYnJ2YmFyXCI6XCLCplwiLFwiJmJydmJhcjtcIjpcIsKmXCIsXCImYnNjcjtcIjpcIvCdkrdcIixcIiZic2VtaTtcIjpcIuKBj1wiLFwiJmJzaW07XCI6XCLiiL1cIixcIiZic2ltZTtcIjpcIuKLjVwiLFwiJmJzb2w7XCI6XCJcXFxcXCIsXCImYnNvbGI7XCI6XCLip4VcIixcIiZic29saHN1YjtcIjpcIuKfiFwiLFwiJmJ1bGw7XCI6XCLigKJcIixcIiZidWxsZXQ7XCI6XCLigKJcIixcIiZidW1wO1wiOlwi4omOXCIsXCImYnVtcEU7XCI6XCLiqq5cIixcIiZidW1wZTtcIjpcIuKJj1wiLFwiJmJ1bXBlcTtcIjpcIuKJj1wiLFwiJmNhY3V0ZTtcIjpcIsSHXCIsXCImY2FwO1wiOlwi4oipXCIsXCImY2FwYW5kO1wiOlwi4qmEXCIsXCImY2FwYnJjdXA7XCI6XCLiqYlcIixcIiZjYXBjYXA7XCI6XCLiqYtcIixcIiZjYXBjdXA7XCI6XCLiqYdcIixcIiZjYXBkb3Q7XCI6XCLiqYBcIixcIiZjYXBzO1wiOlwi4oip77iAXCIsXCImY2FyZXQ7XCI6XCLigYFcIixcIiZjYXJvbjtcIjpcIsuHXCIsXCImY2NhcHM7XCI6XCLiqY1cIixcIiZjY2Fyb247XCI6XCLEjVwiLFwiJmNjZWRpbFwiOlwiw6dcIixcIiZjY2VkaWw7XCI6XCLDp1wiLFwiJmNjaXJjO1wiOlwixIlcIixcIiZjY3VwcztcIjpcIuKpjFwiLFwiJmNjdXBzc207XCI6XCLiqZBcIixcIiZjZG90O1wiOlwixItcIixcIiZjZWRpbFwiOlwiwrhcIixcIiZjZWRpbDtcIjpcIsK4XCIsXCImY2VtcHR5djtcIjpcIuKmslwiLFwiJmNlbnRcIjpcIsKiXCIsXCImY2VudDtcIjpcIsKiXCIsXCImY2VudGVyZG90O1wiOlwiwrdcIixcIiZjZnI7XCI6XCLwnZSgXCIsXCImY2hjeTtcIjpcItGHXCIsXCImY2hlY2s7XCI6XCLinJNcIixcIiZjaGVja21hcms7XCI6XCLinJNcIixcIiZjaGk7XCI6XCLPh1wiLFwiJmNpcjtcIjpcIuKXi1wiLFwiJmNpckU7XCI6XCLip4NcIixcIiZjaXJjO1wiOlwiy4ZcIixcIiZjaXJjZXE7XCI6XCLiiZdcIixcIiZjaXJjbGVhcnJvd2xlZnQ7XCI6XCLihrpcIixcIiZjaXJjbGVhcnJvd3JpZ2h0O1wiOlwi4oa7XCIsXCImY2lyY2xlZFI7XCI6XCLCrlwiLFwiJmNpcmNsZWRTO1wiOlwi4pOIXCIsXCImY2lyY2xlZGFzdDtcIjpcIuKKm1wiLFwiJmNpcmNsZWRjaXJjO1wiOlwi4oqaXCIsXCImY2lyY2xlZGRhc2g7XCI6XCLiip1cIixcIiZjaXJlO1wiOlwi4omXXCIsXCImY2lyZm5pbnQ7XCI6XCLiqJBcIixcIiZjaXJtaWQ7XCI6XCLiq69cIixcIiZjaXJzY2lyO1wiOlwi4qeCXCIsXCImY2x1YnM7XCI6XCLimaNcIixcIiZjbHVic3VpdDtcIjpcIuKZo1wiLFwiJmNvbG9uO1wiOlwiOlwiLFwiJmNvbG9uZTtcIjpcIuKJlFwiLFwiJmNvbG9uZXE7XCI6XCLiiZRcIixcIiZjb21tYTtcIjpcIixcIixcIiZjb21tYXQ7XCI6XCJAXCIsXCImY29tcDtcIjpcIuKIgVwiLFwiJmNvbXBmbjtcIjpcIuKImFwiLFwiJmNvbXBsZW1lbnQ7XCI6XCLiiIFcIixcIiZjb21wbGV4ZXM7XCI6XCLihIJcIixcIiZjb25nO1wiOlwi4omFXCIsXCImY29uZ2RvdDtcIjpcIuKprVwiLFwiJmNvbmludDtcIjpcIuKIrlwiLFwiJmNvcGY7XCI6XCLwnZWUXCIsXCImY29wcm9kO1wiOlwi4oiQXCIsXCImY29weVwiOlwiwqlcIixcIiZjb3B5O1wiOlwiwqlcIixcIiZjb3B5c3I7XCI6XCLihJdcIixcIiZjcmFycjtcIjpcIuKGtVwiLFwiJmNyb3NzO1wiOlwi4pyXXCIsXCImY3NjcjtcIjpcIvCdkrhcIixcIiZjc3ViO1wiOlwi4quPXCIsXCImY3N1YmU7XCI6XCLiq5FcIixcIiZjc3VwO1wiOlwi4quQXCIsXCImY3N1cGU7XCI6XCLiq5JcIixcIiZjdGRvdDtcIjpcIuKLr1wiLFwiJmN1ZGFycmw7XCI6XCLipLhcIixcIiZjdWRhcnJyO1wiOlwi4qS1XCIsXCImY3VlcHI7XCI6XCLii55cIixcIiZjdWVzYztcIjpcIuKLn1wiLFwiJmN1bGFycjtcIjpcIuKGtlwiLFwiJmN1bGFycnA7XCI6XCLipL1cIixcIiZjdXA7XCI6XCLiiKpcIixcIiZjdXBicmNhcDtcIjpcIuKpiFwiLFwiJmN1cGNhcDtcIjpcIuKphlwiLFwiJmN1cGN1cDtcIjpcIuKpilwiLFwiJmN1cGRvdDtcIjpcIuKKjVwiLFwiJmN1cG9yO1wiOlwi4qmFXCIsXCImY3VwcztcIjpcIuKIqu+4gFwiLFwiJmN1cmFycjtcIjpcIuKGt1wiLFwiJmN1cmFycm07XCI6XCLipLxcIixcIiZjdXJseWVxcHJlYztcIjpcIuKLnlwiLFwiJmN1cmx5ZXFzdWNjO1wiOlwi4oufXCIsXCImY3VybHl2ZWU7XCI6XCLii45cIixcIiZjdXJseXdlZGdlO1wiOlwi4ouPXCIsXCImY3VycmVuXCI6XCLCpFwiLFwiJmN1cnJlbjtcIjpcIsKkXCIsXCImY3VydmVhcnJvd2xlZnQ7XCI6XCLihrZcIixcIiZjdXJ2ZWFycm93cmlnaHQ7XCI6XCLihrdcIixcIiZjdXZlZTtcIjpcIuKLjlwiLFwiJmN1d2VkO1wiOlwi4ouPXCIsXCImY3djb25pbnQ7XCI6XCLiiLJcIixcIiZjd2ludDtcIjpcIuKIsVwiLFwiJmN5bGN0eTtcIjpcIuKMrVwiLFwiJmRBcnI7XCI6XCLih5NcIixcIiZkSGFyO1wiOlwi4qWlXCIsXCImZGFnZ2VyO1wiOlwi4oCgXCIsXCImZGFsZXRoO1wiOlwi4oS4XCIsXCImZGFycjtcIjpcIuKGk1wiLFwiJmRhc2g7XCI6XCLigJBcIixcIiZkYXNodjtcIjpcIuKKo1wiLFwiJmRia2Fyb3c7XCI6XCLipI9cIixcIiZkYmxhYztcIjpcIsudXCIsXCImZGNhcm9uO1wiOlwixI9cIixcIiZkY3k7XCI6XCLQtFwiLFwiJmRkO1wiOlwi4oWGXCIsXCImZGRhZ2dlcjtcIjpcIuKAoVwiLFwiJmRkYXJyO1wiOlwi4oeKXCIsXCImZGRvdHNlcTtcIjpcIuKpt1wiLFwiJmRlZ1wiOlwiwrBcIixcIiZkZWc7XCI6XCLCsFwiLFwiJmRlbHRhO1wiOlwizrRcIixcIiZkZW1wdHl2O1wiOlwi4qaxXCIsXCImZGZpc2h0O1wiOlwi4qW/XCIsXCImZGZyO1wiOlwi8J2UoVwiLFwiJmRoYXJsO1wiOlwi4oeDXCIsXCImZGhhcnI7XCI6XCLih4JcIixcIiZkaWFtO1wiOlwi4ouEXCIsXCImZGlhbW9uZDtcIjpcIuKLhFwiLFwiJmRpYW1vbmRzdWl0O1wiOlwi4pmmXCIsXCImZGlhbXM7XCI6XCLimaZcIixcIiZkaWU7XCI6XCLCqFwiLFwiJmRpZ2FtbWE7XCI6XCLPnVwiLFwiJmRpc2luO1wiOlwi4ouyXCIsXCImZGl2O1wiOlwiw7dcIixcIiZkaXZpZGVcIjpcIsO3XCIsXCImZGl2aWRlO1wiOlwiw7dcIixcIiZkaXZpZGVvbnRpbWVzO1wiOlwi4ouHXCIsXCImZGl2b254O1wiOlwi4ouHXCIsXCImZGpjeTtcIjpcItGSXCIsXCImZGxjb3JuO1wiOlwi4oyeXCIsXCImZGxjcm9wO1wiOlwi4oyNXCIsXCImZG9sbGFyO1wiOlwiJFwiLFwiJmRvcGY7XCI6XCLwnZWVXCIsXCImZG90O1wiOlwiy5lcIixcIiZkb3RlcTtcIjpcIuKJkFwiLFwiJmRvdGVxZG90O1wiOlwi4omRXCIsXCImZG90bWludXM7XCI6XCLiiLhcIixcIiZkb3RwbHVzO1wiOlwi4oiUXCIsXCImZG90c3F1YXJlO1wiOlwi4oqhXCIsXCImZG91YmxlYmFyd2VkZ2U7XCI6XCLijIZcIixcIiZkb3duYXJyb3c7XCI6XCLihpNcIixcIiZkb3duZG93bmFycm93cztcIjpcIuKHilwiLFwiJmRvd25oYXJwb29ubGVmdDtcIjpcIuKHg1wiLFwiJmRvd25oYXJwb29ucmlnaHQ7XCI6XCLih4JcIixcIiZkcmJrYXJvdztcIjpcIuKkkFwiLFwiJmRyY29ybjtcIjpcIuKMn1wiLFwiJmRyY3JvcDtcIjpcIuKMjFwiLFwiJmRzY3I7XCI6XCLwnZK5XCIsXCImZHNjeTtcIjpcItGVXCIsXCImZHNvbDtcIjpcIuKntlwiLFwiJmRzdHJvaztcIjpcIsSRXCIsXCImZHRkb3Q7XCI6XCLii7FcIixcIiZkdHJpO1wiOlwi4pa/XCIsXCImZHRyaWY7XCI6XCLilr5cIixcIiZkdWFycjtcIjpcIuKHtVwiLFwiJmR1aGFyO1wiOlwi4qWvXCIsXCImZHdhbmdsZTtcIjpcIuKmplwiLFwiJmR6Y3k7XCI6XCLRn1wiLFwiJmR6aWdyYXJyO1wiOlwi4p+/XCIsXCImZUREb3Q7XCI6XCLiqbdcIixcIiZlRG90O1wiOlwi4omRXCIsXCImZWFjdXRlXCI6XCLDqVwiLFwiJmVhY3V0ZTtcIjpcIsOpXCIsXCImZWFzdGVyO1wiOlwi4qmuXCIsXCImZWNhcm9uO1wiOlwixJtcIixcIiZlY2lyO1wiOlwi4omWXCIsXCImZWNpcmNcIjpcIsOqXCIsXCImZWNpcmM7XCI6XCLDqlwiLFwiJmVjb2xvbjtcIjpcIuKJlVwiLFwiJmVjeTtcIjpcItGNXCIsXCImZWRvdDtcIjpcIsSXXCIsXCImZWU7XCI6XCLihYdcIixcIiZlZkRvdDtcIjpcIuKJklwiLFwiJmVmcjtcIjpcIvCdlKJcIixcIiZlZztcIjpcIuKqmlwiLFwiJmVncmF2ZVwiOlwiw6hcIixcIiZlZ3JhdmU7XCI6XCLDqFwiLFwiJmVncztcIjpcIuKqllwiLFwiJmVnc2RvdDtcIjpcIuKqmFwiLFwiJmVsO1wiOlwi4qqZXCIsXCImZWxpbnRlcnM7XCI6XCLij6dcIixcIiZlbGw7XCI6XCLihJNcIixcIiZlbHM7XCI6XCLiqpVcIixcIiZlbHNkb3Q7XCI6XCLiqpdcIixcIiZlbWFjcjtcIjpcIsSTXCIsXCImZW1wdHk7XCI6XCLiiIVcIixcIiZlbXB0eXNldDtcIjpcIuKIhVwiLFwiJmVtcHR5djtcIjpcIuKIhVwiLFwiJmVtc3AxMztcIjpcIuKAhFwiLFwiJmVtc3AxNDtcIjpcIuKAhVwiLFwiJmVtc3A7XCI6XCLigINcIixcIiZlbmc7XCI6XCLFi1wiLFwiJmVuc3A7XCI6XCLigIJcIixcIiZlb2dvbjtcIjpcIsSZXCIsXCImZW9wZjtcIjpcIvCdlZZcIixcIiZlcGFyO1wiOlwi4ouVXCIsXCImZXBhcnNsO1wiOlwi4qejXCIsXCImZXBsdXM7XCI6XCLiqbFcIixcIiZlcHNpO1wiOlwizrVcIixcIiZlcHNpbG9uO1wiOlwizrVcIixcIiZlcHNpdjtcIjpcIs+1XCIsXCImZXFjaXJjO1wiOlwi4omWXCIsXCImZXFjb2xvbjtcIjpcIuKJlVwiLFwiJmVxc2ltO1wiOlwi4omCXCIsXCImZXFzbGFudGd0cjtcIjpcIuKqllwiLFwiJmVxc2xhbnRsZXNzO1wiOlwi4qqVXCIsXCImZXF1YWxzO1wiOlwiPVwiLFwiJmVxdWVzdDtcIjpcIuKJn1wiLFwiJmVxdWl2O1wiOlwi4omhXCIsXCImZXF1aXZERDtcIjpcIuKpuFwiLFwiJmVxdnBhcnNsO1wiOlwi4qelXCIsXCImZXJEb3Q7XCI6XCLiiZNcIixcIiZlcmFycjtcIjpcIuKlsVwiLFwiJmVzY3I7XCI6XCLihK9cIixcIiZlc2RvdDtcIjpcIuKJkFwiLFwiJmVzaW07XCI6XCLiiYJcIixcIiZldGE7XCI6XCLOt1wiLFwiJmV0aFwiOlwiw7BcIixcIiZldGg7XCI6XCLDsFwiLFwiJmV1bWxcIjpcIsOrXCIsXCImZXVtbDtcIjpcIsOrXCIsXCImZXVybztcIjpcIuKCrFwiLFwiJmV4Y2w7XCI6XCIhXCIsXCImZXhpc3Q7XCI6XCLiiINcIixcIiZleHBlY3RhdGlvbjtcIjpcIuKEsFwiLFwiJmV4cG9uZW50aWFsZTtcIjpcIuKFh1wiLFwiJmZhbGxpbmdkb3RzZXE7XCI6XCLiiZJcIixcIiZmY3k7XCI6XCLRhFwiLFwiJmZlbWFsZTtcIjpcIuKZgFwiLFwiJmZmaWxpZztcIjpcIu+sg1wiLFwiJmZmbGlnO1wiOlwi76yAXCIsXCImZmZsbGlnO1wiOlwi76yEXCIsXCImZmZyO1wiOlwi8J2Uo1wiLFwiJmZpbGlnO1wiOlwi76yBXCIsXCImZmpsaWc7XCI6XCJmalwiLFwiJmZsYXQ7XCI6XCLima1cIixcIiZmbGxpZztcIjpcIu+sglwiLFwiJmZsdG5zO1wiOlwi4paxXCIsXCImZm5vZjtcIjpcIsaSXCIsXCImZm9wZjtcIjpcIvCdlZdcIixcIiZmb3JhbGw7XCI6XCLiiIBcIixcIiZmb3JrO1wiOlwi4ouUXCIsXCImZm9ya3Y7XCI6XCLiq5lcIixcIiZmcGFydGludDtcIjpcIuKojVwiLFwiJmZyYWMxMlwiOlwiwr1cIixcIiZmcmFjMTI7XCI6XCLCvVwiLFwiJmZyYWMxMztcIjpcIuKFk1wiLFwiJmZyYWMxNFwiOlwiwrxcIixcIiZmcmFjMTQ7XCI6XCLCvFwiLFwiJmZyYWMxNTtcIjpcIuKFlVwiLFwiJmZyYWMxNjtcIjpcIuKFmVwiLFwiJmZyYWMxODtcIjpcIuKFm1wiLFwiJmZyYWMyMztcIjpcIuKFlFwiLFwiJmZyYWMyNTtcIjpcIuKFllwiLFwiJmZyYWMzNFwiOlwiwr5cIixcIiZmcmFjMzQ7XCI6XCLCvlwiLFwiJmZyYWMzNTtcIjpcIuKFl1wiLFwiJmZyYWMzODtcIjpcIuKFnFwiLFwiJmZyYWM0NTtcIjpcIuKFmFwiLFwiJmZyYWM1NjtcIjpcIuKFmlwiLFwiJmZyYWM1ODtcIjpcIuKFnVwiLFwiJmZyYWM3ODtcIjpcIuKFnlwiLFwiJmZyYXNsO1wiOlwi4oGEXCIsXCImZnJvd247XCI6XCLijKJcIixcIiZmc2NyO1wiOlwi8J2Su1wiLFwiJmdFO1wiOlwi4omnXCIsXCImZ0VsO1wiOlwi4qqMXCIsXCImZ2FjdXRlO1wiOlwix7VcIixcIiZnYW1tYTtcIjpcIs6zXCIsXCImZ2FtbWFkO1wiOlwiz51cIixcIiZnYXA7XCI6XCLiqoZcIixcIiZnYnJldmU7XCI6XCLEn1wiLFwiJmdjaXJjO1wiOlwixJ1cIixcIiZnY3k7XCI6XCLQs1wiLFwiJmdkb3Q7XCI6XCLEoVwiLFwiJmdlO1wiOlwi4omlXCIsXCImZ2VsO1wiOlwi4oubXCIsXCImZ2VxO1wiOlwi4omlXCIsXCImZ2VxcTtcIjpcIuKJp1wiLFwiJmdlcXNsYW50O1wiOlwi4qm+XCIsXCImZ2VzO1wiOlwi4qm+XCIsXCImZ2VzY2M7XCI6XCLiqqlcIixcIiZnZXNkb3Q7XCI6XCLiqoBcIixcIiZnZXNkb3RvO1wiOlwi4qqCXCIsXCImZ2VzZG90b2w7XCI6XCLiqoRcIixcIiZnZXNsO1wiOlwi4oub77iAXCIsXCImZ2VzbGVzO1wiOlwi4qqUXCIsXCImZ2ZyO1wiOlwi8J2UpFwiLFwiJmdnO1wiOlwi4omrXCIsXCImZ2dnO1wiOlwi4ouZXCIsXCImZ2ltZWw7XCI6XCLihLdcIixcIiZnamN5O1wiOlwi0ZNcIixcIiZnbDtcIjpcIuKJt1wiLFwiJmdsRTtcIjpcIuKqklwiLFwiJmdsYTtcIjpcIuKqpVwiLFwiJmdsajtcIjpcIuKqpFwiLFwiJmduRTtcIjpcIuKJqVwiLFwiJmduYXA7XCI6XCLiqopcIixcIiZnbmFwcHJveDtcIjpcIuKqilwiLFwiJmduZTtcIjpcIuKqiFwiLFwiJmduZXE7XCI6XCLiqohcIixcIiZnbmVxcTtcIjpcIuKJqVwiLFwiJmduc2ltO1wiOlwi4ounXCIsXCImZ29wZjtcIjpcIvCdlZhcIixcIiZncmF2ZTtcIjpcImBcIixcIiZnc2NyO1wiOlwi4oSKXCIsXCImZ3NpbTtcIjpcIuKJs1wiLFwiJmdzaW1lO1wiOlwi4qqOXCIsXCImZ3NpbWw7XCI6XCLiqpBcIixcIiZndFwiOlwiPlwiLFwiJmd0O1wiOlwiPlwiLFwiJmd0Y2M7XCI6XCLiqqdcIixcIiZndGNpcjtcIjpcIuKpulwiLFwiJmd0ZG90O1wiOlwi4ouXXCIsXCImZ3RsUGFyO1wiOlwi4qaVXCIsXCImZ3RxdWVzdDtcIjpcIuKpvFwiLFwiJmd0cmFwcHJveDtcIjpcIuKqhlwiLFwiJmd0cmFycjtcIjpcIuKluFwiLFwiJmd0cmRvdDtcIjpcIuKLl1wiLFwiJmd0cmVxbGVzcztcIjpcIuKLm1wiLFwiJmd0cmVxcWxlc3M7XCI6XCLiqoxcIixcIiZndHJsZXNzO1wiOlwi4om3XCIsXCImZ3Ryc2ltO1wiOlwi4omzXCIsXCImZ3ZlcnRuZXFxO1wiOlwi4omp77iAXCIsXCImZ3ZuRTtcIjpcIuKJqe+4gFwiLFwiJmhBcnI7XCI6XCLih5RcIixcIiZoYWlyc3A7XCI6XCLigIpcIixcIiZoYWxmO1wiOlwiwr1cIixcIiZoYW1pbHQ7XCI6XCLihItcIixcIiZoYXJkY3k7XCI6XCLRilwiLFwiJmhhcnI7XCI6XCLihpRcIixcIiZoYXJyY2lyO1wiOlwi4qWIXCIsXCImaGFycnc7XCI6XCLihq1cIixcIiZoYmFyO1wiOlwi4oSPXCIsXCImaGNpcmM7XCI6XCLEpVwiLFwiJmhlYXJ0cztcIjpcIuKZpVwiLFwiJmhlYXJ0c3VpdDtcIjpcIuKZpVwiLFwiJmhlbGxpcDtcIjpcIuKAplwiLFwiJmhlcmNvbjtcIjpcIuKKuVwiLFwiJmhmcjtcIjpcIvCdlKVcIixcIiZoa3NlYXJvdztcIjpcIuKkpVwiLFwiJmhrc3dhcm93O1wiOlwi4qSmXCIsXCImaG9hcnI7XCI6XCLih79cIixcIiZob210aHQ7XCI6XCLiiLtcIixcIiZob29rbGVmdGFycm93O1wiOlwi4oapXCIsXCImaG9va3JpZ2h0YXJyb3c7XCI6XCLihqpcIixcIiZob3BmO1wiOlwi8J2VmVwiLFwiJmhvcmJhcjtcIjpcIuKAlVwiLFwiJmhzY3I7XCI6XCLwnZK9XCIsXCImaHNsYXNoO1wiOlwi4oSPXCIsXCImaHN0cm9rO1wiOlwixKdcIixcIiZoeWJ1bGw7XCI6XCLigYNcIixcIiZoeXBoZW47XCI6XCLigJBcIixcIiZpYWN1dGVcIjpcIsOtXCIsXCImaWFjdXRlO1wiOlwiw61cIixcIiZpYztcIjpcIuKBo1wiLFwiJmljaXJjXCI6XCLDrlwiLFwiJmljaXJjO1wiOlwiw65cIixcIiZpY3k7XCI6XCLQuFwiLFwiJmllY3k7XCI6XCLQtVwiLFwiJmlleGNsXCI6XCLCoVwiLFwiJmlleGNsO1wiOlwiwqFcIixcIiZpZmY7XCI6XCLih5RcIixcIiZpZnI7XCI6XCLwnZSmXCIsXCImaWdyYXZlXCI6XCLDrFwiLFwiJmlncmF2ZTtcIjpcIsOsXCIsXCImaWk7XCI6XCLihYhcIixcIiZpaWlpbnQ7XCI6XCLiqIxcIixcIiZpaWludDtcIjpcIuKIrVwiLFwiJmlpbmZpbjtcIjpcIuKnnFwiLFwiJmlpb3RhO1wiOlwi4oSpXCIsXCImaWpsaWc7XCI6XCLEs1wiLFwiJmltYWNyO1wiOlwixKtcIixcIiZpbWFnZTtcIjpcIuKEkVwiLFwiJmltYWdsaW5lO1wiOlwi4oSQXCIsXCImaW1hZ3BhcnQ7XCI6XCLihJFcIixcIiZpbWF0aDtcIjpcIsSxXCIsXCImaW1vZjtcIjpcIuKKt1wiLFwiJmltcGVkO1wiOlwixrVcIixcIiZpbjtcIjpcIuKIiFwiLFwiJmluY2FyZTtcIjpcIuKEhVwiLFwiJmluZmluO1wiOlwi4oieXCIsXCImaW5maW50aWU7XCI6XCLip51cIixcIiZpbm9kb3Q7XCI6XCLEsVwiLFwiJmludDtcIjpcIuKIq1wiLFwiJmludGNhbDtcIjpcIuKKulwiLFwiJmludGVnZXJzO1wiOlwi4oSkXCIsXCImaW50ZXJjYWw7XCI6XCLiirpcIixcIiZpbnRsYXJoaztcIjpcIuKol1wiLFwiJmludHByb2Q7XCI6XCLiqLxcIixcIiZpb2N5O1wiOlwi0ZFcIixcIiZpb2dvbjtcIjpcIsSvXCIsXCImaW9wZjtcIjpcIvCdlZpcIixcIiZpb3RhO1wiOlwizrlcIixcIiZpcHJvZDtcIjpcIuKovFwiLFwiJmlxdWVzdFwiOlwiwr9cIixcIiZpcXVlc3Q7XCI6XCLCv1wiLFwiJmlzY3I7XCI6XCLwnZK+XCIsXCImaXNpbjtcIjpcIuKIiFwiLFwiJmlzaW5FO1wiOlwi4ou5XCIsXCImaXNpbmRvdDtcIjpcIuKLtVwiLFwiJmlzaW5zO1wiOlwi4ou0XCIsXCImaXNpbnN2O1wiOlwi4ouzXCIsXCImaXNpbnY7XCI6XCLiiIhcIixcIiZpdDtcIjpcIuKBolwiLFwiJml0aWxkZTtcIjpcIsSpXCIsXCImaXVrY3k7XCI6XCLRllwiLFwiJml1bWxcIjpcIsOvXCIsXCImaXVtbDtcIjpcIsOvXCIsXCImamNpcmM7XCI6XCLEtVwiLFwiJmpjeTtcIjpcItC5XCIsXCImamZyO1wiOlwi8J2Up1wiLFwiJmptYXRoO1wiOlwiyLdcIixcIiZqb3BmO1wiOlwi8J2Vm1wiLFwiJmpzY3I7XCI6XCLwnZK/XCIsXCImanNlcmN5O1wiOlwi0ZhcIixcIiZqdWtjeTtcIjpcItGUXCIsXCIma2FwcGE7XCI6XCLOulwiLFwiJmthcHBhdjtcIjpcIs+wXCIsXCIma2NlZGlsO1wiOlwixLdcIixcIiZrY3k7XCI6XCLQulwiLFwiJmtmcjtcIjpcIvCdlKhcIixcIiZrZ3JlZW47XCI6XCLEuFwiLFwiJmtoY3k7XCI6XCLRhVwiLFwiJmtqY3k7XCI6XCLRnFwiLFwiJmtvcGY7XCI6XCLwnZWcXCIsXCIma3NjcjtcIjpcIvCdk4BcIixcIiZsQWFycjtcIjpcIuKHmlwiLFwiJmxBcnI7XCI6XCLih5BcIixcIiZsQXRhaWw7XCI6XCLipJtcIixcIiZsQmFycjtcIjpcIuKkjlwiLFwiJmxFO1wiOlwi4ommXCIsXCImbEVnO1wiOlwi4qqLXCIsXCImbEhhcjtcIjpcIuKlolwiLFwiJmxhY3V0ZTtcIjpcIsS6XCIsXCImbGFlbXB0eXY7XCI6XCLiprRcIixcIiZsYWdyYW47XCI6XCLihJJcIixcIiZsYW1iZGE7XCI6XCLOu1wiLFwiJmxhbmc7XCI6XCLin6hcIixcIiZsYW5nZDtcIjpcIuKmkVwiLFwiJmxhbmdsZTtcIjpcIuKfqFwiLFwiJmxhcDtcIjpcIuKqhVwiLFwiJmxhcXVvXCI6XCLCq1wiLFwiJmxhcXVvO1wiOlwiwqtcIixcIiZsYXJyO1wiOlwi4oaQXCIsXCImbGFycmI7XCI6XCLih6RcIixcIiZsYXJyYmZzO1wiOlwi4qSfXCIsXCImbGFycmZzO1wiOlwi4qSdXCIsXCImbGFycmhrO1wiOlwi4oapXCIsXCImbGFycmxwO1wiOlwi4oarXCIsXCImbGFycnBsO1wiOlwi4qS5XCIsXCImbGFycnNpbTtcIjpcIuKls1wiLFwiJmxhcnJ0bDtcIjpcIuKGolwiLFwiJmxhdDtcIjpcIuKqq1wiLFwiJmxhdGFpbDtcIjpcIuKkmVwiLFwiJmxhdGU7XCI6XCLiqq1cIixcIiZsYXRlcztcIjpcIuKqre+4gFwiLFwiJmxiYXJyO1wiOlwi4qSMXCIsXCImbGJicms7XCI6XCLinbJcIixcIiZsYnJhY2U7XCI6XCJ7XCIsXCImbGJyYWNrO1wiOlwiW1wiLFwiJmxicmtlO1wiOlwi4qaLXCIsXCImbGJya3NsZDtcIjpcIuKmj1wiLFwiJmxicmtzbHU7XCI6XCLipo1cIixcIiZsY2Fyb247XCI6XCLEvlwiLFwiJmxjZWRpbDtcIjpcIsS8XCIsXCImbGNlaWw7XCI6XCLijIhcIixcIiZsY3ViO1wiOlwie1wiLFwiJmxjeTtcIjpcItC7XCIsXCImbGRjYTtcIjpcIuKktlwiLFwiJmxkcXVvO1wiOlwi4oCcXCIsXCImbGRxdW9yO1wiOlwi4oCeXCIsXCImbGRyZGhhcjtcIjpcIuKlp1wiLFwiJmxkcnVzaGFyO1wiOlwi4qWLXCIsXCImbGRzaDtcIjpcIuKGslwiLFwiJmxlO1wiOlwi4omkXCIsXCImbGVmdGFycm93O1wiOlwi4oaQXCIsXCImbGVmdGFycm93dGFpbDtcIjpcIuKGolwiLFwiJmxlZnRoYXJwb29uZG93bjtcIjpcIuKGvVwiLFwiJmxlZnRoYXJwb29udXA7XCI6XCLihrxcIixcIiZsZWZ0bGVmdGFycm93cztcIjpcIuKHh1wiLFwiJmxlZnRyaWdodGFycm93O1wiOlwi4oaUXCIsXCImbGVmdHJpZ2h0YXJyb3dzO1wiOlwi4oeGXCIsXCImbGVmdHJpZ2h0aGFycG9vbnM7XCI6XCLih4tcIixcIiZsZWZ0cmlnaHRzcXVpZ2Fycm93O1wiOlwi4oatXCIsXCImbGVmdHRocmVldGltZXM7XCI6XCLii4tcIixcIiZsZWc7XCI6XCLii5pcIixcIiZsZXE7XCI6XCLiiaRcIixcIiZsZXFxO1wiOlwi4ommXCIsXCImbGVxc2xhbnQ7XCI6XCLiqb1cIixcIiZsZXM7XCI6XCLiqb1cIixcIiZsZXNjYztcIjpcIuKqqFwiLFwiJmxlc2RvdDtcIjpcIuKpv1wiLFwiJmxlc2RvdG87XCI6XCLiqoFcIixcIiZsZXNkb3RvcjtcIjpcIuKqg1wiLFwiJmxlc2c7XCI6XCLii5rvuIBcIixcIiZsZXNnZXM7XCI6XCLiqpNcIixcIiZsZXNzYXBwcm94O1wiOlwi4qqFXCIsXCImbGVzc2RvdDtcIjpcIuKLllwiLFwiJmxlc3NlcWd0cjtcIjpcIuKLmlwiLFwiJmxlc3NlcXFndHI7XCI6XCLiqotcIixcIiZsZXNzZ3RyO1wiOlwi4om2XCIsXCImbGVzc3NpbTtcIjpcIuKJslwiLFwiJmxmaXNodDtcIjpcIuKlvFwiLFwiJmxmbG9vcjtcIjpcIuKMilwiLFwiJmxmcjtcIjpcIvCdlKlcIixcIiZsZztcIjpcIuKJtlwiLFwiJmxnRTtcIjpcIuKqkVwiLFwiJmxoYXJkO1wiOlwi4oa9XCIsXCImbGhhcnU7XCI6XCLihrxcIixcIiZsaGFydWw7XCI6XCLipapcIixcIiZsaGJsaztcIjpcIuKWhFwiLFwiJmxqY3k7XCI6XCLRmVwiLFwiJmxsO1wiOlwi4omqXCIsXCImbGxhcnI7XCI6XCLih4dcIixcIiZsbGNvcm5lcjtcIjpcIuKMnlwiLFwiJmxsaGFyZDtcIjpcIuKlq1wiLFwiJmxsdHJpO1wiOlwi4pe6XCIsXCImbG1pZG90O1wiOlwixYBcIixcIiZsbW91c3Q7XCI6XCLijrBcIixcIiZsbW91c3RhY2hlO1wiOlwi4o6wXCIsXCImbG5FO1wiOlwi4omoXCIsXCImbG5hcDtcIjpcIuKqiVwiLFwiJmxuYXBwcm94O1wiOlwi4qqJXCIsXCImbG5lO1wiOlwi4qqHXCIsXCImbG5lcTtcIjpcIuKqh1wiLFwiJmxuZXFxO1wiOlwi4omoXCIsXCImbG5zaW07XCI6XCLii6ZcIixcIiZsb2FuZztcIjpcIuKfrFwiLFwiJmxvYXJyO1wiOlwi4oe9XCIsXCImbG9icms7XCI6XCLin6ZcIixcIiZsb25nbGVmdGFycm93O1wiOlwi4p+1XCIsXCImbG9uZ2xlZnRyaWdodGFycm93O1wiOlwi4p+3XCIsXCImbG9uZ21hcHN0bztcIjpcIuKfvFwiLFwiJmxvbmdyaWdodGFycm93O1wiOlwi4p+2XCIsXCImbG9vcGFycm93bGVmdDtcIjpcIuKGq1wiLFwiJmxvb3BhcnJvd3JpZ2h0O1wiOlwi4oasXCIsXCImbG9wYXI7XCI6XCLipoVcIixcIiZsb3BmO1wiOlwi8J2VnVwiLFwiJmxvcGx1cztcIjpcIuKorVwiLFwiJmxvdGltZXM7XCI6XCLiqLRcIixcIiZsb3dhc3Q7XCI6XCLiiJdcIixcIiZsb3diYXI7XCI6XCJfXCIsXCImbG96O1wiOlwi4peKXCIsXCImbG96ZW5nZTtcIjpcIuKXilwiLFwiJmxvemY7XCI6XCLip6tcIixcIiZscGFyO1wiOlwiKFwiLFwiJmxwYXJsdDtcIjpcIuKmk1wiLFwiJmxyYXJyO1wiOlwi4oeGXCIsXCImbHJjb3JuZXI7XCI6XCLijJ9cIixcIiZscmhhcjtcIjpcIuKHi1wiLFwiJmxyaGFyZDtcIjpcIuKlrVwiLFwiJmxybTtcIjpcIuKAjlwiLFwiJmxydHJpO1wiOlwi4oq/XCIsXCImbHNhcXVvO1wiOlwi4oC5XCIsXCImbHNjcjtcIjpcIvCdk4FcIixcIiZsc2g7XCI6XCLihrBcIixcIiZsc2ltO1wiOlwi4omyXCIsXCImbHNpbWU7XCI6XCLiqo1cIixcIiZsc2ltZztcIjpcIuKqj1wiLFwiJmxzcWI7XCI6XCJbXCIsXCImbHNxdW87XCI6XCLigJhcIixcIiZsc3F1b3I7XCI6XCLigJpcIixcIiZsc3Ryb2s7XCI6XCLFglwiLFwiJmx0XCI6XCI8XCIsXCImbHQ7XCI6XCI8XCIsXCImbHRjYztcIjpcIuKqplwiLFwiJmx0Y2lyO1wiOlwi4qm5XCIsXCImbHRkb3Q7XCI6XCLii5ZcIixcIiZsdGhyZWU7XCI6XCLii4tcIixcIiZsdGltZXM7XCI6XCLii4lcIixcIiZsdGxhcnI7XCI6XCLipbZcIixcIiZsdHF1ZXN0O1wiOlwi4qm7XCIsXCImbHRyUGFyO1wiOlwi4qaWXCIsXCImbHRyaTtcIjpcIuKXg1wiLFwiJmx0cmllO1wiOlwi4oq0XCIsXCImbHRyaWY7XCI6XCLil4JcIixcIiZsdXJkc2hhcjtcIjpcIuKlilwiLFwiJmx1cnVoYXI7XCI6XCLipaZcIixcIiZsdmVydG5lcXE7XCI6XCLiiajvuIBcIixcIiZsdm5FO1wiOlwi4omo77iAXCIsXCImbUREb3Q7XCI6XCLiiLpcIixcIiZtYWNyXCI6XCLCr1wiLFwiJm1hY3I7XCI6XCLCr1wiLFwiJm1hbGU7XCI6XCLimYJcIixcIiZtYWx0O1wiOlwi4pygXCIsXCImbWFsdGVzZTtcIjpcIuKcoFwiLFwiJm1hcDtcIjpcIuKGplwiLFwiJm1hcHN0bztcIjpcIuKGplwiLFwiJm1hcHN0b2Rvd247XCI6XCLihqdcIixcIiZtYXBzdG9sZWZ0O1wiOlwi4oakXCIsXCImbWFwc3RvdXA7XCI6XCLihqVcIixcIiZtYXJrZXI7XCI6XCLilq5cIixcIiZtY29tbWE7XCI6XCLiqKlcIixcIiZtY3k7XCI6XCLQvFwiLFwiJm1kYXNoO1wiOlwi4oCUXCIsXCImbWVhc3VyZWRhbmdsZTtcIjpcIuKIoVwiLFwiJm1mcjtcIjpcIvCdlKpcIixcIiZtaG87XCI6XCLihKdcIixcIiZtaWNyb1wiOlwiwrVcIixcIiZtaWNybztcIjpcIsK1XCIsXCImbWlkO1wiOlwi4oijXCIsXCImbWlkYXN0O1wiOlwiKlwiLFwiJm1pZGNpcjtcIjpcIuKrsFwiLFwiJm1pZGRvdFwiOlwiwrdcIixcIiZtaWRkb3Q7XCI6XCLCt1wiLFwiJm1pbnVzO1wiOlwi4oiSXCIsXCImbWludXNiO1wiOlwi4oqfXCIsXCImbWludXNkO1wiOlwi4oi4XCIsXCImbWludXNkdTtcIjpcIuKoqlwiLFwiJm1sY3A7XCI6XCLiq5tcIixcIiZtbGRyO1wiOlwi4oCmXCIsXCImbW5wbHVzO1wiOlwi4oiTXCIsXCImbW9kZWxzO1wiOlwi4oqnXCIsXCImbW9wZjtcIjpcIvCdlZ5cIixcIiZtcDtcIjpcIuKIk1wiLFwiJm1zY3I7XCI6XCLwnZOCXCIsXCImbXN0cG9zO1wiOlwi4oi+XCIsXCImbXU7XCI6XCLOvFwiLFwiJm11bHRpbWFwO1wiOlwi4oq4XCIsXCImbXVtYXA7XCI6XCLiirhcIixcIiZuR2c7XCI6XCLii5nMuFwiLFwiJm5HdDtcIjpcIuKJq+KDklwiLFwiJm5HdHY7XCI6XCLiiavMuFwiLFwiJm5MZWZ0YXJyb3c7XCI6XCLih41cIixcIiZuTGVmdHJpZ2h0YXJyb3c7XCI6XCLih45cIixcIiZuTGw7XCI6XCLii5jMuFwiLFwiJm5MdDtcIjpcIuKJquKDklwiLFwiJm5MdHY7XCI6XCLiiarMuFwiLFwiJm5SaWdodGFycm93O1wiOlwi4oePXCIsXCImblZEYXNoO1wiOlwi4oqvXCIsXCImblZkYXNoO1wiOlwi4oquXCIsXCImbmFibGE7XCI6XCLiiIdcIixcIiZuYWN1dGU7XCI6XCLFhFwiLFwiJm5hbmc7XCI6XCLiiKDig5JcIixcIiZuYXA7XCI6XCLiiYlcIixcIiZuYXBFO1wiOlwi4qmwzLhcIixcIiZuYXBpZDtcIjpcIuKJi8y4XCIsXCImbmFwb3M7XCI6XCLFiVwiLFwiJm5hcHByb3g7XCI6XCLiiYlcIixcIiZuYXR1cjtcIjpcIuKZrlwiLFwiJm5hdHVyYWw7XCI6XCLima5cIixcIiZuYXR1cmFscztcIjpcIuKElVwiLFwiJm5ic3BcIjpcIsKgXCIsXCImbmJzcDtcIjpcIsKgXCIsXCImbmJ1bXA7XCI6XCLiiY7MuFwiLFwiJm5idW1wZTtcIjpcIuKJj8y4XCIsXCImbmNhcDtcIjpcIuKpg1wiLFwiJm5jYXJvbjtcIjpcIsWIXCIsXCImbmNlZGlsO1wiOlwixYZcIixcIiZuY29uZztcIjpcIuKJh1wiLFwiJm5jb25nZG90O1wiOlwi4qmtzLhcIixcIiZuY3VwO1wiOlwi4qmCXCIsXCImbmN5O1wiOlwi0L1cIixcIiZuZGFzaDtcIjpcIuKAk1wiLFwiJm5lO1wiOlwi4omgXCIsXCImbmVBcnI7XCI6XCLih5dcIixcIiZuZWFyaGs7XCI6XCLipKRcIixcIiZuZWFycjtcIjpcIuKGl1wiLFwiJm5lYXJyb3c7XCI6XCLihpdcIixcIiZuZWRvdDtcIjpcIuKJkMy4XCIsXCImbmVxdWl2O1wiOlwi4omiXCIsXCImbmVzZWFyO1wiOlwi4qSoXCIsXCImbmVzaW07XCI6XCLiiYLMuFwiLFwiJm5leGlzdDtcIjpcIuKIhFwiLFwiJm5leGlzdHM7XCI6XCLiiIRcIixcIiZuZnI7XCI6XCLwnZSrXCIsXCImbmdFO1wiOlwi4omnzLhcIixcIiZuZ2U7XCI6XCLiibFcIixcIiZuZ2VxO1wiOlwi4omxXCIsXCImbmdlcXE7XCI6XCLiiafMuFwiLFwiJm5nZXFzbGFudDtcIjpcIuKpvsy4XCIsXCImbmdlcztcIjpcIuKpvsy4XCIsXCImbmdzaW07XCI6XCLiibVcIixcIiZuZ3Q7XCI6XCLiia9cIixcIiZuZ3RyO1wiOlwi4omvXCIsXCImbmhBcnI7XCI6XCLih45cIixcIiZuaGFycjtcIjpcIuKGrlwiLFwiJm5ocGFyO1wiOlwi4quyXCIsXCImbmk7XCI6XCLiiItcIixcIiZuaXM7XCI6XCLii7xcIixcIiZuaXNkO1wiOlwi4ou6XCIsXCImbml2O1wiOlwi4oiLXCIsXCImbmpjeTtcIjpcItGaXCIsXCImbmxBcnI7XCI6XCLih41cIixcIiZubEU7XCI6XCLiiabMuFwiLFwiJm5sYXJyO1wiOlwi4oaaXCIsXCImbmxkcjtcIjpcIuKApVwiLFwiJm5sZTtcIjpcIuKJsFwiLFwiJm5sZWZ0YXJyb3c7XCI6XCLihppcIixcIiZubGVmdHJpZ2h0YXJyb3c7XCI6XCLihq5cIixcIiZubGVxO1wiOlwi4omwXCIsXCImbmxlcXE7XCI6XCLiiabMuFwiLFwiJm5sZXFzbGFudDtcIjpcIuKpvcy4XCIsXCImbmxlcztcIjpcIuKpvcy4XCIsXCImbmxlc3M7XCI6XCLiia5cIixcIiZubHNpbTtcIjpcIuKJtFwiLFwiJm5sdDtcIjpcIuKJrlwiLFwiJm5sdHJpO1wiOlwi4ouqXCIsXCImbmx0cmllO1wiOlwi4ousXCIsXCImbm1pZDtcIjpcIuKIpFwiLFwiJm5vcGY7XCI6XCLwnZWfXCIsXCImbm90XCI6XCLCrFwiLFwiJm5vdDtcIjpcIsKsXCIsXCImbm90aW47XCI6XCLiiIlcIixcIiZub3RpbkU7XCI6XCLii7nMuFwiLFwiJm5vdGluZG90O1wiOlwi4ou1zLhcIixcIiZub3RpbnZhO1wiOlwi4oiJXCIsXCImbm90aW52YjtcIjpcIuKLt1wiLFwiJm5vdGludmM7XCI6XCLii7ZcIixcIiZub3RuaTtcIjpcIuKIjFwiLFwiJm5vdG5pdmE7XCI6XCLiiIxcIixcIiZub3RuaXZiO1wiOlwi4ou+XCIsXCImbm90bml2YztcIjpcIuKLvVwiLFwiJm5wYXI7XCI6XCLiiKZcIixcIiZucGFyYWxsZWw7XCI6XCLiiKZcIixcIiZucGFyc2w7XCI6XCLiq73ig6VcIixcIiZucGFydDtcIjpcIuKIgsy4XCIsXCImbnBvbGludDtcIjpcIuKolFwiLFwiJm5wcjtcIjpcIuKKgFwiLFwiJm5wcmN1ZTtcIjpcIuKLoFwiLFwiJm5wcmU7XCI6XCLiqq/MuFwiLFwiJm5wcmVjO1wiOlwi4oqAXCIsXCImbnByZWNlcTtcIjpcIuKqr8y4XCIsXCImbnJBcnI7XCI6XCLih49cIixcIiZucmFycjtcIjpcIuKGm1wiLFwiJm5yYXJyYztcIjpcIuKks8y4XCIsXCImbnJhcnJ3O1wiOlwi4oadzLhcIixcIiZucmlnaHRhcnJvdztcIjpcIuKGm1wiLFwiJm5ydHJpO1wiOlwi4ourXCIsXCImbnJ0cmllO1wiOlwi4outXCIsXCImbnNjO1wiOlwi4oqBXCIsXCImbnNjY3VlO1wiOlwi4ouhXCIsXCImbnNjZTtcIjpcIuKqsMy4XCIsXCImbnNjcjtcIjpcIvCdk4NcIixcIiZuc2hvcnRtaWQ7XCI6XCLiiKRcIixcIiZuc2hvcnRwYXJhbGxlbDtcIjpcIuKIplwiLFwiJm5zaW07XCI6XCLiiYFcIixcIiZuc2ltZTtcIjpcIuKJhFwiLFwiJm5zaW1lcTtcIjpcIuKJhFwiLFwiJm5zbWlkO1wiOlwi4oikXCIsXCImbnNwYXI7XCI6XCLiiKZcIixcIiZuc3FzdWJlO1wiOlwi4ouiXCIsXCImbnNxc3VwZTtcIjpcIuKLo1wiLFwiJm5zdWI7XCI6XCLiioRcIixcIiZuc3ViRTtcIjpcIuKrhcy4XCIsXCImbnN1YmU7XCI6XCLiiohcIixcIiZuc3Vic2V0O1wiOlwi4oqC4oOSXCIsXCImbnN1YnNldGVxO1wiOlwi4oqIXCIsXCImbnN1YnNldGVxcTtcIjpcIuKrhcy4XCIsXCImbnN1Y2M7XCI6XCLiioFcIixcIiZuc3VjY2VxO1wiOlwi4qqwzLhcIixcIiZuc3VwO1wiOlwi4oqFXCIsXCImbnN1cEU7XCI6XCLiq4bMuFwiLFwiJm5zdXBlO1wiOlwi4oqJXCIsXCImbnN1cHNldDtcIjpcIuKKg+KDklwiLFwiJm5zdXBzZXRlcTtcIjpcIuKKiVwiLFwiJm5zdXBzZXRlcXE7XCI6XCLiq4bMuFwiLFwiJm50Z2w7XCI6XCLiiblcIixcIiZudGlsZGVcIjpcIsOxXCIsXCImbnRpbGRlO1wiOlwiw7FcIixcIiZudGxnO1wiOlwi4om4XCIsXCImbnRyaWFuZ2xlbGVmdDtcIjpcIuKLqlwiLFwiJm50cmlhbmdsZWxlZnRlcTtcIjpcIuKLrFwiLFwiJm50cmlhbmdsZXJpZ2h0O1wiOlwi4ourXCIsXCImbnRyaWFuZ2xlcmlnaHRlcTtcIjpcIuKLrVwiLFwiJm51O1wiOlwizr1cIixcIiZudW07XCI6XCIjXCIsXCImbnVtZXJvO1wiOlwi4oSWXCIsXCImbnVtc3A7XCI6XCLigIdcIixcIiZudkRhc2g7XCI6XCLiiq1cIixcIiZudkhhcnI7XCI6XCLipIRcIixcIiZudmFwO1wiOlwi4omN4oOSXCIsXCImbnZkYXNoO1wiOlwi4oqsXCIsXCImbnZnZTtcIjpcIuKJpeKDklwiLFwiJm52Z3Q7XCI6XCI+4oOSXCIsXCImbnZpbmZpbjtcIjpcIuKnnlwiLFwiJm52bEFycjtcIjpcIuKkglwiLFwiJm52bGU7XCI6XCLiiaTig5JcIixcIiZudmx0O1wiOlwiPOKDklwiLFwiJm52bHRyaWU7XCI6XCLiirTig5JcIixcIiZudnJBcnI7XCI6XCLipINcIixcIiZudnJ0cmllO1wiOlwi4oq14oOSXCIsXCImbnZzaW07XCI6XCLiiLzig5JcIixcIiZud0FycjtcIjpcIuKHllwiLFwiJm53YXJoaztcIjpcIuKko1wiLFwiJm53YXJyO1wiOlwi4oaWXCIsXCImbndhcnJvdztcIjpcIuKGllwiLFwiJm53bmVhcjtcIjpcIuKkp1wiLFwiJm9TO1wiOlwi4pOIXCIsXCImb2FjdXRlXCI6XCLDs1wiLFwiJm9hY3V0ZTtcIjpcIsOzXCIsXCImb2FzdDtcIjpcIuKKm1wiLFwiJm9jaXI7XCI6XCLiippcIixcIiZvY2lyY1wiOlwiw7RcIixcIiZvY2lyYztcIjpcIsO0XCIsXCImb2N5O1wiOlwi0L5cIixcIiZvZGFzaDtcIjpcIuKKnVwiLFwiJm9kYmxhYztcIjpcIsWRXCIsXCImb2RpdjtcIjpcIuKouFwiLFwiJm9kb3Q7XCI6XCLiiplcIixcIiZvZHNvbGQ7XCI6XCLiprxcIixcIiZvZWxpZztcIjpcIsWTXCIsXCImb2ZjaXI7XCI6XCLipr9cIixcIiZvZnI7XCI6XCLwnZSsXCIsXCImb2dvbjtcIjpcIsubXCIsXCImb2dyYXZlXCI6XCLDslwiLFwiJm9ncmF2ZTtcIjpcIsOyXCIsXCImb2d0O1wiOlwi4qeBXCIsXCImb2hiYXI7XCI6XCLiprVcIixcIiZvaG07XCI6XCLOqVwiLFwiJm9pbnQ7XCI6XCLiiK5cIixcIiZvbGFycjtcIjpcIuKGulwiLFwiJm9sY2lyO1wiOlwi4qa+XCIsXCImb2xjcm9zcztcIjpcIuKmu1wiLFwiJm9saW5lO1wiOlwi4oC+XCIsXCImb2x0O1wiOlwi4qeAXCIsXCImb21hY3I7XCI6XCLFjVwiLFwiJm9tZWdhO1wiOlwiz4lcIixcIiZvbWljcm9uO1wiOlwizr9cIixcIiZvbWlkO1wiOlwi4qa2XCIsXCImb21pbnVzO1wiOlwi4oqWXCIsXCImb29wZjtcIjpcIvCdlaBcIixcIiZvcGFyO1wiOlwi4qa3XCIsXCImb3BlcnA7XCI6XCLiprlcIixcIiZvcGx1cztcIjpcIuKKlVwiLFwiJm9yO1wiOlwi4oioXCIsXCImb3JhcnI7XCI6XCLihrtcIixcIiZvcmQ7XCI6XCLiqZ1cIixcIiZvcmRlcjtcIjpcIuKEtFwiLFwiJm9yZGVyb2Y7XCI6XCLihLRcIixcIiZvcmRmXCI6XCLCqlwiLFwiJm9yZGY7XCI6XCLCqlwiLFwiJm9yZG1cIjpcIsK6XCIsXCImb3JkbTtcIjpcIsK6XCIsXCImb3JpZ29mO1wiOlwi4oq2XCIsXCImb3JvcjtcIjpcIuKpllwiLFwiJm9yc2xvcGU7XCI6XCLiqZdcIixcIiZvcnY7XCI6XCLiqZtcIixcIiZvc2NyO1wiOlwi4oS0XCIsXCImb3NsYXNoXCI6XCLDuFwiLFwiJm9zbGFzaDtcIjpcIsO4XCIsXCImb3NvbDtcIjpcIuKKmFwiLFwiJm90aWxkZVwiOlwiw7VcIixcIiZvdGlsZGU7XCI6XCLDtVwiLFwiJm90aW1lcztcIjpcIuKKl1wiLFwiJm90aW1lc2FzO1wiOlwi4qi2XCIsXCImb3VtbFwiOlwiw7ZcIixcIiZvdW1sO1wiOlwiw7ZcIixcIiZvdmJhcjtcIjpcIuKMvVwiLFwiJnBhcjtcIjpcIuKIpVwiLFwiJnBhcmFcIjpcIsK2XCIsXCImcGFyYTtcIjpcIsK2XCIsXCImcGFyYWxsZWw7XCI6XCLiiKVcIixcIiZwYXJzaW07XCI6XCLiq7NcIixcIiZwYXJzbDtcIjpcIuKrvVwiLFwiJnBhcnQ7XCI6XCLiiIJcIixcIiZwY3k7XCI6XCLQv1wiLFwiJnBlcmNudDtcIjpcIiVcIixcIiZwZXJpb2Q7XCI6XCIuXCIsXCImcGVybWlsO1wiOlwi4oCwXCIsXCImcGVycDtcIjpcIuKKpVwiLFwiJnBlcnRlbms7XCI6XCLigLFcIixcIiZwZnI7XCI6XCLwnZStXCIsXCImcGhpO1wiOlwiz4ZcIixcIiZwaGl2O1wiOlwiz5VcIixcIiZwaG1tYXQ7XCI6XCLihLNcIixcIiZwaG9uZTtcIjpcIuKYjlwiLFwiJnBpO1wiOlwiz4BcIixcIiZwaXRjaGZvcms7XCI6XCLii5RcIixcIiZwaXY7XCI6XCLPllwiLFwiJnBsYW5jaztcIjpcIuKEj1wiLFwiJnBsYW5ja2g7XCI6XCLihI5cIixcIiZwbGFua3Y7XCI6XCLihI9cIixcIiZwbHVzO1wiOlwiK1wiLFwiJnBsdXNhY2lyO1wiOlwi4qijXCIsXCImcGx1c2I7XCI6XCLiip5cIixcIiZwbHVzY2lyO1wiOlwi4qiiXCIsXCImcGx1c2RvO1wiOlwi4oiUXCIsXCImcGx1c2R1O1wiOlwi4qilXCIsXCImcGx1c2U7XCI6XCLiqbJcIixcIiZwbHVzbW5cIjpcIsKxXCIsXCImcGx1c21uO1wiOlwiwrFcIixcIiZwbHVzc2ltO1wiOlwi4qimXCIsXCImcGx1c3R3bztcIjpcIuKop1wiLFwiJnBtO1wiOlwiwrFcIixcIiZwb2ludGludDtcIjpcIuKolVwiLFwiJnBvcGY7XCI6XCLwnZWhXCIsXCImcG91bmRcIjpcIsKjXCIsXCImcG91bmQ7XCI6XCLCo1wiLFwiJnByO1wiOlwi4om6XCIsXCImcHJFO1wiOlwi4qqzXCIsXCImcHJhcDtcIjpcIuKqt1wiLFwiJnByY3VlO1wiOlwi4om8XCIsXCImcHJlO1wiOlwi4qqvXCIsXCImcHJlYztcIjpcIuKJulwiLFwiJnByZWNhcHByb3g7XCI6XCLiqrdcIixcIiZwcmVjY3VybHllcTtcIjpcIuKJvFwiLFwiJnByZWNlcTtcIjpcIuKqr1wiLFwiJnByZWNuYXBwcm94O1wiOlwi4qq5XCIsXCImcHJlY25lcXE7XCI6XCLiqrVcIixcIiZwcmVjbnNpbTtcIjpcIuKLqFwiLFwiJnByZWNzaW07XCI6XCLiib5cIixcIiZwcmltZTtcIjpcIuKAslwiLFwiJnByaW1lcztcIjpcIuKEmVwiLFwiJnBybkU7XCI6XCLiqrVcIixcIiZwcm5hcDtcIjpcIuKquVwiLFwiJnBybnNpbTtcIjpcIuKLqFwiLFwiJnByb2Q7XCI6XCLiiI9cIixcIiZwcm9mYWxhcjtcIjpcIuKMrlwiLFwiJnByb2ZsaW5lO1wiOlwi4oySXCIsXCImcHJvZnN1cmY7XCI6XCLijJNcIixcIiZwcm9wO1wiOlwi4oidXCIsXCImcHJvcHRvO1wiOlwi4oidXCIsXCImcHJzaW07XCI6XCLiib5cIixcIiZwcnVyZWw7XCI6XCLiirBcIixcIiZwc2NyO1wiOlwi8J2ThVwiLFwiJnBzaTtcIjpcIs+IXCIsXCImcHVuY3NwO1wiOlwi4oCIXCIsXCImcWZyO1wiOlwi8J2UrlwiLFwiJnFpbnQ7XCI6XCLiqIxcIixcIiZxb3BmO1wiOlwi8J2VolwiLFwiJnFwcmltZTtcIjpcIuKBl1wiLFwiJnFzY3I7XCI6XCLwnZOGXCIsXCImcXVhdGVybmlvbnM7XCI6XCLihI1cIixcIiZxdWF0aW50O1wiOlwi4qiWXCIsXCImcXVlc3Q7XCI6XCI/XCIsXCImcXVlc3RlcTtcIjpcIuKJn1wiLFwiJnF1b3RcIjonXCInLFwiJnF1b3Q7XCI6J1wiJyxcIiZyQWFycjtcIjpcIuKHm1wiLFwiJnJBcnI7XCI6XCLih5JcIixcIiZyQXRhaWw7XCI6XCLipJxcIixcIiZyQmFycjtcIjpcIuKkj1wiLFwiJnJIYXI7XCI6XCLipaRcIixcIiZyYWNlO1wiOlwi4oi9zLFcIixcIiZyYWN1dGU7XCI6XCLFlVwiLFwiJnJhZGljO1wiOlwi4oiaXCIsXCImcmFlbXB0eXY7XCI6XCLiprNcIixcIiZyYW5nO1wiOlwi4p+pXCIsXCImcmFuZ2Q7XCI6XCLippJcIixcIiZyYW5nZTtcIjpcIuKmpVwiLFwiJnJhbmdsZTtcIjpcIuKfqVwiLFwiJnJhcXVvXCI6XCLCu1wiLFwiJnJhcXVvO1wiOlwiwrtcIixcIiZyYXJyO1wiOlwi4oaSXCIsXCImcmFycmFwO1wiOlwi4qW1XCIsXCImcmFycmI7XCI6XCLih6VcIixcIiZyYXJyYmZzO1wiOlwi4qSgXCIsXCImcmFycmM7XCI6XCLipLNcIixcIiZyYXJyZnM7XCI6XCLipJ5cIixcIiZyYXJyaGs7XCI6XCLihqpcIixcIiZyYXJybHA7XCI6XCLihqxcIixcIiZyYXJycGw7XCI6XCLipYVcIixcIiZyYXJyc2ltO1wiOlwi4qW0XCIsXCImcmFycnRsO1wiOlwi4oajXCIsXCImcmFycnc7XCI6XCLihp1cIixcIiZyYXRhaWw7XCI6XCLipJpcIixcIiZyYXRpbztcIjpcIuKItlwiLFwiJnJhdGlvbmFscztcIjpcIuKEmlwiLFwiJnJiYXJyO1wiOlwi4qSNXCIsXCImcmJicms7XCI6XCLinbNcIixcIiZyYnJhY2U7XCI6XCJ9XCIsXCImcmJyYWNrO1wiOlwiXVwiLFwiJnJicmtlO1wiOlwi4qaMXCIsXCImcmJya3NsZDtcIjpcIuKmjlwiLFwiJnJicmtzbHU7XCI6XCLippBcIixcIiZyY2Fyb247XCI6XCLFmVwiLFwiJnJjZWRpbDtcIjpcIsWXXCIsXCImcmNlaWw7XCI6XCLijIlcIixcIiZyY3ViO1wiOlwifVwiLFwiJnJjeTtcIjpcItGAXCIsXCImcmRjYTtcIjpcIuKkt1wiLFwiJnJkbGRoYXI7XCI6XCLipalcIixcIiZyZHF1bztcIjpcIuKAnVwiLFwiJnJkcXVvcjtcIjpcIuKAnVwiLFwiJnJkc2g7XCI6XCLihrNcIixcIiZyZWFsO1wiOlwi4oScXCIsXCImcmVhbGluZTtcIjpcIuKEm1wiLFwiJnJlYWxwYXJ0O1wiOlwi4oScXCIsXCImcmVhbHM7XCI6XCLihJ1cIixcIiZyZWN0O1wiOlwi4patXCIsXCImcmVnXCI6XCLCrlwiLFwiJnJlZztcIjpcIsKuXCIsXCImcmZpc2h0O1wiOlwi4qW9XCIsXCImcmZsb29yO1wiOlwi4oyLXCIsXCImcmZyO1wiOlwi8J2Ur1wiLFwiJnJoYXJkO1wiOlwi4oeBXCIsXCImcmhhcnU7XCI6XCLih4BcIixcIiZyaGFydWw7XCI6XCLipaxcIixcIiZyaG87XCI6XCLPgVwiLFwiJnJob3Y7XCI6XCLPsVwiLFwiJnJpZ2h0YXJyb3c7XCI6XCLihpJcIixcIiZyaWdodGFycm93dGFpbDtcIjpcIuKGo1wiLFwiJnJpZ2h0aGFycG9vbmRvd247XCI6XCLih4FcIixcIiZyaWdodGhhcnBvb251cDtcIjpcIuKHgFwiLFwiJnJpZ2h0bGVmdGFycm93cztcIjpcIuKHhFwiLFwiJnJpZ2h0bGVmdGhhcnBvb25zO1wiOlwi4oeMXCIsXCImcmlnaHRyaWdodGFycm93cztcIjpcIuKHiVwiLFwiJnJpZ2h0c3F1aWdhcnJvdztcIjpcIuKGnVwiLFwiJnJpZ2h0dGhyZWV0aW1lcztcIjpcIuKLjFwiLFwiJnJpbmc7XCI6XCLLmlwiLFwiJnJpc2luZ2RvdHNlcTtcIjpcIuKJk1wiLFwiJnJsYXJyO1wiOlwi4oeEXCIsXCImcmxoYXI7XCI6XCLih4xcIixcIiZybG07XCI6XCLigI9cIixcIiZybW91c3Q7XCI6XCLijrFcIixcIiZybW91c3RhY2hlO1wiOlwi4o6xXCIsXCImcm5taWQ7XCI6XCLiq65cIixcIiZyb2FuZztcIjpcIuKfrVwiLFwiJnJvYXJyO1wiOlwi4oe+XCIsXCImcm9icms7XCI6XCLin6dcIixcIiZyb3BhcjtcIjpcIuKmhlwiLFwiJnJvcGY7XCI6XCLwnZWjXCIsXCImcm9wbHVzO1wiOlwi4qiuXCIsXCImcm90aW1lcztcIjpcIuKotVwiLFwiJnJwYXI7XCI6XCIpXCIsXCImcnBhcmd0O1wiOlwi4qaUXCIsXCImcnBwb2xpbnQ7XCI6XCLiqJJcIixcIiZycmFycjtcIjpcIuKHiVwiLFwiJnJzYXF1bztcIjpcIuKAulwiLFwiJnJzY3I7XCI6XCLwnZOHXCIsXCImcnNoO1wiOlwi4oaxXCIsXCImcnNxYjtcIjpcIl1cIixcIiZyc3F1bztcIjpcIuKAmVwiLFwiJnJzcXVvcjtcIjpcIuKAmVwiLFwiJnJ0aHJlZTtcIjpcIuKLjFwiLFwiJnJ0aW1lcztcIjpcIuKLilwiLFwiJnJ0cmk7XCI6XCLilrlcIixcIiZydHJpZTtcIjpcIuKKtVwiLFwiJnJ0cmlmO1wiOlwi4pa4XCIsXCImcnRyaWx0cmk7XCI6XCLip45cIixcIiZydWx1aGFyO1wiOlwi4qWoXCIsXCImcng7XCI6XCLihJ5cIixcIiZzYWN1dGU7XCI6XCLFm1wiLFwiJnNicXVvO1wiOlwi4oCaXCIsXCImc2M7XCI6XCLiibtcIixcIiZzY0U7XCI6XCLiqrRcIixcIiZzY2FwO1wiOlwi4qq4XCIsXCImc2Nhcm9uO1wiOlwixaFcIixcIiZzY2N1ZTtcIjpcIuKJvVwiLFwiJnNjZTtcIjpcIuKqsFwiLFwiJnNjZWRpbDtcIjpcIsWfXCIsXCImc2NpcmM7XCI6XCLFnVwiLFwiJnNjbkU7XCI6XCLiqrZcIixcIiZzY25hcDtcIjpcIuKqulwiLFwiJnNjbnNpbTtcIjpcIuKLqVwiLFwiJnNjcG9saW50O1wiOlwi4qiTXCIsXCImc2NzaW07XCI6XCLiib9cIixcIiZzY3k7XCI6XCLRgVwiLFwiJnNkb3Q7XCI6XCLii4VcIixcIiZzZG90YjtcIjpcIuKKoVwiLFwiJnNkb3RlO1wiOlwi4qmmXCIsXCImc2VBcnI7XCI6XCLih5hcIixcIiZzZWFyaGs7XCI6XCLipKVcIixcIiZzZWFycjtcIjpcIuKGmFwiLFwiJnNlYXJyb3c7XCI6XCLihphcIixcIiZzZWN0XCI6XCLCp1wiLFwiJnNlY3Q7XCI6XCLCp1wiLFwiJnNlbWk7XCI6XCI7XCIsXCImc2Vzd2FyO1wiOlwi4qSpXCIsXCImc2V0bWludXM7XCI6XCLiiJZcIixcIiZzZXRtbjtcIjpcIuKIllwiLFwiJnNleHQ7XCI6XCLinLZcIixcIiZzZnI7XCI6XCLwnZSwXCIsXCImc2Zyb3duO1wiOlwi4oyiXCIsXCImc2hhcnA7XCI6XCLima9cIixcIiZzaGNoY3k7XCI6XCLRiVwiLFwiJnNoY3k7XCI6XCLRiFwiLFwiJnNob3J0bWlkO1wiOlwi4oijXCIsXCImc2hvcnRwYXJhbGxlbDtcIjpcIuKIpVwiLFwiJnNoeVwiOlwiwq1cIixcIiZzaHk7XCI6XCLCrVwiLFwiJnNpZ21hO1wiOlwiz4NcIixcIiZzaWdtYWY7XCI6XCLPglwiLFwiJnNpZ21hdjtcIjpcIs+CXCIsXCImc2ltO1wiOlwi4oi8XCIsXCImc2ltZG90O1wiOlwi4qmqXCIsXCImc2ltZTtcIjpcIuKJg1wiLFwiJnNpbWVxO1wiOlwi4omDXCIsXCImc2ltZztcIjpcIuKqnlwiLFwiJnNpbWdFO1wiOlwi4qqgXCIsXCImc2ltbDtcIjpcIuKqnVwiLFwiJnNpbWxFO1wiOlwi4qqfXCIsXCImc2ltbmU7XCI6XCLiiYZcIixcIiZzaW1wbHVzO1wiOlwi4qikXCIsXCImc2ltcmFycjtcIjpcIuKlslwiLFwiJnNsYXJyO1wiOlwi4oaQXCIsXCImc21hbGxzZXRtaW51cztcIjpcIuKIllwiLFwiJnNtYXNocDtcIjpcIuKos1wiLFwiJnNtZXBhcnNsO1wiOlwi4qekXCIsXCImc21pZDtcIjpcIuKIo1wiLFwiJnNtaWxlO1wiOlwi4oyjXCIsXCImc210O1wiOlwi4qqqXCIsXCImc210ZTtcIjpcIuKqrFwiLFwiJnNtdGVzO1wiOlwi4qqs77iAXCIsXCImc29mdGN5O1wiOlwi0YxcIixcIiZzb2w7XCI6XCIvXCIsXCImc29sYjtcIjpcIuKnhFwiLFwiJnNvbGJhcjtcIjpcIuKMv1wiLFwiJnNvcGY7XCI6XCLwnZWkXCIsXCImc3BhZGVzO1wiOlwi4pmgXCIsXCImc3BhZGVzdWl0O1wiOlwi4pmgXCIsXCImc3BhcjtcIjpcIuKIpVwiLFwiJnNxY2FwO1wiOlwi4oqTXCIsXCImc3FjYXBzO1wiOlwi4oqT77iAXCIsXCImc3FjdXA7XCI6XCLiipRcIixcIiZzcWN1cHM7XCI6XCLiipTvuIBcIixcIiZzcXN1YjtcIjpcIuKKj1wiLFwiJnNxc3ViZTtcIjpcIuKKkVwiLFwiJnNxc3Vic2V0O1wiOlwi4oqPXCIsXCImc3FzdWJzZXRlcTtcIjpcIuKKkVwiLFwiJnNxc3VwO1wiOlwi4oqQXCIsXCImc3FzdXBlO1wiOlwi4oqSXCIsXCImc3FzdXBzZXQ7XCI6XCLiipBcIixcIiZzcXN1cHNldGVxO1wiOlwi4oqSXCIsXCImc3F1O1wiOlwi4pahXCIsXCImc3F1YXJlO1wiOlwi4pahXCIsXCImc3F1YXJmO1wiOlwi4paqXCIsXCImc3F1ZjtcIjpcIuKWqlwiLFwiJnNyYXJyO1wiOlwi4oaSXCIsXCImc3NjcjtcIjpcIvCdk4hcIixcIiZzc2V0bW47XCI6XCLiiJZcIixcIiZzc21pbGU7XCI6XCLijKNcIixcIiZzc3RhcmY7XCI6XCLii4ZcIixcIiZzdGFyO1wiOlwi4piGXCIsXCImc3RhcmY7XCI6XCLimIVcIixcIiZzdHJhaWdodGVwc2lsb247XCI6XCLPtVwiLFwiJnN0cmFpZ2h0cGhpO1wiOlwiz5VcIixcIiZzdHJucztcIjpcIsKvXCIsXCImc3ViO1wiOlwi4oqCXCIsXCImc3ViRTtcIjpcIuKrhVwiLFwiJnN1YmRvdDtcIjpcIuKqvVwiLFwiJnN1YmU7XCI6XCLiioZcIixcIiZzdWJlZG90O1wiOlwi4quDXCIsXCImc3VibXVsdDtcIjpcIuKrgVwiLFwiJnN1Ym5FO1wiOlwi4quLXCIsXCImc3VibmU7XCI6XCLiiopcIixcIiZzdWJwbHVzO1wiOlwi4qq/XCIsXCImc3VicmFycjtcIjpcIuKluVwiLFwiJnN1YnNldDtcIjpcIuKKglwiLFwiJnN1YnNldGVxO1wiOlwi4oqGXCIsXCImc3Vic2V0ZXFxO1wiOlwi4quFXCIsXCImc3Vic2V0bmVxO1wiOlwi4oqKXCIsXCImc3Vic2V0bmVxcTtcIjpcIuKri1wiLFwiJnN1YnNpbTtcIjpcIuKrh1wiLFwiJnN1YnN1YjtcIjpcIuKrlVwiLFwiJnN1YnN1cDtcIjpcIuKrk1wiLFwiJnN1Y2M7XCI6XCLiibtcIixcIiZzdWNjYXBwcm94O1wiOlwi4qq4XCIsXCImc3VjY2N1cmx5ZXE7XCI6XCLiib1cIixcIiZzdWNjZXE7XCI6XCLiqrBcIixcIiZzdWNjbmFwcHJveDtcIjpcIuKqulwiLFwiJnN1Y2NuZXFxO1wiOlwi4qq2XCIsXCImc3VjY25zaW07XCI6XCLii6lcIixcIiZzdWNjc2ltO1wiOlwi4om/XCIsXCImc3VtO1wiOlwi4oiRXCIsXCImc3VuZztcIjpcIuKZqlwiLFwiJnN1cDFcIjpcIsK5XCIsXCImc3VwMTtcIjpcIsK5XCIsXCImc3VwMlwiOlwiwrJcIixcIiZzdXAyO1wiOlwiwrJcIixcIiZzdXAzXCI6XCLCs1wiLFwiJnN1cDM7XCI6XCLCs1wiLFwiJnN1cDtcIjpcIuKKg1wiLFwiJnN1cEU7XCI6XCLiq4ZcIixcIiZzdXBkb3Q7XCI6XCLiqr5cIixcIiZzdXBkc3ViO1wiOlwi4quYXCIsXCImc3VwZTtcIjpcIuKKh1wiLFwiJnN1cGVkb3Q7XCI6XCLiq4RcIixcIiZzdXBoc29sO1wiOlwi4p+JXCIsXCImc3VwaHN1YjtcIjpcIuKrl1wiLFwiJnN1cGxhcnI7XCI6XCLipbtcIixcIiZzdXBtdWx0O1wiOlwi4quCXCIsXCImc3VwbkU7XCI6XCLiq4xcIixcIiZzdXBuZTtcIjpcIuKKi1wiLFwiJnN1cHBsdXM7XCI6XCLiq4BcIixcIiZzdXBzZXQ7XCI6XCLiioNcIixcIiZzdXBzZXRlcTtcIjpcIuKKh1wiLFwiJnN1cHNldGVxcTtcIjpcIuKrhlwiLFwiJnN1cHNldG5lcTtcIjpcIuKKi1wiLFwiJnN1cHNldG5lcXE7XCI6XCLiq4xcIixcIiZzdXBzaW07XCI6XCLiq4hcIixcIiZzdXBzdWI7XCI6XCLiq5RcIixcIiZzdXBzdXA7XCI6XCLiq5ZcIixcIiZzd0FycjtcIjpcIuKHmVwiLFwiJnN3YXJoaztcIjpcIuKkplwiLFwiJnN3YXJyO1wiOlwi4oaZXCIsXCImc3dhcnJvdztcIjpcIuKGmVwiLFwiJnN3bndhcjtcIjpcIuKkqlwiLFwiJnN6bGlnXCI6XCLDn1wiLFwiJnN6bGlnO1wiOlwiw59cIixcIiZ0YXJnZXQ7XCI6XCLijJZcIixcIiZ0YXU7XCI6XCLPhFwiLFwiJnRicms7XCI6XCLijrRcIixcIiZ0Y2Fyb247XCI6XCLFpVwiLFwiJnRjZWRpbDtcIjpcIsWjXCIsXCImdGN5O1wiOlwi0YJcIixcIiZ0ZG90O1wiOlwi4oObXCIsXCImdGVscmVjO1wiOlwi4oyVXCIsXCImdGZyO1wiOlwi8J2UsVwiLFwiJnRoZXJlNDtcIjpcIuKItFwiLFwiJnRoZXJlZm9yZTtcIjpcIuKItFwiLFwiJnRoZXRhO1wiOlwizrhcIixcIiZ0aGV0YXN5bTtcIjpcIs+RXCIsXCImdGhldGF2O1wiOlwiz5FcIixcIiZ0aGlja2FwcHJveDtcIjpcIuKJiFwiLFwiJnRoaWNrc2ltO1wiOlwi4oi8XCIsXCImdGhpbnNwO1wiOlwi4oCJXCIsXCImdGhrYXA7XCI6XCLiiYhcIixcIiZ0aGtzaW07XCI6XCLiiLxcIixcIiZ0aG9yblwiOlwiw75cIixcIiZ0aG9ybjtcIjpcIsO+XCIsXCImdGlsZGU7XCI6XCLLnFwiLFwiJnRpbWVzXCI6XCLDl1wiLFwiJnRpbWVzO1wiOlwiw5dcIixcIiZ0aW1lc2I7XCI6XCLiiqBcIixcIiZ0aW1lc2JhcjtcIjpcIuKosVwiLFwiJnRpbWVzZDtcIjpcIuKosFwiLFwiJnRpbnQ7XCI6XCLiiK1cIixcIiZ0b2VhO1wiOlwi4qSoXCIsXCImdG9wO1wiOlwi4oqkXCIsXCImdG9wYm90O1wiOlwi4oy2XCIsXCImdG9wY2lyO1wiOlwi4quxXCIsXCImdG9wZjtcIjpcIvCdlaVcIixcIiZ0b3Bmb3JrO1wiOlwi4quaXCIsXCImdG9zYTtcIjpcIuKkqVwiLFwiJnRwcmltZTtcIjpcIuKAtFwiLFwiJnRyYWRlO1wiOlwi4oSiXCIsXCImdHJpYW5nbGU7XCI6XCLilrVcIixcIiZ0cmlhbmdsZWRvd247XCI6XCLilr9cIixcIiZ0cmlhbmdsZWxlZnQ7XCI6XCLil4NcIixcIiZ0cmlhbmdsZWxlZnRlcTtcIjpcIuKKtFwiLFwiJnRyaWFuZ2xlcTtcIjpcIuKJnFwiLFwiJnRyaWFuZ2xlcmlnaHQ7XCI6XCLilrlcIixcIiZ0cmlhbmdsZXJpZ2h0ZXE7XCI6XCLiirVcIixcIiZ0cmlkb3Q7XCI6XCLil6xcIixcIiZ0cmllO1wiOlwi4omcXCIsXCImdHJpbWludXM7XCI6XCLiqLpcIixcIiZ0cmlwbHVzO1wiOlwi4qi5XCIsXCImdHJpc2I7XCI6XCLip41cIixcIiZ0cml0aW1lO1wiOlwi4qi7XCIsXCImdHJwZXppdW07XCI6XCLij6JcIixcIiZ0c2NyO1wiOlwi8J2TiVwiLFwiJnRzY3k7XCI6XCLRhlwiLFwiJnRzaGN5O1wiOlwi0ZtcIixcIiZ0c3Ryb2s7XCI6XCLFp1wiLFwiJnR3aXh0O1wiOlwi4omsXCIsXCImdHdvaGVhZGxlZnRhcnJvdztcIjpcIuKGnlwiLFwiJnR3b2hlYWRyaWdodGFycm93O1wiOlwi4oagXCIsXCImdUFycjtcIjpcIuKHkVwiLFwiJnVIYXI7XCI6XCLipaNcIixcIiZ1YWN1dGVcIjpcIsO6XCIsXCImdWFjdXRlO1wiOlwiw7pcIixcIiZ1YXJyO1wiOlwi4oaRXCIsXCImdWJyY3k7XCI6XCLRnlwiLFwiJnVicmV2ZTtcIjpcIsWtXCIsXCImdWNpcmNcIjpcIsO7XCIsXCImdWNpcmM7XCI6XCLDu1wiLFwiJnVjeTtcIjpcItGDXCIsXCImdWRhcnI7XCI6XCLih4VcIixcIiZ1ZGJsYWM7XCI6XCLFsVwiLFwiJnVkaGFyO1wiOlwi4qWuXCIsXCImdWZpc2h0O1wiOlwi4qW+XCIsXCImdWZyO1wiOlwi8J2UslwiLFwiJnVncmF2ZVwiOlwiw7lcIixcIiZ1Z3JhdmU7XCI6XCLDuVwiLFwiJnVoYXJsO1wiOlwi4oa/XCIsXCImdWhhcnI7XCI6XCLihr5cIixcIiZ1aGJsaztcIjpcIuKWgFwiLFwiJnVsY29ybjtcIjpcIuKMnFwiLFwiJnVsY29ybmVyO1wiOlwi4oycXCIsXCImdWxjcm9wO1wiOlwi4oyPXCIsXCImdWx0cmk7XCI6XCLil7hcIixcIiZ1bWFjcjtcIjpcIsWrXCIsXCImdW1sXCI6XCLCqFwiLFwiJnVtbDtcIjpcIsKoXCIsXCImdW9nb247XCI6XCLFs1wiLFwiJnVvcGY7XCI6XCLwnZWmXCIsXCImdXBhcnJvdztcIjpcIuKGkVwiLFwiJnVwZG93bmFycm93O1wiOlwi4oaVXCIsXCImdXBoYXJwb29ubGVmdDtcIjpcIuKGv1wiLFwiJnVwaGFycG9vbnJpZ2h0O1wiOlwi4oa+XCIsXCImdXBsdXM7XCI6XCLiio5cIixcIiZ1cHNpO1wiOlwiz4VcIixcIiZ1cHNpaDtcIjpcIs+SXCIsXCImdXBzaWxvbjtcIjpcIs+FXCIsXCImdXB1cGFycm93cztcIjpcIuKHiFwiLFwiJnVyY29ybjtcIjpcIuKMnVwiLFwiJnVyY29ybmVyO1wiOlwi4oydXCIsXCImdXJjcm9wO1wiOlwi4oyOXCIsXCImdXJpbmc7XCI6XCLFr1wiLFwiJnVydHJpO1wiOlwi4pe5XCIsXCImdXNjcjtcIjpcIvCdk4pcIixcIiZ1dGRvdDtcIjpcIuKLsFwiLFwiJnV0aWxkZTtcIjpcIsWpXCIsXCImdXRyaTtcIjpcIuKWtVwiLFwiJnV0cmlmO1wiOlwi4pa0XCIsXCImdXVhcnI7XCI6XCLih4hcIixcIiZ1dW1sXCI6XCLDvFwiLFwiJnV1bWw7XCI6XCLDvFwiLFwiJnV3YW5nbGU7XCI6XCLipqdcIixcIiZ2QXJyO1wiOlwi4oeVXCIsXCImdkJhcjtcIjpcIuKrqFwiLFwiJnZCYXJ2O1wiOlwi4qupXCIsXCImdkRhc2g7XCI6XCLiiqhcIixcIiZ2YW5ncnQ7XCI6XCLippxcIixcIiZ2YXJlcHNpbG9uO1wiOlwiz7VcIixcIiZ2YXJrYXBwYTtcIjpcIs+wXCIsXCImdmFybm90aGluZztcIjpcIuKIhVwiLFwiJnZhcnBoaTtcIjpcIs+VXCIsXCImdmFycGk7XCI6XCLPllwiLFwiJnZhcnByb3B0bztcIjpcIuKInVwiLFwiJnZhcnI7XCI6XCLihpVcIixcIiZ2YXJyaG87XCI6XCLPsVwiLFwiJnZhcnNpZ21hO1wiOlwiz4JcIixcIiZ2YXJzdWJzZXRuZXE7XCI6XCLiiorvuIBcIixcIiZ2YXJzdWJzZXRuZXFxO1wiOlwi4quL77iAXCIsXCImdmFyc3Vwc2V0bmVxO1wiOlwi4oqL77iAXCIsXCImdmFyc3Vwc2V0bmVxcTtcIjpcIuKrjO+4gFwiLFwiJnZhcnRoZXRhO1wiOlwiz5FcIixcIiZ2YXJ0cmlhbmdsZWxlZnQ7XCI6XCLiirJcIixcIiZ2YXJ0cmlhbmdsZXJpZ2h0O1wiOlwi4oqzXCIsXCImdmN5O1wiOlwi0LJcIixcIiZ2ZGFzaDtcIjpcIuKKolwiLFwiJnZlZTtcIjpcIuKIqFwiLFwiJnZlZWJhcjtcIjpcIuKKu1wiLFwiJnZlZWVxO1wiOlwi4omaXCIsXCImdmVsbGlwO1wiOlwi4ouuXCIsXCImdmVyYmFyO1wiOlwifFwiLFwiJnZlcnQ7XCI6XCJ8XCIsXCImdmZyO1wiOlwi8J2Us1wiLFwiJnZsdHJpO1wiOlwi4oqyXCIsXCImdm5zdWI7XCI6XCLiioLig5JcIixcIiZ2bnN1cDtcIjpcIuKKg+KDklwiLFwiJnZvcGY7XCI6XCLwnZWnXCIsXCImdnByb3A7XCI6XCLiiJ1cIixcIiZ2cnRyaTtcIjpcIuKKs1wiLFwiJnZzY3I7XCI6XCLwnZOLXCIsXCImdnN1Ym5FO1wiOlwi4quL77iAXCIsXCImdnN1Ym5lO1wiOlwi4oqK77iAXCIsXCImdnN1cG5FO1wiOlwi4quM77iAXCIsXCImdnN1cG5lO1wiOlwi4oqL77iAXCIsXCImdnppZ3phZztcIjpcIuKmmlwiLFwiJndjaXJjO1wiOlwixbVcIixcIiZ3ZWRiYXI7XCI6XCLiqZ9cIixcIiZ3ZWRnZTtcIjpcIuKIp1wiLFwiJndlZGdlcTtcIjpcIuKJmVwiLFwiJndlaWVycDtcIjpcIuKEmFwiLFwiJndmcjtcIjpcIvCdlLRcIixcIiZ3b3BmO1wiOlwi8J2VqFwiLFwiJndwO1wiOlwi4oSYXCIsXCImd3I7XCI6XCLiiYBcIixcIiZ3cmVhdGg7XCI6XCLiiYBcIixcIiZ3c2NyO1wiOlwi8J2TjFwiLFwiJnhjYXA7XCI6XCLii4JcIixcIiZ4Y2lyYztcIjpcIuKXr1wiLFwiJnhjdXA7XCI6XCLii4NcIixcIiZ4ZHRyaTtcIjpcIuKWvVwiLFwiJnhmcjtcIjpcIvCdlLVcIixcIiZ4aEFycjtcIjpcIuKfulwiLFwiJnhoYXJyO1wiOlwi4p+3XCIsXCImeGk7XCI6XCLOvlwiLFwiJnhsQXJyO1wiOlwi4p+4XCIsXCImeGxhcnI7XCI6XCLin7VcIixcIiZ4bWFwO1wiOlwi4p+8XCIsXCImeG5pcztcIjpcIuKLu1wiLFwiJnhvZG90O1wiOlwi4qiAXCIsXCImeG9wZjtcIjpcIvCdlalcIixcIiZ4b3BsdXM7XCI6XCLiqIFcIixcIiZ4b3RpbWU7XCI6XCLiqIJcIixcIiZ4ckFycjtcIjpcIuKfuVwiLFwiJnhyYXJyO1wiOlwi4p+2XCIsXCImeHNjcjtcIjpcIvCdk41cIixcIiZ4c3FjdXA7XCI6XCLiqIZcIixcIiZ4dXBsdXM7XCI6XCLiqIRcIixcIiZ4dXRyaTtcIjpcIuKWs1wiLFwiJnh2ZWU7XCI6XCLii4FcIixcIiZ4d2VkZ2U7XCI6XCLii4BcIixcIiZ5YWN1dGVcIjpcIsO9XCIsXCImeWFjdXRlO1wiOlwiw71cIixcIiZ5YWN5O1wiOlwi0Y9cIixcIiZ5Y2lyYztcIjpcIsW3XCIsXCImeWN5O1wiOlwi0YtcIixcIiZ5ZW5cIjpcIsKlXCIsXCImeWVuO1wiOlwiwqVcIixcIiZ5ZnI7XCI6XCLwnZS2XCIsXCImeWljeTtcIjpcItGXXCIsXCImeW9wZjtcIjpcIvCdlapcIixcIiZ5c2NyO1wiOlwi8J2TjlwiLFwiJnl1Y3k7XCI6XCLRjlwiLFwiJnl1bWxcIjpcIsO/XCIsXCImeXVtbDtcIjpcIsO/XCIsXCImemFjdXRlO1wiOlwixbpcIixcIiZ6Y2Fyb247XCI6XCLFvlwiLFwiJnpjeTtcIjpcItC3XCIsXCImemRvdDtcIjpcIsW8XCIsXCImemVldHJmO1wiOlwi4oSoXCIsXCImemV0YTtcIjpcIs62XCIsXCImemZyO1wiOlwi8J2Ut1wiLFwiJnpoY3k7XCI6XCLQtlwiLFwiJnppZ3JhcnI7XCI6XCLih51cIixcIiZ6b3BmO1wiOlwi8J2Vq1wiLFwiJnpzY3I7XCI6XCLwnZOPXCIsXCImendqO1wiOlwi4oCNXCIsXCImenduajtcIjpcIuKAjFwifSxjaGFyYWN0ZXJzOntcIsOGXCI6XCImQUVsaWc7XCIsXCImXCI6XCImYW1wO1wiLFwiw4FcIjpcIiZBYWN1dGU7XCIsXCLEglwiOlwiJkFicmV2ZTtcIixcIsOCXCI6XCImQWNpcmM7XCIsXCLQkFwiOlwiJkFjeTtcIixcIvCdlIRcIjpcIiZBZnI7XCIsXCLDgFwiOlwiJkFncmF2ZTtcIixcIs6RXCI6XCImQWxwaGE7XCIsXCLEgFwiOlwiJkFtYWNyO1wiLFwi4qmTXCI6XCImQW5kO1wiLFwixIRcIjpcIiZBb2dvbjtcIixcIvCdlLhcIjpcIiZBb3BmO1wiLFwi4oGhXCI6XCImYWY7XCIsXCLDhVwiOlwiJmFuZ3N0O1wiLFwi8J2SnFwiOlwiJkFzY3I7XCIsXCLiiZRcIjpcIiZjb2xvbmVxO1wiLFwiw4NcIjpcIiZBdGlsZGU7XCIsXCLDhFwiOlwiJkF1bWw7XCIsXCLiiJZcIjpcIiZzc2V0bW47XCIsXCLiq6dcIjpcIiZCYXJ2O1wiLFwi4oyGXCI6XCImZG91YmxlYmFyd2VkZ2U7XCIsXCLQkVwiOlwiJkJjeTtcIixcIuKItVwiOlwiJmJlY2F1c2U7XCIsXCLihKxcIjpcIiZiZXJub3U7XCIsXCLOklwiOlwiJkJldGE7XCIsXCLwnZSFXCI6XCImQmZyO1wiLFwi8J2UuVwiOlwiJkJvcGY7XCIsXCLLmFwiOlwiJmJyZXZlO1wiLFwi4omOXCI6XCImYnVtcDtcIixcItCnXCI6XCImQ0hjeTtcIixcIsKpXCI6XCImY29weTtcIixcIsSGXCI6XCImQ2FjdXRlO1wiLFwi4ouSXCI6XCImQ2FwO1wiLFwi4oWFXCI6XCImREQ7XCIsXCLihK1cIjpcIiZDZnI7XCIsXCLEjFwiOlwiJkNjYXJvbjtcIixcIsOHXCI6XCImQ2NlZGlsO1wiLFwixIhcIjpcIiZDY2lyYztcIixcIuKIsFwiOlwiJkNjb25pbnQ7XCIsXCLEilwiOlwiJkNkb3Q7XCIsXCLCuFwiOlwiJmNlZGlsO1wiLFwiwrdcIjpcIiZtaWRkb3Q7XCIsXCLOp1wiOlwiJkNoaTtcIixcIuKKmVwiOlwiJm9kb3Q7XCIsXCLiipZcIjpcIiZvbWludXM7XCIsXCLiipVcIjpcIiZvcGx1cztcIixcIuKKl1wiOlwiJm90aW1lcztcIixcIuKIslwiOlwiJmN3Y29uaW50O1wiLFwi4oCdXCI6XCImcmRxdW9yO1wiLFwi4oCZXCI6XCImcnNxdW9yO1wiLFwi4oi3XCI6XCImUHJvcG9ydGlvbjtcIixcIuKptFwiOlwiJkNvbG9uZTtcIixcIuKJoVwiOlwiJmVxdWl2O1wiLFwi4oivXCI6XCImRG91YmxlQ29udG91ckludGVncmFsO1wiLFwi4oiuXCI6XCImb2ludDtcIixcIuKEglwiOlwiJmNvbXBsZXhlcztcIixcIuKIkFwiOlwiJmNvcHJvZDtcIixcIuKIs1wiOlwiJmF3Y29uaW50O1wiLFwi4qivXCI6XCImQ3Jvc3M7XCIsXCLwnZKeXCI6XCImQ3NjcjtcIixcIuKLk1wiOlwiJkN1cDtcIixcIuKJjVwiOlwiJmFzeW1wZXE7XCIsXCLipJFcIjpcIiZERG90cmFoZDtcIixcItCCXCI6XCImREpjeTtcIixcItCFXCI6XCImRFNjeTtcIixcItCPXCI6XCImRFpjeTtcIixcIuKAoVwiOlwiJmRkYWdnZXI7XCIsXCLihqFcIjpcIiZEYXJyO1wiLFwi4qukXCI6XCImRG91YmxlTGVmdFRlZTtcIixcIsSOXCI6XCImRGNhcm9uO1wiLFwi0JRcIjpcIiZEY3k7XCIsXCLiiIdcIjpcIiZuYWJsYTtcIixcIs6UXCI6XCImRGVsdGE7XCIsXCLwnZSHXCI6XCImRGZyO1wiLFwiwrRcIjpcIiZhY3V0ZTtcIixcIsuZXCI6XCImZG90O1wiLFwiy51cIjpcIiZkYmxhYztcIixcImBcIjpcIiZncmF2ZTtcIixcIsucXCI6XCImdGlsZGU7XCIsXCLii4RcIjpcIiZkaWFtb25kO1wiLFwi4oWGXCI6XCImZGQ7XCIsXCLwnZS7XCI6XCImRG9wZjtcIixcIsKoXCI6XCImdW1sO1wiLFwi4oOcXCI6XCImRG90RG90O1wiLFwi4omQXCI6XCImZXNkb3Q7XCIsXCLih5NcIjpcIiZkQXJyO1wiLFwi4oeQXCI6XCImbEFycjtcIixcIuKHlFwiOlwiJmlmZjtcIixcIuKfuFwiOlwiJnhsQXJyO1wiLFwi4p+6XCI6XCImeGhBcnI7XCIsXCLin7lcIjpcIiZ4ckFycjtcIixcIuKHklwiOlwiJnJBcnI7XCIsXCLiiqhcIjpcIiZ2RGFzaDtcIixcIuKHkVwiOlwiJnVBcnI7XCIsXCLih5VcIjpcIiZ2QXJyO1wiLFwi4oilXCI6XCImc3BhcjtcIixcIuKGk1wiOlwiJmRvd25hcnJvdztcIixcIuKkk1wiOlwiJkRvd25BcnJvd0JhcjtcIixcIuKHtVwiOlwiJmR1YXJyO1wiLFwizJFcIjpcIiZEb3duQnJldmU7XCIsXCLipZBcIjpcIiZEb3duTGVmdFJpZ2h0VmVjdG9yO1wiLFwi4qWeXCI6XCImRG93bkxlZnRUZWVWZWN0b3I7XCIsXCLihr1cIjpcIiZsaGFyZDtcIixcIuKlllwiOlwiJkRvd25MZWZ0VmVjdG9yQmFyO1wiLFwi4qWfXCI6XCImRG93blJpZ2h0VGVlVmVjdG9yO1wiLFwi4oeBXCI6XCImcmlnaHRoYXJwb29uZG93bjtcIixcIuKll1wiOlwiJkRvd25SaWdodFZlY3RvckJhcjtcIixcIuKKpFwiOlwiJnRvcDtcIixcIuKGp1wiOlwiJm1hcHN0b2Rvd247XCIsXCLwnZKfXCI6XCImRHNjcjtcIixcIsSQXCI6XCImRHN0cm9rO1wiLFwixYpcIjpcIiZFTkc7XCIsXCLDkFwiOlwiJkVUSDtcIixcIsOJXCI6XCImRWFjdXRlO1wiLFwixJpcIjpcIiZFY2Fyb247XCIsXCLDilwiOlwiJkVjaXJjO1wiLFwi0K1cIjpcIiZFY3k7XCIsXCLEllwiOlwiJkVkb3Q7XCIsXCLwnZSIXCI6XCImRWZyO1wiLFwiw4hcIjpcIiZFZ3JhdmU7XCIsXCLiiIhcIjpcIiZpc2ludjtcIixcIsSSXCI6XCImRW1hY3I7XCIsXCLil7tcIjpcIiZFbXB0eVNtYWxsU3F1YXJlO1wiLFwi4parXCI6XCImRW1wdHlWZXJ5U21hbGxTcXVhcmU7XCIsXCLEmFwiOlwiJkVvZ29uO1wiLFwi8J2UvFwiOlwiJkVvcGY7XCIsXCLOlVwiOlwiJkVwc2lsb247XCIsXCLiqbVcIjpcIiZFcXVhbDtcIixcIuKJglwiOlwiJmVzaW07XCIsXCLih4xcIjpcIiZybGhhcjtcIixcIuKEsFwiOlwiJmV4cGVjdGF0aW9uO1wiLFwi4qmzXCI6XCImRXNpbTtcIixcIs6XXCI6XCImRXRhO1wiLFwiw4tcIjpcIiZFdW1sO1wiLFwi4oiDXCI6XCImZXhpc3Q7XCIsXCLihYdcIjpcIiZleHBvbmVudGlhbGU7XCIsXCLQpFwiOlwiJkZjeTtcIixcIvCdlIlcIjpcIiZGZnI7XCIsXCLil7xcIjpcIiZGaWxsZWRTbWFsbFNxdWFyZTtcIixcIuKWqlwiOlwiJnNxdWY7XCIsXCLwnZS9XCI6XCImRm9wZjtcIixcIuKIgFwiOlwiJmZvcmFsbDtcIixcIuKEsVwiOlwiJkZzY3I7XCIsXCLQg1wiOlwiJkdKY3k7XCIsXCI+XCI6XCImZ3Q7XCIsXCLOk1wiOlwiJkdhbW1hO1wiLFwiz5xcIjpcIiZHYW1tYWQ7XCIsXCLEnlwiOlwiJkdicmV2ZTtcIixcIsSiXCI6XCImR2NlZGlsO1wiLFwixJxcIjpcIiZHY2lyYztcIixcItCTXCI6XCImR2N5O1wiLFwixKBcIjpcIiZHZG90O1wiLFwi8J2UilwiOlwiJkdmcjtcIixcIuKLmVwiOlwiJmdnZztcIixcIvCdlL5cIjpcIiZHb3BmO1wiLFwi4omlXCI6XCImZ2VxO1wiLFwi4oubXCI6XCImZ3RyZXFsZXNzO1wiLFwi4omnXCI6XCImZ2VxcTtcIixcIuKqolwiOlwiJkdyZWF0ZXJHcmVhdGVyO1wiLFwi4om3XCI6XCImZ3RybGVzcztcIixcIuKpvlwiOlwiJmdlcztcIixcIuKJs1wiOlwiJmd0cnNpbTtcIixcIvCdkqJcIjpcIiZHc2NyO1wiLFwi4omrXCI6XCImZ2c7XCIsXCLQqlwiOlwiJkhBUkRjeTtcIixcIsuHXCI6XCImY2Fyb247XCIsXCJeXCI6XCImSGF0O1wiLFwixKRcIjpcIiZIY2lyYztcIixcIuKEjFwiOlwiJlBvaW5jYXJlcGxhbmU7XCIsXCLihItcIjpcIiZoYW1pbHQ7XCIsXCLihI1cIjpcIiZxdWF0ZXJuaW9ucztcIixcIuKUgFwiOlwiJmJveGg7XCIsXCLEplwiOlwiJkhzdHJvaztcIixcIuKJj1wiOlwiJmJ1bXBlcTtcIixcItCVXCI6XCImSUVjeTtcIixcIsSyXCI6XCImSUpsaWc7XCIsXCLQgVwiOlwiJklPY3k7XCIsXCLDjVwiOlwiJklhY3V0ZTtcIixcIsOOXCI6XCImSWNpcmM7XCIsXCLQmFwiOlwiJkljeTtcIixcIsSwXCI6XCImSWRvdDtcIixcIuKEkVwiOlwiJmltYWdwYXJ0O1wiLFwiw4xcIjpcIiZJZ3JhdmU7XCIsXCLEqlwiOlwiJkltYWNyO1wiLFwi4oWIXCI6XCImaWk7XCIsXCLiiKxcIjpcIiZJbnQ7XCIsXCLiiKtcIjpcIiZpbnQ7XCIsXCLii4JcIjpcIiZ4Y2FwO1wiLFwi4oGjXCI6XCImaWM7XCIsXCLigaJcIjpcIiZpdDtcIixcIsSuXCI6XCImSW9nb247XCIsXCLwnZWAXCI6XCImSW9wZjtcIixcIs6ZXCI6XCImSW90YTtcIixcIuKEkFwiOlwiJmltYWdsaW5lO1wiLFwixKhcIjpcIiZJdGlsZGU7XCIsXCLQhlwiOlwiJkl1a2N5O1wiLFwiw49cIjpcIiZJdW1sO1wiLFwixLRcIjpcIiZKY2lyYztcIixcItCZXCI6XCImSmN5O1wiLFwi8J2UjVwiOlwiJkpmcjtcIixcIvCdlYFcIjpcIiZKb3BmO1wiLFwi8J2SpVwiOlwiJkpzY3I7XCIsXCLQiFwiOlwiJkpzZXJjeTtcIixcItCEXCI6XCImSnVrY3k7XCIsXCLQpVwiOlwiJktIY3k7XCIsXCLQjFwiOlwiJktKY3k7XCIsXCLOmlwiOlwiJkthcHBhO1wiLFwixLZcIjpcIiZLY2VkaWw7XCIsXCLQmlwiOlwiJktjeTtcIixcIvCdlI5cIjpcIiZLZnI7XCIsXCLwnZWCXCI6XCImS29wZjtcIixcIvCdkqZcIjpcIiZLc2NyO1wiLFwi0IlcIjpcIiZMSmN5O1wiLFwiPFwiOlwiJmx0O1wiLFwixLlcIjpcIiZMYWN1dGU7XCIsXCLOm1wiOlwiJkxhbWJkYTtcIixcIuKfqlwiOlwiJkxhbmc7XCIsXCLihJJcIjpcIiZsYWdyYW47XCIsXCLihp5cIjpcIiZ0d29oZWFkbGVmdGFycm93O1wiLFwixL1cIjpcIiZMY2Fyb247XCIsXCLEu1wiOlwiJkxjZWRpbDtcIixcItCbXCI6XCImTGN5O1wiLFwi4p+oXCI6XCImbGFuZ2xlO1wiLFwi4oaQXCI6XCImc2xhcnI7XCIsXCLih6RcIjpcIiZsYXJyYjtcIixcIuKHhlwiOlwiJmxyYXJyO1wiLFwi4oyIXCI6XCImbGNlaWw7XCIsXCLin6ZcIjpcIiZsb2JyaztcIixcIuKloVwiOlwiJkxlZnREb3duVGVlVmVjdG9yO1wiLFwi4oeDXCI6XCImZG93bmhhcnBvb25sZWZ0O1wiLFwi4qWZXCI6XCImTGVmdERvd25WZWN0b3JCYXI7XCIsXCLijIpcIjpcIiZsZmxvb3I7XCIsXCLihpRcIjpcIiZsZWZ0cmlnaHRhcnJvdztcIixcIuKljlwiOlwiJkxlZnRSaWdodFZlY3RvcjtcIixcIuKKo1wiOlwiJmRhc2h2O1wiLFwi4oakXCI6XCImbWFwc3RvbGVmdDtcIixcIuKlmlwiOlwiJkxlZnRUZWVWZWN0b3I7XCIsXCLiirJcIjpcIiZ2bHRyaTtcIixcIuKnj1wiOlwiJkxlZnRUcmlhbmdsZUJhcjtcIixcIuKKtFwiOlwiJnRyaWFuZ2xlbGVmdGVxO1wiLFwi4qWRXCI6XCImTGVmdFVwRG93blZlY3RvcjtcIixcIuKloFwiOlwiJkxlZnRVcFRlZVZlY3RvcjtcIixcIuKGv1wiOlwiJnVwaGFycG9vbmxlZnQ7XCIsXCLipZhcIjpcIiZMZWZ0VXBWZWN0b3JCYXI7XCIsXCLihrxcIjpcIiZsaGFydTtcIixcIuKlklwiOlwiJkxlZnRWZWN0b3JCYXI7XCIsXCLii5pcIjpcIiZsZXNzZXFndHI7XCIsXCLiiaZcIjpcIiZsZXFxO1wiLFwi4om2XCI6XCImbGc7XCIsXCLiqqFcIjpcIiZMZXNzTGVzcztcIixcIuKpvVwiOlwiJmxlcztcIixcIuKJslwiOlwiJmxzaW07XCIsXCLwnZSPXCI6XCImTGZyO1wiLFwi4ouYXCI6XCImTGw7XCIsXCLih5pcIjpcIiZsQWFycjtcIixcIsS/XCI6XCImTG1pZG90O1wiLFwi4p+1XCI6XCImeGxhcnI7XCIsXCLin7dcIjpcIiZ4aGFycjtcIixcIuKftlwiOlwiJnhyYXJyO1wiLFwi8J2Vg1wiOlwiJkxvcGY7XCIsXCLihplcIjpcIiZzd2Fycm93O1wiLFwi4oaYXCI6XCImc2VhcnJvdztcIixcIuKGsFwiOlwiJmxzaDtcIixcIsWBXCI6XCImTHN0cm9rO1wiLFwi4omqXCI6XCImbGw7XCIsXCLipIVcIjpcIiZNYXA7XCIsXCLQnFwiOlwiJk1jeTtcIixcIuKBn1wiOlwiJk1lZGl1bVNwYWNlO1wiLFwi4oSzXCI6XCImcGhtbWF0O1wiLFwi8J2UkFwiOlwiJk1mcjtcIixcIuKIk1wiOlwiJm1wO1wiLFwi8J2VhFwiOlwiJk1vcGY7XCIsXCLOnFwiOlwiJk11O1wiLFwi0IpcIjpcIiZOSmN5O1wiLFwixYNcIjpcIiZOYWN1dGU7XCIsXCLFh1wiOlwiJk5jYXJvbjtcIixcIsWFXCI6XCImTmNlZGlsO1wiLFwi0J1cIjpcIiZOY3k7XCIsXCLigItcIjpcIiZaZXJvV2lkdGhTcGFjZTtcIixcIlxcblwiOlwiJk5ld0xpbmU7XCIsXCLwnZSRXCI6XCImTmZyO1wiLFwi4oGgXCI6XCImTm9CcmVhaztcIixcIsKgXCI6XCImbmJzcDtcIixcIuKElVwiOlwiJm5hdHVyYWxzO1wiLFwi4qusXCI6XCImTm90O1wiLFwi4omiXCI6XCImbmVxdWl2O1wiLFwi4omtXCI6XCImTm90Q3VwQ2FwO1wiLFwi4oimXCI6XCImbnNwYXI7XCIsXCLiiIlcIjpcIiZub3RpbnZhO1wiLFwi4omgXCI6XCImbmU7XCIsXCLiiYLMuFwiOlwiJm5lc2ltO1wiLFwi4oiEXCI6XCImbmV4aXN0cztcIixcIuKJr1wiOlwiJm5ndHI7XCIsXCLiibFcIjpcIiZuZ2VxO1wiLFwi4omnzLhcIjpcIiZuZ2VxcTtcIixcIuKJq8y4XCI6XCImbkd0djtcIixcIuKJuVwiOlwiJm50Z2w7XCIsXCLiqb7MuFwiOlwiJm5nZXM7XCIsXCLiibVcIjpcIiZuZ3NpbTtcIixcIuKJjsy4XCI6XCImbmJ1bXA7XCIsXCLiiY/MuFwiOlwiJm5idW1wZTtcIixcIuKLqlwiOlwiJm50cmlhbmdsZWxlZnQ7XCIsXCLip4/MuFwiOlwiJk5vdExlZnRUcmlhbmdsZUJhcjtcIixcIuKLrFwiOlwiJm50cmlhbmdsZWxlZnRlcTtcIixcIuKJrlwiOlwiJm5sdDtcIixcIuKJsFwiOlwiJm5sZXE7XCIsXCLiibhcIjpcIiZudGxnO1wiLFwi4omqzLhcIjpcIiZuTHR2O1wiLFwi4qm9zLhcIjpcIiZubGVzO1wiLFwi4om0XCI6XCImbmxzaW07XCIsXCLiqqLMuFwiOlwiJk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyO1wiLFwi4qqhzLhcIjpcIiZOb3ROZXN0ZWRMZXNzTGVzcztcIixcIuKKgFwiOlwiJm5wcmVjO1wiLFwi4qqvzLhcIjpcIiZucHJlY2VxO1wiLFwi4ougXCI6XCImbnByY3VlO1wiLFwi4oiMXCI6XCImbm90bml2YTtcIixcIuKLq1wiOlwiJm50cmlhbmdsZXJpZ2h0O1wiLFwi4qeQzLhcIjpcIiZOb3RSaWdodFRyaWFuZ2xlQmFyO1wiLFwi4outXCI6XCImbnRyaWFuZ2xlcmlnaHRlcTtcIixcIuKKj8y4XCI6XCImTm90U3F1YXJlU3Vic2V0O1wiLFwi4ouiXCI6XCImbnNxc3ViZTtcIixcIuKKkMy4XCI6XCImTm90U3F1YXJlU3VwZXJzZXQ7XCIsXCLii6NcIjpcIiZuc3FzdXBlO1wiLFwi4oqC4oOSXCI6XCImdm5zdWI7XCIsXCLiiohcIjpcIiZuc3Vic2V0ZXE7XCIsXCLiioFcIjpcIiZuc3VjYztcIixcIuKqsMy4XCI6XCImbnN1Y2NlcTtcIixcIuKLoVwiOlwiJm5zY2N1ZTtcIixcIuKJv8y4XCI6XCImTm90U3VjY2VlZHNUaWxkZTtcIixcIuKKg+KDklwiOlwiJnZuc3VwO1wiLFwi4oqJXCI6XCImbnN1cHNldGVxO1wiLFwi4omBXCI6XCImbnNpbTtcIixcIuKJhFwiOlwiJm5zaW1lcTtcIixcIuKJh1wiOlwiJm5jb25nO1wiLFwi4omJXCI6XCImbmFwcHJveDtcIixcIuKIpFwiOlwiJm5zbWlkO1wiLFwi8J2SqVwiOlwiJk5zY3I7XCIsXCLDkVwiOlwiJk50aWxkZTtcIixcIs6dXCI6XCImTnU7XCIsXCLFklwiOlwiJk9FbGlnO1wiLFwiw5NcIjpcIiZPYWN1dGU7XCIsXCLDlFwiOlwiJk9jaXJjO1wiLFwi0J5cIjpcIiZPY3k7XCIsXCLFkFwiOlwiJk9kYmxhYztcIixcIvCdlJJcIjpcIiZPZnI7XCIsXCLDklwiOlwiJk9ncmF2ZTtcIixcIsWMXCI6XCImT21hY3I7XCIsXCLOqVwiOlwiJm9obTtcIixcIs6fXCI6XCImT21pY3JvbjtcIixcIvCdlYZcIjpcIiZPb3BmO1wiLFwi4oCcXCI6XCImbGRxdW87XCIsXCLigJhcIjpcIiZsc3F1bztcIixcIuKplFwiOlwiJk9yO1wiLFwi8J2SqlwiOlwiJk9zY3I7XCIsXCLDmFwiOlwiJk9zbGFzaDtcIixcIsOVXCI6XCImT3RpbGRlO1wiLFwi4qi3XCI6XCImT3RpbWVzO1wiLFwiw5ZcIjpcIiZPdW1sO1wiLFwi4oC+XCI6XCImb2xpbmU7XCIsXCLij55cIjpcIiZPdmVyQnJhY2U7XCIsXCLijrRcIjpcIiZ0YnJrO1wiLFwi4o+cXCI6XCImT3ZlclBhcmVudGhlc2lzO1wiLFwi4oiCXCI6XCImcGFydDtcIixcItCfXCI6XCImUGN5O1wiLFwi8J2Uk1wiOlwiJlBmcjtcIixcIs6mXCI6XCImUGhpO1wiLFwizqBcIjpcIiZQaTtcIixcIsKxXCI6XCImcG07XCIsXCLihJlcIjpcIiZwcmltZXM7XCIsXCLiqrtcIjpcIiZQcjtcIixcIuKJulwiOlwiJnByZWM7XCIsXCLiqq9cIjpcIiZwcmVjZXE7XCIsXCLiibxcIjpcIiZwcmVjY3VybHllcTtcIixcIuKJvlwiOlwiJnByc2ltO1wiLFwi4oCzXCI6XCImUHJpbWU7XCIsXCLiiI9cIjpcIiZwcm9kO1wiLFwi4oidXCI6XCImdnByb3A7XCIsXCLwnZKrXCI6XCImUHNjcjtcIixcIs6oXCI6XCImUHNpO1wiLCdcIic6XCImcXVvdDtcIixcIvCdlJRcIjpcIiZRZnI7XCIsXCLihJpcIjpcIiZyYXRpb25hbHM7XCIsXCLwnZKsXCI6XCImUXNjcjtcIixcIuKkkFwiOlwiJmRyYmthcm93O1wiLFwiwq5cIjpcIiZyZWc7XCIsXCLFlFwiOlwiJlJhY3V0ZTtcIixcIuKfq1wiOlwiJlJhbmc7XCIsXCLihqBcIjpcIiZ0d29oZWFkcmlnaHRhcnJvdztcIixcIuKkllwiOlwiJlJhcnJ0bDtcIixcIsWYXCI6XCImUmNhcm9uO1wiLFwixZZcIjpcIiZSY2VkaWw7XCIsXCLQoFwiOlwiJlJjeTtcIixcIuKEnFwiOlwiJnJlYWxwYXJ0O1wiLFwi4oiLXCI6XCImbml2O1wiLFwi4oeLXCI6XCImbHJoYXI7XCIsXCLipa9cIjpcIiZkdWhhcjtcIixcIs6hXCI6XCImUmhvO1wiLFwi4p+pXCI6XCImcmFuZ2xlO1wiLFwi4oaSXCI6XCImc3JhcnI7XCIsXCLih6VcIjpcIiZyYXJyYjtcIixcIuKHhFwiOlwiJnJsYXJyO1wiLFwi4oyJXCI6XCImcmNlaWw7XCIsXCLin6dcIjpcIiZyb2JyaztcIixcIuKlnVwiOlwiJlJpZ2h0RG93blRlZVZlY3RvcjtcIixcIuKHglwiOlwiJmRvd25oYXJwb29ucmlnaHQ7XCIsXCLipZVcIjpcIiZSaWdodERvd25WZWN0b3JCYXI7XCIsXCLijItcIjpcIiZyZmxvb3I7XCIsXCLiiqJcIjpcIiZ2ZGFzaDtcIixcIuKGplwiOlwiJm1hcHN0bztcIixcIuKlm1wiOlwiJlJpZ2h0VGVlVmVjdG9yO1wiLFwi4oqzXCI6XCImdnJ0cmk7XCIsXCLip5BcIjpcIiZSaWdodFRyaWFuZ2xlQmFyO1wiLFwi4oq1XCI6XCImdHJpYW5nbGVyaWdodGVxO1wiLFwi4qWPXCI6XCImUmlnaHRVcERvd25WZWN0b3I7XCIsXCLipZxcIjpcIiZSaWdodFVwVGVlVmVjdG9yO1wiLFwi4oa+XCI6XCImdXBoYXJwb29ucmlnaHQ7XCIsXCLipZRcIjpcIiZSaWdodFVwVmVjdG9yQmFyO1wiLFwi4oeAXCI6XCImcmlnaHRoYXJwb29udXA7XCIsXCLipZNcIjpcIiZSaWdodFZlY3RvckJhcjtcIixcIuKEnVwiOlwiJnJlYWxzO1wiLFwi4qWwXCI6XCImUm91bmRJbXBsaWVzO1wiLFwi4oebXCI6XCImckFhcnI7XCIsXCLihJtcIjpcIiZyZWFsaW5lO1wiLFwi4oaxXCI6XCImcnNoO1wiLFwi4qe0XCI6XCImUnVsZURlbGF5ZWQ7XCIsXCLQqVwiOlwiJlNIQ0hjeTtcIixcItCoXCI6XCImU0hjeTtcIixcItCsXCI6XCImU09GVGN5O1wiLFwixZpcIjpcIiZTYWN1dGU7XCIsXCLiqrxcIjpcIiZTYztcIixcIsWgXCI6XCImU2Nhcm9uO1wiLFwixZ5cIjpcIiZTY2VkaWw7XCIsXCLFnFwiOlwiJlNjaXJjO1wiLFwi0KFcIjpcIiZTY3k7XCIsXCLwnZSWXCI6XCImU2ZyO1wiLFwi4oaRXCI6XCImdXBhcnJvdztcIixcIs6jXCI6XCImU2lnbWE7XCIsXCLiiJhcIjpcIiZjb21wZm47XCIsXCLwnZWKXCI6XCImU29wZjtcIixcIuKImlwiOlwiJnJhZGljO1wiLFwi4pahXCI6XCImc3F1YXJlO1wiLFwi4oqTXCI6XCImc3FjYXA7XCIsXCLiio9cIjpcIiZzcXN1YnNldDtcIixcIuKKkVwiOlwiJnNxc3Vic2V0ZXE7XCIsXCLiipBcIjpcIiZzcXN1cHNldDtcIixcIuKKklwiOlwiJnNxc3Vwc2V0ZXE7XCIsXCLiipRcIjpcIiZzcWN1cDtcIixcIvCdkq5cIjpcIiZTc2NyO1wiLFwi4ouGXCI6XCImc3N0YXJmO1wiLFwi4ouQXCI6XCImU3Vic2V0O1wiLFwi4oqGXCI6XCImc3Vic2V0ZXE7XCIsXCLiibtcIjpcIiZzdWNjO1wiLFwi4qqwXCI6XCImc3VjY2VxO1wiLFwi4om9XCI6XCImc3VjY2N1cmx5ZXE7XCIsXCLiib9cIjpcIiZzdWNjc2ltO1wiLFwi4oiRXCI6XCImc3VtO1wiLFwi4ouRXCI6XCImU3Vwc2V0O1wiLFwi4oqDXCI6XCImc3Vwc2V0O1wiLFwi4oqHXCI6XCImc3Vwc2V0ZXE7XCIsXCLDnlwiOlwiJlRIT1JOO1wiLFwi4oSiXCI6XCImdHJhZGU7XCIsXCLQi1wiOlwiJlRTSGN5O1wiLFwi0KZcIjpcIiZUU2N5O1wiLFwiXFx0XCI6XCImVGFiO1wiLFwizqRcIjpcIiZUYXU7XCIsXCLFpFwiOlwiJlRjYXJvbjtcIixcIsWiXCI6XCImVGNlZGlsO1wiLFwi0KJcIjpcIiZUY3k7XCIsXCLwnZSXXCI6XCImVGZyO1wiLFwi4oi0XCI6XCImdGhlcmVmb3JlO1wiLFwizphcIjpcIiZUaGV0YTtcIixcIuKBn+KAilwiOlwiJlRoaWNrU3BhY2U7XCIsXCLigIlcIjpcIiZ0aGluc3A7XCIsXCLiiLxcIjpcIiZ0aGtzaW07XCIsXCLiiYNcIjpcIiZzaW1lcTtcIixcIuKJhVwiOlwiJmNvbmc7XCIsXCLiiYhcIjpcIiZ0aGthcDtcIixcIvCdlYtcIjpcIiZUb3BmO1wiLFwi4oObXCI6XCImdGRvdDtcIixcIvCdkq9cIjpcIiZUc2NyO1wiLFwixaZcIjpcIiZUc3Ryb2s7XCIsXCLDmlwiOlwiJlVhY3V0ZTtcIixcIuKGn1wiOlwiJlVhcnI7XCIsXCLipYlcIjpcIiZVYXJyb2NpcjtcIixcItCOXCI6XCImVWJyY3k7XCIsXCLFrFwiOlwiJlVicmV2ZTtcIixcIsObXCI6XCImVWNpcmM7XCIsXCLQo1wiOlwiJlVjeTtcIixcIsWwXCI6XCImVWRibGFjO1wiLFwi8J2UmFwiOlwiJlVmcjtcIixcIsOZXCI6XCImVWdyYXZlO1wiLFwixapcIjpcIiZVbWFjcjtcIixfOlwiJmxvd2JhcjtcIixcIuKPn1wiOlwiJlVuZGVyQnJhY2U7XCIsXCLijrVcIjpcIiZiYnJrO1wiLFwi4o+dXCI6XCImVW5kZXJQYXJlbnRoZXNpcztcIixcIuKLg1wiOlwiJnhjdXA7XCIsXCLiio5cIjpcIiZ1cGx1cztcIixcIsWyXCI6XCImVW9nb247XCIsXCLwnZWMXCI6XCImVW9wZjtcIixcIuKkklwiOlwiJlVwQXJyb3dCYXI7XCIsXCLih4VcIjpcIiZ1ZGFycjtcIixcIuKGlVwiOlwiJnZhcnI7XCIsXCLipa5cIjpcIiZ1ZGhhcjtcIixcIuKKpVwiOlwiJnBlcnA7XCIsXCLihqVcIjpcIiZtYXBzdG91cDtcIixcIuKGllwiOlwiJm53YXJyb3c7XCIsXCLihpdcIjpcIiZuZWFycm93O1wiLFwiz5JcIjpcIiZ1cHNpaDtcIixcIs6lXCI6XCImVXBzaWxvbjtcIixcIsWuXCI6XCImVXJpbmc7XCIsXCLwnZKwXCI6XCImVXNjcjtcIixcIsWoXCI6XCImVXRpbGRlO1wiLFwiw5xcIjpcIiZVdW1sO1wiLFwi4oqrXCI6XCImVkRhc2g7XCIsXCLiq6tcIjpcIiZWYmFyO1wiLFwi0JJcIjpcIiZWY3k7XCIsXCLiiqlcIjpcIiZWZGFzaDtcIixcIuKrplwiOlwiJlZkYXNobDtcIixcIuKLgVwiOlwiJnh2ZWU7XCIsXCLigJZcIjpcIiZWZXJ0O1wiLFwi4oijXCI6XCImc21pZDtcIixcInxcIjpcIiZ2ZXJ0O1wiLFwi4p2YXCI6XCImVmVydGljYWxTZXBhcmF0b3I7XCIsXCLiiYBcIjpcIiZ3cmVhdGg7XCIsXCLigIpcIjpcIiZoYWlyc3A7XCIsXCLwnZSZXCI6XCImVmZyO1wiLFwi8J2VjVwiOlwiJlZvcGY7XCIsXCLwnZKxXCI6XCImVnNjcjtcIixcIuKKqlwiOlwiJlZ2ZGFzaDtcIixcIsW0XCI6XCImV2NpcmM7XCIsXCLii4BcIjpcIiZ4d2VkZ2U7XCIsXCLwnZSaXCI6XCImV2ZyO1wiLFwi8J2VjlwiOlwiJldvcGY7XCIsXCLwnZKyXCI6XCImV3NjcjtcIixcIvCdlJtcIjpcIiZYZnI7XCIsXCLOnlwiOlwiJlhpO1wiLFwi8J2Vj1wiOlwiJlhvcGY7XCIsXCLwnZKzXCI6XCImWHNjcjtcIixcItCvXCI6XCImWUFjeTtcIixcItCHXCI6XCImWUljeTtcIixcItCuXCI6XCImWVVjeTtcIixcIsOdXCI6XCImWWFjdXRlO1wiLFwixbZcIjpcIiZZY2lyYztcIixcItCrXCI6XCImWWN5O1wiLFwi8J2UnFwiOlwiJllmcjtcIixcIvCdlZBcIjpcIiZZb3BmO1wiLFwi8J2StFwiOlwiJllzY3I7XCIsXCLFuFwiOlwiJll1bWw7XCIsXCLQllwiOlwiJlpIY3k7XCIsXCLFuVwiOlwiJlphY3V0ZTtcIixcIsW9XCI6XCImWmNhcm9uO1wiLFwi0JdcIjpcIiZaY3k7XCIsXCLFu1wiOlwiJlpkb3Q7XCIsXCLOllwiOlwiJlpldGE7XCIsXCLihKhcIjpcIiZ6ZWV0cmY7XCIsXCLihKRcIjpcIiZpbnRlZ2VycztcIixcIvCdkrVcIjpcIiZac2NyO1wiLFwiw6FcIjpcIiZhYWN1dGU7XCIsXCLEg1wiOlwiJmFicmV2ZTtcIixcIuKIvlwiOlwiJm1zdHBvcztcIixcIuKIvsyzXCI6XCImYWNFO1wiLFwi4oi/XCI6XCImYWNkO1wiLFwiw6JcIjpcIiZhY2lyYztcIixcItCwXCI6XCImYWN5O1wiLFwiw6ZcIjpcIiZhZWxpZztcIixcIvCdlJ5cIjpcIiZhZnI7XCIsXCLDoFwiOlwiJmFncmF2ZTtcIixcIuKEtVwiOlwiJmFsZXBoO1wiLFwizrFcIjpcIiZhbHBoYTtcIixcIsSBXCI6XCImYW1hY3I7XCIsXCLiqL9cIjpcIiZhbWFsZztcIixcIuKIp1wiOlwiJndlZGdlO1wiLFwi4qmVXCI6XCImYW5kYW5kO1wiLFwi4qmcXCI6XCImYW5kZDtcIixcIuKpmFwiOlwiJmFuZHNsb3BlO1wiLFwi4qmaXCI6XCImYW5kdjtcIixcIuKIoFwiOlwiJmFuZ2xlO1wiLFwi4qakXCI6XCImYW5nZTtcIixcIuKIoVwiOlwiJm1lYXN1cmVkYW5nbGU7XCIsXCLipqhcIjpcIiZhbmdtc2RhYTtcIixcIuKmqVwiOlwiJmFuZ21zZGFiO1wiLFwi4qaqXCI6XCImYW5nbXNkYWM7XCIsXCLipqtcIjpcIiZhbmdtc2RhZDtcIixcIuKmrFwiOlwiJmFuZ21zZGFlO1wiLFwi4qatXCI6XCImYW5nbXNkYWY7XCIsXCLipq5cIjpcIiZhbmdtc2RhZztcIixcIuKmr1wiOlwiJmFuZ21zZGFoO1wiLFwi4oifXCI6XCImYW5ncnQ7XCIsXCLiir5cIjpcIiZhbmdydHZiO1wiLFwi4qadXCI6XCImYW5ncnR2YmQ7XCIsXCLiiKJcIjpcIiZhbmdzcGg7XCIsXCLijbxcIjpcIiZhbmd6YXJyO1wiLFwixIVcIjpcIiZhb2dvbjtcIixcIvCdlZJcIjpcIiZhb3BmO1wiLFwi4qmwXCI6XCImYXBFO1wiLFwi4qmvXCI6XCImYXBhY2lyO1wiLFwi4omKXCI6XCImYXBwcm94ZXE7XCIsXCLiiYtcIjpcIiZhcGlkO1wiLFwiJ1wiOlwiJmFwb3M7XCIsXCLDpVwiOlwiJmFyaW5nO1wiLFwi8J2StlwiOlwiJmFzY3I7XCIsXCIqXCI6XCImbWlkYXN0O1wiLFwiw6NcIjpcIiZhdGlsZGU7XCIsXCLDpFwiOlwiJmF1bWw7XCIsXCLiqJFcIjpcIiZhd2ludDtcIixcIuKrrVwiOlwiJmJOb3Q7XCIsXCLiiYxcIjpcIiZiY29uZztcIixcIs+2XCI6XCImYmVwc2k7XCIsXCLigLVcIjpcIiZicHJpbWU7XCIsXCLiiL1cIjpcIiZic2ltO1wiLFwi4ouNXCI6XCImYnNpbWU7XCIsXCLiir1cIjpcIiZiYXJ2ZWU7XCIsXCLijIVcIjpcIiZiYXJ3ZWRnZTtcIixcIuKOtlwiOlwiJmJicmt0YnJrO1wiLFwi0LFcIjpcIiZiY3k7XCIsXCLigJ5cIjpcIiZsZHF1b3I7XCIsXCLiprBcIjpcIiZiZW1wdHl2O1wiLFwizrJcIjpcIiZiZXRhO1wiLFwi4oS2XCI6XCImYmV0aDtcIixcIuKJrFwiOlwiJnR3aXh0O1wiLFwi8J2Un1wiOlwiJmJmcjtcIixcIuKXr1wiOlwiJnhjaXJjO1wiLFwi4qiAXCI6XCImeG9kb3Q7XCIsXCLiqIFcIjpcIiZ4b3BsdXM7XCIsXCLiqIJcIjpcIiZ4b3RpbWU7XCIsXCLiqIZcIjpcIiZ4c3FjdXA7XCIsXCLimIVcIjpcIiZzdGFyZjtcIixcIuKWvVwiOlwiJnhkdHJpO1wiLFwi4pazXCI6XCImeHV0cmk7XCIsXCLiqIRcIjpcIiZ4dXBsdXM7XCIsXCLipI1cIjpcIiZyYmFycjtcIixcIuKnq1wiOlwiJmxvemY7XCIsXCLilrRcIjpcIiZ1dHJpZjtcIixcIuKWvlwiOlwiJmR0cmlmO1wiLFwi4peCXCI6XCImbHRyaWY7XCIsXCLilrhcIjpcIiZydHJpZjtcIixcIuKQo1wiOlwiJmJsYW5rO1wiLFwi4paSXCI6XCImYmxrMTI7XCIsXCLilpFcIjpcIiZibGsxNDtcIixcIuKWk1wiOlwiJmJsazM0O1wiLFwi4paIXCI6XCImYmxvY2s7XCIsXCI94oOlXCI6XCImYm5lO1wiLFwi4omh4oOlXCI6XCImYm5lcXVpdjtcIixcIuKMkFwiOlwiJmJub3Q7XCIsXCLwnZWTXCI6XCImYm9wZjtcIixcIuKLiFwiOlwiJmJvd3RpZTtcIixcIuKVl1wiOlwiJmJveERMO1wiLFwi4pWUXCI6XCImYm94RFI7XCIsXCLilZZcIjpcIiZib3hEbDtcIixcIuKVk1wiOlwiJmJveERyO1wiLFwi4pWQXCI6XCImYm94SDtcIixcIuKVplwiOlwiJmJveEhEO1wiLFwi4pWpXCI6XCImYm94SFU7XCIsXCLilaRcIjpcIiZib3hIZDtcIixcIuKVp1wiOlwiJmJveEh1O1wiLFwi4pWdXCI6XCImYm94VUw7XCIsXCLilZpcIjpcIiZib3hVUjtcIixcIuKVnFwiOlwiJmJveFVsO1wiLFwi4pWZXCI6XCImYm94VXI7XCIsXCLilZFcIjpcIiZib3hWO1wiLFwi4pWsXCI6XCImYm94Vkg7XCIsXCLilaNcIjpcIiZib3hWTDtcIixcIuKVoFwiOlwiJmJveFZSO1wiLFwi4pWrXCI6XCImYm94Vmg7XCIsXCLilaJcIjpcIiZib3hWbDtcIixcIuKVn1wiOlwiJmJveFZyO1wiLFwi4qeJXCI6XCImYm94Ym94O1wiLFwi4pWVXCI6XCImYm94ZEw7XCIsXCLilZJcIjpcIiZib3hkUjtcIixcIuKUkFwiOlwiJmJveGRsO1wiLFwi4pSMXCI6XCImYm94ZHI7XCIsXCLilaVcIjpcIiZib3hoRDtcIixcIuKVqFwiOlwiJmJveGhVO1wiLFwi4pSsXCI6XCImYm94aGQ7XCIsXCLilLRcIjpcIiZib3hodTtcIixcIuKKn1wiOlwiJm1pbnVzYjtcIixcIuKKnlwiOlwiJnBsdXNiO1wiLFwi4oqgXCI6XCImdGltZXNiO1wiLFwi4pWbXCI6XCImYm94dUw7XCIsXCLilZhcIjpcIiZib3h1UjtcIixcIuKUmFwiOlwiJmJveHVsO1wiLFwi4pSUXCI6XCImYm94dXI7XCIsXCLilIJcIjpcIiZib3h2O1wiLFwi4pWqXCI6XCImYm94dkg7XCIsXCLilaFcIjpcIiZib3h2TDtcIixcIuKVnlwiOlwiJmJveHZSO1wiLFwi4pS8XCI6XCImYm94dmg7XCIsXCLilKRcIjpcIiZib3h2bDtcIixcIuKUnFwiOlwiJmJveHZyO1wiLFwiwqZcIjpcIiZicnZiYXI7XCIsXCLwnZK3XCI6XCImYnNjcjtcIixcIuKBj1wiOlwiJmJzZW1pO1wiLFwiXFxcXFwiOlwiJmJzb2w7XCIsXCLip4VcIjpcIiZic29sYjtcIixcIuKfiFwiOlwiJmJzb2xoc3ViO1wiLFwi4oCiXCI6XCImYnVsbGV0O1wiLFwi4qquXCI6XCImYnVtcEU7XCIsXCLEh1wiOlwiJmNhY3V0ZTtcIixcIuKIqVwiOlwiJmNhcDtcIixcIuKphFwiOlwiJmNhcGFuZDtcIixcIuKpiVwiOlwiJmNhcGJyY3VwO1wiLFwi4qmLXCI6XCImY2FwY2FwO1wiLFwi4qmHXCI6XCImY2FwY3VwO1wiLFwi4qmAXCI6XCImY2FwZG90O1wiLFwi4oip77iAXCI6XCImY2FwcztcIixcIuKBgVwiOlwiJmNhcmV0O1wiLFwi4qmNXCI6XCImY2NhcHM7XCIsXCLEjVwiOlwiJmNjYXJvbjtcIixcIsOnXCI6XCImY2NlZGlsO1wiLFwixIlcIjpcIiZjY2lyYztcIixcIuKpjFwiOlwiJmNjdXBzO1wiLFwi4qmQXCI6XCImY2N1cHNzbTtcIixcIsSLXCI6XCImY2RvdDtcIixcIuKmslwiOlwiJmNlbXB0eXY7XCIsXCLColwiOlwiJmNlbnQ7XCIsXCLwnZSgXCI6XCImY2ZyO1wiLFwi0YdcIjpcIiZjaGN5O1wiLFwi4pyTXCI6XCImY2hlY2ttYXJrO1wiLFwiz4dcIjpcIiZjaGk7XCIsXCLil4tcIjpcIiZjaXI7XCIsXCLip4NcIjpcIiZjaXJFO1wiLFwiy4ZcIjpcIiZjaXJjO1wiLFwi4omXXCI6XCImY2lyZTtcIixcIuKGulwiOlwiJm9sYXJyO1wiLFwi4oa7XCI6XCImb3JhcnI7XCIsXCLik4hcIjpcIiZvUztcIixcIuKKm1wiOlwiJm9hc3Q7XCIsXCLiippcIjpcIiZvY2lyO1wiLFwi4oqdXCI6XCImb2Rhc2g7XCIsXCLiqJBcIjpcIiZjaXJmbmludDtcIixcIuKrr1wiOlwiJmNpcm1pZDtcIixcIuKnglwiOlwiJmNpcnNjaXI7XCIsXCLimaNcIjpcIiZjbHVic3VpdDtcIixcIjpcIjpcIiZjb2xvbjtcIixcIixcIjpcIiZjb21tYTtcIixcIkBcIjpcIiZjb21tYXQ7XCIsXCLiiIFcIjpcIiZjb21wbGVtZW50O1wiLFwi4qmtXCI6XCImY29uZ2RvdDtcIixcIvCdlZRcIjpcIiZjb3BmO1wiLFwi4oSXXCI6XCImY29weXNyO1wiLFwi4oa1XCI6XCImY3JhcnI7XCIsXCLinJdcIjpcIiZjcm9zcztcIixcIvCdkrhcIjpcIiZjc2NyO1wiLFwi4quPXCI6XCImY3N1YjtcIixcIuKrkVwiOlwiJmNzdWJlO1wiLFwi4quQXCI6XCImY3N1cDtcIixcIuKrklwiOlwiJmNzdXBlO1wiLFwi4ouvXCI6XCImY3Rkb3Q7XCIsXCLipLhcIjpcIiZjdWRhcnJsO1wiLFwi4qS1XCI6XCImY3VkYXJycjtcIixcIuKLnlwiOlwiJmN1cmx5ZXFwcmVjO1wiLFwi4oufXCI6XCImY3VybHllcXN1Y2M7XCIsXCLihrZcIjpcIiZjdXJ2ZWFycm93bGVmdDtcIixcIuKkvVwiOlwiJmN1bGFycnA7XCIsXCLiiKpcIjpcIiZjdXA7XCIsXCLiqYhcIjpcIiZjdXBicmNhcDtcIixcIuKphlwiOlwiJmN1cGNhcDtcIixcIuKpilwiOlwiJmN1cGN1cDtcIixcIuKKjVwiOlwiJmN1cGRvdDtcIixcIuKphVwiOlwiJmN1cG9yO1wiLFwi4oiq77iAXCI6XCImY3VwcztcIixcIuKGt1wiOlwiJmN1cnZlYXJyb3dyaWdodDtcIixcIuKkvFwiOlwiJmN1cmFycm07XCIsXCLii45cIjpcIiZjdXZlZTtcIixcIuKLj1wiOlwiJmN1d2VkO1wiLFwiwqRcIjpcIiZjdXJyZW47XCIsXCLiiLFcIjpcIiZjd2ludDtcIixcIuKMrVwiOlwiJmN5bGN0eTtcIixcIuKlpVwiOlwiJmRIYXI7XCIsXCLigKBcIjpcIiZkYWdnZXI7XCIsXCLihLhcIjpcIiZkYWxldGg7XCIsXCLigJBcIjpcIiZoeXBoZW47XCIsXCLipI9cIjpcIiZyQmFycjtcIixcIsSPXCI6XCImZGNhcm9uO1wiLFwi0LRcIjpcIiZkY3k7XCIsXCLih4pcIjpcIiZkb3duZG93bmFycm93cztcIixcIuKpt1wiOlwiJmVERG90O1wiLFwiwrBcIjpcIiZkZWc7XCIsXCLOtFwiOlwiJmRlbHRhO1wiLFwi4qaxXCI6XCImZGVtcHR5djtcIixcIuKlv1wiOlwiJmRmaXNodDtcIixcIvCdlKFcIjpcIiZkZnI7XCIsXCLimaZcIjpcIiZkaWFtcztcIixcIs+dXCI6XCImZ2FtbWFkO1wiLFwi4ouyXCI6XCImZGlzaW47XCIsXCLDt1wiOlwiJmRpdmlkZTtcIixcIuKLh1wiOlwiJmRpdm9ueDtcIixcItGSXCI6XCImZGpjeTtcIixcIuKMnlwiOlwiJmxsY29ybmVyO1wiLFwi4oyNXCI6XCImZGxjcm9wO1wiLCQ6XCImZG9sbGFyO1wiLFwi8J2VlVwiOlwiJmRvcGY7XCIsXCLiiZFcIjpcIiZlRG90O1wiLFwi4oi4XCI6XCImbWludXNkO1wiLFwi4oiUXCI6XCImcGx1c2RvO1wiLFwi4oqhXCI6XCImc2RvdGI7XCIsXCLijJ9cIjpcIiZscmNvcm5lcjtcIixcIuKMjFwiOlwiJmRyY3JvcDtcIixcIvCdkrlcIjpcIiZkc2NyO1wiLFwi0ZVcIjpcIiZkc2N5O1wiLFwi4qe2XCI6XCImZHNvbDtcIixcIsSRXCI6XCImZHN0cm9rO1wiLFwi4ouxXCI6XCImZHRkb3Q7XCIsXCLilr9cIjpcIiZ0cmlhbmdsZWRvd247XCIsXCLipqZcIjpcIiZkd2FuZ2xlO1wiLFwi0Z9cIjpcIiZkemN5O1wiLFwi4p+/XCI6XCImZHppZ3JhcnI7XCIsXCLDqVwiOlwiJmVhY3V0ZTtcIixcIuKprlwiOlwiJmVhc3RlcjtcIixcIsSbXCI6XCImZWNhcm9uO1wiLFwi4omWXCI6XCImZXFjaXJjO1wiLFwiw6pcIjpcIiZlY2lyYztcIixcIuKJlVwiOlwiJmVxY29sb247XCIsXCLRjVwiOlwiJmVjeTtcIixcIsSXXCI6XCImZWRvdDtcIixcIuKJklwiOlwiJmZhbGxpbmdkb3RzZXE7XCIsXCLwnZSiXCI6XCImZWZyO1wiLFwi4qqaXCI6XCImZWc7XCIsXCLDqFwiOlwiJmVncmF2ZTtcIixcIuKqllwiOlwiJmVxc2xhbnRndHI7XCIsXCLiqphcIjpcIiZlZ3Nkb3Q7XCIsXCLiqplcIjpcIiZlbDtcIixcIuKPp1wiOlwiJmVsaW50ZXJzO1wiLFwi4oSTXCI6XCImZWxsO1wiLFwi4qqVXCI6XCImZXFzbGFudGxlc3M7XCIsXCLiqpdcIjpcIiZlbHNkb3Q7XCIsXCLEk1wiOlwiJmVtYWNyO1wiLFwi4oiFXCI6XCImdmFybm90aGluZztcIixcIuKAhFwiOlwiJmVtc3AxMztcIixcIuKAhVwiOlwiJmVtc3AxNDtcIixcIuKAg1wiOlwiJmVtc3A7XCIsXCLFi1wiOlwiJmVuZztcIixcIuKAglwiOlwiJmVuc3A7XCIsXCLEmVwiOlwiJmVvZ29uO1wiLFwi8J2VllwiOlwiJmVvcGY7XCIsXCLii5VcIjpcIiZlcGFyO1wiLFwi4qejXCI6XCImZXBhcnNsO1wiLFwi4qmxXCI6XCImZXBsdXM7XCIsXCLOtVwiOlwiJmVwc2lsb247XCIsXCLPtVwiOlwiJnZhcmVwc2lsb247XCIsXCI9XCI6XCImZXF1YWxzO1wiLFwi4omfXCI6XCImcXVlc3RlcTtcIixcIuKpuFwiOlwiJmVxdWl2REQ7XCIsXCLip6VcIjpcIiZlcXZwYXJzbDtcIixcIuKJk1wiOlwiJnJpc2luZ2RvdHNlcTtcIixcIuKlsVwiOlwiJmVyYXJyO1wiLFwi4oSvXCI6XCImZXNjcjtcIixcIs63XCI6XCImZXRhO1wiLFwiw7BcIjpcIiZldGg7XCIsXCLDq1wiOlwiJmV1bWw7XCIsXCLigqxcIjpcIiZldXJvO1wiLFwiIVwiOlwiJmV4Y2w7XCIsXCLRhFwiOlwiJmZjeTtcIixcIuKZgFwiOlwiJmZlbWFsZTtcIixcIu+sg1wiOlwiJmZmaWxpZztcIixcIu+sgFwiOlwiJmZmbGlnO1wiLFwi76yEXCI6XCImZmZsbGlnO1wiLFwi8J2Uo1wiOlwiJmZmcjtcIixcIu+sgVwiOlwiJmZpbGlnO1wiLGZqOlwiJmZqbGlnO1wiLFwi4pmtXCI6XCImZmxhdDtcIixcIu+sglwiOlwiJmZsbGlnO1wiLFwi4paxXCI6XCImZmx0bnM7XCIsXCLGklwiOlwiJmZub2Y7XCIsXCLwnZWXXCI6XCImZm9wZjtcIixcIuKLlFwiOlwiJnBpdGNoZm9yaztcIixcIuKrmVwiOlwiJmZvcmt2O1wiLFwi4qiNXCI6XCImZnBhcnRpbnQ7XCIsXCLCvVwiOlwiJmhhbGY7XCIsXCLihZNcIjpcIiZmcmFjMTM7XCIsXCLCvFwiOlwiJmZyYWMxNDtcIixcIuKFlVwiOlwiJmZyYWMxNTtcIixcIuKFmVwiOlwiJmZyYWMxNjtcIixcIuKFm1wiOlwiJmZyYWMxODtcIixcIuKFlFwiOlwiJmZyYWMyMztcIixcIuKFllwiOlwiJmZyYWMyNTtcIixcIsK+XCI6XCImZnJhYzM0O1wiLFwi4oWXXCI6XCImZnJhYzM1O1wiLFwi4oWcXCI6XCImZnJhYzM4O1wiLFwi4oWYXCI6XCImZnJhYzQ1O1wiLFwi4oWaXCI6XCImZnJhYzU2O1wiLFwi4oWdXCI6XCImZnJhYzU4O1wiLFwi4oWeXCI6XCImZnJhYzc4O1wiLFwi4oGEXCI6XCImZnJhc2w7XCIsXCLijKJcIjpcIiZzZnJvd247XCIsXCLwnZK7XCI6XCImZnNjcjtcIixcIuKqjFwiOlwiJmd0cmVxcWxlc3M7XCIsXCLHtVwiOlwiJmdhY3V0ZTtcIixcIs6zXCI6XCImZ2FtbWE7XCIsXCLiqoZcIjpcIiZndHJhcHByb3g7XCIsXCLEn1wiOlwiJmdicmV2ZTtcIixcIsSdXCI6XCImZ2NpcmM7XCIsXCLQs1wiOlwiJmdjeTtcIixcIsShXCI6XCImZ2RvdDtcIixcIuKqqVwiOlwiJmdlc2NjO1wiLFwi4qqAXCI6XCImZ2VzZG90O1wiLFwi4qqCXCI6XCImZ2VzZG90bztcIixcIuKqhFwiOlwiJmdlc2RvdG9sO1wiLFwi4oub77iAXCI6XCImZ2VzbDtcIixcIuKqlFwiOlwiJmdlc2xlcztcIixcIvCdlKRcIjpcIiZnZnI7XCIsXCLihLdcIjpcIiZnaW1lbDtcIixcItGTXCI6XCImZ2pjeTtcIixcIuKqklwiOlwiJmdsRTtcIixcIuKqpVwiOlwiJmdsYTtcIixcIuKqpFwiOlwiJmdsajtcIixcIuKJqVwiOlwiJmduZXFxO1wiLFwi4qqKXCI6XCImZ25hcHByb3g7XCIsXCLiqohcIjpcIiZnbmVxO1wiLFwi4ounXCI6XCImZ25zaW07XCIsXCLwnZWYXCI6XCImZ29wZjtcIixcIuKEilwiOlwiJmdzY3I7XCIsXCLiqo5cIjpcIiZnc2ltZTtcIixcIuKqkFwiOlwiJmdzaW1sO1wiLFwi4qqnXCI6XCImZ3RjYztcIixcIuKpulwiOlwiJmd0Y2lyO1wiLFwi4ouXXCI6XCImZ3RyZG90O1wiLFwi4qaVXCI6XCImZ3RsUGFyO1wiLFwi4qm8XCI6XCImZ3RxdWVzdDtcIixcIuKluFwiOlwiJmd0cmFycjtcIixcIuKJqe+4gFwiOlwiJmd2bkU7XCIsXCLRilwiOlwiJmhhcmRjeTtcIixcIuKliFwiOlwiJmhhcnJjaXI7XCIsXCLihq1cIjpcIiZsZWZ0cmlnaHRzcXVpZ2Fycm93O1wiLFwi4oSPXCI6XCImcGxhbmt2O1wiLFwixKVcIjpcIiZoY2lyYztcIixcIuKZpVwiOlwiJmhlYXJ0c3VpdDtcIixcIuKAplwiOlwiJm1sZHI7XCIsXCLiirlcIjpcIiZoZXJjb247XCIsXCLwnZSlXCI6XCImaGZyO1wiLFwi4qSlXCI6XCImc2VhcmhrO1wiLFwi4qSmXCI6XCImc3dhcmhrO1wiLFwi4oe/XCI6XCImaG9hcnI7XCIsXCLiiLtcIjpcIiZob210aHQ7XCIsXCLihqlcIjpcIiZsYXJyaGs7XCIsXCLihqpcIjpcIiZyYXJyaGs7XCIsXCLwnZWZXCI6XCImaG9wZjtcIixcIuKAlVwiOlwiJmhvcmJhcjtcIixcIvCdkr1cIjpcIiZoc2NyO1wiLFwixKdcIjpcIiZoc3Ryb2s7XCIsXCLigYNcIjpcIiZoeWJ1bGw7XCIsXCLDrVwiOlwiJmlhY3V0ZTtcIixcIsOuXCI6XCImaWNpcmM7XCIsXCLQuFwiOlwiJmljeTtcIixcItC1XCI6XCImaWVjeTtcIixcIsKhXCI6XCImaWV4Y2w7XCIsXCLwnZSmXCI6XCImaWZyO1wiLFwiw6xcIjpcIiZpZ3JhdmU7XCIsXCLiqIxcIjpcIiZxaW50O1wiLFwi4oitXCI6XCImdGludDtcIixcIuKnnFwiOlwiJmlpbmZpbjtcIixcIuKEqVwiOlwiJmlpb3RhO1wiLFwixLNcIjpcIiZpamxpZztcIixcIsSrXCI6XCImaW1hY3I7XCIsXCLEsVwiOlwiJmlub2RvdDtcIixcIuKKt1wiOlwiJmltb2Y7XCIsXCLGtVwiOlwiJmltcGVkO1wiLFwi4oSFXCI6XCImaW5jYXJlO1wiLFwi4oieXCI6XCImaW5maW47XCIsXCLip51cIjpcIiZpbmZpbnRpZTtcIixcIuKKulwiOlwiJmludGVyY2FsO1wiLFwi4qiXXCI6XCImaW50bGFyaGs7XCIsXCLiqLxcIjpcIiZpcHJvZDtcIixcItGRXCI6XCImaW9jeTtcIixcIsSvXCI6XCImaW9nb247XCIsXCLwnZWaXCI6XCImaW9wZjtcIixcIs65XCI6XCImaW90YTtcIixcIsK/XCI6XCImaXF1ZXN0O1wiLFwi8J2SvlwiOlwiJmlzY3I7XCIsXCLii7lcIjpcIiZpc2luRTtcIixcIuKLtVwiOlwiJmlzaW5kb3Q7XCIsXCLii7RcIjpcIiZpc2lucztcIixcIuKLs1wiOlwiJmlzaW5zdjtcIixcIsSpXCI6XCImaXRpbGRlO1wiLFwi0ZZcIjpcIiZpdWtjeTtcIixcIsOvXCI6XCImaXVtbDtcIixcIsS1XCI6XCImamNpcmM7XCIsXCLQuVwiOlwiJmpjeTtcIixcIvCdlKdcIjpcIiZqZnI7XCIsXCLIt1wiOlwiJmptYXRoO1wiLFwi8J2Vm1wiOlwiJmpvcGY7XCIsXCLwnZK/XCI6XCImanNjcjtcIixcItGYXCI6XCImanNlcmN5O1wiLFwi0ZRcIjpcIiZqdWtjeTtcIixcIs66XCI6XCIma2FwcGE7XCIsXCLPsFwiOlwiJnZhcmthcHBhO1wiLFwixLdcIjpcIiZrY2VkaWw7XCIsXCLQulwiOlwiJmtjeTtcIixcIvCdlKhcIjpcIiZrZnI7XCIsXCLEuFwiOlwiJmtncmVlbjtcIixcItGFXCI6XCIma2hjeTtcIixcItGcXCI6XCIma2pjeTtcIixcIvCdlZxcIjpcIiZrb3BmO1wiLFwi8J2TgFwiOlwiJmtzY3I7XCIsXCLipJtcIjpcIiZsQXRhaWw7XCIsXCLipI5cIjpcIiZsQmFycjtcIixcIuKqi1wiOlwiJmxlc3NlcXFndHI7XCIsXCLipaJcIjpcIiZsSGFyO1wiLFwixLpcIjpcIiZsYWN1dGU7XCIsXCLiprRcIjpcIiZsYWVtcHR5djtcIixcIs67XCI6XCImbGFtYmRhO1wiLFwi4qaRXCI6XCImbGFuZ2Q7XCIsXCLiqoVcIjpcIiZsZXNzYXBwcm94O1wiLFwiwqtcIjpcIiZsYXF1bztcIixcIuKkn1wiOlwiJmxhcnJiZnM7XCIsXCLipJ1cIjpcIiZsYXJyZnM7XCIsXCLihqtcIjpcIiZsb29wYXJyb3dsZWZ0O1wiLFwi4qS5XCI6XCImbGFycnBsO1wiLFwi4qWzXCI6XCImbGFycnNpbTtcIixcIuKGolwiOlwiJmxlZnRhcnJvd3RhaWw7XCIsXCLiqqtcIjpcIiZsYXQ7XCIsXCLipJlcIjpcIiZsYXRhaWw7XCIsXCLiqq1cIjpcIiZsYXRlO1wiLFwi4qqt77iAXCI6XCImbGF0ZXM7XCIsXCLipIxcIjpcIiZsYmFycjtcIixcIuKdslwiOlwiJmxiYnJrO1wiLFwie1wiOlwiJmxjdWI7XCIsXCJbXCI6XCImbHNxYjtcIixcIuKmi1wiOlwiJmxicmtlO1wiLFwi4qaPXCI6XCImbGJya3NsZDtcIixcIuKmjVwiOlwiJmxicmtzbHU7XCIsXCLEvlwiOlwiJmxjYXJvbjtcIixcIsS8XCI6XCImbGNlZGlsO1wiLFwi0LtcIjpcIiZsY3k7XCIsXCLipLZcIjpcIiZsZGNhO1wiLFwi4qWnXCI6XCImbGRyZGhhcjtcIixcIuKli1wiOlwiJmxkcnVzaGFyO1wiLFwi4oayXCI6XCImbGRzaDtcIixcIuKJpFwiOlwiJmxlcTtcIixcIuKHh1wiOlwiJmxsYXJyO1wiLFwi4ouLXCI6XCImbHRocmVlO1wiLFwi4qqoXCI6XCImbGVzY2M7XCIsXCLiqb9cIjpcIiZsZXNkb3Q7XCIsXCLiqoFcIjpcIiZsZXNkb3RvO1wiLFwi4qqDXCI6XCImbGVzZG90b3I7XCIsXCLii5rvuIBcIjpcIiZsZXNnO1wiLFwi4qqTXCI6XCImbGVzZ2VzO1wiLFwi4ouWXCI6XCImbHRkb3Q7XCIsXCLipbxcIjpcIiZsZmlzaHQ7XCIsXCLwnZSpXCI6XCImbGZyO1wiLFwi4qqRXCI6XCImbGdFO1wiLFwi4qWqXCI6XCImbGhhcnVsO1wiLFwi4paEXCI6XCImbGhibGs7XCIsXCLRmVwiOlwiJmxqY3k7XCIsXCLipatcIjpcIiZsbGhhcmQ7XCIsXCLil7pcIjpcIiZsbHRyaTtcIixcIsWAXCI6XCImbG1pZG90O1wiLFwi4o6wXCI6XCImbG1vdXN0YWNoZTtcIixcIuKJqFwiOlwiJmxuZXFxO1wiLFwi4qqJXCI6XCImbG5hcHByb3g7XCIsXCLiqodcIjpcIiZsbmVxO1wiLFwi4oumXCI6XCImbG5zaW07XCIsXCLin6xcIjpcIiZsb2FuZztcIixcIuKHvVwiOlwiJmxvYXJyO1wiLFwi4p+8XCI6XCImeG1hcDtcIixcIuKGrFwiOlwiJnJhcnJscDtcIixcIuKmhVwiOlwiJmxvcGFyO1wiLFwi8J2VnVwiOlwiJmxvcGY7XCIsXCLiqK1cIjpcIiZsb3BsdXM7XCIsXCLiqLRcIjpcIiZsb3RpbWVzO1wiLFwi4oiXXCI6XCImbG93YXN0O1wiLFwi4peKXCI6XCImbG96ZW5nZTtcIixcIihcIjpcIiZscGFyO1wiLFwi4qaTXCI6XCImbHBhcmx0O1wiLFwi4qWtXCI6XCImbHJoYXJkO1wiLFwi4oCOXCI6XCImbHJtO1wiLFwi4oq/XCI6XCImbHJ0cmk7XCIsXCLigLlcIjpcIiZsc2FxdW87XCIsXCLwnZOBXCI6XCImbHNjcjtcIixcIuKqjVwiOlwiJmxzaW1lO1wiLFwi4qqPXCI6XCImbHNpbWc7XCIsXCLigJpcIjpcIiZzYnF1bztcIixcIsWCXCI6XCImbHN0cm9rO1wiLFwi4qqmXCI6XCImbHRjYztcIixcIuKpuVwiOlwiJmx0Y2lyO1wiLFwi4ouJXCI6XCImbHRpbWVzO1wiLFwi4qW2XCI6XCImbHRsYXJyO1wiLFwi4qm7XCI6XCImbHRxdWVzdDtcIixcIuKmllwiOlwiJmx0clBhcjtcIixcIuKXg1wiOlwiJnRyaWFuZ2xlbGVmdDtcIixcIuKlilwiOlwiJmx1cmRzaGFyO1wiLFwi4qWmXCI6XCImbHVydWhhcjtcIixcIuKJqO+4gFwiOlwiJmx2bkU7XCIsXCLiiLpcIjpcIiZtRERvdDtcIixcIsKvXCI6XCImc3RybnM7XCIsXCLimYJcIjpcIiZtYWxlO1wiLFwi4pygXCI6XCImbWFsdGVzZTtcIixcIuKWrlwiOlwiJm1hcmtlcjtcIixcIuKoqVwiOlwiJm1jb21tYTtcIixcItC8XCI6XCImbWN5O1wiLFwi4oCUXCI6XCImbWRhc2g7XCIsXCLwnZSqXCI6XCImbWZyO1wiLFwi4oSnXCI6XCImbWhvO1wiLFwiwrVcIjpcIiZtaWNybztcIixcIuKrsFwiOlwiJm1pZGNpcjtcIixcIuKIklwiOlwiJm1pbnVzO1wiLFwi4qiqXCI6XCImbWludXNkdTtcIixcIuKrm1wiOlwiJm1sY3A7XCIsXCLiiqdcIjpcIiZtb2RlbHM7XCIsXCLwnZWeXCI6XCImbW9wZjtcIixcIvCdk4JcIjpcIiZtc2NyO1wiLFwizrxcIjpcIiZtdTtcIixcIuKKuFwiOlwiJm11bWFwO1wiLFwi4ouZzLhcIjpcIiZuR2c7XCIsXCLiiavig5JcIjpcIiZuR3Q7XCIsXCLih41cIjpcIiZubEFycjtcIixcIuKHjlwiOlwiJm5oQXJyO1wiLFwi4ouYzLhcIjpcIiZuTGw7XCIsXCLiiarig5JcIjpcIiZuTHQ7XCIsXCLih49cIjpcIiZuckFycjtcIixcIuKKr1wiOlwiJm5WRGFzaDtcIixcIuKKrlwiOlwiJm5WZGFzaDtcIixcIsWEXCI6XCImbmFjdXRlO1wiLFwi4oig4oOSXCI6XCImbmFuZztcIixcIuKpsMy4XCI6XCImbmFwRTtcIixcIuKJi8y4XCI6XCImbmFwaWQ7XCIsXCLFiVwiOlwiJm5hcG9zO1wiLFwi4pmuXCI6XCImbmF0dXJhbDtcIixcIuKpg1wiOlwiJm5jYXA7XCIsXCLFiFwiOlwiJm5jYXJvbjtcIixcIsWGXCI6XCImbmNlZGlsO1wiLFwi4qmtzLhcIjpcIiZuY29uZ2RvdDtcIixcIuKpglwiOlwiJm5jdXA7XCIsXCLQvVwiOlwiJm5jeTtcIixcIuKAk1wiOlwiJm5kYXNoO1wiLFwi4oeXXCI6XCImbmVBcnI7XCIsXCLipKRcIjpcIiZuZWFyaGs7XCIsXCLiiZDMuFwiOlwiJm5lZG90O1wiLFwi4qSoXCI6XCImdG9lYTtcIixcIvCdlKtcIjpcIiZuZnI7XCIsXCLihq5cIjpcIiZubGVmdHJpZ2h0YXJyb3c7XCIsXCLiq7JcIjpcIiZuaHBhcjtcIixcIuKLvFwiOlwiJm5pcztcIixcIuKLulwiOlwiJm5pc2Q7XCIsXCLRmlwiOlwiJm5qY3k7XCIsXCLiiabMuFwiOlwiJm5sZXFxO1wiLFwi4oaaXCI6XCImbmxlZnRhcnJvdztcIixcIuKApVwiOlwiJm5sZHI7XCIsXCLwnZWfXCI6XCImbm9wZjtcIixcIsKsXCI6XCImbm90O1wiLFwi4ou5zLhcIjpcIiZub3RpbkU7XCIsXCLii7XMuFwiOlwiJm5vdGluZG90O1wiLFwi4ou3XCI6XCImbm90aW52YjtcIixcIuKLtlwiOlwiJm5vdGludmM7XCIsXCLii75cIjpcIiZub3RuaXZiO1wiLFwi4ou9XCI6XCImbm90bml2YztcIixcIuKrveKDpVwiOlwiJm5wYXJzbDtcIixcIuKIgsy4XCI6XCImbnBhcnQ7XCIsXCLiqJRcIjpcIiZucG9saW50O1wiLFwi4oabXCI6XCImbnJpZ2h0YXJyb3c7XCIsXCLipLPMuFwiOlwiJm5yYXJyYztcIixcIuKGncy4XCI6XCImbnJhcnJ3O1wiLFwi8J2Tg1wiOlwiJm5zY3I7XCIsXCLiioRcIjpcIiZuc3ViO1wiLFwi4quFzLhcIjpcIiZuc3Vic2V0ZXFxO1wiLFwi4oqFXCI6XCImbnN1cDtcIixcIuKrhsy4XCI6XCImbnN1cHNldGVxcTtcIixcIsOxXCI6XCImbnRpbGRlO1wiLFwizr1cIjpcIiZudTtcIixcIiNcIjpcIiZudW07XCIsXCLihJZcIjpcIiZudW1lcm87XCIsXCLigIdcIjpcIiZudW1zcDtcIixcIuKKrVwiOlwiJm52RGFzaDtcIixcIuKkhFwiOlwiJm52SGFycjtcIixcIuKJjeKDklwiOlwiJm52YXA7XCIsXCLiiqxcIjpcIiZudmRhc2g7XCIsXCLiiaXig5JcIjpcIiZudmdlO1wiLFwiPuKDklwiOlwiJm52Z3Q7XCIsXCLip55cIjpcIiZudmluZmluO1wiLFwi4qSCXCI6XCImbnZsQXJyO1wiLFwi4omk4oOSXCI6XCImbnZsZTtcIixcIjzig5JcIjpcIiZudmx0O1wiLFwi4oq04oOSXCI6XCImbnZsdHJpZTtcIixcIuKkg1wiOlwiJm52ckFycjtcIixcIuKKteKDklwiOlwiJm52cnRyaWU7XCIsXCLiiLzig5JcIjpcIiZudnNpbTtcIixcIuKHllwiOlwiJm53QXJyO1wiLFwi4qSjXCI6XCImbndhcmhrO1wiLFwi4qSnXCI6XCImbnduZWFyO1wiLFwiw7NcIjpcIiZvYWN1dGU7XCIsXCLDtFwiOlwiJm9jaXJjO1wiLFwi0L5cIjpcIiZvY3k7XCIsXCLFkVwiOlwiJm9kYmxhYztcIixcIuKouFwiOlwiJm9kaXY7XCIsXCLiprxcIjpcIiZvZHNvbGQ7XCIsXCLFk1wiOlwiJm9lbGlnO1wiLFwi4qa/XCI6XCImb2ZjaXI7XCIsXCLwnZSsXCI6XCImb2ZyO1wiLFwiy5tcIjpcIiZvZ29uO1wiLFwiw7JcIjpcIiZvZ3JhdmU7XCIsXCLip4FcIjpcIiZvZ3Q7XCIsXCLiprVcIjpcIiZvaGJhcjtcIixcIuKmvlwiOlwiJm9sY2lyO1wiLFwi4qa7XCI6XCImb2xjcm9zcztcIixcIuKngFwiOlwiJm9sdDtcIixcIsWNXCI6XCImb21hY3I7XCIsXCLPiVwiOlwiJm9tZWdhO1wiLFwizr9cIjpcIiZvbWljcm9uO1wiLFwi4qa2XCI6XCImb21pZDtcIixcIvCdlaBcIjpcIiZvb3BmO1wiLFwi4qa3XCI6XCImb3BhcjtcIixcIuKmuVwiOlwiJm9wZXJwO1wiLFwi4oioXCI6XCImdmVlO1wiLFwi4qmdXCI6XCImb3JkO1wiLFwi4oS0XCI6XCImb3NjcjtcIixcIsKqXCI6XCImb3JkZjtcIixcIsK6XCI6XCImb3JkbTtcIixcIuKKtlwiOlwiJm9yaWdvZjtcIixcIuKpllwiOlwiJm9yb3I7XCIsXCLiqZdcIjpcIiZvcnNsb3BlO1wiLFwi4qmbXCI6XCImb3J2O1wiLFwiw7hcIjpcIiZvc2xhc2g7XCIsXCLiiphcIjpcIiZvc29sO1wiLFwiw7VcIjpcIiZvdGlsZGU7XCIsXCLiqLZcIjpcIiZvdGltZXNhcztcIixcIsO2XCI6XCImb3VtbDtcIixcIuKMvVwiOlwiJm92YmFyO1wiLFwiwrZcIjpcIiZwYXJhO1wiLFwi4quzXCI6XCImcGFyc2ltO1wiLFwi4qu9XCI6XCImcGFyc2w7XCIsXCLQv1wiOlwiJnBjeTtcIixcIiVcIjpcIiZwZXJjbnQ7XCIsXCIuXCI6XCImcGVyaW9kO1wiLFwi4oCwXCI6XCImcGVybWlsO1wiLFwi4oCxXCI6XCImcGVydGVuaztcIixcIvCdlK1cIjpcIiZwZnI7XCIsXCLPhlwiOlwiJnBoaTtcIixcIs+VXCI6XCImdmFycGhpO1wiLFwi4piOXCI6XCImcGhvbmU7XCIsXCLPgFwiOlwiJnBpO1wiLFwiz5ZcIjpcIiZ2YXJwaTtcIixcIuKEjlwiOlwiJnBsYW5ja2g7XCIsXCIrXCI6XCImcGx1cztcIixcIuKoo1wiOlwiJnBsdXNhY2lyO1wiLFwi4qiiXCI6XCImcGx1c2NpcjtcIixcIuKopVwiOlwiJnBsdXNkdTtcIixcIuKpslwiOlwiJnBsdXNlO1wiLFwi4qimXCI6XCImcGx1c3NpbTtcIixcIuKop1wiOlwiJnBsdXN0d287XCIsXCLiqJVcIjpcIiZwb2ludGludDtcIixcIvCdlaFcIjpcIiZwb3BmO1wiLFwiwqNcIjpcIiZwb3VuZDtcIixcIuKqs1wiOlwiJnByRTtcIixcIuKqt1wiOlwiJnByZWNhcHByb3g7XCIsXCLiqrlcIjpcIiZwcm5hcDtcIixcIuKqtVwiOlwiJnBybkU7XCIsXCLii6hcIjpcIiZwcm5zaW07XCIsXCLigLJcIjpcIiZwcmltZTtcIixcIuKMrlwiOlwiJnByb2ZhbGFyO1wiLFwi4oySXCI6XCImcHJvZmxpbmU7XCIsXCLijJNcIjpcIiZwcm9mc3VyZjtcIixcIuKKsFwiOlwiJnBydXJlbDtcIixcIvCdk4VcIjpcIiZwc2NyO1wiLFwiz4hcIjpcIiZwc2k7XCIsXCLigIhcIjpcIiZwdW5jc3A7XCIsXCLwnZSuXCI6XCImcWZyO1wiLFwi8J2VolwiOlwiJnFvcGY7XCIsXCLigZdcIjpcIiZxcHJpbWU7XCIsXCLwnZOGXCI6XCImcXNjcjtcIixcIuKollwiOlwiJnF1YXRpbnQ7XCIsXCI/XCI6XCImcXVlc3Q7XCIsXCLipJxcIjpcIiZyQXRhaWw7XCIsXCLipaRcIjpcIiZySGFyO1wiLFwi4oi9zLFcIjpcIiZyYWNlO1wiLFwixZVcIjpcIiZyYWN1dGU7XCIsXCLiprNcIjpcIiZyYWVtcHR5djtcIixcIuKmklwiOlwiJnJhbmdkO1wiLFwi4qalXCI6XCImcmFuZ2U7XCIsXCLCu1wiOlwiJnJhcXVvO1wiLFwi4qW1XCI6XCImcmFycmFwO1wiLFwi4qSgXCI6XCImcmFycmJmcztcIixcIuKks1wiOlwiJnJhcnJjO1wiLFwi4qSeXCI6XCImcmFycmZzO1wiLFwi4qWFXCI6XCImcmFycnBsO1wiLFwi4qW0XCI6XCImcmFycnNpbTtcIixcIuKGo1wiOlwiJnJpZ2h0YXJyb3d0YWlsO1wiLFwi4oadXCI6XCImcmlnaHRzcXVpZ2Fycm93O1wiLFwi4qSaXCI6XCImcmF0YWlsO1wiLFwi4oi2XCI6XCImcmF0aW87XCIsXCLinbNcIjpcIiZyYmJyaztcIixcIn1cIjpcIiZyY3ViO1wiLFwiXVwiOlwiJnJzcWI7XCIsXCLipoxcIjpcIiZyYnJrZTtcIixcIuKmjlwiOlwiJnJicmtzbGQ7XCIsXCLippBcIjpcIiZyYnJrc2x1O1wiLFwixZlcIjpcIiZyY2Fyb247XCIsXCLFl1wiOlwiJnJjZWRpbDtcIixcItGAXCI6XCImcmN5O1wiLFwi4qS3XCI6XCImcmRjYTtcIixcIuKlqVwiOlwiJnJkbGRoYXI7XCIsXCLihrNcIjpcIiZyZHNoO1wiLFwi4patXCI6XCImcmVjdDtcIixcIuKlvVwiOlwiJnJmaXNodDtcIixcIvCdlK9cIjpcIiZyZnI7XCIsXCLipaxcIjpcIiZyaGFydWw7XCIsXCLPgVwiOlwiJnJobztcIixcIs+xXCI6XCImdmFycmhvO1wiLFwi4oeJXCI6XCImcnJhcnI7XCIsXCLii4xcIjpcIiZydGhyZWU7XCIsXCLLmlwiOlwiJnJpbmc7XCIsXCLigI9cIjpcIiZybG07XCIsXCLijrFcIjpcIiZybW91c3RhY2hlO1wiLFwi4quuXCI6XCImcm5taWQ7XCIsXCLin61cIjpcIiZyb2FuZztcIixcIuKHvlwiOlwiJnJvYXJyO1wiLFwi4qaGXCI6XCImcm9wYXI7XCIsXCLwnZWjXCI6XCImcm9wZjtcIixcIuKorlwiOlwiJnJvcGx1cztcIixcIuKotVwiOlwiJnJvdGltZXM7XCIsXCIpXCI6XCImcnBhcjtcIixcIuKmlFwiOlwiJnJwYXJndDtcIixcIuKoklwiOlwiJnJwcG9saW50O1wiLFwi4oC6XCI6XCImcnNhcXVvO1wiLFwi8J2Th1wiOlwiJnJzY3I7XCIsXCLii4pcIjpcIiZydGltZXM7XCIsXCLilrlcIjpcIiZ0cmlhbmdsZXJpZ2h0O1wiLFwi4qeOXCI6XCImcnRyaWx0cmk7XCIsXCLipahcIjpcIiZydWx1aGFyO1wiLFwi4oSeXCI6XCImcng7XCIsXCLFm1wiOlwiJnNhY3V0ZTtcIixcIuKqtFwiOlwiJnNjRTtcIixcIuKquFwiOlwiJnN1Y2NhcHByb3g7XCIsXCLFoVwiOlwiJnNjYXJvbjtcIixcIsWfXCI6XCImc2NlZGlsO1wiLFwixZ1cIjpcIiZzY2lyYztcIixcIuKqtlwiOlwiJnN1Y2NuZXFxO1wiLFwi4qq6XCI6XCImc3VjY25hcHByb3g7XCIsXCLii6lcIjpcIiZzdWNjbnNpbTtcIixcIuKok1wiOlwiJnNjcG9saW50O1wiLFwi0YFcIjpcIiZzY3k7XCIsXCLii4VcIjpcIiZzZG90O1wiLFwi4qmmXCI6XCImc2RvdGU7XCIsXCLih5hcIjpcIiZzZUFycjtcIixcIsKnXCI6XCImc2VjdDtcIixcIjtcIjpcIiZzZW1pO1wiLFwi4qSpXCI6XCImdG9zYTtcIixcIuKctlwiOlwiJnNleHQ7XCIsXCLwnZSwXCI6XCImc2ZyO1wiLFwi4pmvXCI6XCImc2hhcnA7XCIsXCLRiVwiOlwiJnNoY2hjeTtcIixcItGIXCI6XCImc2hjeTtcIixcIsKtXCI6XCImc2h5O1wiLFwiz4NcIjpcIiZzaWdtYTtcIixcIs+CXCI6XCImdmFyc2lnbWE7XCIsXCLiqapcIjpcIiZzaW1kb3Q7XCIsXCLiqp5cIjpcIiZzaW1nO1wiLFwi4qqgXCI6XCImc2ltZ0U7XCIsXCLiqp1cIjpcIiZzaW1sO1wiLFwi4qqfXCI6XCImc2ltbEU7XCIsXCLiiYZcIjpcIiZzaW1uZTtcIixcIuKopFwiOlwiJnNpbXBsdXM7XCIsXCLipbJcIjpcIiZzaW1yYXJyO1wiLFwi4qizXCI6XCImc21hc2hwO1wiLFwi4qekXCI6XCImc21lcGFyc2w7XCIsXCLijKNcIjpcIiZzc21pbGU7XCIsXCLiqqpcIjpcIiZzbXQ7XCIsXCLiqqxcIjpcIiZzbXRlO1wiLFwi4qqs77iAXCI6XCImc210ZXM7XCIsXCLRjFwiOlwiJnNvZnRjeTtcIixcIi9cIjpcIiZzb2w7XCIsXCLip4RcIjpcIiZzb2xiO1wiLFwi4oy/XCI6XCImc29sYmFyO1wiLFwi8J2VpFwiOlwiJnNvcGY7XCIsXCLimaBcIjpcIiZzcGFkZXN1aXQ7XCIsXCLiipPvuIBcIjpcIiZzcWNhcHM7XCIsXCLiipTvuIBcIjpcIiZzcWN1cHM7XCIsXCLwnZOIXCI6XCImc3NjcjtcIixcIuKYhlwiOlwiJnN0YXI7XCIsXCLiioJcIjpcIiZzdWJzZXQ7XCIsXCLiq4VcIjpcIiZzdWJzZXRlcXE7XCIsXCLiqr1cIjpcIiZzdWJkb3Q7XCIsXCLiq4NcIjpcIiZzdWJlZG90O1wiLFwi4quBXCI6XCImc3VibXVsdDtcIixcIuKri1wiOlwiJnN1YnNldG5lcXE7XCIsXCLiiopcIjpcIiZzdWJzZXRuZXE7XCIsXCLiqr9cIjpcIiZzdWJwbHVzO1wiLFwi4qW5XCI6XCImc3VicmFycjtcIixcIuKrh1wiOlwiJnN1YnNpbTtcIixcIuKrlVwiOlwiJnN1YnN1YjtcIixcIuKrk1wiOlwiJnN1YnN1cDtcIixcIuKZqlwiOlwiJnN1bmc7XCIsXCLCuVwiOlwiJnN1cDE7XCIsXCLCslwiOlwiJnN1cDI7XCIsXCLCs1wiOlwiJnN1cDM7XCIsXCLiq4ZcIjpcIiZzdXBzZXRlcXE7XCIsXCLiqr5cIjpcIiZzdXBkb3Q7XCIsXCLiq5hcIjpcIiZzdXBkc3ViO1wiLFwi4quEXCI6XCImc3VwZWRvdDtcIixcIuKfiVwiOlwiJnN1cGhzb2w7XCIsXCLiq5dcIjpcIiZzdXBoc3ViO1wiLFwi4qW7XCI6XCImc3VwbGFycjtcIixcIuKrglwiOlwiJnN1cG11bHQ7XCIsXCLiq4xcIjpcIiZzdXBzZXRuZXFxO1wiLFwi4oqLXCI6XCImc3Vwc2V0bmVxO1wiLFwi4quAXCI6XCImc3VwcGx1cztcIixcIuKriFwiOlwiJnN1cHNpbTtcIixcIuKrlFwiOlwiJnN1cHN1YjtcIixcIuKrllwiOlwiJnN1cHN1cDtcIixcIuKHmVwiOlwiJnN3QXJyO1wiLFwi4qSqXCI6XCImc3dud2FyO1wiLFwiw59cIjpcIiZzemxpZztcIixcIuKMllwiOlwiJnRhcmdldDtcIixcIs+EXCI6XCImdGF1O1wiLFwixaVcIjpcIiZ0Y2Fyb247XCIsXCLFo1wiOlwiJnRjZWRpbDtcIixcItGCXCI6XCImdGN5O1wiLFwi4oyVXCI6XCImdGVscmVjO1wiLFwi8J2UsVwiOlwiJnRmcjtcIixcIs64XCI6XCImdGhldGE7XCIsXCLPkVwiOlwiJnZhcnRoZXRhO1wiLFwiw75cIjpcIiZ0aG9ybjtcIixcIsOXXCI6XCImdGltZXM7XCIsXCLiqLFcIjpcIiZ0aW1lc2JhcjtcIixcIuKosFwiOlwiJnRpbWVzZDtcIixcIuKMtlwiOlwiJnRvcGJvdDtcIixcIuKrsVwiOlwiJnRvcGNpcjtcIixcIvCdlaVcIjpcIiZ0b3BmO1wiLFwi4quaXCI6XCImdG9wZm9yaztcIixcIuKAtFwiOlwiJnRwcmltZTtcIixcIuKWtVwiOlwiJnV0cmk7XCIsXCLiiZxcIjpcIiZ0cmllO1wiLFwi4pesXCI6XCImdHJpZG90O1wiLFwi4qi6XCI6XCImdHJpbWludXM7XCIsXCLiqLlcIjpcIiZ0cmlwbHVzO1wiLFwi4qeNXCI6XCImdHJpc2I7XCIsXCLiqLtcIjpcIiZ0cml0aW1lO1wiLFwi4o+iXCI6XCImdHJwZXppdW07XCIsXCLwnZOJXCI6XCImdHNjcjtcIixcItGGXCI6XCImdHNjeTtcIixcItGbXCI6XCImdHNoY3k7XCIsXCLFp1wiOlwiJnRzdHJvaztcIixcIuKlo1wiOlwiJnVIYXI7XCIsXCLDulwiOlwiJnVhY3V0ZTtcIixcItGeXCI6XCImdWJyY3k7XCIsXCLFrVwiOlwiJnVicmV2ZTtcIixcIsO7XCI6XCImdWNpcmM7XCIsXCLRg1wiOlwiJnVjeTtcIixcIsWxXCI6XCImdWRibGFjO1wiLFwi4qW+XCI6XCImdWZpc2h0O1wiLFwi8J2UslwiOlwiJnVmcjtcIixcIsO5XCI6XCImdWdyYXZlO1wiLFwi4paAXCI6XCImdWhibGs7XCIsXCLijJxcIjpcIiZ1bGNvcm5lcjtcIixcIuKMj1wiOlwiJnVsY3JvcDtcIixcIuKXuFwiOlwiJnVsdHJpO1wiLFwixatcIjpcIiZ1bWFjcjtcIixcIsWzXCI6XCImdW9nb247XCIsXCLwnZWmXCI6XCImdW9wZjtcIixcIs+FXCI6XCImdXBzaWxvbjtcIixcIuKHiFwiOlwiJnV1YXJyO1wiLFwi4oydXCI6XCImdXJjb3JuZXI7XCIsXCLijI5cIjpcIiZ1cmNyb3A7XCIsXCLFr1wiOlwiJnVyaW5nO1wiLFwi4pe5XCI6XCImdXJ0cmk7XCIsXCLwnZOKXCI6XCImdXNjcjtcIixcIuKLsFwiOlwiJnV0ZG90O1wiLFwixalcIjpcIiZ1dGlsZGU7XCIsXCLDvFwiOlwiJnV1bWw7XCIsXCLipqdcIjpcIiZ1d2FuZ2xlO1wiLFwi4quoXCI6XCImdkJhcjtcIixcIuKrqVwiOlwiJnZCYXJ2O1wiLFwi4qacXCI6XCImdmFuZ3J0O1wiLFwi4oqK77iAXCI6XCImdnN1Ym5lO1wiLFwi4quL77iAXCI6XCImdnN1Ym5FO1wiLFwi4oqL77iAXCI6XCImdnN1cG5lO1wiLFwi4quM77iAXCI6XCImdnN1cG5FO1wiLFwi0LJcIjpcIiZ2Y3k7XCIsXCLiirtcIjpcIiZ2ZWViYXI7XCIsXCLiiZpcIjpcIiZ2ZWVlcTtcIixcIuKLrlwiOlwiJnZlbGxpcDtcIixcIvCdlLNcIjpcIiZ2ZnI7XCIsXCLwnZWnXCI6XCImdm9wZjtcIixcIvCdk4tcIjpcIiZ2c2NyO1wiLFwi4qaaXCI6XCImdnppZ3phZztcIixcIsW1XCI6XCImd2NpcmM7XCIsXCLiqZ9cIjpcIiZ3ZWRiYXI7XCIsXCLiiZlcIjpcIiZ3ZWRnZXE7XCIsXCLihJhcIjpcIiZ3cDtcIixcIvCdlLRcIjpcIiZ3ZnI7XCIsXCLwnZWoXCI6XCImd29wZjtcIixcIvCdk4xcIjpcIiZ3c2NyO1wiLFwi8J2UtVwiOlwiJnhmcjtcIixcIs6+XCI6XCImeGk7XCIsXCLii7tcIjpcIiZ4bmlzO1wiLFwi8J2VqVwiOlwiJnhvcGY7XCIsXCLwnZONXCI6XCImeHNjcjtcIixcIsO9XCI6XCImeWFjdXRlO1wiLFwi0Y9cIjpcIiZ5YWN5O1wiLFwixbdcIjpcIiZ5Y2lyYztcIixcItGLXCI6XCImeWN5O1wiLFwiwqVcIjpcIiZ5ZW47XCIsXCLwnZS2XCI6XCImeWZyO1wiLFwi0ZdcIjpcIiZ5aWN5O1wiLFwi8J2VqlwiOlwiJnlvcGY7XCIsXCLwnZOOXCI6XCImeXNjcjtcIixcItGOXCI6XCImeXVjeTtcIixcIsO/XCI6XCImeXVtbDtcIixcIsW6XCI6XCImemFjdXRlO1wiLFwixb5cIjpcIiZ6Y2Fyb247XCIsXCLQt1wiOlwiJnpjeTtcIixcIsW8XCI6XCImemRvdDtcIixcIs62XCI6XCImemV0YTtcIixcIvCdlLdcIjpcIiZ6ZnI7XCIsXCLQtlwiOlwiJnpoY3k7XCIsXCLih51cIjpcIiZ6aWdyYXJyO1wiLFwi8J2Vq1wiOlwiJnpvcGY7XCIsXCLwnZOPXCI6XCImenNjcjtcIixcIuKAjVwiOlwiJnp3ajtcIixcIuKAjFwiOlwiJnp3bmo7XCJ9fX07IiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzLm51bWVyaWNVbmljb2RlTWFwPXswOjY1NTMzLDEyODo4MzY0LDEzMDo4MjE4LDEzMTo0MDIsMTMyOjgyMjIsMTMzOjgyMzAsMTM0OjgyMjQsMTM1OjgyMjUsMTM2OjcxMCwxMzc6ODI0MCwxMzg6MzUyLDEzOTo4MjQ5LDE0MDozMzgsMTQyOjM4MSwxNDU6ODIxNiwxNDY6ODIxNywxNDc6ODIyMCwxNDg6ODIyMSwxNDk6ODIyNiwxNTA6ODIxMSwxNTE6ODIxMiwxNTI6NzMyLDE1Mzo4NDgyLDE1NDozNTMsMTU1OjgyNTAsMTU2OjMzOSwxNTg6MzgyLDE1OTozNzZ9OyIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0cy5mcm9tQ29kZVBvaW50PVN0cmluZy5mcm9tQ29kZVBvaW50fHxmdW5jdGlvbihhc3RyYWxDb2RlUG9pbnQpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGguZmxvb3IoKGFzdHJhbENvZGVQb2ludC02NTUzNikvMTAyNCkrNTUyOTYsKGFzdHJhbENvZGVQb2ludC02NTUzNiklMTAyNCs1NjMyMCl9O2V4cG9ydHMuZ2V0Q29kZVBvaW50PVN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQ/ZnVuY3Rpb24oaW5wdXQscG9zaXRpb24pe3JldHVybiBpbnB1dC5jb2RlUG9pbnRBdChwb3NpdGlvbil9OmZ1bmN0aW9uKGlucHV0LHBvc2l0aW9uKXtyZXR1cm4oaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbiktNTUyOTYpKjEwMjQraW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbisxKS01NjMyMCs2NTUzNn07ZXhwb3J0cy5oaWdoU3Vycm9nYXRlRnJvbT01NTI5NjtleHBvcnRzLmhpZ2hTdXJyb2dhdGVUbz01NjMxOTsiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mb3JFYWNoJyk7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMjEnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcbiAgICAgIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJyxcbiAgICAgIElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQgPSAnSW52YWxpZCBgdmFyaWFibGVgIG9wdGlvbiBwYXNzZWQgaW50byBgXy50ZW1wbGF0ZWAnO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbiAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xuICB2YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy8sXG4gICAgICByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLFxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gdmFsaWRhdGUgdGhlIGB2YWxpZGF0ZWAgb3B0aW9uIGluIGBfLnRlbXBsYXRlYCB2YXJpYWJsZS5cbiAgICpcbiAgICogRm9yYmlkcyBjaGFyYWN0ZXJzIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGNoYW5nZSB0aGUgbWVhbmluZyBvZiB0aGUgZnVuY3Rpb24gYXJndW1lbnQgZGVmaW5pdGlvbjpcbiAgICogLSBcIigpLFwiIChtb2RpZmljYXRpb24gb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAgICogLSBcIj1cIiAoZGVmYXVsdCB2YWx1ZSlcbiAgICogLSBcIltde31cIiAoZGVzdHJ1Y3R1cmluZyBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICAgKiAtIFwiL1wiIChiZWdpbm5pbmcgb2YgYSBjb21tZW50KVxuICAgKiAtIHdoaXRlc3BhY2VcbiAgICovXG4gIHZhciByZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycyA9IC9bKCk9LHt9XFxbXFxdXFwvXFxzXS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxLFxuICAgICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG4gIHZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xuICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICAgIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICByc0RpZ2l0cyxcbiAgICByc0Vtb2ppXG4gIF0uam9pbignfCcpLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG4gIHZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXAnLCAnTWF0aCcsICdPYmplY3QnLFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcycsXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAgICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAgICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAgICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAgICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAgICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAgICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCJcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG4gIHZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgIH1cblxuICAgICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCkpO1xuXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG4gIHZhciBub2RlSXNBcnJheUJ1ZmZlciA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzQXJyYXlCdWZmZXIsXG4gICAgICBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlLFxuICAgICAgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXG4gICAgICBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cCxcbiAgICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgIH1cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIHZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgOiAocmVzdWx0ICsgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAgICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgICAgOiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgdmFyIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAyNTYgLSBgXy5hcnlgXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgICAgIH1cbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBmbGlwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxpcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZsaXBwZWQgPSBfLmZsaXAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gWydkJywgJ2MnLCAnYicsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfRkxJUF9GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAqXG4gICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqXG4gICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKlxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50cyB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgW3NxdWFyZSwgZG91YmxlZF0pO1xuICAgICAqXG4gICAgICogZnVuYyg5LCAzKTtcbiAgICAgKiAvLyA9PiBbODEsIDZdXG4gICAgICpcbiAgICAgKiBmdW5jKDEwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTAwLCAxMF1cbiAgICAgKi9cbiAgICB2YXIgb3ZlckFyZ3MgPSBjYXN0UmVzdChmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gKHRyYW5zZm9ybXMubGVuZ3RoID09IDEgJiYgaXNBcnJheSh0cmFuc2Zvcm1zWzBdKSlcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXG4gICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4odHJhbnNmb3JtcywgMSksIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXhlcyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAgICAgKiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXG4gICAgICogW2BGdW5jdGlvbiNhcHBseWBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vbWRuLmlvL3NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gICAgICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAgICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMjsgfSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gICAgICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICAgICAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuOC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIuIEFuIGludGVnZXIgaXMgc2FmZSBpZiBpdCdzIGFuIElFRUUtNzU0XG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIDAsIE1BWF9BUlJBWV9MRU5HVEgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b051bWJlcigzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAgICAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgICAgIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJylcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGEgZm9yYmlkZGVuIGNoYXJhY3RlciB3YXMgZm91bmQgaW4gYHZhcmlhYmxlYCwgdG8gcHJldmVudFxuICAgICAgLy8gcG90ZW50aWFsIGNvbW1hbmQgaW5qZWN0aW9uIGF0dGFja3MuXG4gICAgICBlbHNlIGlmIChyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycy50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gYmFzZVRyaW0oc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRW5kKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJTeW1ib2xzXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHRvSXRlcmF0ZWUgPSBnZXRJdGVyYXRlZSgpO1xuXG4gICAgICBwYWlycyA9ICFsZW5ndGggPyBbXSA6IGFycmF5TWFwKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFpclsxXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdG9JdGVyYXRlZShwYWlyWzBdKSwgcGFpclsxXV07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkocGFpclsxXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBwcmVkaWNhdGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCByZXR1cm5pbmcgYHRydWVgIGlmXG4gICAgICogYWxsIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNUb2Agd2l0aFxuICAgICAqIGBzb3VyY2VgIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDIsICdiJzogMSB9LFxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8uY29uZm9ybXMoeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxuICAgICAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcbiAgICAgKiBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8oMSwgMTApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbnNcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93UmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KFtfLmFkZCwgc3F1YXJlXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoW3NxdWFyZSwgXy5hZGRdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lLCB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAgICAqIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYCBpcyBhbiBhcnJheSBvciBvYmplY3QsIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZSh7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCBfLml0ZXJhdGVlKCd1c2VyJykpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGN1c3RvbSBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqIF8uaXRlcmF0ZWUgPSBfLndyYXAoXy5pdGVyYXRlZSwgZnVuY3Rpb24oaXRlcmF0ZWUsIGZ1bmMpIHtcbiAgICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICAgIHJldHVybiBmdW5jLnRlc3Qoc3RyaW5nKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbJ2FiYycsICdkZWYnXSwgL2VmLyk7XG4gICAgICogLy8gPT4gWydkZWYnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiYXNlSXRlcmF0ZWUodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyA/IGZ1bmMgOiBiYXNlQ2xvbmUoZnVuYywgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5tYXRjaGVzKHsgJ2EnOiA0LCAnYyc6IDYgfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgXy5tYXRjaGVzKHsgJ2EnOiA0IH0pXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDEpLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgbWF0Y2hlc0Z1bmMgPSBfLm92ZXJTb21lKFt7ICdhJzogMSB9LCB7ICdhJzogMiB9XSlcbiAgICAgKiB2YXIgbWF0Y2hlc1Byb3BlcnR5RnVuYyA9IF8ub3ZlclNvbWUoW1snYScsIDFdLCBbJ2EnLCAyXV0pXG4gICAgICovXG4gICAgdmFyIG92ZXJTb21lID0gY3JlYXRlT3ZlcihhcnJheVNvbWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKC00KTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yYW5nZWAgZXhjZXB0IHRoYXQgaXQgcG9wdWxhdGVzIHZhbHVlcyBpblxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xuICAgICAqIC8vID0+IFszLCAyLCAxLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcbiAgICAgKiAvLyA9PiBbNCwgMywgMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzE1LCAxMCwgNSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlN0cmluZyk7XG4gICAgICogLy8gPT4gWycnLCAnJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICAgICAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICAgICAqXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUpO1xuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xuICAgICAqIC8vID0+IDEuNVxuICAgICAqL1xuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4QnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpZXIgVGhlIGZpcnN0IG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xuICAgICAqIC8vID0+IDI0XG4gICAgICovXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsaWVyICogbXVsdGlwbGljYW5kO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zdW1gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xuICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xuICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XG4gICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgIGxvZGFzaC5vdmVyRXZlcnkgPSBvdmVyRXZlcnk7XG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBpY2tCeSA9IHBpY2tCeTtcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgIGxvZGFzaC5wdWxsQWxsV2l0aCA9IHB1bGxBbGxXaXRoO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJhbmdlUmlnaHQgPSByYW5nZVJpZ2h0O1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIGxvZGFzaC5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcSA9IHNvcnRlZFVuaXE7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2gudG9QYXRoID0gdG9QYXRoO1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmFyeSA9IHVuYXJ5O1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICBsb2Rhc2gudW5pb25XaXRoID0gdW5pb25XaXRoO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgIGxvZGFzaC51bmlxV2l0aCA9IHVuaXFXaXRoO1xuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnhvckJ5ID0geG9yQnk7XG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xhbXAgPSBjbGFtcDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jbG9uZURlZXBXaXRoID0gY2xvbmVEZWVwV2l0aDtcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXEgPSBlcTtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3Q7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG4gICAgbG9kYXNoLmlzTGVuZ3RoID0gaXNMZW5ndGg7XG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc01hdGNoV2l0aCA9IGlzTWF0Y2hXaXRoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xuICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcbiAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4T2YgPSBzb3J0ZWRJbmRleE9mO1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleE9mID0gc29ydGVkTGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcbiAgICBsb2Rhc2gudG9JbnRlZ2VyID0gdG9JbnRlZ2VyO1xuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcbiAgICBsb2Rhc2gudG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgbG9kYXNoLnRvVXBwZXIgPSB0b1VwcGVyO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XG4gICAgbG9kYXNoLnRyaW1TdGFydCA9IHRyaW1TdGFydDtcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihuLCByZXN1bHQuX190YWtlQ291bnRfXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcbiAgICAgICAgICAgICdzaXplJzogbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpLFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHIHx8IHR5cGUgPT0gTEFaWV9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXG4gICAgICAgICAgJ3R5cGUnOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZExhc3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gdG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtpc1Rha2VyID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICAgIHJldHVybiAoaXNUYWtlciAmJiBjaGFpbkFsbCkgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgcmV0dXJuIGlzVW53cmFwcGVkID8gKGlzVGFrZXIgPyByZXN1bHQudmFsdWUoKVswXSA6IHJlc3VsdC52YWx1ZSgpKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IGxvZGFzaEZ1bmMubmFtZSArICcnO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCBrZXkpKSB7XG4gICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZWFsTmFtZXNba2V5XS5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XG4gICAgICAnbmFtZSc6ICd3cmFwcGVyJyxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbiBzZXF1ZW5jZSBtZXRob2RzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgbGF6eSBhbGlhc2VzLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XG5cbiAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XG4gICAgfVxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qXG4gIGVzbGludC1kaXNhYmxlXG4gIG5vLWNvbnNvbGUsXG4gIGZ1bmMtbmFtZXNcbiovXG52YXIgbm9ybWFsaXplVXJsID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXVybFwiKTtcblxudmFyIHNyY0J5TW9kdWxlSWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIG5vRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCI7XG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgdGltZSkge1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiBmdW5jdGlvbkNhbGwoKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfTtcblxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbkNhbGwsIHRpbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFVybChtb2R1bGVJZCkge1xuICB2YXIgc3JjID0gc3JjQnlNb2R1bGVJZFttb2R1bGVJZF07XG5cbiAgaWYgKCFzcmMpIHtcbiAgICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgICAgc3JjID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG4gICAgICB2YXIgbGFzdFNjcmlwdFRhZyA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGxhc3RTY3JpcHRUYWcpIHtcbiAgICAgICAgc3JjID0gbGFzdFNjcmlwdFRhZy5zcmM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3JjQnlNb2R1bGVJZFttb2R1bGVJZF0gPSBzcmM7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZpbGVNYXApIHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHNwbGl0UmVzdWx0ID0gc3JjLnNwbGl0KC8oW15cXFxcL10rKVxcLmpzJC8pO1xuICAgIHZhciBmaWxlbmFtZSA9IHNwbGl0UmVzdWx0ICYmIHNwbGl0UmVzdWx0WzFdO1xuXG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgcmV0dXJuIFtzcmMucmVwbGFjZShcIi5qc1wiLCBcIi5jc3NcIildO1xuICAgIH1cblxuICAgIGlmICghZmlsZU1hcCkge1xuICAgICAgcmV0dXJuIFtzcmMucmVwbGFjZShcIi5qc1wiLCBcIi5jc3NcIildO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxlTWFwLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24gKG1hcFJ1bGUpIHtcbiAgICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KGZpbGVuYW1lLCBcIlxcXFwuanMkXCIpLCBcImdcIik7XG4gICAgICByZXR1cm4gbm9ybWFsaXplVXJsKHNyYy5yZXBsYWNlKHJlZywgXCJcIi5jb25jYXQobWFwUnVsZS5yZXBsYWNlKC97ZmlsZU5hbWV9L2csIGZpbGVuYW1lKSwgXCIuY3NzXCIpKSk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNzcyhlbCwgdXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgaWYgKCFlbC5ocmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG4gICAgdXJsID0gZWwuaHJlZi5zcGxpdChcIj9cIilbMF07XG4gIH1cblxuICBpZiAoIWlzVXJsUmVxdWVzdCh1cmwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsLmlzTG9hZGVkID09PSBmYWxzZSkge1xuICAgIC8vIFdlIHNlZW0gdG8gYmUgYWJvdXQgdG8gcmVwbGFjZSBhIGNzcyBsaW5rIHRoYXQgaGFzbid0IGxvYWRlZCB5ZXQuXG4gICAgLy8gV2UncmUgcHJvYmFibHkgY2hhbmdpbmcgdGhlIHNhbWUgZmlsZSBtb3JlIHRoYW4gb25jZS5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXVybCB8fCAhKHVybC5pbmRleE9mKFwiLmNzc1wiKSA+IC0xKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblxuXG4gIGVsLnZpc2l0ZWQgPSB0cnVlO1xuICB2YXIgbmV3RWwgPSBlbC5jbG9uZU5vZGUoKTtcbiAgbmV3RWwuaXNMb2FkZWQgPSBmYWxzZTtcbiAgbmV3RWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChuZXdFbC5pc0xvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5ld0VsLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfSk7XG4gIG5ld0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG5ld0VsLmlzTG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV3RWwuaXNMb2FkZWQgPSB0cnVlO1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9KTtcbiAgbmV3RWwuaHJlZiA9IFwiXCIuY29uY2F0KHVybCwgXCI/XCIpLmNvbmNhdChEYXRlLm5vdygpKTtcblxuICBpZiAoZWwubmV4dFNpYmxpbmcpIHtcbiAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdFbCwgZWwubmV4dFNpYmxpbmcpO1xuICB9IGVsc2Uge1xuICAgIGVsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobmV3RWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlbG9hZFVybChocmVmLCBzcmMpIHtcbiAgdmFyIHJldDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cbiAgaHJlZiA9IG5vcm1hbGl6ZVVybChocmVmLCB7XG4gICAgc3RyaXBXV1c6IGZhbHNlXG4gIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG5cbiAgc3JjLnNvbWUoZnVuY3Rpb24gKHVybCkge1xuICAgIGlmIChocmVmLmluZGV4T2Yoc3JjKSA+IC0xKSB7XG4gICAgICByZXQgPSB1cmw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gcmVsb2FkU3R5bGUoc3JjKSB7XG4gIGlmICghc3JjKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7XG4gIHZhciBsb2FkZWQgPSBmYWxzZTtcbiAgZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoIWVsLmhyZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXJsID0gZ2V0UmVsb2FkVXJsKGVsLmhyZWYsIHNyYyk7XG5cbiAgICBpZiAoIWlzVXJsUmVxdWVzdCh1cmwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsLnZpc2l0ZWQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXJsKSB7XG4gICAgICB1cGRhdGVDc3MoZWwsIHVybCk7XG4gICAgICBsb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsb2FkZWQ7XG59XG5cbmZ1bmN0aW9uIHJlbG9hZEFsbCgpIHtcbiAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7XG4gIGZvckVhY2guY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLnZpc2l0ZWQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVDc3MoZWwpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KHVybCkge1xuICAvLyBBbiBVUkwgaXMgbm90IGFuIHJlcXVlc3QgaWZcbiAgLy8gSXQgaXMgbm90IGh0dHAgb3IgaHR0cHNcbiAgaWYgKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kdWxlSWQsIG9wdGlvbnMpIHtcbiAgaWYgKG5vRG9jdW1lbnQpIHtcbiAgICBjb25zb2xlLmxvZyhcIm5vIHdpbmRvdy5kb2N1bWVudCBmb3VuZCwgd2lsbCBub3QgSE1SIENTU1wiKTtcbiAgICByZXR1cm4gbm9vcDtcbiAgfVxuXG4gIHZhciBnZXRTY3JpcHRTcmMgPSBnZXRDdXJyZW50U2NyaXB0VXJsKG1vZHVsZUlkKTtcblxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIHNyYyA9IGdldFNjcmlwdFNyYyhvcHRpb25zLmZpbGVuYW1lKTtcbiAgICB2YXIgcmVsb2FkZWQgPSByZWxvYWRTdHlsZShzcmMpO1xuXG4gICAgaWYgKG9wdGlvbnMubG9jYWxzKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtcbiAgICAgIHJlbG9hZEFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZWxvYWRlZCkge1xuICAgICAgY29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsIHNyYy5qb2luKFwiIFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW0hNUl0gUmVsb2FkIGFsbCBjc3NcIik7XG4gICAgICByZWxvYWRBbGwoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVib3VuY2UodXBkYXRlLCA1MCk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsKHBhdGhDb21wb25lbnRzKSB7XG4gIHJldHVybiBwYXRoQ29tcG9uZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBpdGVtKSB7XG4gICAgc3dpdGNoIChpdGVtKSB7XG4gICAgICBjYXNlIFwiLi5cIjpcbiAgICAgICAgYWNjdW11bGF0b3IucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiLlwiOlxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYWNjdW11bGF0b3IucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH0sIFtdKS5qb2luKFwiL1wiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsU3RyaW5nKSB7XG4gIHVybFN0cmluZyA9IHVybFN0cmluZy50cmltKCk7XG5cbiAgaWYgKC9eZGF0YTovaS50ZXN0KHVybFN0cmluZykpIHtcbiAgICByZXR1cm4gdXJsU3RyaW5nO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdXJsU3RyaW5nLmluZGV4T2YoXCIvL1wiKSAhPT0gLTEgPyB1cmxTdHJpbmcuc3BsaXQoXCIvL1wiKVswXSArIFwiLy9cIiA6IFwiXCI7XG4gIHZhciBjb21wb25lbnRzID0gdXJsU3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChwcm90b2NvbCwgXCJpXCIpLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIHZhciBob3N0ID0gY29tcG9uZW50c1swXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLiQvLCBcIlwiKTtcbiAgY29tcG9uZW50c1swXSA9IFwiXCI7XG4gIHZhciBwYXRoID0gbm9ybWFsaXplVXJsKGNvbXBvbmVudHMpO1xuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aDtcbn07IiwiLy8gY2hlY2sgZG9jdW1lbnQgZmlyc3Qgc28gaXQgZG9lc24ndCBlcnJvciBpbiBub2RlLmpzXG52YXIgc3R5bGUgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJykuc3R5bGVcbiAgOiB7fVxuXG52YXIgcHJlZml4ZXMgPSBbJ08nLCAnbXMnLCAnTW96JywgJ1dlYmtpdCddXG52YXIgdXBwZXIgPSAvKFtBLVpdKS9nXG52YXIgbWVtbyA9IHt9XG5cbi8qKlxuICogcHJlZml4IGBrZXlgXG4gKlxuICogICBwcmVmaXgoJ3RyYW5zZm9ybScpIC8vID0+IFdlYmtpdFRyYW5zZm9ybVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHByZWZpeChrZXkpe1xuICAvLyBDYW1lbCBjYXNlXG4gIGtleSA9IGtleS5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbihfLCBjaGFyKXtcbiAgICByZXR1cm4gY2hhci50b1VwcGVyQ2FzZSgpXG4gIH0pXG5cbiAgLy8gV2l0aG91dCBwcmVmaXhcbiAgaWYgKHN0eWxlW2tleV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGtleVxuXG4gIC8vIFdpdGggcHJlZml4XG4gIHZhciBLZXkgPSBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSlcbiAgdmFyIGkgPSBwcmVmaXhlcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBuYW1lID0gcHJlZml4ZXNbaV0gKyBLZXlcbiAgICBpZiAoc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIHJldHVybiBrZXlcbn1cblxuLyoqXG4gKiBNZW1vaXplZCB2ZXJzaW9uIG9mIGBwcmVmaXhgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcHJlZml4TWVtb3ppZWQoa2V5KXtcbiAgcmV0dXJuIGtleSBpbiBtZW1vXG4gICAgPyBtZW1vW2tleV1cbiAgICA6IG1lbW9ba2V5XSA9IHByZWZpeChrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGFzaGVkIHByZWZpeFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHByZWZpeERhc2hlZChrZXkpe1xuICBrZXkgPSBwcmVmaXgoa2V5KVxuICBpZiAodXBwZXIudGVzdChrZXkpKSB7XG4gICAga2V5ID0gJy0nICsga2V5LnJlcGxhY2UodXBwZXIsICctJDEnKVxuICAgIHVwcGVyLmxhc3RJbmRleCA9IDBcbiAgfVxuICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcmVmaXhNZW1vemllZFxubW9kdWxlLmV4cG9ydHMuZGFzaCA9IHByZWZpeERhc2hlZFxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuaW1wb3J0IHsgbG9nIH0gZnJvbSBcIi4uL3V0aWxzL2xvZy5qc1wiO1xuXG52YXIgV2ViU29ja2V0Q2xpZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViU29ja2V0Q2xpZW50KHVybCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJTb2NrZXRDbGllbnQpO1xuXG4gICAgdGhpcy5jbGllbnQgPSBuZXcgV2ViU29ja2V0KHVybCk7XG5cbiAgICB0aGlzLmNsaWVudC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViU29ja2V0Q2xpZW50LCBbe1xuICAgIGtleTogXCJvbk9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25PcGVuKGYpIHtcbiAgICAgIHRoaXMuY2xpZW50Lm9ub3BlbiA9IGY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbG9zZShmKSB7XG4gICAgICB0aGlzLmNsaWVudC5vbmNsb3NlID0gZjtcbiAgICB9IC8vIGNhbGwgZiB3aXRoIHRoZSBtZXNzYWdlIHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcblxuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5jbGllbnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZihlLmRhdGEpO1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViU29ja2V0Q2xpZW50O1xufSgpO1xuXG5leHBvcnQgeyBXZWJTb2NrZXRDbGllbnQgYXMgZGVmYXVsdCB9OyIsIi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnksIF9fd2VicGFja19oYXNoX18gKi9cbmltcG9ydCB3ZWJwYWNrSG90TG9nIGZyb20gXCJ3ZWJwYWNrL2hvdC9sb2cuanNcIjtcbmltcG9ydCBzdHJpcEFuc2kgZnJvbSBcIi4vbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzXCI7XG5pbXBvcnQgcGFyc2VVUkwgZnJvbSBcIi4vdXRpbHMvcGFyc2VVUkwuanNcIjtcbmltcG9ydCBzb2NrZXQgZnJvbSBcIi4vc29ja2V0LmpzXCI7XG5pbXBvcnQgeyBzaG93LCBoaWRlIH0gZnJvbSBcIi4vb3ZlcmxheS5qc1wiO1xuaW1wb3J0IHsgbG9nLCBzZXRMb2dMZXZlbCB9IGZyb20gXCIuL3V0aWxzL2xvZy5qc1wiO1xuaW1wb3J0IHNlbmRNZXNzYWdlIGZyb20gXCIuL3V0aWxzL3NlbmRNZXNzYWdlLmpzXCI7XG5pbXBvcnQgcmVsb2FkQXBwIGZyb20gXCIuL3V0aWxzL3JlbG9hZEFwcC5qc1wiO1xuaW1wb3J0IGNyZWF0ZVNvY2tldFVSTCBmcm9tIFwiLi91dGlscy9jcmVhdGVTb2NrZXRVUkwuanNcIjtcbnZhciBzdGF0dXMgPSB7XG4gIGlzVW5sb2FkaW5nOiBmYWxzZSxcbiAgLy8gVE9ETyBXb3JrYXJvdW5kIGZvciB3ZWJwYWNrIHY0LCBgX193ZWJwYWNrX2hhc2hfX2AgaXMgbm90IHJlcGxhY2VkIHdpdGhvdXQgSG90TW9kdWxlUmVwbGFjZW1lbnRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICBjdXJyZW50SGFzaDogdHlwZW9mIF9fd2VicGFja19oYXNoX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfaGFzaF9fIDogXCJcIlxufTsgLy8gY29uc29sZS5sb2coX193ZWJwYWNrX2hhc2hfXyk7XG5cbnZhciBvcHRpb25zID0ge1xuICBob3Q6IGZhbHNlLFxuICBsaXZlUmVsb2FkOiBmYWxzZSxcbiAgcHJvZ3Jlc3M6IGZhbHNlLFxuICBvdmVybGF5OiBmYWxzZVxufTtcbnZhciBwYXJzZWRSZXNvdXJjZVF1ZXJ5ID0gcGFyc2VVUkwoX19yZXNvdXJjZVF1ZXJ5KTtcblxuaWYgKHBhcnNlZFJlc291cmNlUXVlcnkuaG90ID09PSBcInRydWVcIikge1xuICBvcHRpb25zLmhvdCA9IHRydWU7XG4gIGxvZy5pbmZvKFwiSG90IE1vZHVsZSBSZXBsYWNlbWVudCBlbmFibGVkLlwiKTtcbn1cblxuaWYgKHBhcnNlZFJlc291cmNlUXVlcnlbXCJsaXZlLXJlbG9hZFwiXSA9PT0gXCJ0cnVlXCIpIHtcbiAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgbG9nLmluZm8oXCJMaXZlIFJlbG9hZGluZyBlbmFibGVkLlwiKTtcbn1cblxuaWYgKHBhcnNlZFJlc291cmNlUXVlcnkubG9nZ2luZykge1xuICBvcHRpb25zLmxvZ2dpbmcgPSBwYXJzZWRSZXNvdXJjZVF1ZXJ5LmxvZ2dpbmc7XG59XG5cbmZ1bmN0aW9uIHNldEFsbExvZ0xldmVsKGxldmVsKSB7XG4gIC8vIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIEhNUiBsb2dnZXIgb3BlcmF0ZSBzZXBhcmF0ZWx5IGZyb20gZGV2IHNlcnZlciBsb2dnZXJcbiAgd2VicGFja0hvdExvZy5zZXRMb2dMZXZlbChsZXZlbCA9PT0gXCJ2ZXJib3NlXCIgfHwgbGV2ZWwgPT09IFwibG9nXCIgPyBcImluZm9cIiA6IGxldmVsKTtcbiAgc2V0TG9nTGV2ZWwobGV2ZWwpO1xufVxuXG5pZiAob3B0aW9ucy5sb2dnaW5nKSB7XG4gIHNldEFsbExvZ0xldmVsKG9wdGlvbnMubG9nZ2luZyk7XG59XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gIHN0YXR1cy5pc1VubG9hZGluZyA9IHRydWU7XG59KTtcbnZhciBvblNvY2tldE1lc3NhZ2UgPSB7XG4gIGhvdDogZnVuY3Rpb24gaG90KCkge1xuICAgIGlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LmhvdCA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKFwiSG90IE1vZHVsZSBSZXBsYWNlbWVudCBlbmFibGVkLlwiKTtcbiAgfSxcbiAgbGl2ZVJlbG9hZDogZnVuY3Rpb24gbGl2ZVJlbG9hZCgpIHtcbiAgICBpZiAocGFyc2VkUmVzb3VyY2VRdWVyeVtcImxpdmUtcmVsb2FkXCJdID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zLmxpdmVSZWxvYWQgPSB0cnVlO1xuICAgIGxvZy5pbmZvKFwiTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC5cIik7XG4gIH0sXG4gIGludmFsaWQ6IGZ1bmN0aW9uIGludmFsaWQoKSB7XG4gICAgbG9nLmluZm8oXCJBcHAgdXBkYXRlZC4gUmVjb21waWxpbmcuLi5cIik7IC8vIEZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgaGlkZSgpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKFwiSW52YWxpZFwiKTtcbiAgfSxcbiAgaGFzaDogZnVuY3Rpb24gaGFzaChfaGFzaCkge1xuICAgIHN0YXR1cy5wcmV2aW91c0hhc2ggPSBzdGF0dXMuY3VycmVudEhhc2g7XG4gICAgc3RhdHVzLmN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gIGxvZ2dpbmc6IHNldEFsbExvZ0xldmVsLFxuICBvdmVybGF5OiBmdW5jdGlvbiBvdmVybGF5KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMub3ZlcmxheSA9IHZhbHVlO1xuICB9LFxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XG4gICAgb3B0aW9ucy5wcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgfSxcbiAgXCJwcm9ncmVzcy11cGRhdGVcIjogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmIChvcHRpb25zLnByb2dyZXNzKSB7XG4gICAgICBsb2cuaW5mbyhcIlwiLmNvbmNhdChkYXRhLnBsdWdpbk5hbWUgPyBcIltcIi5jb25jYXQoZGF0YS5wbHVnaW5OYW1lLCBcIl0gXCIpIDogXCJcIikuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZShcIlByb2dyZXNzXCIsIGRhdGEpO1xuICB9LFxuICBcInN0aWxsLW9rXCI6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oXCJOb3RoaW5nIGNoYW5nZWQuXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgaGlkZSgpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKFwiU3RpbGxPa1wiKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKFwiT2tcIik7XG5cbiAgICBpZiAob3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICBoaWRlKCk7XG4gICAgfVxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIC8vIFRPRE86IHJlbW92ZSBpbiB2NSBpbiBmYXZvciBvZiAnc3RhdGljLWNoYW5nZWQnXG4gIFwiY29udGVudC1jaGFuZ2VkXCI6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKGZpbGUpIHtcbiAgICBsb2cuaW5mbyhcIlwiLmNvbmNhdChmaWxlID8gXCJcXFwiXCIuY29uY2F0KGZpbGUsIFwiXFxcIlwiKSA6IFwiQ29udGVudFwiLCBcIiBmcm9tIHN0YXRpYyBkaXJlY3Rvcnkgd2FzIGNoYW5nZWQuIFJlbG9hZGluZy4uLlwiKSk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgXCJzdGF0aWMtY2hhbmdlZFwiOiBmdW5jdGlvbiBzdGF0aWNDaGFuZ2VkKGZpbGUpIHtcbiAgICBsb2cuaW5mbyhcIlwiLmNvbmNhdChmaWxlID8gXCJcXFwiXCIuY29uY2F0KGZpbGUsIFwiXFxcIlwiKSA6IFwiQ29udGVudFwiLCBcIiBmcm9tIHN0YXRpYyBkaXJlY3Rvcnkgd2FzIGNoYW5nZWQuIFJlbG9hZGluZy4uLlwiKSk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xuICAgIGxvZy53YXJuKFwiV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLlwiKTtcblxuICAgIHZhciBzdHJpcHBlZFdhcm5pbmdzID0gX3dhcm5pbmdzLm1hcChmdW5jdGlvbiAod2FybmluZykge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaSh3YXJuaW5nLm1lc3NhZ2UgPyB3YXJuaW5nLm1lc3NhZ2UgOiB3YXJuaW5nKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKFwiV2FybmluZ3NcIiwgc3RyaXBwZWRXYXJuaW5ncyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIHZhciBuZWVkU2hvd092ZXJsYXlGb3JXYXJuaW5ncyA9IHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucy5vdmVybGF5IDogb3B0aW9ucy5vdmVybGF5ICYmIG9wdGlvbnMub3ZlcmxheS53YXJuaW5ncztcblxuICAgIGlmIChuZWVkU2hvd092ZXJsYXlGb3JXYXJuaW5ncykge1xuICAgICAgc2hvdyhfd2FybmluZ3MsIFwid2FybmluZ3NcIik7XG4gICAgfVxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoXCJFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLlwiKTtcblxuICAgIHZhciBzdHJpcHBlZEVycm9ycyA9IF9lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaShlcnJvci5tZXNzYWdlID8gZXJyb3IubWVzc2FnZSA6IGVycm9yKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKFwiRXJyb3JzXCIsIHN0cmlwcGVkRXJyb3JzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy5lcnJvcihzdHJpcHBlZEVycm9yc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRTaG93T3ZlcmxheUZvckVycm9ycyA9IHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucy5vdmVybGF5IDogb3B0aW9ucy5vdmVybGF5ICYmIG9wdGlvbnMub3ZlcmxheS5lcnJvcnM7XG5cbiAgICBpZiAobmVlZFNob3dPdmVybGF5Rm9yRXJyb3JzKSB7XG4gICAgICBzaG93KF9lcnJvcnMsIFwiZXJyb3JzXCIpO1xuICAgIH1cbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmluZm8oXCJEaXNjb25uZWN0ZWQhXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgaGlkZSgpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKFwiQ2xvc2VcIik7XG4gIH1cbn07XG52YXIgc29ja2V0VVJMID0gY3JlYXRlU29ja2V0VVJMKHBhcnNlZFJlc291cmNlUXVlcnkpO1xuc29ja2V0KHNvY2tldFVSTCwgb25Tb2NrZXRNZXNzYWdlKTsiLCIvKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL2NsaWVudC1zcmMvbW9kdWxlcy9sb2dnZXIvU3luY0JhaWxIb29rRmFrZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NsaWVudC1zcmMvbW9kdWxlcy9sb2dnZXIvU3luY0JhaWxIb29rRmFrZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXG4vKipcbiAqIENsaWVudCBzdHViIGZvciB0YXBhYmxlIFN5bmNCYWlsSG9va1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xpZW50VGFwYWJsZVN5bmNCYWlsSG9vaygpIHtcbiAgcmV0dXJuIHtcbiAgICBjYWxsOiBmdW5jdGlvbiBjYWxsKCkge31cbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvTG9nZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvTG9nZ2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgTG9nVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBlcnJvcjogXCJlcnJvclwiLFxuICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuICB3YXJuOiBcIndhcm5cIixcbiAgLy8gbWVzc2FnZSwgYyBzdHlsZSBhcmd1bWVudHNcbiAgaW5mbzogXCJpbmZvXCIsXG4gIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gIGxvZzogXCJsb2dcIixcbiAgLy8gbWVzc2FnZSwgYyBzdHlsZSBhcmd1bWVudHNcbiAgZGVidWc6IFwiZGVidWdcIixcbiAgLy8gbWVzc2FnZSwgYyBzdHlsZSBhcmd1bWVudHNcbiAgdHJhY2U6IFwidHJhY2VcIixcbiAgLy8gbm8gYXJndW1lbnRzXG4gIGdyb3VwOiBcImdyb3VwXCIsXG4gIC8vIFtsYWJlbF1cbiAgZ3JvdXBDb2xsYXBzZWQ6IFwiZ3JvdXBDb2xsYXBzZWRcIixcbiAgLy8gW2xhYmVsXVxuICBncm91cEVuZDogXCJncm91cEVuZFwiLFxuICAvLyBbbGFiZWxdXG4gIHByb2ZpbGU6IFwicHJvZmlsZVwiLFxuICAvLyBbcHJvZmlsZU5hbWVdXG4gIHByb2ZpbGVFbmQ6IFwicHJvZmlsZUVuZFwiLFxuICAvLyBbcHJvZmlsZU5hbWVdXG4gIHRpbWU6IFwidGltZVwiLFxuICAvLyBuYW1lLCB0aW1lIGFzIFtzZWNvbmRzLCBuYW5vc2Vjb25kc11cbiAgY2xlYXI6IFwiY2xlYXJcIixcbiAgLy8gbm8gYXJndW1lbnRzXG4gIHN0YXR1czogXCJzdGF0dXNcIiAvLyBtZXNzYWdlLCBhcmd1bWVudHNcblxufSk7XG5leHBvcnRzLkxvZ1R5cGUgPSBMb2dUeXBlO1xuLyoqIEB0eXBlZGVmIHt0eXBlb2YgTG9nVHlwZVtrZXlvZiB0eXBlb2YgTG9nVHlwZV19IExvZ1R5cGVFbnVtICovXG5cbnZhciBMT0dfU1lNQk9MID0gKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkoXCJ3ZWJwYWNrIGxvZ2dlciByYXcgbG9nIG1ldGhvZFwiKTtcbnZhciBUSU1FUlNfU1lNQk9MID0gKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkoXCJ3ZWJwYWNrIGxvZ2dlciB0aW1lc1wiKTtcbnZhciBUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0wgPSAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7IHJldHVybiBpOyB9KShcIndlYnBhY2sgbG9nZ2VyIGFnZ3JlZ2F0ZWQgdGltZXNcIik7XG5cbnZhciBXZWJwYWNrTG9nZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oTG9nVHlwZUVudW0sIGFueVtdPSk6IHZvaWR9IGxvZyBsb2cgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcgfCBmdW5jdGlvbigpOiBzdHJpbmcpOiBXZWJwYWNrTG9nZ2VyfSBnZXRDaGlsZExvZ2dlciBmdW5jdGlvbiB0byBjcmVhdGUgY2hpbGQgbG9nZ2VyXG4gICAqL1xuICBmdW5jdGlvbiBXZWJwYWNrTG9nZ2VyKGxvZywgZ2V0Q2hpbGRMb2dnZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2VicGFja0xvZ2dlcik7XG5cbiAgICB0aGlzW0xPR19TWU1CT0xdID0gbG9nO1xuICAgIHRoaXMuZ2V0Q2hpbGRMb2dnZXIgPSBnZXRDaGlsZExvZ2dlcjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJwYWNrTG9nZ2VyLCBbe1xuICAgIGtleTogXCJlcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZXJyb3IsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3YXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUud2FybiwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5pbmZvLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZygpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5sb2csIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWJ1Z1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICB9XG5cbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5kZWJ1ZywgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzc2VydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnQoYXNzZXJ0aW9uKSB7XG4gICAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYgPiAxID8gX2xlbjYgLSAxIDogMCksIF9rZXk2ID0gMTsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTYgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZXJyb3IsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFjZSgpIHtcbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS50cmFjZSwgW1wiVHJhY2VcIl0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5jbGVhcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXR1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGF0dXMoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuc3RhdHVzLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjgpLCBfa2V5OCA9IDA7IF9rZXk4IDwgX2xlbjg7IF9rZXk4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OF0gPSBhcmd1bWVudHNbX2tleThdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZ3JvdXAsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncm91cENvbGxhcHNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cENvbGxhcHNlZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW45ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOSksIF9rZXk5ID0gMDsgX2tleTkgPCBfbGVuOTsgX2tleTkrKykge1xuICAgICAgICBhcmdzW19rZXk5XSA9IGFyZ3VtZW50c1tfa2V5OV07XG4gICAgICB9XG5cbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5ncm91cENvbGxhcHNlZCwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwRW5kKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTApLCBfa2V5MTAgPSAwOyBfa2V5MTAgPCBfbGVuMTA7IF9rZXkxMCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTEwXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZ3JvdXBFbmQsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9maWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2ZpbGUobGFiZWwpIHtcbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5wcm9maWxlLCBbbGFiZWxdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvZmlsZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9maWxlRW5kKGxhYmVsKSB7XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUucHJvZmlsZUVuZCwgW2xhYmVsXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgICAgdGhpc1tUSU1FUlNfU1lNQk9MXSA9IHRoaXNbVElNRVJTX1NZTUJPTF0gfHwgbmV3IE1hcCgpO1xuICAgICAgdGhpc1tUSU1FUlNfU1lNQk9MXS5zZXQobGFiZWwsIHByb2Nlc3MuaHJ0aW1lKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lTG9nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVMb2cobGFiZWwpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpc1tUSU1FUlNfU1lNQk9MXSAmJiB0aGlzW1RJTUVSU19TWU1CT0xdLmdldChsYWJlbCk7XG5cbiAgICAgIGlmICghcHJldikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsICdcIi5jb25jYXQobGFiZWwsIFwiJyBmb3IgV2VicGFja0xvZ2dlci50aW1lTG9nKClcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKHByZXYpO1xuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnRpbWUsIFtsYWJlbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aW1lKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpc1tUSU1FUlNfU1lNQk9MXSAmJiB0aGlzW1RJTUVSU19TWU1CT0xdLmdldChsYWJlbCk7XG5cbiAgICAgIGlmICghcHJldikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsICdcIi5jb25jYXQobGFiZWwsIFwiJyBmb3IgV2VicGFja0xvZ2dlci50aW1lRW5kKClcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKHByZXYpO1xuICAgICAgdGhpc1tUSU1FUlNfU1lNQk9MXS5kZWxldGUobGFiZWwpO1xuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnRpbWUsIFtsYWJlbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aW1lKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lQWdncmVnYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVBZ2dyZWdhdGUobGFiZWwpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpc1tUSU1FUlNfU1lNQk9MXSAmJiB0aGlzW1RJTUVSU19TWU1CT0xdLmdldChsYWJlbCk7XG5cbiAgICAgIGlmICghcHJldikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsICdcIi5jb25jYXQobGFiZWwsIFwiJyBmb3IgV2VicGFja0xvZ2dlci50aW1lQWdncmVnYXRlKClcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKHByZXYpO1xuICAgICAgdGhpc1tUSU1FUlNfU1lNQk9MXS5kZWxldGUobGFiZWwpO1xuICAgICAgdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdID0gdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdIHx8IG5ldyBNYXAoKTtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdLmdldChsYWJlbCk7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRpbWVbMV0gKyBjdXJyZW50WzFdID4gMWU5KSB7XG4gICAgICAgICAgdGltZVswXSArPSBjdXJyZW50WzBdICsgMTtcbiAgICAgICAgICB0aW1lWzFdID0gdGltZVsxXSAtIDFlOSArIGN1cnJlbnRbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZVswXSArPSBjdXJyZW50WzBdO1xuICAgICAgICAgIHRpbWVbMV0gKz0gY3VycmVudFsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzW1RJTUVSU19BR0dSRUdBVEVTX1NZTUJPTF0uc2V0KGxhYmVsLCB0aW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUFnZ3JlZ2F0ZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lQWdncmVnYXRlRW5kKGxhYmVsKSB7XG4gICAgICBpZiAodGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgIHZhciB0aW1lID0gdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdLmdldChsYWJlbCk7XG4gICAgICBpZiAodGltZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUudGltZSwgW2xhYmVsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRpbWUpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYnBhY2tMb2dnZXI7XG59KCk7XG5cbmV4cG9ydHMuTG9nZ2VyID0gV2VicGFja0xvZ2dlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9jcmVhdGVDb25zb2xlTG9nZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL2NyZWF0ZUNvbnNvbGVMb2dnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Mb2dnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL0xvZ2dlci5qc1wiKSxcbiAgICBMb2dUeXBlID0gX3JlcXVpcmUuTG9nVHlwZTtcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZGVjbGFyYXRpb25zL1dlYnBhY2tPcHRpb25zXCIpLkZpbHRlckl0ZW1UeXBlc30gRmlsdGVySXRlbVR5cGVzICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZGVjbGFyYXRpb25zL1dlYnBhY2tPcHRpb25zXCIpLkZpbHRlclR5cGVzfSBGaWx0ZXJUeXBlcyAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4vTG9nZ2VyXCIpLkxvZ1R5cGVFbnVtfSBMb2dUeXBlRW51bSAqL1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9uKHN0cmluZyk6IGJvb2xlYW59IEZpbHRlckZ1bmN0aW9uICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTG9nZ2VyQ29uc29sZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiB2b2lkfSBjbGVhclxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiB2b2lkfSB0cmFjZVxuICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGluZm9cbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBsb2dcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSB3YXJuXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZXJyb3JcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZGVidWdcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBDb2xsYXBzZWRcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBFbmRcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gc3RhdHVzXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IHByb2ZpbGVcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gcHJvZmlsZUVuZFxuICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBsb2dUaW1lXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMb2dnZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge2ZhbHNlfHRydWV8XCJub25lXCJ8XCJlcnJvclwifFwid2FyblwifFwiaW5mb1wifFwibG9nXCJ8XCJ2ZXJib3NlXCJ9IGxldmVsIGxvZ2xldmVsXG4gKiBAcHJvcGVydHkge0ZpbHRlclR5cGVzfGJvb2xlYW59IGRlYnVnIGZpbHRlciBmb3IgZGVidWcgbG9nZ2luZ1xuICogQHByb3BlcnR5IHtMb2dnZXJDb25zb2xlfSBjb25zb2xlIHRoZSBjb25zb2xlIHRvIGxvZyB0b1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtGaWx0ZXJJdGVtVHlwZXN9IGl0ZW0gYW4gaW5wdXQgaXRlbVxuICogQHJldHVybnMge0ZpbHRlckZ1bmN0aW9ufSBmaWx0ZXIgZnVuY3Rpb25cbiAqL1xuXG5cbnZhciBmaWx0ZXJUb0Z1bmN0aW9uID0gZnVuY3Rpb24gZmlsdGVyVG9GdW5jdGlvbihpdGVtKSB7XG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKFwiW1xcXFxcXFxcL11cIi5jb25jYXQoaXRlbS5yZXBsYWNlKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAvWy1bXFxde30oKSorPy5cXFxcXiR8XS9nLCBcIlxcXFwkJlwiKSwgXCIoW1xcXFxcXFxcL118JHwhfFxcXFw/KVwiKSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpZGVudCkge1xuICAgICAgcmV0dXJuIHJlZ0V4cC50ZXN0KGlkZW50KTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGl0ZW0udGVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpZGVudCkge1xuICAgICAgcmV0dXJuIGl0ZW0udGVzdChpZGVudCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cblxuXG52YXIgTG9nTGV2ZWwgPSB7XG4gIG5vbmU6IDYsXG4gIGZhbHNlOiA2LFxuICBlcnJvcjogNSxcbiAgd2FybjogNCxcbiAgaW5mbzogMyxcbiAgbG9nOiAyLFxuICB0cnVlOiAyLFxuICB2ZXJib3NlOiAxXG59O1xuLyoqXG4gKiBAcGFyYW0ge0xvZ2dlck9wdGlvbnN9IG9wdGlvbnMgb3B0aW9ucyBvYmplY3RcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIExvZ1R5cGVFbnVtLCBhbnlbXSk6IHZvaWR9IGxvZ2dpbmcgZnVuY3Rpb25cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBfcmVmJGxldmVsID0gX3JlZi5sZXZlbCxcbiAgICAgIGxldmVsID0gX3JlZiRsZXZlbCA9PT0gdm9pZCAwID8gXCJpbmZvXCIgOiBfcmVmJGxldmVsLFxuICAgICAgX3JlZiRkZWJ1ZyA9IF9yZWYuZGVidWcsXG4gICAgICBkZWJ1ZyA9IF9yZWYkZGVidWcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRkZWJ1ZyxcbiAgICAgIGNvbnNvbGUgPSBfcmVmLmNvbnNvbGU7XG4gIHZhciBkZWJ1Z0ZpbHRlcnMgPSB0eXBlb2YgZGVidWcgPT09IFwiYm9vbGVhblwiID8gW2Z1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1dIDpcbiAgLyoqIEB0eXBlIHtGaWx0ZXJJdGVtVHlwZXNbXX0gKi9cbiAgW10uY29uY2F0KGRlYnVnKS5tYXAoZmlsdGVyVG9GdW5jdGlvbik7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gIHZhciBsb2dsZXZlbCA9IExvZ0xldmVsW1wiXCIuY29uY2F0KGxldmVsKV0gfHwgMDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGxvZ2dlclxuICAgKiBAcGFyYW0ge0xvZ1R5cGVFbnVtfSB0eXBlIHR5cGUgb2YgdGhlIGxvZyBlbnRyeVxuICAgKiBAcGFyYW0ge2FueVtdfSBhcmdzIGFyZ3VtZW50cyBvZiB0aGUgbG9nIGVudHJ5XG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuICB2YXIgbG9nZ2VyID0gZnVuY3Rpb24gbG9nZ2VyKG5hbWUsIHR5cGUsIGFyZ3MpIHtcbiAgICB2YXIgbGFiZWxlZEFyZ3MgPSBmdW5jdGlvbiBsYWJlbGVkQXJncygpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gW1wiW1wiLmNvbmNhdChuYW1lLCBcIl0gXCIpLmNvbmNhdChhcmdzWzBdKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzLnNsaWNlKDEpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtcIltcIi5jb25jYXQobmFtZSwgXCJdXCIpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVidWcgPSBkZWJ1Z0ZpbHRlcnMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGYobmFtZSk7XG4gICAgfSk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgTG9nVHlwZS5kZWJ1ZzpcbiAgICAgICAgaWYgKCFkZWJ1ZykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmRlYnVnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgY29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLmxvZzpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLmluZm86XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5pbmZvKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLndhcm46XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC53YXJuKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLmVycm9yOlxuICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwuZXJyb3IpIHJldHVybjtcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLnRyYWNlOlxuICAgICAgICBpZiAoIWRlYnVnKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5ncm91cENvbGxhcHNlZDpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuO1xuXG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC52ZXJib3NlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5ncm91cENvbGxhcHNlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICBjYXNlIExvZ1R5cGUuZ3JvdXA6XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5ncm91cCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGNvbnNvbGUuZ3JvdXAuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5ncm91cEVuZDpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmdyb3VwRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS50aW1lOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuO1xuICAgICAgICAgIHZhciBtcyA9IGFyZ3NbMV0gKiAxMDAwICsgYXJnc1syXSAvIDEwMDAwMDA7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiW1wiLmNvbmNhdChuYW1lLCBcIl0gXCIpLmNvbmNhdChhcmdzWzBdLCBcIjogXCIpLmNvbmNhdChtcywgXCIgbXNcIik7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUubG9nVGltZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZ1RpbWUobXNnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIExvZ1R5cGUucHJvZmlsZTpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUucHJvZmlsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGNvbnNvbGUucHJvZmlsZS5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5wcm9maWxlRW5kOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5wcm9maWxlRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgY29uc29sZS5wcm9maWxlRW5kLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLmNsZWFyOlxuICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwubG9nKSByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuY2xlYXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLnN0YXR1czpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmluZm8pIHJldHVybjtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuc3RhdHVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuc3RhdHVzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuc3RhdHVzLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgTG9nVHlwZSBcIi5jb25jYXQodHlwZSkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbG9nZ2VyO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL3J1bnRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIFN5bmNCYWlsSG9vayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRhcGFibGUvbGliL1N5bmNCYWlsSG9vayAqLyBcIi4vY2xpZW50LXNyYy9tb2R1bGVzL2xvZ2dlci9TeW5jQmFpbEhvb2tGYWtlLmpzXCIpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0xvZ2dlciAqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvTG9nZ2VyLmpzXCIpLFxuICAgIExvZ2dlciA9IF9yZXF1aXJlLkxvZ2dlcjtcblxudmFyIGNyZWF0ZUNvbnNvbGVMb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZUNvbnNvbGVMb2dnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL2NyZWF0ZUNvbnNvbGVMb2dnZXIuanNcIik7XG4vKiogQHR5cGUge2NyZWF0ZUNvbnNvbGVMb2dnZXIuTG9nZ2VyT3B0aW9uc30gKi9cblxuXG52YXIgY3VycmVudERlZmF1bHRMb2dnZXJPcHRpb25zID0ge1xuICBsZXZlbDogXCJpbmZvXCIsXG4gIGRlYnVnOiBmYWxzZSxcbiAgY29uc29sZTogY29uc29sZVxufTtcbnZhciBjdXJyZW50RGVmYXVsdExvZ2dlciA9IGNyZWF0ZUNvbnNvbGVMb2dnZXIoY3VycmVudERlZmF1bHRMb2dnZXJPcHRpb25zKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbG9nZ2VyXG4gKiBAcmV0dXJucyB7TG9nZ2VyfSBhIGxvZ2dlclxuICovXG5cbmV4cG9ydHMuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBMb2dnZXIoZnVuY3Rpb24gKHR5cGUsIGFyZ3MpIHtcbiAgICBpZiAoZXhwb3J0cy5ob29rcy5sb2cuY2FsbChuYW1lLCB0eXBlLCBhcmdzKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdXJyZW50RGVmYXVsdExvZ2dlcihuYW1lLCB0eXBlLCBhcmdzKTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5nZXRMb2dnZXIoXCJcIi5jb25jYXQobmFtZSwgXCIvXCIpLmNvbmNhdChjaGlsZE5hbWUpKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2NyZWF0ZUNvbnNvbGVMb2dnZXIuTG9nZ2VyT3B0aW9uc30gb3B0aW9ucyBuZXcgb3B0aW9ucywgbWVyZ2Ugd2l0aCBvbGQgb3B0aW9uc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuXG5leHBvcnRzLmNvbmZpZ3VyZURlZmF1bHRMb2dnZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBfZXh0ZW5kcyhjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIGN1cnJlbnREZWZhdWx0TG9nZ2VyID0gY3JlYXRlQ29uc29sZUxvZ2dlcihjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMpO1xufTtcblxuZXhwb3J0cy5ob29rcyA9IHtcbiAgbG9nOiBuZXcgU3luY0JhaWxIb29rKFtcIm9yaWdpblwiLCBcInR5cGVcIiwgXCJhcmdzXCJdKVxufTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfVxuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpc29sYXRlZCBhZ2FpbnN0IG90aGVyIG1vZHVsZXMgaW4gdGhlIGNodW5rLlxuIWZ1bmN0aW9uKCkge1xuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jbGllbnQtc3JjL21vZHVsZXMvbG9nZ2VyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0IGRlZmF1bHQgZXhwb3J0IGZyb20gbmFtZWQgbW9kdWxlICovIHdlYnBhY2tfbGliX2xvZ2dpbmdfcnVudGltZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fOyB9XG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB3ZWJwYWNrX2xpYl9sb2dnaW5nX3J1bnRpbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHdlYnBhY2svbGliL2xvZ2dpbmcvcnVudGltZS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvcnVudGltZS5qc1wiKTtcblxufSgpO1xudmFyIF9fd2VicGFja19leHBvcnRfdGFyZ2V0X18gPSBleHBvcnRzO1xuZm9yKHZhciBpIGluIF9fd2VicGFja19leHBvcnRzX18pIF9fd2VicGFja19leHBvcnRfdGFyZ2V0X19baV0gPSBfX3dlYnBhY2tfZXhwb3J0c19fW2ldO1xuaWYoX193ZWJwYWNrX2V4cG9ydHNfXy5fX2VzTW9kdWxlKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyB9KSgpXG47IiwiLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHN0cmlwQW5zaTsgfVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgYW5zaV9yZWdleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgYW5zaS1yZWdleCAqLyBcIi4vbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanNcIik7XG5cbmZ1bmN0aW9uIHN0cmlwQW5zaShzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgYHN0cmluZ2AsIGdvdCBgXCIuY29uY2F0KHR5cGVvZiBzdHJpbmcsIFwiYFwiKSk7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoKDAsYW5zaV9yZWdleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSkoKSwgJycpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gYW5zaVJlZ2V4OyB9XG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbmZ1bmN0aW9uIGFuc2lSZWdleCgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgX3JlZiRvbmx5Rmlyc3QgPSBfcmVmLm9ubHlGaXJzdCxcbiAgICAgIG9ubHlGaXJzdCA9IF9yZWYkb25seUZpcnN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkb25seUZpcnN0O1xuXG4gIHZhciBwYXR0ZXJuID0gW1wiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/Oig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSspKnxbYS16QS1aXFxcXGRdKyg/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLCAnKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSknXS5qb2luKCd8Jyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIG9ubHlGaXJzdCA/IHVuZGVmaW5lZCA6ICdnJyk7XG59XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH1cbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaXNvbGF0ZWQgYWdhaW5zdCBvdGhlciBtb2R1bGVzIGluIHRoZSBjaHVuay5cbiFmdW5jdGlvbigpIHtcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NsaWVudC1zcmMvbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgc3RyaXBfYW5zaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3RyaXAtYW5zaSAqLyBcIi4vbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanNcIik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoc3RyaXBfYW5zaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG59KCk7XG52YXIgX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXyA9IGV4cG9ydHM7XG5mb3IodmFyIGkgaW4gX193ZWJwYWNrX2V4cG9ydHNfXykgX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfX1tpXSA9IF9fd2VicGFja19leHBvcnRzX19baV07XG5pZihfX3dlYnBhY2tfZXhwb3J0c19fLl9fZXNNb2R1bGUpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIH0pKClcbjsiLCIvLyBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCAoYW5kIG1vc3RseSBjb3BpZWQpIGZyb20gQ3JlYXRlIFJlYWN0IEFwcCAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHApXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cbmltcG9ydCBhbnNpSFRNTCBmcm9tIFwiYW5zaS1odG1sLWNvbW11bml0eVwiO1xuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSBcImh0bWwtZW50aXRpZXNcIjtcbnZhciBjb2xvcnMgPSB7XG4gIHJlc2V0OiBbXCJ0cmFuc3BhcmVudFwiLCBcInRyYW5zcGFyZW50XCJdLFxuICBibGFjazogXCIxODE4MThcIixcbiAgcmVkOiBcIkUzNjA0OVwiLFxuICBncmVlbjogXCJCM0NCNzRcIixcbiAgeWVsbG93OiBcIkZGRDA4MFwiLFxuICBibHVlOiBcIjdDQUZDMlwiLFxuICBtYWdlbnRhOiBcIjdGQUNDQVwiLFxuICBjeWFuOiBcIkMzQzJFRlwiLFxuICBsaWdodGdyZXk6IFwiRUJFN0UzXCIsXG4gIGRhcmtncmV5OiBcIjZENzg5MVwiXG59O1xudmFyIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQ7XG52YXIgY29udGFpbmVyRWxlbWVudDtcbnZhciBvbkxvYWRRdWV1ZSA9IFtdO1xuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuaWQgPSBcIndlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheVwiO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LnNyYyA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS50b3AgPSAwO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LnN0eWxlLnJpZ2h0ID0gMDtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5ib3R0b20gPSAwO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDB2d1wiO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiMTAwdmhcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS56SW5kZXggPSA5OTk5OTk5OTk5O1xuXG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRhaW5lckVsZW1lbnQgPSBpZnJhbWVDb250YWluZXJFbGVtZW50LmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuaWQgPSBcIndlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXZcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLnRvcCA9IDA7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5yaWdodCA9IDA7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5ib3R0b20gPSAwO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMHZ3XCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIjEwMHZoXCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoMCwgMCwgMCwgMC44NSlcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmNvbG9yID0gXCIjRThFOEU4XCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5mb250RmFtaWx5ID0gXCJNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZVwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSBcImxhcmdlXCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gXCIycmVtXCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5saW5lSGVpZ2h0ID0gXCIxLjJcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSBcInByZS13cmFwXCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IFwiYXV0b1wiO1xuICAgIHZhciBoZWFkZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaGVhZGVyRWxlbWVudC5pbm5lclRleHQgPSBcIkNvbXBpbGVkIHdpdGggcHJvYmxlbXM6XCI7XG4gICAgdmFyIGNsb3NlQnV0dG9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgY2xvc2VCdXR0b25FbGVtZW50LmlubmVyVGV4dCA9IFwiWFwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSBcIjIwcHhcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5jb2xvciA9IFwid2hpdGVcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgY2xvc2VCdXR0b25FbGVtZW50LnN0eWxlLmNzc0Zsb2F0ID0gXCJyaWdodFwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5zdHlsZUZsb2F0ID0gXCJyaWdodFwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaGlkZSgpO1xuICAgIH0pO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoaGVhZGVyRWxlbWVudCk7XG4gICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbkVsZW1lbnQpO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXJFbGVtZW50KTtcbiAgICBvbkxvYWRRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChvbkxvYWQpIHtcbiAgICAgIG9uTG9hZChjb250YWluZXJFbGVtZW50KTtcbiAgICB9KTtcbiAgICBvbkxvYWRRdWV1ZSA9IFtdO1xuICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQub25sb2FkID0gbnVsbDtcbiAgfTtcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUNvbnRhaW5lckVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVPdmVybGF5RXhpc3RzKGNhbGxiYWNrKSB7XG4gIGlmIChjb250YWluZXJFbGVtZW50KSB7XG4gICAgLy8gRXZlcnl0aGluZyBpcyByZWFkeSwgY2FsbCB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheS5cbiAgICBjYWxsYmFjayhjb250YWluZXJFbGVtZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBvbkxvYWRRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcblxuICBpZiAoaWZyYW1lQ29udGFpbmVyRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNyZWF0ZUNvbnRhaW5lcigpO1xufSAvLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuXG5cbmZ1bmN0aW9uIGhpZGUoKSB7XG4gIGlmICghaWZyYW1lQ29udGFpbmVyRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG5cblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZUNvbnRhaW5lckVsZW1lbnQpO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgY29udGFpbmVyRWxlbWVudCA9IG51bGw7XG59IC8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuXG5cbmZ1bmN0aW9uIHNob3cobWVzc2FnZXMsIHR5cGUpIHtcbiAgZW5zdXJlT3ZlcmxheUV4aXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgdmFyIGVudHJ5RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB2YXIgdHlwZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHR5cGVFbGVtZW50LmlubmVyVGV4dCA9IHR5cGUgPT09IFwid2FybmluZ3NcIiA/IFwiV2FybmluZzpcIiA6IFwiRXJyb3I6XCI7XG4gICAgICB0eXBlRWxlbWVudC5zdHlsZS5jb2xvciA9IFwiI1wiLmNvbmNhdChjb2xvcnMucmVkKTsgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuXG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gbWVzc2FnZS5tZXNzYWdlIHx8IG1lc3NhZ2VzWzBdO1xuICAgICAgdmFyIHRleHQgPSBhbnNpSFRNTChlbmNvZGUoZXJyb3JNZXNzYWdlKSk7XG4gICAgICB2YXIgbWVzc2FnZVRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIG1lc3NhZ2VUZXh0Tm9kZS5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKHR5cGVFbGVtZW50KTtcbiAgICAgIGVudHJ5RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICBlbnRyeUVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZVRleHROb2RlKTtcbiAgICAgIGVudHJ5RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGVudHJ5RWxlbWVudCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBzaG93LCBoaWRlIH07IiwiLyogZ2xvYmFsIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICovXG5pbXBvcnQgV2ViU29ja2V0Q2xpZW50IGZyb20gXCIuL2NsaWVudHMvV2ViU29ja2V0Q2xpZW50LmpzXCI7IC8vIHRoaXMgV2Vic29ja2V0Q2xpZW50IGlzIGhlcmUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLCBpbiBjYXNlIHRoZSBjbGllbnQgaXMgbm90IGluamVjdGVkXG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuXG52YXIgQ2xpZW50ID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZSwgbm8tbmVzdGVkLXRlcm5hcnlcbnR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbnR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXy5kZWZhdWx0ICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18uZGVmYXVsdCA6IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIDogV2ViU29ja2V0Q2xpZW50O1xuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxudmFyIHJldHJpZXMgPSAwO1xudmFyIGNsaWVudCA9IG51bGw7XG5cbnZhciBzb2NrZXQgPSBmdW5jdGlvbiBpbml0U29ja2V0KHVybCwgaGFuZGxlcnMpIHtcbiAgY2xpZW50ID0gbmV3IENsaWVudCh1cmwpO1xuICBjbGllbnQub25PcGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXRyaWVzID0gMDtcbiAgfSk7XG4gIGNsaWVudC5vbkNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9IC8vIFRyeSB0byByZWNvbm5lY3QuXG5cblxuICAgIGNsaWVudCA9IG51bGw7IC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cblxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycyk7XG4gICAgICB9LCByZXRyeUluTXMpO1xuICAgIH1cbiAgfSk7XG4gIGNsaWVudC5vbk1lc3NhZ2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICBpZiAoaGFuZGxlcnNbbWVzc2FnZS50eXBlXSkge1xuICAgICAgaGFuZGxlcnNbbWVzc2FnZS50eXBlXShtZXNzYWdlLmRhdGEpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzb2NrZXQ7IiwiaW1wb3J0IHVybCBmcm9tIFwidXJsXCI7IC8vIFdlIGhhbmRsZSBsZWdhY3kgQVBJIHRoYXQgaXMgTm9kZS5qcyBzcGVjaWZpYywgYW5kIGEgbmV3ZXIgQVBJIHRoYXQgaW1wbGVtZW50cyB0aGUgc2FtZSBXSEFUV0cgVVJMIFN0YW5kYXJkIHVzZWQgYnkgd2ViIGJyb3dzZXJzXG4vLyBQbGVhc2UgbG9vayBhdCBodHRwczovL25vZGVqcy5vcmcvYXBpL3VybC5odG1sI3VybF91cmxfc3RyaW5nc19hbmRfdXJsX29iamVjdHNcblxuZnVuY3Rpb24gY3JlYXRlU29ja2V0VVJMKHBhcnNlZFVSTCkge1xuICB2YXIgaG9zdG5hbWUgPSBwYXJzZWRVUkwuaG9zdG5hbWU7IC8vIE5vZGUuanMgbW9kdWxlIHBhcnNlcyBpdCBhcyBgOjpgXG4gIC8vIGBuZXcgVVJMKHVybFN0cmluZywgW2Jhc2VVUkxzdHJpbmddKWAgcGFyc2VzIGl0IGFzICdbOjpdJ1xuXG4gIHZhciBpc0luQWRkckFueSA9IGhvc3RuYW1lID09PSBcIjAuMC4wLjBcIiB8fCBob3N0bmFtZSA9PT0gXCI6OlwiIHx8IGhvc3RuYW1lID09PSBcIls6Ol1cIjsgLy8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cbiAgLy8gaG9zdG5hbWUgbi9hIGZvciBmaWxlIHByb3RvY29sIChleGFtcGxlLCB3aGVuIHVzaW5nIGVsZWN0cm9uLCBpb25pYylcbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcblxuICBpZiAoaXNJbkFkZHJBbnkgJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAmJiBzZWxmLmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwXCIpID09PSAwKSB7XG4gICAgaG9zdG5hbWUgPSBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9XG5cbiAgdmFyIHNvY2tldFVSTFByb3RvY29sID0gcGFyc2VkVVJMLnByb3RvY29sIHx8IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7IC8vIFdoZW4gaHR0cHMgaXMgdXNlZCBpbiB0aGUgYXBwLCBzZWN1cmUgd2ViIHNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYiBzb2NrZXRzLlxuXG4gIGlmIChzb2NrZXRVUkxQcm90b2NvbCA9PT0gXCJhdXRvOlwiIHx8IGhvc3RuYW1lICYmIGlzSW5BZGRyQW55ICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICBzb2NrZXRVUkxQcm90b2NvbCA9IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7XG4gIH1cblxuICBzb2NrZXRVUkxQcm90b2NvbCA9IHNvY2tldFVSTFByb3RvY29sLnJlcGxhY2UoL14oPzpodHRwfC4rLWV4dGVuc2lvbnxmaWxlKS9pLCBcIndzXCIpO1xuICB2YXIgc29ja2V0VVJMQXV0aCA9IFwiXCI7IC8vIGBuZXcgVVJMKHVybFN0cmluZywgW2Jhc2VVUkxzdHJpbmddKWAgZG9lc24ndCBoYXZlIGBhdXRoYCBwcm9wZXJ0eVxuICAvLyBQYXJzZSBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBpbiBjYXNlIHdlIG5lZWQgdGhlbVxuXG4gIGlmIChwYXJzZWRVUkwudXNlcm5hbWUpIHtcbiAgICBzb2NrZXRVUkxBdXRoID0gcGFyc2VkVVJMLnVzZXJuYW1lOyAvLyBTaW5jZSBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uIGRvZXMgbm90IGFsbG93IGVtcHR5IHVzZXJuYW1lLFxuICAgIC8vIHdlIG9ubHkgaW5jbHVkZSBwYXNzd29yZCBpZiB0aGUgdXNlcm5hbWUgaXMgbm90IGVtcHR5LlxuXG4gICAgaWYgKHBhcnNlZFVSTC5wYXNzd29yZCkge1xuICAgICAgLy8gUmVzdWx0OiA8dXNlcm5hbWU+OjxwYXNzd29yZD5cbiAgICAgIHNvY2tldFVSTEF1dGggPSBzb2NrZXRVUkxBdXRoLmNvbmNhdChcIjpcIiwgcGFyc2VkVVJMLnBhc3N3b3JkKTtcbiAgICB9XG4gIH0gLy8gSW4gY2FzZSB0aGUgaG9zdCBpcyBhIHJhdyBJUHY2IGFkZHJlc3MsIGl0IGNhbiBiZSBlbmNsb3NlZCBpblxuICAvLyB0aGUgYnJhY2tldHMgYXMgdGhlIGJyYWNrZXRzIGFyZSBuZWVkZWQgaW4gdGhlIGZpbmFsIFVSTCBzdHJpbmcuXG4gIC8vIE5lZWQgdG8gcmVtb3ZlIHRob3NlIGFzIHVybC5mb3JtYXQgYmxpbmRseSBhZGRzIGl0cyBvd24gc2V0IG9mIGJyYWNrZXRzXG4gIC8vIGlmIHRoZSBob3N0IHN0cmluZyBjb250YWlucyBjb2xvbnMuIFRoYXQgd291bGQgbGVhZCB0byBub24td29ya2luZ1xuICAvLyBkb3VibGUgYnJhY2tldHMgKGUuZy4gW1s6Ol1dKSBob3N0XG4gIC8vXG4gIC8vIEFsbCBvZiB0aGVzZSB3ZWIgc29ja2V0IHVybCBwYXJhbXMgYXJlIG9wdGlvbmFsbHkgcGFzc2VkIGluIHRocm91Z2ggcmVzb3VyY2VRdWVyeSxcbiAgLy8gc28gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgaWYgdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cblxuICB2YXIgc29ja2V0VVJMSG9zdG5hbWUgPSAoaG9zdG5hbWUgfHwgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSB8fCBcImxvY2FsaG9zdFwiKS5yZXBsYWNlKC9eXFxbKC4qKVxcXSQvLCBcIiQxXCIpO1xuICB2YXIgc29ja2V0VVJMUG9ydCA9IHBhcnNlZFVSTC5wb3J0O1xuXG4gIGlmICghc29ja2V0VVJMUG9ydCB8fCBzb2NrZXRVUkxQb3J0ID09PSBcIjBcIikge1xuICAgIHNvY2tldFVSTFBvcnQgPSBzZWxmLmxvY2F0aW9uLnBvcnQ7XG4gIH0gLy8gSWYgcGF0aCBpcyBwcm92aWRlZCBpdCdsbCBiZSBwYXNzZWQgaW4gdmlhIHRoZSByZXNvdXJjZVF1ZXJ5IGFzIGFcbiAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgLy8gY2xpZW50IHRvIG9wZW4gdGhlIHNvY2tldCB0byB0aGUgY29ycmVjdCBsb2NhdGlvbi5cblxuXG4gIHZhciBzb2NrZXRVUkxQYXRobmFtZSA9IFwiL3dzXCI7XG5cbiAgaWYgKHBhcnNlZFVSTC5wYXRobmFtZSAmJiAhcGFyc2VkVVJMLmZyb21DdXJyZW50U2NyaXB0KSB7XG4gICAgc29ja2V0VVJMUGF0aG5hbWUgPSBwYXJzZWRVUkwucGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4gdXJsLmZvcm1hdCh7XG4gICAgcHJvdG9jb2w6IHNvY2tldFVSTFByb3RvY29sLFxuICAgIGF1dGg6IHNvY2tldFVSTEF1dGgsXG4gICAgaG9zdG5hbWU6IHNvY2tldFVSTEhvc3RuYW1lLFxuICAgIHBvcnQ6IHNvY2tldFVSTFBvcnQsXG4gICAgcGF0aG5hbWU6IHNvY2tldFVSTFBhdGhuYW1lLFxuICAgIHNsYXNoZXM6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNvY2tldFVSTDsiLCJmdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICB9IC8vIEZhbGxiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgcnVubmluZyBpbiB0aGUgZG9jdW1lbnQuXG5cblxuICB2YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5zY3JpcHRzIHx8IFtdO1xuICB2YXIgc2NyaXB0RWxlbWVudHNXaXRoU3JjID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHNjcmlwdEVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgfSk7XG5cbiAgaWYgKHNjcmlwdEVsZW1lbnRzV2l0aFNyYy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1dpdGhTcmNbc2NyaXB0RWxlbWVudHNXaXRoU3JjLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgfSAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiW3dlYnBhY2stZGV2LXNlcnZlcl0gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2UuXCIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRDdXJyZW50U2NyaXB0U291cmNlOyIsImltcG9ydCBsb2dnZXIgZnJvbSBcIi4uL21vZHVsZXMvbG9nZ2VyL2luZGV4LmpzXCI7XG52YXIgbmFtZSA9IFwid2VicGFjay1kZXYtc2VydmVyXCI7IC8vIGRlZmF1bHQgbGV2ZWwgaXMgc2V0IG9uIHRoZSBjbGllbnQgc2lkZSwgc28gaXQgZG9lcyBub3QgbmVlZFxuLy8gdG8gYmUgc2V0IGJ5IHRoZSBDTEkgb3IgQVBJXG5cbnZhciBkZWZhdWx0TGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgbG9nZ2VyLmNvbmZpZ3VyZURlZmF1bHRMb2dnZXIoe1xuICAgIGxldmVsOiBsZXZlbFxuICB9KTtcbn1cblxuc2V0TG9nTGV2ZWwoZGVmYXVsdExldmVsKTtcbnZhciBsb2cgPSBsb2dnZXIuZ2V0TG9nZ2VyKG5hbWUpO1xuZXhwb3J0IHsgbG9nLCBzZXRMb2dMZXZlbCB9OyIsImltcG9ydCB1cmwgZnJvbSBcInVybFwiO1xuaW1wb3J0IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UgZnJvbSBcIi4vZ2V0Q3VycmVudFNjcmlwdFNvdXJjZS5qc1wiO1xuXG5mdW5jdGlvbiBwYXJzZVVSTChyZXNvdXJjZVF1ZXJ5KSB7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSBcInN0cmluZ1wiICYmIHJlc291cmNlUXVlcnkgIT09IFwiXCIpIHtcbiAgICB2YXIgc2VhcmNoUGFyYW1zID0gcmVzb3VyY2VRdWVyeS5zdWJzdHIoMSkuc3BsaXQoXCImXCIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWFyY2hQYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYWlyID0gc2VhcmNoUGFyYW1zW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgIG9wdGlvbnNbcGFpclswXV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gICAgdmFyIHNjcmlwdFNvdXJjZSA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTtcblxuICAgIGlmIChzY3JpcHRTb3VyY2UpIHtcbiAgICAgIHZhciBzY3JpcHRTb3VyY2VVUkw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZSBwbGFjZWhvbGRlciBgYmFzZVVSTGAgd2l0aCBgd2luZG93LmxvY2F0aW9uLmhyZWZgLFxuICAgICAgICAvLyBpcyB0byBhbGxvdyBwYXJzaW5nIG9mIHBhdGgtcmVsYXRpdmUgb3IgcHJvdG9jb2wtcmVsYXRpdmUgVVJMcyxcbiAgICAgICAgLy8gYW5kIHdpbGwgaGF2ZSBubyBlZmZlY3QgaWYgYHNjcmlwdFNvdXJjZWAgaXMgYSBmdWxseSB2YWxpZCBVUkwuXG4gICAgICAgIHNjcmlwdFNvdXJjZVVSTCA9IG5ldyBVUkwoc2NyaXB0U291cmNlLCBzZWxmLmxvY2F0aW9uLmhyZWYpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBVUkwgcGFyc2luZyBmYWlsZWQsIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIFdlIHdpbGwgc3RpbGwgcHJvY2VlZCB0byBzZWUgaWYgd2UgY2FuIHJlY292ZXIgdXNpbmcgYHJlc291cmNlUXVlcnlgXG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JpcHRTb3VyY2VVUkwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNjcmlwdFNvdXJjZVVSTDtcbiAgICAgICAgb3B0aW9ucy5mcm9tQ3VycmVudFNjcmlwdCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB1cmwucGFyc2Uoc2VsZi5sb2NhdGlvbi5ocmVmLCB0cnVlLCB0cnVlKTtcbiAgICAgIG9wdGlvbnMuZnJvbUN1cnJlbnRTY3JpcHQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZVVSTDsiLCIvKiBnbG9iYWwgX193ZWJwYWNrX2hhc2hfXyAqL1xuaW1wb3J0IGhvdEVtaXR0ZXIgZnJvbSBcIndlYnBhY2svaG90L2VtaXR0ZXIuanNcIjtcbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuL2xvZy5qc1wiO1xuXG5mdW5jdGlvbiByZWxvYWRBcHAoX3JlZiwgc3RhdHVzKSB7XG4gIHZhciBob3QgPSBfcmVmLmhvdCxcbiAgICAgIGxpdmVSZWxvYWQgPSBfcmVmLmxpdmVSZWxvYWQ7XG5cbiAgaWYgKHN0YXR1cy5pc1VubG9hZGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50SGFzaCA9IHN0YXR1cy5jdXJyZW50SGFzaCxcbiAgICAgIHByZXZpb3VzSGFzaCA9IHN0YXR1cy5wcmV2aW91c0hhc2g7XG4gIHZhciBpc0luaXRpYWwgPSBjdXJyZW50SGFzaC5pbmRleE9mKHByZXZpb3VzSGFzaCkgPj0gMDtcblxuICBpZiAoaXNJbml0aWFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCkge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgbG9nLmluZm8oXCJBcHAgdXBkYXRlZC4gUmVsb2FkaW5nLi4uXCIpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gc2VsZi5sb2NhdGlvbi5zZWFyY2gudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsbG93VG9Ib3QgPSBzZWFyY2guaW5kZXhPZihcIndlYnBhY2stZGV2LXNlcnZlci1ob3Q9ZmFsc2VcIikgPT09IC0xO1xuICB2YXIgYWxsb3dUb0xpdmVSZWxvYWQgPSBzZWFyY2guaW5kZXhPZihcIndlYnBhY2stZGV2LXNlcnZlci1saXZlLXJlbG9hZD1mYWxzZVwiKSA9PT0gLTE7XG5cbiAgaWYgKGhvdCAmJiBhbGxvd1RvSG90KSB7XG4gICAgbG9nLmluZm8oXCJBcHAgaG90IHVwZGF0ZS4uLlwiKTtcbiAgICBob3RFbWl0dGVyLmVtaXQoXCJ3ZWJwYWNrSG90VXBkYXRlXCIsIHN0YXR1cy5jdXJyZW50SGFzaCk7XG5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi53aW5kb3cpIHtcbiAgICAgIC8vIGJyb2FkY2FzdCB1cGRhdGUgdG8gd2luZG93XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKFwid2VicGFja0hvdFVwZGF0ZVwiLmNvbmNhdChzdGF0dXMuY3VycmVudEhhc2gpLCBcIipcIik7XG4gICAgfVxuICB9IC8vIGFsbG93IHJlZnJlc2hpbmcgdGhlIHBhZ2Ugb25seSBpZiBsaXZlUmVsb2FkIGlzbid0IGRpc2FibGVkXG4gIGVsc2UgaWYgKGxpdmVSZWxvYWQgJiYgYWxsb3dUb0xpdmVSZWxvYWQpIHtcbiAgICB2YXIgcm9vdFdpbmRvdyA9IHNlbGY7IC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuXG4gICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSBcImFib3V0OlwiKSB7XG4gICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcblxuICAgICAgICBpZiAocm9vdFdpbmRvdy5wYXJlbnQgPT09IHJvb3RXaW5kb3cpIHtcbiAgICAgICAgICAvLyBpZiBwYXJlbnQgZXF1YWxzIGN1cnJlbnQgd2luZG93IHdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3Qgd2hpY2ggd291bGQgY29udGludWUgZm9yZXZlciwgc28gdHJpZ2dlciBhIHJlbG9hZCBhbnl3YXlzXG4gICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCByZWxvYWRBcHA7IiwiLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSAqL1xuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIndlYnBhY2tcIi5jb25jYXQodHlwZSksXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgXCIqXCIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNlbmRNc2c7IiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8qIGdsb2JhbHMgX193ZWJwYWNrX2hhc2hfXyAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcblx0dmFyIGxhc3RIYXNoO1xuXHR2YXIgdXBUb0RhdGUgPSBmdW5jdGlvbiB1cFRvRGF0ZSgpIHtcblx0XHRyZXR1cm4gbGFzdEhhc2guaW5kZXhPZihfX3dlYnBhY2tfaGFzaF9fKSA+PSAwO1xuXHR9O1xuXHR2YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xuXHR2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjaygpIHtcblx0XHRtb2R1bGUuaG90XG5cdFx0XHQuY2hlY2sodHJ1ZSlcblx0XHRcdC50aGVuKGZ1bmN0aW9uICh1cGRhdGVkTW9kdWxlcykge1xuXHRcdFx0XHRpZiAoIXVwZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIENhbm5vdCBmaW5kIHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcblx0XHRcdFx0XHRsb2coXG5cdFx0XHRcdFx0XHRcIndhcm5pbmdcIixcblx0XHRcdFx0XHRcdFwiW0hNUl0gKFByb2JhYmx5IGJlY2F1c2Ugb2YgcmVzdGFydGluZyB0aGUgd2VicGFjay1kZXYtc2VydmVyKVwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF1cFRvRGF0ZSgpKSB7XG5cdFx0XHRcdFx0Y2hlY2soKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlcXVpcmUoXCIuL2xvZy1hcHBseS1yZXN1bHRcIikodXBkYXRlZE1vZHVsZXMsIHVwZGF0ZWRNb2R1bGVzKTtcblxuXHRcdFx0XHRpZiAodXBUb0RhdGUoKSkge1xuXHRcdFx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSBBcHAgaXMgdXAgdG8gZGF0ZS5cIik7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHR2YXIgc3RhdHVzID0gbW9kdWxlLmhvdC5zdGF0dXMoKTtcblx0XHRcdFx0aWYgKFtcImFib3J0XCIsIFwiZmFpbFwiXS5pbmRleE9mKHN0YXR1cykgPj0gMCkge1xuXHRcdFx0XHRcdGxvZyhcblx0XHRcdFx0XHRcdFwid2FybmluZ1wiLFxuXHRcdFx0XHRcdFx0XCJbSE1SXSBDYW5ub3QgYXBwbHkgdXBkYXRlLiBOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBcIiArIGxvZy5mb3JtYXRFcnJvcihlcnIpKTtcblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIFVwZGF0ZSBmYWlsZWQ6IFwiICsgbG9nLmZvcm1hdEVycm9yKGVycikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fTtcblx0dmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9lbWl0dGVyXCIpO1xuXHRob3RFbWl0dGVyLm9uKFwid2VicGFja0hvdFVwZGF0ZVwiLCBmdW5jdGlvbiAoY3VycmVudEhhc2gpIHtcblx0XHRsYXN0SGFzaCA9IGN1cnJlbnRIYXNoO1xuXHRcdGlmICghdXBUb0RhdGUoKSAmJiBtb2R1bGUuaG90LnN0YXR1cygpID09PSBcImlkbGVcIikge1xuXHRcdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdIENoZWNraW5nIGZvciB1cGRhdGVzIG9uIHRoZSBzZXJ2ZXIuLi5cIik7XG5cdFx0XHRjaGVjaygpO1xuXHRcdH1cblx0fSk7XG5cdGxvZyhcImluZm9cIiwgXCJbSE1SXSBXYWl0aW5nIGZvciB1cGRhdGUgc2lnbmFsIGZyb20gV0RTLi4uXCIpO1xufSBlbHNlIHtcblx0dGhyb3cgbmV3IEVycm9yKFwiW0hNUl0gSG90IE1vZHVsZSBSZXBsYWNlbWVudCBpcyBkaXNhYmxlZC5cIik7XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcykge1xuXHR2YXIgdW5hY2NlcHRlZE1vZHVsZXMgPSB1cGRhdGVkTW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG5cdFx0cmV0dXJuIHJlbmV3ZWRNb2R1bGVzICYmIHJlbmV3ZWRNb2R1bGVzLmluZGV4T2YobW9kdWxlSWQpIDwgMDtcblx0fSk7XG5cdHZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG5cblx0aWYgKHVuYWNjZXB0ZWRNb2R1bGVzLmxlbmd0aCA+IDApIHtcblx0XHRsb2coXG5cdFx0XHRcIndhcm5pbmdcIixcblx0XHRcdFwiW0hNUl0gVGhlIGZvbGxvd2luZyBtb2R1bGVzIGNvdWxkbid0IGJlIGhvdCB1cGRhdGVkOiAoVGhleSB3b3VsZCBuZWVkIGEgZnVsbCByZWxvYWQhKVwiXG5cdFx0KTtcblx0XHR1bmFjY2VwdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCFyZW5ld2VkTW9kdWxlcyB8fCByZW5ld2VkTW9kdWxlcy5sZW5ndGggPT09IDApIHtcblx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gTm90aGluZyBob3QgdXBkYXRlZC5cIik7XG5cdH0gZWxzZSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdIFVwZGF0ZWQgbW9kdWxlczpcIik7XG5cdFx0cmVuZXdlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdGlmICh0eXBlb2YgbW9kdWxlSWQgPT09IFwic3RyaW5nXCIgJiYgbW9kdWxlSWQuaW5kZXhPZihcIiFcIikgIT09IC0xKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IG1vZHVsZUlkLnNwbGl0KFwiIVwiKTtcblx0XHRcdFx0bG9nLmdyb3VwQ29sbGFwc2VkKFwiaW5mb1wiLCBcIltITVJdICAtIFwiICsgcGFydHMucG9wKCkpO1xuXHRcdFx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG5cdFx0XHRcdGxvZy5ncm91cEVuZChcImluZm9cIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dmFyIG51bWJlcklkcyA9IHJlbmV3ZWRNb2R1bGVzLmV2ZXJ5KGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBtb2R1bGVJZCA9PT0gXCJudW1iZXJcIjtcblx0XHR9KTtcblx0XHRpZiAobnVtYmVySWRzKVxuXHRcdFx0bG9nKFxuXHRcdFx0XHRcImluZm9cIixcblx0XHRcdFx0J1tITVJdIENvbnNpZGVyIHVzaW5nIHRoZSBvcHRpbWl6YXRpb24ubW9kdWxlSWRzOiBcIm5hbWVkXCIgZm9yIG1vZHVsZSBuYW1lcy4nXG5cdFx0XHQpO1xuXHR9XG59O1xuIiwidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5cbmZ1bmN0aW9uIGR1bW15KCkge31cblxuZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsKSB7XG5cdHZhciBzaG91bGRMb2cgPVxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCIpO1xuXHRyZXR1cm4gc2hvdWxkTG9nO1xufVxuXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGxldmVsLCBtc2cpIHtcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0bG9nRm4obXNnKTtcblx0XHR9XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxldmVsLCBtc2cpIHtcblx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRpZiAobGV2ZWwgPT09IFwiaW5mb1wiKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwid2FybmluZ1wiKSB7XG5cdFx0XHRjb25zb2xlLndhcm4obXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcImVycm9yXCIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IobXNnKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xudmFyIGdyb3VwID0gY29uc29sZS5ncm91cCB8fCBkdW1teTtcbnZhciBncm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgfHwgZHVtbXk7XG52YXIgZ3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kIHx8IGR1bW15O1xuLyogZXNsaW50LWVuYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cblxubW9kdWxlLmV4cG9ydHMuZ3JvdXAgPSBsb2dHcm91cChncm91cCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gbG9nR3JvdXAoZ3JvdXBDb2xsYXBzZWQpO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cEVuZCA9IGxvZ0dyb3VwKGdyb3VwRW5kKTtcblxubW9kdWxlLmV4cG9ydHMuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcblx0bG9nTGV2ZWwgPSBsZXZlbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZvcm1hdEVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXHR2YXIgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuXHR2YXIgc3RhY2sgPSBlcnIuc3RhY2s7XG5cdGlmICghc3RhY2spIHtcblx0XHRyZXR1cm4gbWVzc2FnZTtcblx0fSBlbHNlIGlmIChzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDwgMCkge1xuXHRcdHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzdGFjaztcblx0fVxufTtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE2MzU5ODgxMTkwNTBcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiL2hvbWUvbHVjYXNzaWx2YS9iYWNrdXAvcHJvamV0b3MvZW5kdXJhbmNlL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIlwiLFwibG9jYWxzXCI6ZmFsc2V9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgbW9kdWxlLmhvdC5hY2NlcHQodW5kZWZpbmVkLCBjc3NSZWxvYWQpO1xuICAgIH1cbiAgIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZWRNb2R1bGUuZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgY2FjaGVkTW9kdWxlLmVycm9yO1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHR0cnkge1xuXHRcdHZhciBleGVjT3B0aW9ucyA9IHsgaWQ6IG1vZHVsZUlkLCBtb2R1bGU6IG1vZHVsZSwgZmFjdG9yeTogX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0sIHJlcXVpcmU6IF9fd2VicGFja19yZXF1aXJlX18gfTtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7IGhhbmRsZXIoZXhlY09wdGlvbnMpOyB9KTtcblx0XHRtb2R1bGUgPSBleGVjT3B0aW9ucy5tb2R1bGU7XG5cdFx0ZXhlY09wdGlvbnMuZmFjdG9yeS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBleGVjT3B0aW9ucy5yZXF1aXJlKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0bW9kdWxlLmVycm9yID0gZTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4vLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fO1xuXG4vLyBleHBvc2UgdGhlIG1vZHVsZSBleGVjdXRpb24gaW50ZXJjZXB0b3Jcbl9fd2VicGFja19yZXF1aXJlX18uaSA9IFtdO1xuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFsbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uaHUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiXCIgKyBjaHVua0lkICsgXCIuXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNcIjtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYWxsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRiA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJcIiArIGNodW5rSWQgKyBcIi5jc3NcIjtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5obXJGID0gKCkgPT4gKFwibWFpbi5cIiArIF9fd2VicGFja19yZXF1aXJlX18uaCgpICsgXCIuaG90LXVwZGF0ZS5qc29uXCIpOyIsIl9fd2VicGFja19yZXF1aXJlX18uaCA9ICgpID0+IChcImQ4NGQyYWJjMTJmOGM1NzlkN2FiXCIpIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwidmFyIGluUHJvZ3Jlc3MgPSB7fTtcbnZhciBkYXRhV2VicGFja1ByZWZpeCA9IFwiZmxvZW1hOlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXHRcdHNjcmlwdC5zcmMgPSB1cmw7XG5cdH1cblx0aW5Qcm9ncmVzc1t1cmxdID0gW2RvbmVdO1xuXHR2YXIgb25TY3JpcHRDb21wbGV0ZSA9IChwcmV2LCBldmVudCkgPT4ge1xuXHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cblx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR2YXIgZG9uZUZucyA9IGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRkZWxldGUgaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdHNjcmlwdC5wYXJlbnROb2RlICYmIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZG9uZUZucyAmJiBkb25lRm5zLmZvckVhY2goKGZuKSA9PiAoZm4oZXZlbnQpKSk7XG5cdFx0aWYocHJldikgcmV0dXJuIHByZXYoZXZlbnQpO1xuXHR9XG5cdDtcblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsInZhciBjdXJyZW50TW9kdWxlRGF0YSA9IHt9O1xudmFyIGluc3RhbGxlZE1vZHVsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmM7XG5cbi8vIG1vZHVsZSBhbmQgcmVxdWlyZSBjcmVhdGlvblxudmFyIGN1cnJlbnRDaGlsZE1vZHVsZTtcbnZhciBjdXJyZW50UGFyZW50cyA9IFtdO1xuXG4vLyBzdGF0dXNcbnZhciByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMgPSBbXTtcbnZhciBjdXJyZW50U3RhdHVzID0gXCJpZGxlXCI7XG5cbi8vIHdoaWxlIGRvd25sb2FkaW5nXG52YXIgYmxvY2tpbmdQcm9taXNlcztcblxuLy8gVGhlIHVwZGF0ZSBpbmZvXG52YXIgY3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnM7XG52YXIgcXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbl9fd2VicGFja19yZXF1aXJlX18uaG1yRCA9IGN1cnJlbnRNb2R1bGVEYXRhO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkucHVzaChmdW5jdGlvbiAob3B0aW9ucykge1xuXHR2YXIgbW9kdWxlID0gb3B0aW9ucy5tb2R1bGU7XG5cdHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShvcHRpb25zLnJlcXVpcmUsIG9wdGlvbnMuaWQpO1xuXHRtb2R1bGUuaG90ID0gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG9wdGlvbnMuaWQsIG1vZHVsZSk7XG5cdG1vZHVsZS5wYXJlbnRzID0gY3VycmVudFBhcmVudHM7XG5cdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRvcHRpb25zLnJlcXVpcmUgPSByZXF1aXJlO1xufSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yQyA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmUocmVxdWlyZSwgbW9kdWxlSWQpIHtcblx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cdGlmICghbWUpIHJldHVybiByZXF1aXJlO1xuXHR2YXIgZm4gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG5cdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuXHRcdFx0XHR2YXIgcGFyZW50cyA9IGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cztcblx0XHRcdFx0aWYgKHBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0cGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG5cdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuXHRcdFx0XHRcdHJlcXVlc3QgK1xuXHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG5cdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdCk7XG5cdFx0XHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVxdWlyZShyZXF1ZXN0KTtcblx0fTtcblx0dmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHJlcXVpcmVbbmFtZV07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmVxdWlyZVtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGZvciAodmFyIG5hbWUgaW4gcmVxdWlyZSkge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxdWlyZSwgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKG5hbWUpKTtcblx0XHR9XG5cdH1cblx0Zm4uZSA9IGZ1bmN0aW9uIChjaHVua0lkKSB7XG5cdFx0cmV0dXJuIHRyYWNrQmxvY2tpbmdQcm9taXNlKHJlcXVpcmUuZShjaHVua0lkKSk7XG5cdH07XG5cdHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG1vZHVsZUlkLCBtZSkge1xuXHR2YXIgX21haW4gPSBjdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkO1xuXHR2YXIgaG90ID0ge1xuXHRcdC8vIHByaXZhdGUgc3R1ZmZcblx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9hY2NlcHRlZEVycm9ySGFuZGxlcnM6IHt9LFxuXHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG5cdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG5cdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG5cdFx0X3NlbGZJbnZhbGlkYXRlZDogZmFsc2UsXG5cdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG5cdFx0X21haW46IF9tYWluLFxuXHRcdF9yZXF1aXJlU2VsZjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBtZS5wYXJlbnRzLnNsaWNlKCk7XG5cdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSBfbWFpbiA/IHVuZGVmaW5lZCA6IG1vZHVsZUlkO1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XG5cdFx0fSxcblxuXHRcdC8vIE1vZHVsZSBBUElcblx0XHRhY3RpdmU6IHRydWUsXG5cdFx0YWNjZXB0OiBmdW5jdGlvbiAoZGVwLCBjYWxsYmFjaywgZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHRpZiAoZGVwID09PSB1bmRlZmluZWQpIGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIikgaG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcFtpXV0gPSBlcnJvckhhbmRsZXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBdID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVjbGluZTogZnVuY3Rpb24gKGRlcCkge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbClcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcblx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcblx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9zZWxmSW52YWxpZGF0ZWQgPSB0cnVlO1xuXHRcdFx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgXCJpZGxlXCI6XG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0XHRcdG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRTdGF0dXMoXCJyZWFkeVwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwcmVwYXJlXCI6XG5cdFx0XHRcdGNhc2UgXCJjaGVja1wiOlxuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZVwiOlxuXHRcdFx0XHRjYXNlIFwiYXBwbHlcIjpcblx0XHRcdFx0XHQocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gcXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzIHx8IFtdKS5wdXNoKFxuXHRcdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIGlnbm9yZSByZXF1ZXN0cyBpbiBlcnJvciBzdGF0ZXNcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTWFuYWdlbWVudCBBUElcblx0XHRjaGVjazogaG90Q2hlY2ssXG5cdFx0YXBwbHk6IGhvdEFwcGx5LFxuXHRcdHN0YXR1czogZnVuY3Rpb24gKGwpIHtcblx0XHRcdGlmICghbCkgcmV0dXJuIGN1cnJlbnRTdGF0dXM7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHR2YXIgaWR4ID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG5cdFx0XHRpZiAoaWR4ID49IDApIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9LFxuXG5cdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXG5cdFx0ZGF0YTogY3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXG5cdH07XG5cdGN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcblx0cmV0dXJuIGhvdDtcbn1cblxuZnVuY3Rpb24gc2V0U3RhdHVzKG5ld1N0YXR1cykge1xuXHRjdXJyZW50U3RhdHVzID0gbmV3U3RhdHVzO1xuXHR2YXIgcmVzdWx0cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxuXHRcdHJlc3VsdHNbaV0gPSByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKTtcbn1cblxuZnVuY3Rpb24gdHJhY2tCbG9ja2luZ1Byb21pc2UocHJvbWlzZSkge1xuXHRzd2l0Y2ggKGN1cnJlbnRTdGF0dXMpIHtcblx0XHRjYXNlIFwicmVhZHlcIjpcblx0XHRcdHNldFN0YXR1cyhcInByZXBhcmVcIik7XG5cdFx0XHRibG9ja2luZ1Byb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cdFx0XHR3YWl0Rm9yQmxvY2tpbmdQcm9taXNlcyhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBzZXRTdGF0dXMoXCJyZWFkeVwiKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0Y2FzZSBcInByZXBhcmVcIjpcblx0XHRcdGJsb2NraW5nUHJvbWlzZXMucHVzaChwcm9taXNlKTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fVxufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQmxvY2tpbmdQcm9taXNlcyhmbikge1xuXHRpZiAoYmxvY2tpbmdQcm9taXNlcy5sZW5ndGggPT09IDApIHJldHVybiBmbigpO1xuXHR2YXIgYmxvY2tlciA9IGJsb2NraW5nUHJvbWlzZXM7XG5cdGJsb2NraW5nUHJvbWlzZXMgPSBbXTtcblx0cmV0dXJuIFByb21pc2UuYWxsKGJsb2NrZXIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB3YWl0Rm9yQmxvY2tpbmdQcm9taXNlcyhmbik7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBob3RDaGVjayhhcHBseU9uVXBkYXRlKSB7XG5cdGlmIChjdXJyZW50U3RhdHVzICE9PSBcImlkbGVcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xuXHR9XG5cdHJldHVybiBzZXRTdGF0dXMoXCJjaGVja1wiKVxuXHRcdC50aGVuKF9fd2VicGFja19yZXF1aXJlX18uaG1yTSlcblx0XHQudGhlbihmdW5jdGlvbiAodXBkYXRlKSB7XG5cdFx0XHRpZiAoIXVwZGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gc2V0U3RhdHVzKGFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCkgPyBcInJlYWR5XCIgOiBcImlkbGVcIikudGhlbihcblx0XHRcdFx0XHRmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRTdGF0dXMoXCJwcmVwYXJlXCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgdXBkYXRlZE1vZHVsZXMgPSBbXTtcblx0XHRcdFx0YmxvY2tpbmdQcm9taXNlcyA9IFtdO1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbChcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMpLnJlZHVjZShmdW5jdGlvbiAoXG5cdFx0XHRcdFx0XHRwcm9taXNlcyxcblx0XHRcdFx0XHRcdGtleVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJDW2tleV0oXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZS5jLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGUucixcblx0XHRcdFx0XHRcdFx0dXBkYXRlLm0sXG5cdFx0XHRcdFx0XHRcdHByb21pc2VzLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyxcblx0XHRcdFx0XHRcdFx0dXBkYXRlZE1vZHVsZXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRbXSlcblx0XHRcdFx0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gd2FpdEZvckJsb2NraW5nUHJvbWlzZXMoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKGFwcGx5T25VcGRhdGUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGludGVybmFsQXBwbHkoYXBwbHlPblVwZGF0ZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicmVhZHlcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVwZGF0ZWRNb2R1bGVzO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcbn1cblxuZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0YXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKTtcblxuXHR2YXIgcmVzdWx0cyA9IGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzLm1hcChmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdHJldHVybiBoYW5kbGVyKG9wdGlvbnMpO1xuXHR9KTtcblx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSB1bmRlZmluZWQ7XG5cblx0dmFyIGVycm9ycyA9IHJlc3VsdHNcblx0XHQubWFwKGZ1bmN0aW9uIChyKSB7XG5cdFx0XHRyZXR1cm4gci5lcnJvcjtcblx0XHR9KVxuXHRcdC5maWx0ZXIoQm9vbGVhbik7XG5cblx0aWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG5cdFx0cmV0dXJuIHNldFN0YXR1cyhcImFib3J0XCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgZXJyb3JzWzBdO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXG5cdHZhciBkaXNwb3NlUHJvbWlzZSA9IHNldFN0YXR1cyhcImRpc3Bvc2VcIik7XG5cblx0cmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRpZiAocmVzdWx0LmRpc3Bvc2UpIHJlc3VsdC5kaXNwb3NlKCk7XG5cdH0pO1xuXG5cdC8vIE5vdyBpbiBcImFwcGx5XCIgcGhhc2Vcblx0dmFyIGFwcGx5UHJvbWlzZSA9IHNldFN0YXR1cyhcImFwcGx5XCIpO1xuXG5cdHZhciBlcnJvcjtcblx0dmFyIHJlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuXHR9O1xuXG5cdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcblx0cmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRpZiAocmVzdWx0LmFwcGx5KSB7XG5cdFx0XHR2YXIgbW9kdWxlcyA9IHJlc3VsdC5hcHBseShyZXBvcnRFcnJvcik7XG5cdFx0XHRpZiAobW9kdWxlcykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChtb2R1bGVzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIFByb21pc2UuYWxsKFtkaXNwb3NlUHJvbWlzZSwgYXBwbHlQcm9taXNlXSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaGFuZGxlIGVycm9ycyBpbiBhY2NlcHQgaGFuZGxlcnMgYW5kIHNlbGYgYWNjZXB0ZWQgbW9kdWxlIGxvYWRcblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHJldHVybiBzZXRTdGF0dXMoXCJmYWlsXCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcblx0XHRcdHJldHVybiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGxpc3QpIHtcblx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG5cdFx0XHRcdFx0aWYgKGxpc3QuaW5kZXhPZihtb2R1bGVJZCkgPCAwKSBsaXN0LnB1c2gobW9kdWxlSWQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2V0U3RhdHVzKFwiaWRsZVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBvdXRkYXRlZE1vZHVsZXM7XG5cdFx0fSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhcHBseUludmFsaWRhdGVkTW9kdWxlcygpIHtcblx0aWYgKHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcykge1xuXHRcdGlmICghY3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMpIGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtcklba2V5XShcblx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCJ2YXIgY3JlYXRlU3R5bGVzaGVldCA9IChjaHVua0lkLCBmdWxsaHJlZiwgcmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdHZhciBsaW5rVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0bGlua1RhZy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblx0bGlua1RhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR2YXIgb25MaW5rQ29tcGxldGUgPSAoZXZlbnQpID0+IHtcblx0XHQvLyBhdm9pZCBtZW0gbGVha3MuXG5cdFx0bGlua1RhZy5vbmVycm9yID0gbGlua1RhZy5vbmxvYWQgPSBudWxsO1xuXHRcdGlmIChldmVudC50eXBlID09PSAnbG9hZCcpIHtcblx0XHRcdHJlc29sdmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGVycm9yVHlwZSA9IGV2ZW50ICYmIChldmVudC50eXBlID09PSAnbG9hZCcgPyAnbWlzc2luZycgOiBldmVudC50eXBlKTtcblx0XHRcdHZhciByZWFsSHJlZiA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuaHJlZiB8fCBmdWxsaHJlZjtcblx0XHRcdHZhciBlcnIgPSBuZXcgRXJyb3IoXCJMb2FkaW5nIENTUyBjaHVuayBcIiArIGNodW5rSWQgKyBcIiBmYWlsZWQuXFxuKFwiICsgcmVhbEhyZWYgKyBcIilcIik7XG5cdFx0XHRlcnIuY29kZSA9IFwiQ1NTX0NIVU5LX0xPQURfRkFJTEVEXCI7XG5cdFx0XHRlcnIudHlwZSA9IGVycm9yVHlwZTtcblx0XHRcdGVyci5yZXF1ZXN0ID0gcmVhbEhyZWY7XG5cdFx0XHRsaW5rVGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGlua1RhZylcblx0XHRcdHJlamVjdChlcnIpO1xuXHRcdH1cblx0fVxuXHRsaW5rVGFnLm9uZXJyb3IgPSBsaW5rVGFnLm9ubG9hZCA9IG9uTGlua0NvbXBsZXRlO1xuXHRsaW5rVGFnLmhyZWYgPSBmdWxsaHJlZjtcblxuXHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmtUYWcpO1xuXHRyZXR1cm4gbGlua1RhZztcbn07XG52YXIgZmluZFN0eWxlc2hlZXQgPSAoaHJlZiwgZnVsbGhyZWYpID0+IHtcblx0dmFyIGV4aXN0aW5nTGlua1RhZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIik7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBleGlzdGluZ0xpbmtUYWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHRhZyA9IGV4aXN0aW5nTGlua1RhZ3NbaV07XG5cdFx0dmFyIGRhdGFIcmVmID0gdGFnLmdldEF0dHJpYnV0ZShcImRhdGEtaHJlZlwiKSB8fCB0YWcuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcblx0XHRpZih0YWcucmVsID09PSBcInN0eWxlc2hlZXRcIiAmJiAoZGF0YUhyZWYgPT09IGhyZWYgfHwgZGF0YUhyZWYgPT09IGZ1bGxocmVmKSkgcmV0dXJuIHRhZztcblx0fVxuXHR2YXIgZXhpc3RpbmdTdHlsZVRhZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0eWxlXCIpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgZXhpc3RpbmdTdHlsZVRhZ3MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdGFnID0gZXhpc3RpbmdTdHlsZVRhZ3NbaV07XG5cdFx0dmFyIGRhdGFIcmVmID0gdGFnLmdldEF0dHJpYnV0ZShcImRhdGEtaHJlZlwiKTtcblx0XHRpZihkYXRhSHJlZiA9PT0gaHJlZiB8fCBkYXRhSHJlZiA9PT0gZnVsbGhyZWYpIHJldHVybiB0YWc7XG5cdH1cbn07XG52YXIgbG9hZFN0eWxlc2hlZXQgPSAoY2h1bmtJZCkgPT4ge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdHZhciBocmVmID0gX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRihjaHVua0lkKTtcblx0XHR2YXIgZnVsbGhyZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBocmVmO1xuXHRcdGlmKGZpbmRTdHlsZXNoZWV0KGhyZWYsIGZ1bGxocmVmKSkgcmV0dXJuIHJlc29sdmUoKTtcblx0XHRjcmVhdGVTdHlsZXNoZWV0KGNodW5rSWQsIGZ1bGxocmVmLCByZXNvbHZlLCByZWplY3QpO1xuXHR9KTtcbn1cbi8vIG5vIGNodW5rIGxvYWRpbmdcblxudmFyIG9sZFRhZ3MgPSBbXTtcbnZhciBuZXdUYWdzID0gW107XG52YXIgYXBwbHlIYW5kbGVyID0gKG9wdGlvbnMpID0+IHtcblx0cmV0dXJuIHsgZGlzcG9zZTogKCkgPT4ge1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBvbGRUYWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgb2xkVGFnID0gb2xkVGFnc1tpXTtcblx0XHRcdGlmKG9sZFRhZy5wYXJlbnROb2RlKSBvbGRUYWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvbGRUYWcpO1xuXHRcdH1cblx0XHRvbGRUYWdzLmxlbmd0aCA9IDA7XG5cdH0sIGFwcGx5OiAoKSA9PiB7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5ld1RhZ3MubGVuZ3RoOyBpKyspIG5ld1RhZ3NbaV0ucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdFx0bmV3VGFncy5sZW5ndGggPSAwO1xuXHR9IH07XG59XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMubWluaUNzcyA9IChjaHVua0lkcywgcmVtb3ZlZENodW5rcywgcmVtb3ZlZE1vZHVsZXMsIHByb21pc2VzLCBhcHBseUhhbmRsZXJzLCB1cGRhdGVkTW9kdWxlc0xpc3QpID0+IHtcblx0YXBwbHlIYW5kbGVycy5wdXNoKGFwcGx5SGFuZGxlcik7XG5cdGNodW5rSWRzLmZvckVhY2goKGNodW5rSWQpID0+IHtcblx0XHR2YXIgaHJlZiA9IF9fd2VicGFja19yZXF1aXJlX18ubWluaUNzc0YoY2h1bmtJZCk7XG5cdFx0dmFyIGZ1bGxocmVmID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgaHJlZjtcblx0XHR2YXIgb2xkVGFnID0gZmluZFN0eWxlc2hlZXQoaHJlZiwgZnVsbGhyZWYpO1xuXHRcdGlmKCFvbGRUYWcpIHJldHVybjtcblx0XHRwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHZhciB0YWcgPSBjcmVhdGVTdHlsZXNoZWV0KGNodW5rSWQsIGZ1bGxocmVmLCAoKSA9PiB7XG5cdFx0XHRcdHRhZy5hcyA9IFwic3R5bGVcIjtcblx0XHRcdFx0dGFnLnJlbCA9IFwicHJlbG9hZFwiO1xuXHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHR9LCByZWplY3QpO1xuXHRcdFx0b2xkVGFncy5wdXNoKG9sZFRhZyk7XG5cdFx0XHRuZXdUYWdzLnB1c2godGFnKTtcblx0XHR9KSk7XG5cdH0pO1xufSIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5obXJTX2pzb25wID0gX193ZWJwYWNrX3JlcXVpcmVfXy5obXJTX2pzb25wIHx8IHtcblx0XCJtYWluXCI6IDBcbn07XG5cbi8vIG5vIGNodW5rIG9uIGRlbWFuZCBsb2FkaW5nXG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG52YXIgY3VycmVudFVwZGF0ZWRNb2R1bGVzTGlzdDtcbnZhciB3YWl0aW5nVXBkYXRlUmVzb2x2ZXMgPSB7fTtcbmZ1bmN0aW9uIGxvYWRVcGRhdGVDaHVuayhjaHVua0lkKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gcmVzb2x2ZTtcblx0XHQvLyBzdGFydCB1cGRhdGUgY2h1bmsgbG9hZGluZ1xuXHRcdHZhciB1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmh1KGNodW5rSWQpO1xuXHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRpZih3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0pIHtcblx0XHRcdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gdW5kZWZpbmVkXG5cdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBob3QgdXBkYXRlIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0ZXJyb3IubmFtZSA9ICdDaHVua0xvYWRFcnJvcic7XG5cdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkKTtcblx0fSk7XG59XG5cbnNlbGZbXCJ3ZWJwYWNrSG90VXBkYXRlZmxvZW1hXCJdID0gKGNodW5rSWQsIG1vcmVNb2R1bGVzLCBydW50aW1lKSA9PiB7XG5cdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0Y3VycmVudFVwZGF0ZVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHRpZihjdXJyZW50VXBkYXRlZE1vZHVsZXNMaXN0KSBjdXJyZW50VXBkYXRlZE1vZHVsZXNMaXN0LnB1c2gobW9kdWxlSWQpO1xuXHRcdH1cblx0fVxuXHRpZihydW50aW1lKSBjdXJyZW50VXBkYXRlUnVudGltZS5wdXNoKHJ1bnRpbWUpO1xuXHRpZih3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0pIHtcblx0XHR3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0oKTtcblx0XHR3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG5cdH1cbn07XG5cbnZhciBjdXJyZW50VXBkYXRlQ2h1bmtzO1xudmFyIGN1cnJlbnRVcGRhdGU7XG52YXIgY3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3M7XG52YXIgY3VycmVudFVwZGF0ZVJ1bnRpbWU7XG5mdW5jdGlvbiBhcHBseUhhbmRsZXIob3B0aW9ucykge1xuXHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5mKSBkZWxldGUgX193ZWJwYWNrX3JlcXVpcmVfXy5mLmpzb25wSG1yO1xuXHRjdXJyZW50VXBkYXRlQ2h1bmtzID0gdW5kZWZpbmVkO1xuXHRmdW5jdGlvbiBnZXRBZmZlY3RlZE1vZHVsZUVmZmVjdHModXBkYXRlTW9kdWxlSWQpIHtcblx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW3VwZGF0ZU1vZHVsZUlkXTtcblx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcblxuXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjaGFpbjogW2lkXSxcblx0XHRcdFx0aWQ6IGlkXG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgcXVldWVJdGVtID0gcXVldWUucG9wKCk7XG5cdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XG5cdFx0XHR2YXIgY2hhaW4gPSBxdWV1ZUl0ZW0uY2hhaW47XG5cdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblx0XHRcdGlmIChcblx0XHRcdFx0IW1vZHVsZSB8fFxuXHRcdFx0XHQobW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkICYmICFtb2R1bGUuaG90Ll9zZWxmSW52YWxpZGF0ZWQpXG5cdFx0XHQpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0aWYgKG1vZHVsZS5ob3QuX3NlbGZEZWNsaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxuXHRcdFx0XHRcdGNoYWluOiBjaGFpbixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChtb2R1bGUuaG90Ll9tYWluKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuXHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcblx0XHRcdFx0dmFyIHBhcmVudCA9IF9fd2VicGFja19yZXF1aXJlX18uY1twYXJlbnRJZF07XG5cdFx0XHRcdGlmICghcGFyZW50KSBjb250aW51ZTtcblx0XHRcdFx0aWYgKHBhcmVudC5ob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcImRlY2xpbmVkXCIsXG5cdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxuXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0cGFyZW50SWQ6IHBhcmVudElkXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3V0ZGF0ZWRNb2R1bGVzLmluZGV4T2YocGFyZW50SWQpICE9PSAtMSkgY29udGludWU7XG5cdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcblx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSlcblx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xuXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSwgW21vZHVsZUlkXSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXTtcblx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gocGFyZW50SWQpO1xuXHRcdFx0XHRxdWV1ZS5wdXNoKHtcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxuXHRcdFx0XHRcdGlkOiBwYXJlbnRJZFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogXCJhY2NlcHRlZFwiLFxuXHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxuXHRcdFx0b3V0ZGF0ZWRNb2R1bGVzOiBvdXRkYXRlZE1vZHVsZXMsXG5cdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llczogb3V0ZGF0ZWREZXBlbmRlbmNpZXNcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xuXHRcdFx0aWYgKGEuaW5kZXhPZihpdGVtKSA9PT0gLTEpIGEucHVzaChpdGVtKTtcblx0XHR9XG5cdH1cblxuXHQvLyBhdCBiZWdpbiBhbGwgdXBkYXRlcyBtb2R1bGVzIGFyZSBvdXRkYXRlZFxuXHQvLyB0aGUgXCJvdXRkYXRlZFwiIHN0YXR1cyBjYW4gcHJvcGFnYXRlIHRvIHBhcmVudHMgaWYgdGhleSBkb24ndCBhY2NlcHQgdGhlIGNoaWxkcmVuXG5cdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHZhciBhcHBsaWVkVXBkYXRlID0ge307XG5cblx0dmFyIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSA9IGZ1bmN0aW9uIHdhcm5VbmV4cGVjdGVkUmVxdWlyZShtb2R1bGUpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIG1vZHVsZS5pZCArIFwiKSB0byBkaXNwb3NlZCBtb2R1bGVcIlxuXHRcdCk7XG5cdH07XG5cblx0Zm9yICh2YXIgbW9kdWxlSWQgaW4gY3VycmVudFVwZGF0ZSkge1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8oY3VycmVudFVwZGF0ZSwgbW9kdWxlSWQpKSB7XG5cdFx0XHR2YXIgbmV3TW9kdWxlRmFjdG9yeSA9IGN1cnJlbnRVcGRhdGVbbW9kdWxlSWRdO1xuXHRcdFx0LyoqIEB0eXBlIHtUT0RPfSAqL1xuXHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdGlmIChuZXdNb2R1bGVGYWN0b3J5KSB7XG5cdFx0XHRcdHJlc3VsdCA9IGdldEFmZmVjdGVkTW9kdWxlRWZmZWN0cyhtb2R1bGVJZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxuXHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0LyoqIEB0eXBlIHtFcnJvcnxmYWxzZX0gKi9cblx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XG5cdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xuXHRcdFx0dmFyIGRvRGlzcG9zZSA9IGZhbHNlO1xuXHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XG5cdFx0XHRpZiAocmVzdWx0LmNoYWluKSB7XG5cdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuXHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG5cdFx0XHRcdFx0XHRcdFx0XCIgaW4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wYXJlbnRJZCArXG5cdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uVW5hY2NlcHRlZCkgb3B0aW9ucy5vblVuYWNjZXB0ZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25BY2NlcHRlZCkgb3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGlzcG9zZWQpIG9wdGlvbnMub25EaXNwb3NlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcblx0XHRcdH1cblx0XHRcdGlmIChhYm9ydEVycm9yKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXJyb3I6IGFib3J0RXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChkb0FwcGx5KSB7XG5cdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gbmV3TW9kdWxlRmFjdG9yeTtcblx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcblx0XHRcdFx0Zm9yIChtb2R1bGVJZCBpbiByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XG5cdFx0XHRcdFx0XHRhZGRBbGxUb1NldChcblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLFxuXHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvRGlzcG9zZSkge1xuXHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIFtyZXN1bHQubW9kdWxlSWRdKTtcblx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGN1cnJlbnRVcGRhdGUgPSB1bmRlZmluZWQ7XG5cblx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxuXHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XG5cdGZvciAodmFyIGogPSAwOyBqIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0dmFyIG91dGRhdGVkTW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbal07XG5cdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRpZiAoXG5cdFx0XHRtb2R1bGUgJiZcblx0XHRcdChtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQgfHwgbW9kdWxlLmhvdC5fbWFpbikgJiZcblx0XHRcdC8vIHJlbW92ZWQgc2VsZi1hY2NlcHRlZCBtb2R1bGVzIHNob3VsZCBub3QgYmUgcmVxdWlyZWRcblx0XHRcdGFwcGxpZWRVcGRhdGVbb3V0ZGF0ZWRNb2R1bGVJZF0gIT09IHdhcm5VbmV4cGVjdGVkUmVxdWlyZSAmJlxuXHRcdFx0Ly8gd2hlbiBjYWxsZWQgaW52YWxpZGF0ZSBzZWxmLWFjY2VwdGluZyBpcyBub3QgcG9zc2libGVcblx0XHRcdCFtb2R1bGUuaG90Ll9zZWxmSW52YWxpZGF0ZWRcblx0XHQpIHtcblx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcblx0XHRcdFx0bW9kdWxlOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRyZXF1aXJlOiBtb2R1bGUuaG90Ll9yZXF1aXJlU2VsZixcblx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWRcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcblxuXHRyZXR1cm4ge1xuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rSWQpIHtcblx0XHRcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdH0pO1xuXHRcdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSB1bmRlZmluZWQ7XG5cblx0XHRcdHZhciBpZHg7XG5cdFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcblx0XHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblx0XHRcdFx0aWYgKCFtb2R1bGUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXG5cdFx0XHRcdHZhciBkaXNwb3NlSGFuZGxlcnMgPSBtb2R1bGUuaG90Ll9kaXNwb3NlSGFuZGxlcnM7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRkaXNwb3NlSGFuZGxlcnNbal0uY2FsbChudWxsLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckRbbW9kdWxlSWRdID0gZGF0YTtcblxuXHRcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxuXHRcdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxuXHRcdFx0XHRkZWxldGUgX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblxuXHRcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXG5cdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuXHRcdFx0XHRcdGlmICghY2hpbGQpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XG5cdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxuXHRcdFx0dmFyIGRlcGVuZGVuY3k7XG5cdFx0XHRmb3IgKHZhciBvdXRkYXRlZE1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG91dGRhdGVkTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0bW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdGlmIChtb2R1bGUpIHtcblx0XHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID1cblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuXHRcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcblx0XHRcdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBtb2R1bGUuY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcHBseTogZnVuY3Rpb24gKHJlcG9ydEVycm9yKSB7XG5cdFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcblx0XHRcdGZvciAodmFyIHVwZGF0ZU1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhhcHBsaWVkVXBkYXRlLCB1cGRhdGVNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bdXBkYXRlTW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVt1cGRhdGVNb2R1bGVJZF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcnVuIG5ldyBydW50aW1lIG1vZHVsZXNcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudFVwZGF0ZVJ1bnRpbWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y3VycmVudFVwZGF0ZVJ1bnRpbWVbaV0oX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbGwgYWNjZXB0IGhhbmRsZXJzXG5cdFx0XHRmb3IgKHZhciBvdXRkYXRlZE1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG91dGRhdGVkTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRpZiAobW9kdWxlKSB7XG5cdFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9XG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIGVycm9ySGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcblx0XHRcdFx0XHRcdFx0dmFyIGFjY2VwdENhbGxiYWNrID1cblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcblx0XHRcdFx0XHRcdFx0dmFyIGVycm9ySGFuZGxlciA9XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcGVuZGVuY3ldO1xuXHRcdFx0XHRcdFx0XHRpZiAoYWNjZXB0Q2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2tzLmluZGV4T2YoYWNjZXB0Q2FsbGJhY2spICE9PSAtMSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goYWNjZXB0Q2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9ySGFuZGxlcnMucHVzaChlcnJvckhhbmRsZXIpO1xuXHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrcy5wdXNoKGRlcGVuZGVuY3kpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGNhbGxiYWNrcy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrc1trXS5jYWxsKG51bGwsIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvckhhbmRsZXJzW2tdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9ySGFuZGxlcnNba10oZXJyLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba11cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xuXHRcdFx0Zm9yICh2YXIgbyA9IDA7IG8gPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBvKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbb107XG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGl0ZW0ucmVxdWlyZShtb2R1bGVJZCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyLCB7XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZTogX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH1cblx0fTtcbn1cbl9fd2VicGFja19yZXF1aXJlX18uaG1ySS5qc29ucCA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgYXBwbHlIYW5kbGVycykge1xuXHRpZiAoIWN1cnJlbnRVcGRhdGUpIHtcblx0XHRjdXJyZW50VXBkYXRlID0ge307XG5cdFx0Y3VycmVudFVwZGF0ZVJ1bnRpbWUgPSBbXTtcblx0XHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcyA9IFtdO1xuXHRcdGFwcGx5SGFuZGxlcnMucHVzaChhcHBseUhhbmRsZXIpO1xuXHR9XG5cdGlmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGUsIG1vZHVsZUlkKSkge1xuXHRcdGN1cnJlbnRVcGRhdGVbbW9kdWxlSWRdID0gX193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXTtcblx0fVxufTtcbl9fd2VicGFja19yZXF1aXJlX18uaG1yQy5qc29ucCA9IGZ1bmN0aW9uIChcblx0Y2h1bmtJZHMsXG5cdHJlbW92ZWRDaHVua3MsXG5cdHJlbW92ZWRNb2R1bGVzLFxuXHRwcm9taXNlcyxcblx0YXBwbHlIYW5kbGVycyxcblx0dXBkYXRlZE1vZHVsZXNMaXN0XG4pIHtcblx0YXBwbHlIYW5kbGVycy5wdXNoKGFwcGx5SGFuZGxlcik7XG5cdGN1cnJlbnRVcGRhdGVDaHVua3MgPSB7fTtcblx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSByZW1vdmVkQ2h1bmtzO1xuXHRjdXJyZW50VXBkYXRlID0gcmVtb3ZlZE1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuXHRcdG9ialtrZXldID0gZmFsc2U7XG5cdFx0cmV0dXJuIG9iajtcblx0fSwge30pO1xuXHRjdXJyZW50VXBkYXRlUnVudGltZSA9IFtdO1xuXHRjaHVua0lkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVua0lkKSB7XG5cdFx0aWYgKFxuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiZcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSAhPT0gdW5kZWZpbmVkXG5cdFx0KSB7XG5cdFx0XHRwcm9taXNlcy5wdXNoKGxvYWRVcGRhdGVDaHVuayhjaHVua0lkLCB1cGRhdGVkTW9kdWxlc0xpc3QpKTtcblx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3NbY2h1bmtJZF0gPSB0cnVlO1xuXHRcdH1cblx0fSk7XG5cdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmYpIHtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmYuanNvbnBIbXIgPSBmdW5jdGlvbiAoY2h1bmtJZCwgcHJvbWlzZXMpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rcyAmJlxuXHRcdFx0XHQhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGVDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSAhPT0gdW5kZWZpbmVkXG5cdFx0XHQpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkpO1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0gPSAoKSA9PiB7XG5cdGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgc3VwcG9ydDogbmVlZCBmZXRjaCBBUElcIik7XG5cdHJldHVybiBmZXRjaChfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckYoKSkudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRpZihyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkgcmV0dXJuOyAvLyBubyB1cGRhdGUgYXZhaWxhYmxlXG5cdFx0aWYoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggdXBkYXRlIG1hbmlmZXN0IFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cdFx0cmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcblx0fSk7XG59O1xuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIG5vIGpzb25wIGZ1bmN0aW9uIiwiIiwiLy8gbW9kdWxlIGNhY2hlIGFyZSB1c2VkIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L2luZGV4LmpzP3Byb3RvY29sPXdzJTNBJmhvc3RuYW1lPTAuMC4wLjAmcG9ydD04MDgwJnBhdGhuYW1lPSUyRndzJmxvZ2dpbmc9aW5mb1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9kZXYtc2VydmVyLmpzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vYXBwL2luZGV4LmpzXCIpO1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zdHlsZXMvaW5kZXguc2Nzc1wiKTtcbiIsIiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJlYWNoIiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJlbGVtZW50IiwiZWxlbWVudHMiLCJzZWxlY3RvciIsInNlbGVjdG9yQ2hpbGRyZW4iLCJjcmVhdGUiLCJhZGRFdmVudExpc3RlbmVycyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImVudHJ5Iiwia2V5Iiwid2luZG93IiwiSFRNTEVsZW1lbnQiLCJOb2RlTGlzdCIsIkFycmF5IiwiaXNBcnJheSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsZW5naHQiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsIkdTQVAiLCJQcmVmaXgiLCJQYWdlIiwiaWQiLCJzY3JvbGwiLCJjdXJyZW50IiwidGFyZ2V0IiwibGltaXQiLCJ0cmFuc2Zvcm1QcmVmaXgiLCJnZXRDdXJzb3IiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwic2hvdyIsImFuaW1hdGVJbiIsInRpbWVsaW5lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmcm9tIiwiYXV0b0FscGhhIiwib25Db21wbGV0ZSIsImhpZGUiLCJhbmltYXRlT3V0IiwidG8iLCJ1cGRhdGUiLCJ1dGlscyIsImludGVycG9sYXRlIiwiY2xhbXAiLCJpdGVtIiwic3R5bGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJkZWx0YVkiLCJjdXJzb3IiLCJsZWZ0IiwiY2xpZW50WCIsInRvcCIsImNsaWVudFkiLCJnc2FwIiwic3BsaXQiLCJQcmVsb2FkZXIiLCJ0aXRsZSIsIm51bWJlciIsImltYWdlcyIsImNyZWF0ZUxvYWRlciIsInRpdGxlU3BhbnMiLCJvbkFzc2V0TG9hZGVkIiwiaW1hZ2UiLCJwZXJjZW50IiwiTWF0aCIsInJvdW5kIiwiaW5uZXJIVE1MIiwib25Mb2FkZWQiLCJzcmMiLCJnZXRBdHRyaWJ1dGUiLCJvbmxvYWQiLCJfIiwic3RhZ2dlciIsImR1cmF0aW9uIiwiZWFzZSIsInkiLCJkZWxheSIsImRlc3Ryb3kiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJBYm91dCIsIkhvbWUiLCJBcHAiLCJjcmVhdGVQcmVsb2FkZXIiLCJjcmVhdGVDb250ZW50IiwiY3JlYXRlUGFnZXMiLCJhZGRMaW5rTGlzdGVuZXJzIiwib25QcmVsb2FkZWQiLCJwcmVsb2FkZXIiLCJvbmNlIiwiYmluZCIsImNvbnRlbnQiLCJ0ZW1wbGF0ZSIsInBhZ2VzIiwiaG9tZSIsImFib3V0IiwicGFnZSIsIm9uQ2hhbmdlIiwidXJsIiwicmVxdWVzdCIsImZldGNoIiwic3RhdHVzIiwibmV4dFBhZ2UiLCJ0ZXh0IiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsImRpdkNvbnRlbnQiLCJzZXRBdHRyaWJ1dGUiLCJsaW5rcyIsImxpbmsiLCJvbmNsaWNrIiwicHJldmVudERlZmF1bHQiLCJocmVmIiwiZnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3cmFwcGVyIiwibmF2aWdhdGlvbiIsImV4cHJlc3Npb24iLCJhcHBlbmQiLCJ3b3JkcyIsInNwbGl0VGV4dCIsInRvU3RyaW5nIiwidHJpbSIsImxpbmUiLCJpbmRleE9mIiwibGluZXMiLCJpbmRleCIsInBhcnNlTGluZSIsInNwYW5zIiwic3BhbiIsImlzU2luZ2xlTGV0dGVyIiwidGV4dENvbnRlbnQiLCJpc05vdEVtcHR5IiwiaXNOb3RBbmRDaGFyYWN0ZXIiLCJpc05vdERhc2hDaGFyYWN0ZXIiLCJjYWxjdWxhdGUiLCJwb3NpdGlvbiIsIm9mZnNldFRvcCIsInB1c2giLCJzcGxpdHMiLCJjb25jYXQiLCJpc0xpbmsiLCJ3b3JkIiwiaW5jbHVkZXMiLCJtb2R1bGUiLCJleHBvcnRzIiwiYW5zaUhUTUwiLCJfcmVnQU5TSSIsIl9kZWZDb2xvcnMiLCJyZXNldCIsImJsYWNrIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsImN5YW4iLCJsaWdodGdyZXkiLCJkYXJrZ3JleSIsIl9zdHlsZXMiLCJfb3BlblRhZ3MiLCJfY2xvc2VUYWdzIiwiZm9yRWFjaCIsIm4iLCJ0ZXN0IiwiYW5zaUNvZGVzIiwicmV0IiwicmVwbGFjZSIsIm1hdGNoIiwic2VxIiwib3QiLCJwb3AiLCJjdCIsImwiLCJqb2luIiwic2V0Q29sb3JzIiwiY29sb3JzIiwiRXJyb3IiLCJfZmluYWxDb2xvcnMiLCJoZXgiLCJoYXNPd25Qcm9wZXJ0eSIsInNvbWUiLCJoIiwiZGVmSGV4Q29sb3IiLCJzbGljZSIsIl9zZXRUYWdzIiwidGFncyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwib3BlbiIsImNsb3NlIiwiY29kZSIsImNvbG9yIiwib3JpQ29sb3IiLCJwYXJzZUludCIsIlIiLCJSZWZsZWN0IiwiUmVmbGVjdEFwcGx5IiwiYXBwbHkiLCJyZWNlaXZlciIsImFyZ3MiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImNhbGwiLCJSZWZsZWN0T3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIndhcm4iLCJOdW1iZXJJc05hTiIsIk51bWJlciIsImlzTmFOIiwidmFsdWUiLCJpbml0IiwiX2V2ZW50cyIsInVuZGVmaW5lZCIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwiVHlwZUVycm9yIiwiZW51bWVyYWJsZSIsInNldCIsImFyZyIsIlJhbmdlRXJyb3IiLCJnZXRQcm90b3R5cGVPZiIsInNldE1heExpc3RlbmVycyIsIl9nZXRNYXhMaXN0ZW5lcnMiLCJ0aGF0IiwiZ2V0TWF4TGlzdGVuZXJzIiwiZW1pdCIsInR5cGUiLCJpIiwiYXJndW1lbnRzIiwiZG9FcnJvciIsImV2ZW50cyIsImVycm9yIiwiZXIiLCJlcnIiLCJtZXNzYWdlIiwiY29udGV4dCIsImhhbmRsZXIiLCJsZW4iLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsIm0iLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsInciLCJTdHJpbmciLCJuYW1lIiwiZW1pdHRlciIsImNvdW50IiwiYWRkTGlzdGVuZXIiLCJvbiIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJyZW1vdmVMaXN0ZW5lciIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0Iiwib3JpZ2luYWxMaXN0ZW5lciIsInNoaWZ0Iiwic3BsaWNlT25lIiwib2ZmIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwia2V5cyIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJhcnIiLCJjb3B5IiwicmVqZWN0IiwiZXJyb3JMaXN0ZW5lciIsInJlc29sdmVyIiwiZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyIiwiYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIiLCJmbGFncyIsIndyYXBMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfZ2V0UHJvcGVydHkiLCJfbnVtRXhwIiwiX251bVdpdGhVbml0RXhwIiwiZ2V0VW5pdCIsIl9pc1N0cmluZyIsIl9pc1VuZGVmaW5lZCIsIl9yZW5kZXJDb21wbGV4U3RyaW5nIiwiX3JlbEV4cCIsIl9mb3JFYWNoTmFtZSIsIl9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkiLCJfY29sb3JTdHJpbmdGaWx0ZXIiLCJfY2hlY2tQbHVnaW4iLCJfcmVwbGFjZVJhbmRvbSIsIl9wbHVnaW5zIiwiR1NDYWNoZSIsIlByb3BUd2VlbiIsIl9jb25maWciLCJfdGlja2VyIiwiX3JvdW5kIiwiX21pc3NpbmdQbHVnaW4iLCJfZ2V0U2V0dGVyIiwiX2dldENhY2hlIiwiX2NvbG9yRXhwIiwiX3NldERlZmF1bHRzIiwiX3JlbW92ZUxpbmtlZExpc3RJdGVtIiwiX3dpbiIsIl9kb2MiLCJfZG9jRWxlbWVudCIsIl9wbHVnaW5Jbml0dGVkIiwiX3RlbXBEaXYiLCJfdGVtcERpdlN0eWxlciIsIl9yZWNlbnRTZXR0ZXJQbHVnaW4iLCJfd2luZG93RXhpc3RzIiwiX3RyYW5zZm9ybVByb3BzIiwiX1JBRDJERUciLCJQSSIsIl9ERUcyUkFEIiwiX2F0YW4yIiwiYXRhbjIiLCJfYmlnTnVtIiwiX2NhcHNFeHAiLCJfaG9yaXpvbnRhbEV4cCIsIl9jb21wbGV4RXhwIiwiX3Byb3BlcnR5QWxpYXNlcyIsInNjYWxlIiwiYWxwaGEiLCJfcmVuZGVyQ1NTUHJvcCIsInJhdGlvIiwiZGF0YSIsInQiLCJwIiwicyIsImMiLCJ1IiwiX3JlbmRlclByb3BXaXRoRW5kIiwiZSIsIl9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyIsImIiLCJfcmVuZGVyUm91bmRlZENTU1Byb3AiLCJfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIiwiX3NldHRlckNTU1N0eWxlIiwicHJvcGVydHkiLCJfc2V0dGVyQ1NTUHJvcCIsInNldFByb3BlcnR5IiwiX3NldHRlclRyYW5zZm9ybSIsIl9nc2FwIiwiX3NldHRlclNjYWxlIiwic2NhbGVYIiwic2NhbGVZIiwiX3NldHRlclNjYWxlV2l0aFJlbmRlciIsImNhY2hlIiwicmVuZGVyVHJhbnNmb3JtIiwiX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIiLCJfdHJhbnNmb3JtUHJvcCIsIl90cmFuc2Zvcm1PcmlnaW5Qcm9wIiwiX3N1cHBvcnRzM0QiLCJfY3JlYXRlRWxlbWVudCIsIm5zIiwiY3JlYXRlRWxlbWVudE5TIiwiX2dldENvbXB1dGVkUHJvcGVydHkiLCJza2lwUHJlZml4RmFsbGJhY2siLCJjcyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwidG9Mb3dlckNhc2UiLCJfY2hlY2tQcm9wUHJlZml4IiwiX3ByZWZpeGVzIiwicHJlZmVyUHJlZml4IiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzdWJzdHIiLCJfaW5pdENvcmUiLCJkb2N1bWVudEVsZW1lbnQiLCJjc3NUZXh0IiwiX2dldEJCb3hIYWNrIiwic3dhcElmUG9zc2libGUiLCJzdmciLCJvd25lclNWR0VsZW1lbnQiLCJvbGRQYXJlbnQiLCJvbGRTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJvbGRDU1MiLCJiYm94IiwiYXBwZW5kQ2hpbGQiLCJkaXNwbGF5IiwiZ2V0QkJveCIsIl9nc2FwQkJveCIsImluc2VydEJlZm9yZSIsIl9nZXRBdHRyaWJ1dGVGYWxsYmFja3MiLCJhdHRyaWJ1dGVzQXJyYXkiLCJoYXNBdHRyaWJ1dGUiLCJfZ2V0QkJveCIsImJvdW5kcyIsIndpZHRoIiwiaGVpZ2h0IiwieCIsIl9pc1NWRyIsImdldENUTSIsIl9yZW1vdmVQcm9wZXJ0eSIsInJlbW92ZVByb3BlcnR5IiwicmVtb3ZlQXR0cmlidXRlIiwiX2FkZE5vblR3ZWVuaW5nUFQiLCJwbHVnaW4iLCJiZWdpbm5pbmciLCJlbmQiLCJvbmx5U2V0QXRFbmQiLCJwdCIsIl9wdCIsIl9wcm9wcyIsIl9ub25Db252ZXJ0aWJsZVVuaXRzIiwiZGVnIiwicmFkIiwidHVybiIsIl9jb252ZXJ0VG9Vbml0IiwidW5pdCIsImN1clZhbHVlIiwicGFyc2VGbG9hdCIsImN1clVuaXQiLCJob3Jpem9udGFsIiwiaXNSb290U1ZHIiwidGFnTmFtZSIsIm1lYXN1cmVQcm9wZXJ0eSIsImFtb3VudCIsInRvUGl4ZWxzIiwidG9QZXJjZW50IiwicHgiLCJwYXJlbnQiLCJpc1NWRyIsImJvZHkiLCJ0aW1lIiwiX2dldCIsInVuY2FjaGUiLCJfcGFyc2VUcmFuc2Zvcm0iLCJvcmlnaW4iLCJfZmlyc3RUd29Pbmx5Iiwiek9yaWdpbiIsIl9zcGVjaWFsUHJvcHMiLCJfdHdlZW5Db21wbGV4Q1NTU3RyaW5nIiwicHJvcCIsInN0YXJ0IiwibWF0Y2hJbmRleCIsImEiLCJyZXN1bHQiLCJzdGFydFZhbHVlcyIsInN0YXJ0TnVtIiwic3RhcnRWYWx1ZSIsImVuZFZhbHVlIiwiZW5kTnVtIiwiY2h1bmsiLCJlbmRVbml0Iiwic3RhcnRVbml0IiwicmVsYXRpdmUiLCJlbmRWYWx1ZXMiLCJleGVjIiwic3Vic3RyaW5nIiwibGFzdEluZGV4IiwidW5pdHMiLCJfbmV4dCIsInIiLCJfa2V5d29yZFRvUGVyY2VudCIsImJvdHRvbSIsInJpZ2h0IiwiY2VudGVyIiwiX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMiLCJfcmVuZGVyQ2xlYXJQcm9wcyIsInR3ZWVuIiwiX3RpbWUiLCJfZHVyIiwicHJvcHMiLCJjbGVhclRyYW5zZm9ybXMiLCJjbGVhclByb3BzIiwicHIiLCJfaWRlbnRpdHkyRE1hdHJpeCIsIl9yb3RhdGlvbmFsUHJvcGVydGllcyIsIl9pc051bGxUcmFuc2Zvcm0iLCJfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5IiwibWF0cml4U3RyaW5nIiwibWFwIiwiX2dldE1hdHJpeCIsImZvcmNlMkQiLCJtYXRyaXgiLCJ0ZW1wIiwiYWRkZWRUb0RPTSIsInRyYW5zZm9ybSIsImJhc2VWYWwiLCJjb25zb2xpZGF0ZSIsImQiLCJmIiwib2Zmc2V0UGFyZW50IiwiX2FwcGx5U1ZHT3JpZ2luIiwib3JpZ2luSXNBYnNvbHV0ZSIsInNtb290aCIsIm1hdHJpeEFycmF5IiwicGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8iLCJ4T3JpZ2luT2xkIiwieE9yaWdpbiIsInlPcmlnaW5PbGQiLCJ5T3JpZ2luIiwieE9mZnNldE9sZCIsInhPZmZzZXQiLCJ5T2Zmc2V0T2xkIiwieU9mZnNldCIsInR4IiwidHkiLCJvcmlnaW5TcGxpdCIsImRldGVybWluYW50IiwiaW52ZXJ0ZWRTY2FsZVgiLCJ6Iiwicm90YXRpb24iLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJza2V3WCIsInNrZXdZIiwicGVyc3BlY3RpdmUiLCJhbmdsZSIsImNvcyIsInNpbiIsImExMiIsImEyMiIsInQxIiwidDIiLCJ0MyIsImExMyIsImEyMyIsImEzMyIsImE0MiIsImE0MyIsImEzMiIsInNxcnQiLCJhYnMiLCJmb3JjZUNTUyIsInhQZXJjZW50Iiwib2Zmc2V0V2lkdGgiLCJ5UGVyY2VudCIsIm9mZnNldEhlaWdodCIsInRyYW5zZm9ybVBlcnNwZWN0aXZlIiwiZm9yY2UzRCIsIl9yZW5kZXJTVkdUcmFuc2Zvcm1zIiwiX3JlbmRlckNTU1RyYW5zZm9ybXMiLCJfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zIiwiX2FkZFB4VHJhbnNsYXRlIiwiX3plcm9EZWciLCJfemVyb1B4IiwiX2VuZFBhcmVudGhlc2lzIiwiX3JlZiIsInRyYW5zZm9ybXMiLCJ1c2UzRCIsIl9yZWYyIiwiYTExIiwiYTIxIiwidGFuIiwiX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4iLCJjYXAiLCJpc1N0cmluZyIsImNoYW5nZSIsImZpbmFsVmFsdWUiLCJkaXJlY3Rpb24iLCJfYXNzaWduIiwic291cmNlIiwiX2FkZFJhd1RyYW5zZm9ybVBUcyIsInN0YXJ0Q2FjaGUiLCJleGNsdWRlIiwiZW5kQ2FjaGUiLCJzaWRlIiwidmFycyIsIkNTU1BsdWdpbiIsInJlZ2lzdGVyIiwidGFyZ2V0VGVzdCIsIm5vZGVUeXBlIiwidGFyZ2V0cyIsInN0YXJ0QXQiLCJzcGVjaWFsUHJvcCIsImlzVHJhbnNmb3JtUmVsYXRlZCIsInRyYW5zZm9ybVByb3BUd2VlbiIsImhhc1ByaW9yaXR5IiwiYWRkIiwicGFyc2VUcmFuc2Zvcm0iLCJzbW9vdGhPcmlnaW4iLCJkZXAiLCJhdXRvUm91bmQiLCJhbGlhc2VzIiwiZ2V0U2V0dGVyIiwiY29yZSIsImNoZWNrUHJlZml4IiwicG9zaXRpb25BbmRTY2FsZSIsIm90aGVycyIsImFsbCIsInJlZ2lzdGVyUGx1Z2luIiwiZGVmYXVsdCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIl9fcHJvdG9fXyIsImF1dG9TbGVlcCIsIm51bGxUYXJnZXRXYXJuIiwibGluZUhlaWdodCIsIl9kZWZhdWx0cyIsIm92ZXJ3cml0ZSIsIl9zdXBwcmVzc092ZXJ3cml0ZXMiLCJfdGlueU51bSIsIl8yUEkiLCJfSEFMRl9QSSIsIl9nc0lEIiwiX3NxcnQiLCJfY29zIiwiX3NpbiIsIl9pc0Z1bmN0aW9uIiwiX2lzTnVtYmVyIiwiX2lzT2JqZWN0IiwiX2lzTm90RmFsc2UiLCJfaXNGdW5jT3JTdHJpbmciLCJfaXNUeXBlZEFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJfaXNBcnJheSIsIl9zdHJpY3ROdW1FeHAiLCJfY29tcGxleFN0cmluZ051bUV4cCIsIl9kZWxpbWl0ZWRWYWx1ZUV4cCIsIl91bml0RXhwIiwiX2dsb2JhbFRpbWVsaW5lIiwiX2NvcmVJbml0dGVkIiwiX2dsb2JhbHMiLCJfaW5zdGFsbFNjb3BlIiwiX2NvcmVSZWFkeSIsIl9pbnN0YWxsIiwic2NvcGUiLCJfbWVyZ2UiLCJfd2FybiIsInN1cHByZXNzIiwiX2FkZEdsb2JhbCIsIm9iaiIsIl9lbXB0eUZ1bmMiLCJfcmVzZXJ2ZWRQcm9wcyIsIl9sYXp5VHdlZW5zIiwiX2xhenlMb29rdXAiLCJfbGFzdFJlbmRlcmVkRnJhbWUiLCJfZWZmZWN0cyIsIl9uZXh0R0NGcmFtZSIsIl9oYXJuZXNzUGx1Z2lucyIsIl9jYWxsYmFja05hbWVzIiwiX2hhcm5lc3MiLCJoYXJuZXNzUGx1Z2luIiwiaGFybmVzcyIsInNwbGljZSIsInRvQXJyYXkiLCJ2IiwibmFtZXMiLCJmdW5jIiwiX3JvdW5kUHJlY2lzZSIsIl9hcnJheUNvbnRhaW5zQW55IiwidG9TZWFyY2giLCJ0b0ZpbmQiLCJfbGF6eVJlbmRlciIsIl9sYXp5IiwicmVuZGVyIiwiX2xhenlTYWZlUmVuZGVyIiwiYW5pbWF0aW9uIiwic3VwcHJlc3NFdmVudHMiLCJmb3JjZSIsIl9udW1lcmljSWZQb3NzaWJsZSIsIl9wYXNzVGhyb3VnaCIsImRlZmF1bHRzIiwiX3NldEtleWZyYW1lRGVmYXVsdHMiLCJiYXNlIiwidG9NZXJnZSIsIl9tZXJnZURlZXAiLCJfY29weUV4Y2x1ZGluZyIsImV4Y2x1ZGluZyIsIl9pbmhlcml0RGVmYXVsdHMiLCJrZXlmcmFtZXMiLCJpbmhlcml0IiwiX2RwIiwiX2FycmF5c01hdGNoIiwiYTEiLCJhMiIsIl9hZGRMaW5rZWRMaXN0SXRlbSIsImNoaWxkIiwiZmlyc3RQcm9wIiwibGFzdFByb3AiLCJzb3J0QnkiLCJwcmV2IiwiX3ByZXYiLCJuZXh0IiwiX3JlbW92ZUZyb21QYXJlbnQiLCJvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIiwiYXV0b1JlbW92ZUNoaWxkcmVuIiwicmVtb3ZlIiwiX2FjdCIsIl91bmNhY2hlIiwiX2VuZCIsIl9zdGFydCIsIl9kaXJ0eSIsIl9yZWNhY2hlQW5jZXN0b3JzIiwidG90YWxEdXJhdGlvbiIsIl9oYXNOb1BhdXNlZEFuY2VzdG9ycyIsIl90cyIsIl9lbGFwc2VkQ3ljbGVEdXJhdGlvbiIsIl9yZXBlYXQiLCJfYW5pbWF0aW9uQ3ljbGUiLCJfdFRpbWUiLCJfckRlbGF5IiwidFRpbWUiLCJjeWNsZUR1cmF0aW9uIiwid2hvbGUiLCJmbG9vciIsIl9wYXJlbnRUb0NoaWxkVG90YWxUaW1lIiwicGFyZW50VGltZSIsIl90RHVyIiwiX3NldEVuZCIsIl9ydHMiLCJfYWxpZ25QbGF5aGVhZCIsInRvdGFsVGltZSIsInNtb290aENoaWxkVGltaW5nIiwiX3Bvc3RBZGRDaGVja3MiLCJfaW5pdHRlZCIsInJhd1RpbWUiLCJfY2xhbXAiLCJfelRpbWUiLCJfYWRkVG9UaW1lbGluZSIsInNraXBDaGVja3MiLCJfcGFyc2VQb3NpdGlvbiIsIl9kZWxheSIsInRpbWVTY2FsZSIsIl9zb3J0IiwiX2lzRnJvbU9yRnJvbVN0YXJ0IiwiX3JlY2VudCIsIl9zY3JvbGxUcmlnZ2VyIiwidHJpZ2dlciIsIlNjcm9sbFRyaWdnZXIiLCJfYXR0ZW1wdEluaXRUd2VlbiIsIl9pbml0VHdlZW4iLCJsYXp5IiwiX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCIsIl9sb2NrIiwiX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuIiwicHJldlJhdGlvIiwicmVwZWF0RGVsYXkiLCJpdGVyYXRpb24iLCJwcmV2SXRlcmF0aW9uIiwiX3lveW8iLCJyZXBlYXRSZWZyZXNoIiwiaW52YWxpZGF0ZSIsIl9mcm9tIiwiX3N0YXJ0QXQiLCJfb25VcGRhdGUiLCJfY2FsbGJhY2siLCJfcHJvbSIsIl9maW5kTmV4dFBhdXNlVHdlZW4iLCJwcmV2VGltZSIsIl9maXJzdCIsIl9sYXN0IiwiX3NldER1cmF0aW9uIiwic2tpcFVuY2FjaGUiLCJsZWF2ZVBsYXloZWFkIiwicmVwZWF0IiwiZHVyIiwidG90YWxQcm9ncmVzcyIsIl9vblVwZGF0ZVRvdGFsRHVyYXRpb24iLCJUaW1lbGluZSIsIl96ZXJvUG9zaXRpb24iLCJlbmRUaW1lIiwicGVyY2VudEFuaW1hdGlvbiIsImxhYmVscyIsInJlY2VudCIsImNsaXBwZWREdXJhdGlvbiIsIm9mZnNldCIsImlzUGVyY2VudCIsIl9jcmVhdGVUd2VlblR5cGUiLCJwYXJhbXMiLCJpc0xlZ2FjeSIsInZhcnNJbmRleCIsImlyVmFycyIsImltbWVkaWF0ZVJlbmRlciIsInJ1bkJhY2t3YXJkcyIsIlR3ZWVuIiwiX2NvbmRpdGlvbmFsUmV0dXJuIiwibWluIiwibWF4IiwiX3NsaWNlIiwiX2lzQXJyYXlMaWtlIiwibm9uRW1wdHkiLCJfZmxhdHRlbiIsImFyIiwibGVhdmVTdHJpbmdzIiwiYWNjdW11bGF0b3IiLCJfYWNjdW11bGF0b3IiLCJfd2FrZSIsImVsIiwibmF0aXZlRWxlbWVudCIsInNodWZmbGUiLCJzb3J0IiwicmFuZG9tIiwiZGlzdHJpYnV0ZSIsIl9wYXJzZUVhc2UiLCJpc0RlY2ltYWwiLCJyYXRpb3MiLCJheGlzIiwicmF0aW9YIiwicmF0aW9ZIiwiZWRnZXMiLCJkaXN0YW5jZXMiLCJvcmlnaW5YIiwib3JpZ2luWSIsImoiLCJ3cmFwQXQiLCJncmlkIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2ludmVydEVhc2UiLCJfcm91bmRNb2RpZmllciIsInBvdyIsInJhdyIsInNuYXAiLCJzbmFwVG8iLCJyYWRpdXMiLCJpczJEIiwidmFsdWVzIiwiaW5jcmVtZW50IiwiY2xvc2VzdCIsImR4IiwiZHkiLCJyb3VuZGluZ0luY3JlbWVudCIsInJldHVybkZ1bmN0aW9uIiwicGlwZSIsIl9sZW4iLCJmdW5jdGlvbnMiLCJfa2V5IiwicmVkdWNlIiwidW5pdGl6ZSIsIm5vcm1hbGl6ZSIsIm1hcFJhbmdlIiwiX3dyYXBBcnJheSIsIndyYXAiLCJyYW5nZSIsIndyYXBZb3lvIiwidG90YWwiLCJudW1zIiwiaW5NaW4iLCJpbk1heCIsIm91dE1pbiIsIm91dE1heCIsImluUmFuZ2UiLCJvdXRSYW5nZSIsInByb2dyZXNzIiwibXV0YXRlIiwibWFzdGVyIiwiaW50ZXJwb2xhdG9ycyIsImlsIiwiX2FkZFByb3BUd2VlbiIsIl9yZW5kZXJQcm9wVHdlZW5zIiwiX2dldExhYmVsSW5EaXJlY3Rpb24iLCJmcm9tVGltZSIsImJhY2t3YXJkIiwiZGlzdGFuY2UiLCJsYWJlbCIsImV4ZWN1dGVMYXp5Rmlyc3QiLCJjYWxsYmFjayIsImNhbGxiYWNrU2NvcGUiLCJfaW50ZXJydXB0Iiwic2Nyb2xsVHJpZ2dlciIsImtpbGwiLCJfcXVpY2tUd2VlbiIsIl9jcmVhdGVQbHVnaW4iLCJjb25maWciLCJpc0Z1bmMiLCJQbHVnaW4iLCJpbnN0YW5jZURlZmF1bHRzIiwiX2tpbGxQcm9wVHdlZW5zT2YiLCJtb2RpZmllciIsIl9hZGRQbHVnaW5Nb2RpZmllciIsInJhd1ZhcnMiLCJzdGF0aWNzIiwiXzI1NSIsIl9jb2xvckxvb2t1cCIsImFxdWEiLCJsaW1lIiwic2lsdmVyIiwibWFyb29uIiwidGVhbCIsIm5hdnkiLCJ3aGl0ZSIsIm9saXZlIiwib3JhbmdlIiwiZ3JheSIsInB1cnBsZSIsInBpbmsiLCJ0cmFuc3BhcmVudCIsIl9odWUiLCJtMSIsIm0yIiwic3BsaXRDb2xvciIsInRvSFNMIiwiZm9yY2VBbHBoYSIsImciLCJ3YXNIU0wiLCJfY29sb3JPcmRlckRhdGEiLCJfZm9ybWF0Q29sb3JzIiwib3JkZXJNYXRjaERhdGEiLCJzaGVsbCIsIlJlZ0V4cCIsIl9oc2xFeHAiLCJjb21iaW5lZCIsIl90aWNrZXJBY3RpdmUiLCJfZ2V0VGltZSIsIkRhdGUiLCJub3ciLCJfbGFnVGhyZXNob2xkIiwiX2FkanVzdGVkTGFnIiwiX3N0YXJ0VGltZSIsIl9sYXN0VXBkYXRlIiwiX2dhcCIsIl9uZXh0VGltZSIsIl9pZCIsIl9yZXEiLCJfcmFmIiwiX3NlbGYiLCJfZGVsdGEiLCJfaSIsIl90aWNrIiwiZWxhcHNlZCIsIm1hbnVhbCIsIm92ZXJsYXAiLCJkaXNwYXRjaCIsInRpY2siLCJkZWx0YVJhdGlvIiwiZnBzIiwid2FrZSIsImdzYXBWZXJzaW9ucyIsInZlcnNpb24iLCJHcmVlblNvY2tHbG9iYWxzIiwic2xlZXAiLCJzZXRUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJsYWdTbW9vdGhpbmciLCJ0aHJlc2hvbGQiLCJhZGp1c3RlZExhZyIsIl9mcHMiLCJfZWFzZU1hcCIsIl9jdXN0b21FYXNlRXhwIiwiX3F1b3Rlc0V4cCIsIl9wYXJzZU9iamVjdEluU3RyaW5nIiwidmFsIiwicGFyc2VkVmFsIiwibGFzdEluZGV4T2YiLCJfdmFsdWVJblBhcmVudGhlc2VzIiwibmVzdGVkIiwiX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nIiwiX0NFIiwiX3Byb3BhZ2F0ZVlveW9FYXNlIiwiaXNZb3lvIiwieW95b0Vhc2UiLCJfZWFzZSIsIl95RWFzZSIsImRlZmF1bHRFYXNlIiwiX2luc2VydEVhc2UiLCJlYXNlSW4iLCJlYXNlT3V0IiwiZWFzZUluT3V0IiwibG93ZXJjYXNlTmFtZSIsIl9lYXNlSW5PdXRGcm9tT3V0IiwiX2NvbmZpZ0VsYXN0aWMiLCJhbXBsaXR1ZGUiLCJwZXJpb2QiLCJwMSIsInAyIiwicDMiLCJhc2luIiwiX2NvbmZpZ0JhY2siLCJvdmVyc2hvb3QiLCJwb3dlciIsIkxpbmVhciIsImVhc2VOb25lIiwibm9uZSIsIm4xIiwibjIiLCJuMyIsIlN0ZXBwZWRFYXNlIiwic3RlcHMiLCJpbW1lZGlhdGVTdGFydCIsIkFuaW1hdGlvbiIsIkluZmluaXR5IiwieW95byIsIl9wcm90byIsInN0YXJ0VGltZSIsIl90b3RhbFRpbWUiLCJfcHRMb29rdXAiLCJfcFRpbWUiLCJfcHMiLCJwYXVzZWQiLCJpbmNsdWRlUmVwZWF0cyIsIndyYXBSZXBlYXRzIiwiZ2xvYmFsVGltZSIsInNlZWsiLCJyZXN0YXJ0IiwiaW5jbHVkZURlbGF5IiwicGxheSIsInJldmVyc2VkIiwicmV2ZXJzZSIsInBhdXNlIiwiYXRUaW1lIiwicmVzdW1lIiwiaXNBY3RpdmUiLCJldmVudENhbGxiYWNrIiwidGhlbiIsIm9uRnVsZmlsbGVkIiwiX3Jlc29sdmUiLCJfdGhlbiIsIl9BbmltYXRpb24iLCJfdGhpcyIsInNvcnRDaGlsZHJlbiIsIl9wcm90bzIiLCJmcm9tVG8iLCJmcm9tVmFycyIsInRvVmFycyIsImRlbGF5ZWRDYWxsIiwic3RhZ2dlclRvIiwib25Db21wbGV0ZUFsbCIsIm9uQ29tcGxldGVBbGxQYXJhbXMiLCJvbkNvbXBsZXRlUGFyYW1zIiwic3RhZ2dlckZyb20iLCJzdGFnZ2VyRnJvbVRvIiwidER1ciIsImNyb3NzaW5nU3RhcnQiLCJwcmV2UGF1c2VkIiwicGF1c2VUd2VlbiIsInByZXZTdGFydCIsInJld2luZGluZyIsImRvZXNXcmFwIiwib25SZXBlYXQiLCJfaGFzUGF1c2UiLCJfZm9yY2luZyIsIm9uVXBkYXRlIiwiYWRqdXN0ZWRUaW1lIiwiX3RoaXMyIiwiYWRkTGFiZWwiLCJnZXRDaGlsZHJlbiIsInR3ZWVucyIsInRpbWVsaW5lcyIsImlnbm9yZUJlZm9yZVRpbWUiLCJnZXRCeUlkIiwiYW5pbWF0aW9ucyIsInJlbW92ZUxhYmVsIiwia2lsbFR3ZWVuc09mIiwiX3RvdGFsVGltZTIiLCJhZGRQYXVzZSIsInJlbW92ZVBhdXNlIiwib25seUFjdGl2ZSIsImdldFR3ZWVuc09mIiwiX292ZXJ3cml0aW5nVHdlZW4iLCJwYXJzZWRUYXJnZXRzIiwiaXNHbG9iYWxUaW1lIiwiY2hpbGRyZW4iLCJfdGFyZ2V0cyIsInR3ZWVuVG8iLCJ0bCIsIl92YXJzIiwiX29uU3RhcnQiLCJvblN0YXJ0Iiwib25TdGFydFBhcmFtcyIsImluaXR0ZWQiLCJ0d2VlbkZyb21UbyIsImZyb21Qb3NpdGlvbiIsInRvUG9zaXRpb24iLCJuZXh0TGFiZWwiLCJhZnRlclRpbWUiLCJwcmV2aW91c0xhYmVsIiwiYmVmb3JlVGltZSIsImN1cnJlbnRMYWJlbCIsInNoaWZ0Q2hpbGRyZW4iLCJhZGp1c3RMYWJlbHMiLCJjbGVhciIsImluY2x1ZGVMYWJlbHMiLCJ1cGRhdGVSb290IiwiX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4iLCJzZXR0ZXIiLCJzdHJpbmdGaWx0ZXIiLCJmdW5jUGFyYW0iLCJzdGFydE51bXMiLCJoYXNSYW5kb20iLCJmcCIsImN1cnJlbnRWYWx1ZSIsInBhcnNlZFN0YXJ0IiwiX3NldHRlclBsYWluIiwiX3NldHRlckZ1bmNXaXRoUGFyYW0iLCJfc2V0dGVyRnVuYyIsIl9yZW5kZXJCb29sZWFuIiwiX3JlbmRlclBsYWluIiwiX3Byb2Nlc3NWYXJzIiwiX3BhcnNlRnVuY09yU3RyaW5nIiwicHRMb29rdXAiLCJwcmlvcml0eSIsIm9uVXBkYXRlUGFyYW1zIiwiYXV0b1JldmVydCIsInByZXZTdGFydEF0IiwiZnVsbFRhcmdldHMiLCJhdXRvT3ZlcndyaXRlIiwiX292ZXJ3cml0ZSIsImNsZWFuVmFycyIsImdzRGF0YSIsImhhcm5lc3NWYXJzIiwib3ZlcndyaXR0ZW4iLCJfb3AiLCJfb25Jbml0IiwiX2FkZEFsaWFzZXNUb1ZhcnMiLCJwcm9wZXJ0eUFsaWFzZXMiLCJfc3RhZ2dlclR3ZWVuUHJvcHMiLCJfc3RhZ2dlclByb3BzVG9Ta2lwIiwiX0FuaW1hdGlvbjIiLCJza2lwSW5oZXJpdCIsIl90aGlzMyIsIl90aGlzMyR2YXJzIiwiY3VyVGFyZ2V0Iiwic3RhZ2dlckZ1bmMiLCJzdGFnZ2VyVmFyc1RvTWVyZ2UiLCJfcHJvdG8zIiwia2lsbGluZ1RhcmdldHMiLCJwcm9wVHdlZW5Mb29rdXAiLCJmaXJzdFBUIiwib3ZlcndyaXR0ZW5Qcm9wcyIsImN1ckxvb2t1cCIsImN1ck92ZXJ3cml0ZVByb3BzIiwib25SZXZlcnNlQ29tcGxldGUiLCJvblJldmVyc2VDb21wbGV0ZVBhcmFtcyIsIl9zZXR0ZXJBdHRyaWJ1dGUiLCJoYXNOb25EZXBlbmRlbnRSZW1haW5pbmciLCJvcCIsIl9zZXR0ZXJXaXRoTW9kaWZpZXIiLCJtU2V0IiwibXQiLCJwdDIiLCJmaXJzdCIsImxhc3QiLCJyZW5kZXJlciIsIl9wcm90bzQiLCJUd2Vlbk1heCIsIlR3ZWVuTGl0ZSIsIlRpbWVsaW5lTGl0ZSIsIlRpbWVsaW5lTWF4IiwiX2xlbjIiLCJfa2V5MiIsImdldFByb3BlcnR5IiwiZ2V0dGVyIiwiZm9ybWF0IiwicXVpY2tTZXR0ZXIiLCJzZXR0ZXJzIiwiaXNUd2VlbmluZyIsInJlZ2lzdGVyRWZmZWN0IiwiX3JlZjMiLCJlZmZlY3QiLCJwbHVnaW5zIiwiZXh0ZW5kVGltZWxpbmUiLCJwbHVnaW5OYW1lIiwicmVnaXN0ZXJFYXNlIiwicGFyc2VFYXNlIiwiZXhwb3J0Um9vdCIsImluY2x1ZGVEZWxheWVkQ2FsbHMiLCJpbnN0YWxsIiwiZWZmZWN0cyIsInRpY2tlciIsImdsb2JhbFRpbWVsaW5lIiwiZ2xvYmFscyIsImdldENhY2hlIiwic3VwcHJlc3NPdmVyd3JpdGVzIiwiX2dldFBsdWdpblByb3BUd2VlbiIsIl9hZGRNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJfYnVpbGRNb2RpZmllclBsdWdpbiIsIlBvd2VyMCIsIlBvd2VyMSIsIlBvd2VyMiIsIlBvd2VyMyIsIlBvd2VyNCIsIlF1YWQiLCJDdWJpYyIsIlF1YXJ0IiwiUXVpbnQiLCJTdHJvbmciLCJFbGFzdGljIiwiQmFjayIsIkJvdW5jZSIsIlNpbmUiLCJFeHBvIiwiQ2lyYyIsImdzYXBXaXRoQ1NTIiwiVHdlZW5NYXhXaXRoQ1NTIiwiX19hc3NpZ24iLCJhc3NpZ24iLCJuYW1lZF9yZWZlcmVuY2VzXzEiLCJyZXF1aXJlIiwibnVtZXJpY191bmljb2RlX21hcF8xIiwic3Vycm9nYXRlX3BhaXJzXzEiLCJhbGxOYW1lZFJlZmVyZW5jZXMiLCJuYW1lZFJlZmVyZW5jZXMiLCJodG1sNSIsImVuY29kZVJlZ0V4cHMiLCJzcGVjaWFsQ2hhcnMiLCJub25Bc2NpaSIsIm5vbkFzY2lpUHJpbnRhYmxlIiwiZXh0ZW5zaXZlIiwiZGVmYXVsdEVuY29kZU9wdGlvbnMiLCJtb2RlIiwibGV2ZWwiLCJudW1lcmljIiwiZW5jb2RlIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsImVuY29kZVJlZ0V4cCIsInJlZmVyZW5jZXMiLCJjaGFyYWN0ZXJzIiwiaXNIZXgiLCJyZXN1bHRfMSIsImNvZGVfMSIsImdldENvZGVQb2ludCIsImNoYXJDb2RlQXQiLCJkZWZhdWx0RGVjb2RlT3B0aW9ucyIsInN0cmljdCIsImF0dHJpYnV0ZSIsImJhc2VEZWNvZGVSZWdFeHBzIiwieG1sIiwiYm9keVJlZ0V4cHMiLCJodG1sNCIsImRlY29kZVJlZ0V4cHMiLCJmcm9tQ2hhckNvZGUiLCJvdXRPZkJvdW5kc0NoYXIiLCJkZWZhdWx0RGVjb2RlRW50aXR5T3B0aW9ucyIsImRlY29kZUVudGl0eSIsImVudGl0eSIsImRlY29kZUVudGl0eUxhc3RDaGFyXzEiLCJkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZV8xIiwiZW50aXRpZXMiLCJkZWNvZGVTZWNvbmRDaGFyXzEiLCJkZWNvZGVDb2RlXzEiLCJmcm9tQ29kZVBvaW50IiwibnVtZXJpY1VuaWNvZGVNYXAiLCJkZWNvZGUiLCJkZWNvZGVSZWdFeHAiLCJpc0F0dHJpYnV0ZSIsImlzU3RyaWN0IiwicmVwbGFjZU1hdGNoXzEiLCJyZXBsYWNlUmVzdWx0XzEiLCJyZXBsYWNlTGFzdEluZGV4XzEiLCJyZXBsYWNlSW5wdXRfMSIsImRlY29kZVJlc3VsdF8xIiwiZGVjb2RlRW50aXR5TGFzdENoYXJfMiIsImRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlXzIiLCJkZWNvZGVTZWNvbmRDaGFyXzIiLCJkZWNvZGVDb2RlXzIiLCIkIiwiZmoiLCJhc3RyYWxDb2RlUG9pbnQiLCJjb2RlUG9pbnRBdCIsImlucHV0IiwiaGlnaFN1cnJvZ2F0ZUZyb20iLCJoaWdoU3Vycm9nYXRlVG8iLCJyb290IiwiU3ltYm9sIiwiYXJyYXlFYWNoIiwiYXJyYXkiLCJpdGVyYXRlZSIsImJhc2VUaW1lcyIsImlzQXJndW1lbnRzIiwiaXNCdWZmZXIiLCJpc0luZGV4IiwiaXNUeXBlZEFycmF5Iiwib2JqZWN0UHJvdG8iLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiYmFzZUZvck93biIsImNyZWF0ZUJhc2VFYWNoIiwiYmFzZUVhY2giLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvciIsIm9iamVjdCIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlIiwiYXJnc1RhZyIsImJhc2VJc0FyZ3VtZW50cyIsImlzTGVuZ3RoIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJiYXNlVW5hcnkiLCJpZGVudGl0eSIsImNhc3RGdW5jdGlvbiIsImlzQXJyYXlMaWtlIiwiZWFjaEZ1bmMiLCJmcm9tUmlnaHQiLCJjb2xsZWN0aW9uIiwiaXRlcmFibGUiLCJrZXlzRnVuYyIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImlzT3duIiwidGFnIiwidW5tYXNrZWQiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJDdG9yIiwicHJvdG8iLCJvdmVyQXJnIiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJiaW5kaW5nIiwiZnJlZVNlbGYiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzRnVuY3Rpb24iLCJzdHViRmFsc2UiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzT2JqZWN0IiwiYXN5bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsIm5vZGVJc1R5cGVkQXJyYXkiLCJWRVJTSU9OIiwiTEFSR0VfQVJSQVlfU0laRSIsIkNPUkVfRVJST1JfVEVYVCIsIkZVTkNfRVJST1JfVEVYVCIsIklOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQiLCJIQVNIX1VOREVGSU5FRCIsIk1BWF9NRU1PSVpFX1NJWkUiLCJQTEFDRUhPTERFUiIsIkNMT05FX0RFRVBfRkxBRyIsIkNMT05FX0ZMQVRfRkxBRyIsIkNMT05FX1NZTUJPTFNfRkxBRyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsIldSQVBfQklORF9GTEFHIiwiV1JBUF9CSU5EX0tFWV9GTEFHIiwiV1JBUF9DVVJSWV9CT1VORF9GTEFHIiwiV1JBUF9DVVJSWV9GTEFHIiwiV1JBUF9DVVJSWV9SSUdIVF9GTEFHIiwiV1JBUF9QQVJUSUFMX0ZMQUciLCJXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyIsIldSQVBfQVJZX0ZMQUciLCJXUkFQX1JFQVJHX0ZMQUciLCJXUkFQX0ZMSVBfRkxBRyIsIkRFRkFVTFRfVFJVTkNfTEVOR1RIIiwiREVGQVVMVF9UUlVOQ19PTUlTU0lPTiIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwiTEFaWV9GSUxURVJfRkxBRyIsIkxBWllfTUFQX0ZMQUciLCJMQVpZX1dISUxFX0ZMQUciLCJJTkZJTklUWSIsIk1BWF9JTlRFR0VSIiwiTkFOIiwiTUFYX0FSUkFZX0xFTkdUSCIsIk1BWF9BUlJBWV9JTkRFWCIsIkhBTEZfTUFYX0FSUkFZX0xFTkdUSCIsIndyYXBGbGFncyIsImRvbUV4Y1RhZyIsInByb21pc2VUYWciLCJzeW1ib2xUYWciLCJ3ZWFrU2V0VGFnIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc2NhcGVkSHRtbCIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzRXNjYXBlZEh0bWwiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJyZUludGVycG9sYXRlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsInJlUHJvcE5hbWUiLCJyZVJlZ0V4cENoYXIiLCJyZUhhc1JlZ0V4cENoYXIiLCJyZVRyaW1TdGFydCIsInJlV2hpdGVzcGFjZSIsInJlV3JhcENvbW1lbnQiLCJyZVdyYXBEZXRhaWxzIiwicmVTcGxpdERldGFpbHMiLCJyZUFzY2lpV29yZCIsInJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzIiwicmVFc2NhcGVDaGFyIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVMYXRpbiIsInJlTm9NYXRjaCIsInJlVW5lc2NhcGVkU3RyaW5nIiwicnNBc3RyYWxSYW5nZSIsInJzQ29tYm9NYXJrc1JhbmdlIiwicmVDb21ib0hhbGZNYXJrc1JhbmdlIiwicnNDb21ib1N5bWJvbHNSYW5nZSIsInJzQ29tYm9SYW5nZSIsInJzRGluZ2JhdFJhbmdlIiwicnNMb3dlclJhbmdlIiwicnNNYXRoT3BSYW5nZSIsInJzTm9uQ2hhclJhbmdlIiwicnNQdW5jdHVhdGlvblJhbmdlIiwicnNTcGFjZVJhbmdlIiwicnNVcHBlclJhbmdlIiwicnNWYXJSYW5nZSIsInJzQnJlYWtSYW5nZSIsInJzQXBvcyIsInJzQXN0cmFsIiwicnNCcmVhayIsInJzQ29tYm8iLCJyc0RpZ2l0cyIsInJzRGluZ2JhdCIsInJzTG93ZXIiLCJyc01pc2MiLCJyc0ZpdHoiLCJyc01vZGlmaWVyIiwicnNOb25Bc3RyYWwiLCJyc1JlZ2lvbmFsIiwicnNTdXJyUGFpciIsInJzVXBwZXIiLCJyc1pXSiIsInJzTWlzY0xvd2VyIiwicnNNaXNjVXBwZXIiLCJyc09wdENvbnRyTG93ZXIiLCJyc09wdENvbnRyVXBwZXIiLCJyZU9wdE1vZCIsInJzT3B0VmFyIiwicnNPcHRKb2luIiwicnNPcmRMb3dlciIsInJzT3JkVXBwZXIiLCJyc1NlcSIsInJzRW1vamkiLCJyc1N5bWJvbCIsInJlQXBvcyIsInJlQ29tYm9NYXJrIiwicmVVbmljb2RlIiwicmVVbmljb2RlV29yZCIsInJlSGFzVW5pY29kZSIsInJlSGFzVW5pY29kZVdvcmQiLCJjb250ZXh0UHJvcHMiLCJ0ZW1wbGF0ZUNvdW50ZXIiLCJjbG9uZWFibGVUYWdzIiwiZGVidXJyZWRMZXR0ZXJzIiwiaHRtbEVzY2FwZXMiLCJodG1sVW5lc2NhcGVzIiwic3RyaW5nRXNjYXBlcyIsImZyZWVQYXJzZUZsb2F0IiwiZnJlZVBhcnNlSW50Iiwibm9kZUlzQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwibm9kZUlzRGF0ZSIsImlzRGF0ZSIsIm5vZGVJc01hcCIsImlzTWFwIiwibm9kZUlzUmVnRXhwIiwiaXNSZWdFeHAiLCJub2RlSXNTZXQiLCJpc1NldCIsInRoaXNBcmciLCJhcnJheUFnZ3JlZ2F0b3IiLCJhcnJheUVhY2hSaWdodCIsImFycmF5RXZlcnkiLCJwcmVkaWNhdGUiLCJhcnJheUZpbHRlciIsInJlc0luZGV4IiwiYXJyYXlJbmNsdWRlcyIsImJhc2VJbmRleE9mIiwiYXJyYXlJbmNsdWRlc1dpdGgiLCJjb21wYXJhdG9yIiwiYXJyYXlNYXAiLCJhcnJheVB1c2giLCJhcnJheVJlZHVjZSIsImluaXRBY2N1bSIsImFycmF5UmVkdWNlUmlnaHQiLCJhcnJheVNvbWUiLCJhc2NpaVNpemUiLCJiYXNlUHJvcGVydHkiLCJhc2NpaVRvQXJyYXkiLCJzdHJpbmciLCJhc2NpaVdvcmRzIiwiYmFzZUZpbmRLZXkiLCJiYXNlRmluZEluZGV4IiwiZnJvbUluZGV4Iiwic3RyaWN0SW5kZXhPZiIsImJhc2VJc05hTiIsImJhc2VJbmRleE9mV2l0aCIsImJhc2VNZWFuIiwiYmFzZVN1bSIsImJhc2VQcm9wZXJ0eU9mIiwiYmFzZVJlZHVjZSIsImJhc2VTb3J0QnkiLCJjb21wYXJlciIsImJhc2VUb1BhaXJzIiwiYmFzZVRyaW0iLCJ0cmltbWVkRW5kSW5kZXgiLCJiYXNlVmFsdWVzIiwiY2FjaGVIYXMiLCJoYXMiLCJjaGFyc1N0YXJ0SW5kZXgiLCJzdHJTeW1ib2xzIiwiY2hyU3ltYm9scyIsImNoYXJzRW5kSW5kZXgiLCJjb3VudEhvbGRlcnMiLCJwbGFjZWhvbGRlciIsImRlYnVyckxldHRlciIsImVzY2FwZUh0bWxDaGFyIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsImdldFZhbHVlIiwiaGFzVW5pY29kZSIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwiaXRlcmF0b3IiLCJkb25lIiwibWFwVG9BcnJheSIsInNpemUiLCJyZXBsYWNlSG9sZGVycyIsInNldFRvQXJyYXkiLCJzZXRUb1BhaXJzIiwic3RyaWN0TGFzdEluZGV4T2YiLCJzdHJpbmdTaXplIiwidW5pY29kZVNpemUiLCJzdHJpbmdUb0FycmF5IiwidW5pY29kZVRvQXJyYXkiLCJ1bmVzY2FwZUh0bWxDaGFyIiwidW5pY29kZVdvcmRzIiwicnVuSW5Db250ZXh0IiwicGljayIsImFycmF5UHJvdG8iLCJmdW5jUHJvdG8iLCJjb3JlSnNEYXRhIiwiZnVuY1RvU3RyaW5nIiwiaWRDb3VudGVyIiwibWFza1NyY0tleSIsInVpZCIsIklFX1BST1RPIiwib2JqZWN0Q3RvclN0cmluZyIsIm9sZERhc2giLCJyZUlzTmF0aXZlIiwiVWludDhBcnJheSIsImFsbG9jVW5zYWZlIiwiZ2V0UHJvdG90eXBlIiwib2JqZWN0Q3JlYXRlIiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsInN5bUl0ZXJhdG9yIiwiZ2V0TmF0aXZlIiwiY3R4Q2xlYXJUaW1lb3V0IiwiY3R4Tm93IiwiY3R4U2V0VGltZW91dCIsIm5hdGl2ZUNlaWwiLCJjZWlsIiwibmF0aXZlRmxvb3IiLCJuYXRpdmVHZXRTeW1ib2xzIiwibmF0aXZlSXNGaW5pdGUiLCJpc0Zpbml0ZSIsIm5hdGl2ZUpvaW4iLCJuYXRpdmVNYXgiLCJuYXRpdmVNaW4iLCJuYXRpdmVOb3ciLCJuYXRpdmVQYXJzZUludCIsIm5hdGl2ZVJhbmRvbSIsIm5hdGl2ZVJldmVyc2UiLCJEYXRhVmlldyIsIk1hcCIsIlNldCIsIldlYWtNYXAiLCJuYXRpdmVDcmVhdGUiLCJtZXRhTWFwIiwicmVhbE5hbWVzIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwic3ltYm9sVG9TdHJpbmciLCJsb2Rhc2giLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJiYXNlQ3JlYXRlIiwiYmFzZUxvZGFzaCIsImNoYWluQWxsIiwiX193cmFwcGVkX18iLCJfX2FjdGlvbnNfXyIsIl9fY2hhaW5fXyIsIl9faW5kZXhfXyIsIl9fdmFsdWVzX18iLCJ0ZW1wbGF0ZVNldHRpbmdzIiwiX19kaXJfXyIsIl9fZmlsdGVyZWRfXyIsIl9faXRlcmF0ZWVzX18iLCJfX3Rha2VDb3VudF9fIiwiX192aWV3c19fIiwibGF6eUNsb25lIiwiY29weUFycmF5IiwibGF6eVJldmVyc2UiLCJjbG9uZSIsImxhenlWYWx1ZSIsImRpciIsImlzUmlnaHQiLCJhcnJMZW5ndGgiLCJ2aWV3IiwiZ2V0VmlldyIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwib3V0ZXIiLCJpdGVySW5kZXgiLCJjb21wdXRlZCIsIkhhc2giLCJlbnRyaWVzIiwiaGFzaENsZWFyIiwiX19kYXRhX18iLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiTGlzdENhY2hlIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJhc3NvY0luZGV4T2YiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJNYXBDYWNoZSIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsImdldE1hcERhdGEiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJTZXRDYWNoZSIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTdGFjayIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsInBhaXJzIiwiYXJyYXlTYW1wbGUiLCJiYXNlUmFuZG9tIiwiYXJyYXlTYW1wbGVTaXplIiwic2h1ZmZsZVNlbGYiLCJiYXNlQ2xhbXAiLCJhcnJheVNodWZmbGUiLCJhc3NpZ25NZXJnZVZhbHVlIiwiZXEiLCJiYXNlQXNzaWduVmFsdWUiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiYmFzZUFnZ3JlZ2F0b3IiLCJiYXNlQXNzaWduIiwiY29weU9iamVjdCIsImJhc2VBc3NpZ25JbiIsImtleXNJbiIsImJhc2VBdCIsInBhdGhzIiwic2tpcCIsImxvd2VyIiwidXBwZXIiLCJiYXNlQ2xvbmUiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsInN0YWNrIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwiaW5pdENsb25lQXJyYXkiLCJnZXRUYWciLCJjbG9uZUJ1ZmZlciIsImluaXRDbG9uZU9iamVjdCIsImNvcHlTeW1ib2xzSW4iLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInN1YlZhbHVlIiwiZ2V0QWxsS2V5c0luIiwiZ2V0QWxsS2V5cyIsImJhc2VDb25mb3JtcyIsImJhc2VDb25mb3Jtc1RvIiwiYmFzZURlbGF5Iiwid2FpdCIsImJhc2VEaWZmZXJlbmNlIiwiaXNDb21tb24iLCJ2YWx1ZXNMZW5ndGgiLCJ2YWx1ZXNJbmRleCIsImJhc2VFYWNoUmlnaHQiLCJiYXNlRm9yT3duUmlnaHQiLCJiYXNlRXZlcnkiLCJiYXNlRXh0cmVtdW0iLCJpc1N5bWJvbCIsImJhc2VGaWxsIiwidG9JbnRlZ2VyIiwidG9MZW5ndGgiLCJiYXNlRmlsdGVyIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRm9yUmlnaHQiLCJiYXNlRnVuY3Rpb25zIiwiYmFzZUdldCIsInBhdGgiLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsImJhc2VHdCIsIm90aGVyIiwiYmFzZUhhcyIsImJhc2VIYXNJbiIsImJhc2VJblJhbmdlIiwiYmFzZUludGVyc2VjdGlvbiIsImFycmF5cyIsIm90aExlbmd0aCIsIm90aEluZGV4IiwiY2FjaGVzIiwibWF4TGVuZ3RoIiwic2VlbiIsImJhc2VJbnZlcnRlciIsImJhc2VJbnZva2UiLCJiYXNlSXNBcnJheUJ1ZmZlciIsImJhc2VJc0RhdGUiLCJiYXNlSXNFcXVhbCIsImJhc2VJc0VxdWFsRGVlcCIsImVxdWFsRnVuYyIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwiZXF1YWxBcnJheXMiLCJlcXVhbEJ5VGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiZXF1YWxPYmplY3RzIiwiYmFzZUlzTWFwIiwiYmFzZUlzTWF0Y2giLCJtYXRjaERhdGEiLCJub0N1c3RvbWl6ZXIiLCJzcmNWYWx1ZSIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwicGF0dGVybiIsImJhc2VJc1JlZ0V4cCIsImJhc2VJc1NldCIsImJhc2VJdGVyYXRlZSIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJiYXNlTWF0Y2hlcyIsImJhc2VLZXlzSW4iLCJuYXRpdmVLZXlzSW4iLCJpc1Byb3RvIiwiYmFzZUx0IiwiYmFzZU1hcCIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaXNLZXkiLCJpc1N0cmljdENvbXBhcmFibGUiLCJoYXNJbiIsImJhc2VNZXJnZSIsInNyY0luZGV4IiwiYmFzZU1lcmdlRGVlcCIsIm5ld1ZhbHVlIiwic2FmZUdldCIsIm1lcmdlRnVuYyIsImlzVHlwZWQiLCJpc0FycmF5TGlrZU9iamVjdCIsImNsb25lVHlwZWRBcnJheSIsImlzUGxhaW5PYmplY3QiLCJ0b1BsYWluT2JqZWN0IiwiYmFzZU50aCIsImJhc2VPcmRlckJ5Iiwib3JkZXJzIiwiZ2V0SXRlcmF0ZWUiLCJjcml0ZXJpYSIsImNvbXBhcmVNdWx0aXBsZSIsImJhc2VQaWNrIiwiYmFzZVBpY2tCeSIsImJhc2VTZXQiLCJiYXNlUHJvcGVydHlEZWVwIiwiYmFzZVB1bGxBbGwiLCJiYXNlUHVsbEF0IiwiaW5kZXhlcyIsInByZXZpb3VzIiwiYmFzZVVuc2V0IiwiYmFzZVJhbmdlIiwic3RlcCIsImJhc2VSZXBlYXQiLCJiYXNlUmVzdCIsInNldFRvU3RyaW5nIiwib3ZlclJlc3QiLCJiYXNlU2FtcGxlIiwiYmFzZVNhbXBsZVNpemUiLCJiYXNlU2V0RGF0YSIsImJhc2VTZXRUb1N0cmluZyIsImNvbnN0YW50IiwiYmFzZVNodWZmbGUiLCJiYXNlU2xpY2UiLCJiYXNlU29tZSIsImJhc2VTb3J0ZWRJbmRleCIsInJldEhpZ2hlc3QiLCJsb3ciLCJoaWdoIiwibWlkIiwiYmFzZVNvcnRlZEluZGV4QnkiLCJ2YWxJc05hTiIsInZhbElzTnVsbCIsInZhbElzU3ltYm9sIiwidmFsSXNVbmRlZmluZWQiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwic2V0TG93IiwiYmFzZVNvcnRlZFVuaXEiLCJiYXNlVG9OdW1iZXIiLCJiYXNlVG9TdHJpbmciLCJiYXNlVW5pcSIsImNyZWF0ZVNldCIsInNlZW5JbmRleCIsImJhc2VVcGRhdGUiLCJ1cGRhdGVyIiwiYmFzZVdoaWxlIiwiaXNEcm9wIiwiYWN0aW9ucyIsImFjdGlvbiIsImJhc2VYb3IiLCJiYXNlWmlwT2JqZWN0IiwiYXNzaWduRnVuYyIsInZhbHNMZW5ndGgiLCJjYXN0QXJyYXlMaWtlT2JqZWN0Iiwic3RyaW5nVG9QYXRoIiwiY2FzdFJlc3QiLCJjYXN0U2xpY2UiLCJidWZmZXIiLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiY2xvbmVEYXRhVmlldyIsImRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImNsb25lUmVnRXhwIiwicmVnZXhwIiwiY2xvbmVTeW1ib2wiLCJzeW1ib2wiLCJ0eXBlZEFycmF5IiwiY29tcGFyZUFzY2VuZGluZyIsInZhbElzRGVmaW5lZCIsInZhbElzUmVmbGV4aXZlIiwib2JqQ3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiY29tcG9zZUFyZ3MiLCJwYXJ0aWFscyIsImhvbGRlcnMiLCJpc0N1cnJpZWQiLCJhcmdzSW5kZXgiLCJhcmdzTGVuZ3RoIiwiaG9sZGVyc0xlbmd0aCIsImxlZnRJbmRleCIsImxlZnRMZW5ndGgiLCJyYW5nZUxlbmd0aCIsImlzVW5jdXJyaWVkIiwiY29tcG9zZUFyZ3NSaWdodCIsImhvbGRlcnNJbmRleCIsInJpZ2h0SW5kZXgiLCJyaWdodExlbmd0aCIsImlzTmV3IiwiZ2V0U3ltYm9scyIsImdldFN5bWJvbHNJbiIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJpbml0aWFsaXplciIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJpc0l0ZXJhdGVlQ2FsbCIsImNyZWF0ZUJpbmQiLCJpc0JpbmQiLCJjcmVhdGVDdG9yIiwiZm4iLCJjcmVhdGVDYXNlRmlyc3QiLCJtZXRob2ROYW1lIiwidHJhaWxpbmciLCJjcmVhdGVDb21wb3VuZGVyIiwiZGVidXJyIiwidGhpc0JpbmRpbmciLCJjcmVhdGVDdXJyeSIsImFyaXR5IiwiZ2V0SG9sZGVyIiwiY3JlYXRlUmVjdXJyeSIsImNyZWF0ZUh5YnJpZCIsImNyZWF0ZUZpbmQiLCJmaW5kSW5kZXhGdW5jIiwiY3JlYXRlRmxvdyIsImZsYXRSZXN0IiwiZnVuY3MiLCJwcmVyZXEiLCJ0aHJ1IiwiZ2V0RnVuY05hbWUiLCJmdW5jTmFtZSIsImdldERhdGEiLCJpc0xhemlhYmxlIiwicGxhbnQiLCJwYXJ0aWFsc1JpZ2h0IiwiaG9sZGVyc1JpZ2h0IiwiYXJnUG9zIiwiYXJ5IiwiaXNBcnkiLCJpc0JpbmRLZXkiLCJpc0ZsaXAiLCJob2xkZXJzQ291bnQiLCJuZXdIb2xkZXJzIiwicmVvcmRlciIsImNyZWF0ZUludmVydGVyIiwidG9JdGVyYXRlZSIsImNyZWF0ZU1hdGhPcGVyYXRpb24iLCJvcGVyYXRvciIsImRlZmF1bHRWYWx1ZSIsImNyZWF0ZU92ZXIiLCJhcnJheUZ1bmMiLCJjcmVhdGVQYWRkaW5nIiwiY2hhcnMiLCJjaGFyc0xlbmd0aCIsImNyZWF0ZVBhcnRpYWwiLCJjcmVhdGVSYW5nZSIsInRvRmluaXRlIiwiY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsInRvTnVtYmVyIiwid3JhcEZ1bmMiLCJpc0N1cnJ5IiwibmV3SG9sZGVyc1JpZ2h0IiwibmV3UGFydGlhbHMiLCJuZXdQYXJ0aWFsc1JpZ2h0IiwibmV3RGF0YSIsInNldERhdGEiLCJzZXRXcmFwVG9TdHJpbmciLCJjcmVhdGVSb3VuZCIsInByZWNpc2lvbiIsInBhaXIiLCJub29wIiwiY3JlYXRlVG9QYWlycyIsImNyZWF0ZVdyYXAiLCJtZXJnZURhdGEiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwiY3VzdG9tRGVmYXVsdHNNZXJnZSIsImN1c3RvbU9taXRDbG9uZSIsImlzUGFydGlhbCIsImFyclN0YWNrZWQiLCJvdGhTdGFja2VkIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwiY29udmVydCIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJvYmpTdGFja2VkIiwic2tpcEN0b3IiLCJvYmpDdG9yIiwib3RoQ3RvciIsImZsYXR0ZW4iLCJvdGhlckZ1bmMiLCJpc0tleWFibGUiLCJzdHViQXJyYXkiLCJjdG9yU3RyaW5nIiwiZ2V0V3JhcERldGFpbHMiLCJoYXNQYXRoIiwiaGFzRnVuYyIsImluc2VydFdyYXBEZXRhaWxzIiwiZGV0YWlscyIsImlzTWFza2FibGUiLCJtZW1vaXplQ2FwcGVkIiwibWVtb2l6ZSIsInNyY0JpdG1hc2siLCJuZXdCaXRtYXNrIiwiaXNDb21ibyIsIm90aGVyQXJncyIsIm9sZEFycmF5Iiwic2hvcnRPdXQiLCJyZWZlcmVuY2UiLCJ1cGRhdGVXcmFwRGV0YWlscyIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsInJhbmQiLCJxdW90ZSIsInN1YlN0cmluZyIsImNvbXBhY3QiLCJkaWZmZXJlbmNlIiwiZGlmZmVyZW5jZUJ5IiwiZGlmZmVyZW5jZVdpdGgiLCJkcm9wIiwiZHJvcFJpZ2h0IiwiZHJvcFJpZ2h0V2hpbGUiLCJkcm9wV2hpbGUiLCJmaWxsIiwiZmluZEluZGV4IiwiZmluZExhc3RJbmRleCIsImZsYXR0ZW5EZWVwIiwiZmxhdHRlbkRlcHRoIiwiZnJvbVBhaXJzIiwiaGVhZCIsImluaXRpYWwiLCJpbnRlcnNlY3Rpb24iLCJtYXBwZWQiLCJpbnRlcnNlY3Rpb25CeSIsImludGVyc2VjdGlvbldpdGgiLCJzZXBhcmF0b3IiLCJudGgiLCJwdWxsIiwicHVsbEFsbCIsInB1bGxBbGxCeSIsInB1bGxBbGxXaXRoIiwicHVsbEF0Iiwic29ydGVkSW5kZXgiLCJzb3J0ZWRJbmRleEJ5Iiwic29ydGVkSW5kZXhPZiIsInNvcnRlZExhc3RJbmRleCIsInNvcnRlZExhc3RJbmRleEJ5Iiwic29ydGVkTGFzdEluZGV4T2YiLCJzb3J0ZWRVbmlxIiwic29ydGVkVW5pcUJ5IiwidGFpbCIsInRha2UiLCJ0YWtlUmlnaHQiLCJ0YWtlUmlnaHRXaGlsZSIsInRha2VXaGlsZSIsInVuaW9uIiwidW5pb25CeSIsInVuaW9uV2l0aCIsInVuaXEiLCJ1bmlxQnkiLCJ1bmlxV2l0aCIsInVuemlwIiwiZ3JvdXAiLCJ1bnppcFdpdGgiLCJ3aXRob3V0IiwieG9yIiwieG9yQnkiLCJ4b3JXaXRoIiwiemlwIiwiemlwT2JqZWN0IiwiemlwT2JqZWN0RGVlcCIsInppcFdpdGgiLCJjaGFpbiIsInRhcCIsImludGVyY2VwdG9yIiwid3JhcHBlckF0Iiwid3JhcHBlckNoYWluIiwid3JhcHBlckNvbW1pdCIsIndyYXBwZXJOZXh0Iiwid3JhcHBlclRvSXRlcmF0b3IiLCJ3cmFwcGVyUGxhbnQiLCJ3cmFwcGVyUmV2ZXJzZSIsIndyYXBwZXJWYWx1ZSIsImNvdW50QnkiLCJldmVyeSIsImZpbHRlciIsImZpbmQiLCJmaW5kTGFzdCIsImZsYXRNYXAiLCJmbGF0TWFwRGVlcCIsImZsYXRNYXBEZXB0aCIsImZvckVhY2hSaWdodCIsImdyb3VwQnkiLCJpbnZva2VNYXAiLCJrZXlCeSIsIm9yZGVyQnkiLCJwYXJ0aXRpb24iLCJyZWR1Y2VSaWdodCIsIm5lZ2F0ZSIsInNhbXBsZSIsInNhbXBsZVNpemUiLCJhZnRlciIsImJlZm9yZSIsImJpbmRLZXkiLCJjdXJyeSIsImN1cnJ5UmlnaHQiLCJkZWJvdW5jZSIsIm9wdGlvbnMiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJpbnZva2VGdW5jIiwibGVhZGluZ0VkZ2UiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWZlciIsImZsaXAiLCJtZW1vaXplZCIsIkNhY2hlIiwib3ZlckFyZ3MiLCJmdW5jc0xlbmd0aCIsInBhcnRpYWwiLCJwYXJ0aWFsUmlnaHQiLCJyZWFyZyIsInJlc3QiLCJzcHJlYWQiLCJ0aHJvdHRsZSIsInVuYXJ5IiwiY2FzdEFycmF5IiwiY2xvbmVXaXRoIiwiY2xvbmVEZWVwIiwiY2xvbmVEZWVwV2l0aCIsImNvbmZvcm1zVG8iLCJndCIsImd0ZSIsImlzQm9vbGVhbiIsImlzRWxlbWVudCIsImlzRW1wdHkiLCJpc0VxdWFsIiwiaXNFcXVhbFdpdGgiLCJpc0Vycm9yIiwiaXNJbnRlZ2VyIiwiaXNNYXRjaCIsImlzTWF0Y2hXaXRoIiwiaXNOdW1iZXIiLCJpc05hdGl2ZSIsImlzTnVsbCIsImlzTmlsIiwiaXNTYWZlSW50ZWdlciIsImlzVW5kZWZpbmVkIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwibHQiLCJsdGUiLCJzaWduIiwicmVtYWluZGVyIiwiaXNCaW5hcnkiLCJ0b1NhZmVJbnRlZ2VyIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwiYXQiLCJwcm9wZXJ0aWVzIiwicHJvcHNJbmRleCIsInByb3BzTGVuZ3RoIiwiZGVmYXVsdHNEZWVwIiwibWVyZ2VXaXRoIiwiZmluZEtleSIsImZpbmRMYXN0S2V5IiwiZm9ySW4iLCJmb3JJblJpZ2h0IiwiZm9yT3duIiwiZm9yT3duUmlnaHQiLCJmdW5jdGlvbnNJbiIsImludmVydCIsImludmVydEJ5IiwiaW52b2tlIiwibWFwS2V5cyIsIm1hcFZhbHVlcyIsIm1lcmdlIiwib21pdCIsIm9taXRCeSIsInBpY2tCeSIsInNldFdpdGgiLCJ0b1BhaXJzIiwidG9QYWlyc0luIiwiaXNBcnJMaWtlIiwidW5zZXQiLCJ1cGRhdGVXaXRoIiwidmFsdWVzSW4iLCJmbG9hdGluZyIsImNhbWVsQ2FzZSIsImNhcGl0YWxpemUiLCJ1cHBlckZpcnN0IiwiZW5kc1dpdGgiLCJlc2NhcGUiLCJlc2NhcGVSZWdFeHAiLCJrZWJhYkNhc2UiLCJsb3dlckNhc2UiLCJsb3dlckZpcnN0IiwicGFkIiwic3RyTGVuZ3RoIiwicGFkRW5kIiwicGFkU3RhcnQiLCJyYWRpeCIsInNuYWtlQ2FzZSIsInN0YXJ0Q2FzZSIsInN0YXJ0c1dpdGgiLCJzZXR0aW5ncyIsImltcG9ydHMiLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwicmVEZWxpbWl0ZXJzIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwidmFyaWFibGUiLCJhdHRlbXB0IiwidG9Mb3dlciIsInRvVXBwZXIiLCJ0cmltRW5kIiwidHJpbVN0YXJ0IiwidHJ1bmNhdGUiLCJvbWlzc2lvbiIsInNlYXJjaCIsIm5ld0VuZCIsInVuZXNjYXBlIiwidXBwZXJDYXNlIiwiYmluZEFsbCIsIm1ldGhvZE5hbWVzIiwiY29uZCIsImNvbmZvcm1zIiwiZGVmYXVsdFRvIiwiZmxvdyIsImZsb3dSaWdodCIsIm1hdGNoZXMiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2QiLCJtZXRob2RPZiIsIm1peGluIiwibm9Db25mbGljdCIsIm50aEFyZyIsIm92ZXIiLCJvdmVyRXZlcnkiLCJvdmVyU29tZSIsInByb3BlcnR5T2YiLCJyYW5nZVJpZ2h0Iiwic3R1Yk9iamVjdCIsInN0dWJTdHJpbmciLCJzdHViVHJ1ZSIsInRpbWVzIiwidG9QYXRoIiwidW5pcXVlSWQiLCJwcmVmaXgiLCJhdWdlbmQiLCJhZGRlbmQiLCJkaXZpZGUiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJtYXhCeSIsIm1lYW4iLCJtZWFuQnkiLCJtaW5CeSIsIm11bHRpcGx5IiwibXVsdGlwbGllciIsIm11bHRpcGxpY2FuZCIsInN1YnRyYWN0IiwibWludWVuZCIsInN1YnRyYWhlbmQiLCJzdW0iLCJzdW1CeSIsImVudHJpZXNJbiIsImV4dGVuZCIsImV4dGVuZFdpdGgiLCJlYWNoUmlnaHQiLCJpc0ZpbHRlciIsInRha2VOYW1lIiwiZHJvcE5hbWUiLCJjaGVja0l0ZXJhdGVlIiwiaXNUYWtlciIsImxvZGFzaEZ1bmMiLCJyZXRVbndyYXBwZWQiLCJpc0xhenkiLCJ1c2VMYXp5IiwiaXNIeWJyaWQiLCJpc1Vud3JhcHBlZCIsIm9ubHlMYXp5IiwiY2hhaW5OYW1lIiwiY29tbWl0IiwidG9KU09OIiwiZGVmaW5lIiwiYW1kIiwibm9ybWFsaXplVXJsIiwic3JjQnlNb2R1bGVJZCIsIm5vRG9jdW1lbnQiLCJ0aW1lb3V0IiwiZnVuY3Rpb25DYWxsIiwiZ2V0Q3VycmVudFNjcmlwdFVybCIsIm1vZHVsZUlkIiwiY3VycmVudFNjcmlwdCIsInNjcmlwdHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxhc3RTY3JpcHRUYWciLCJmaWxlTWFwIiwic3BsaXRSZXN1bHQiLCJmaWxlbmFtZSIsIm1hcFJ1bGUiLCJyZWciLCJ1cGRhdGVDc3MiLCJpc1VybFJlcXVlc3QiLCJpc0xvYWRlZCIsInZpc2l0ZWQiLCJuZXdFbCIsImNsb25lTm9kZSIsImdldFJlbG9hZFVybCIsInN0cmlwV1dXIiwicmVsb2FkU3R5bGUiLCJsb2FkZWQiLCJyZWxvYWRBbGwiLCJnZXRTY3JpcHRTcmMiLCJyZWxvYWRlZCIsImxvY2FscyIsInBhdGhDb21wb25lbnRzIiwidXJsU3RyaW5nIiwicHJvdG9jb2wiLCJjb21wb25lbnRzIiwiaG9zdCIsInByZWZpeGVzIiwibWVtbyIsImNoYXIiLCJLZXkiLCJwcmVmaXhNZW1vemllZCIsInByZWZpeERhc2hlZCIsImRhc2giLCJxcyIsInNlcCIsIm1heEtleXMiLCJpZHgiLCJrc3RyIiwidnN0ciIsImsiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJrcyIsImVuY29kZVVSSUNvbXBvbmVudCIsInBhcnNlIiwic3RyaW5naWZ5IiwicHVueWNvZGUiLCJtYXhJbnQiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIm1hcERvbWFpbiIsInBhcnRzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0TGVuZ3RoIiwib3V0IiwiYmlhcyIsImJhc2ljIiwib2xkaSIsImJhc2VNaW51c1QiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwicSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0b0FTQ0lJIiwidXRpbCIsInVybFBhcnNlIiwidXJsUmVzb2x2ZSIsInJlc29sdmVPYmplY3QiLCJ1cmxSZXNvbHZlT2JqZWN0IiwidXJsRm9ybWF0IiwiVXJsIiwic2xhc2hlcyIsImF1dGgiLCJwb3J0IiwiaG9zdG5hbWUiLCJoYXNoIiwicXVlcnkiLCJwYXRobmFtZSIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJ1bnNhZmVQcm90b2NvbCIsImhvc3RsZXNzUHJvdG9jb2wiLCJzbGFzaGVkUHJvdG9jb2wiLCJxdWVyeXN0cmluZyIsInBhcnNlUXVlcnlTdHJpbmciLCJzbGFzaGVzRGVub3RlSG9zdCIsInF1ZXJ5SW5kZXgiLCJzcGxpdHRlciIsInVTcGxpdCIsInNsYXNoUmVnZXgiLCJzaW1wbGVQYXRoIiwibG93ZXJQcm90byIsImhvc3RFbmQiLCJoZWMiLCJhdFNpZ24iLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwiYWUiLCJlc2MiLCJxbSIsInJlbCIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJyZWxQYXRoIiwiaXNTb3VyY2VBYnMiLCJpc1JlbEFicyIsIm11c3RFbmRBYnMiLCJyZW1vdmVBbGxEb3RzIiwic3JjUGF0aCIsInBzeWNob3RpYyIsImlzTnVsbE9yVW5kZWZpbmVkIiwiYXV0aEluSG9zdCIsImhhc1RyYWlsaW5nU2xhc2giLCJ1cCIsImlzQWJzb2x1dGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJXZWJTb2NrZXRDbGllbnQiLCJjbGllbnQiLCJXZWJTb2NrZXQiLCJvbmVycm9yIiwib25PcGVuIiwib25vcGVuIiwib25DbG9zZSIsIm9uY2xvc2UiLCJvbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJ3ZWJwYWNrSG90TG9nIiwic3RyaXBBbnNpIiwicGFyc2VVUkwiLCJzb2NrZXQiLCJzZXRMb2dMZXZlbCIsInNlbmRNZXNzYWdlIiwicmVsb2FkQXBwIiwiY3JlYXRlU29ja2V0VVJMIiwiaXNVbmxvYWRpbmciLCJjdXJyZW50SGFzaCIsIl9fd2VicGFja19oYXNoX18iLCJob3QiLCJsaXZlUmVsb2FkIiwib3ZlcmxheSIsInBhcnNlZFJlc291cmNlUXVlcnkiLCJfX3Jlc291cmNlUXVlcnkiLCJpbmZvIiwibG9nZ2luZyIsInNldEFsbExvZ0xldmVsIiwib25Tb2NrZXRNZXNzYWdlIiwiaW52YWxpZCIsIl9oYXNoIiwicHJldmlvdXNIYXNoIiwiX3Byb2dyZXNzIiwicHJvZ3Jlc3NVcGRhdGUiLCJtc2ciLCJzdGlsbE9rIiwib2siLCJjb250ZW50Q2hhbmdlZCIsImZpbGUiLCJsb2NhdGlvbiIsInJlbG9hZCIsInN0YXRpY0NoYW5nZWQiLCJ3YXJuaW5ncyIsIl93YXJuaW5ncyIsInN0cmlwcGVkV2FybmluZ3MiLCJuZWVkU2hvd092ZXJsYXlGb3JXYXJuaW5ncyIsIl9lcnJvcnMiLCJzdHJpcHBlZEVycm9ycyIsIm5lZWRTaG93T3ZlcmxheUZvckVycm9ycyIsIl9lcnJvciIsInNvY2tldFVSTCIsIl9fd2VicGFja19tb2R1bGVzX18iLCJjbGllbnRUYXBhYmxlU3luY0JhaWxIb29rIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwiaXRlciIsImFycjIiLCJMb2dUeXBlIiwiZnJlZXplIiwiZGVidWciLCJ0cmFjZSIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9maWxlIiwicHJvZmlsZUVuZCIsIkxPR19TWU1CT0wiLCJUSU1FUlNfU1lNQk9MIiwiVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MIiwiV2VicGFja0xvZ2dlciIsImdldENoaWxkTG9nZ2VyIiwiX2xlbjMiLCJfa2V5MyIsIl9sZW40IiwiX2tleTQiLCJfbGVuNSIsIl9rZXk1IiwiYXNzZXJ0IiwiYXNzZXJ0aW9uIiwiX2xlbjYiLCJfa2V5NiIsIl9sZW43IiwiX2tleTciLCJfbGVuOCIsIl9rZXk4IiwiX2xlbjkiLCJfa2V5OSIsIl9sZW4xMCIsIl9rZXkxMCIsImhydGltZSIsInRpbWVMb2ciLCJ0aW1lRW5kIiwiZGVsZXRlIiwidGltZUFnZ3JlZ2F0ZSIsInRpbWVBZ2dyZWdhdGVFbmQiLCJMb2dnZXIiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiX3JlcXVpcmUiLCJmaWx0ZXJUb0Z1bmN0aW9uIiwicmVnRXhwIiwiaWRlbnQiLCJMb2dMZXZlbCIsImZhbHNlIiwidHJ1ZSIsInZlcmJvc2UiLCJfcmVmJGxldmVsIiwiX3JlZiRkZWJ1ZyIsImRlYnVnRmlsdGVycyIsImxvZ2xldmVsIiwibG9nZ2VyIiwibGFiZWxlZEFyZ3MiLCJtcyIsImxvZ1RpbWUiLCJfZXh0ZW5kcyIsIlN5bmNCYWlsSG9vayIsImNyZWF0ZUNvbnNvbGVMb2dnZXIiLCJjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMiLCJjdXJyZW50RGVmYXVsdExvZ2dlciIsImdldExvZ2dlciIsImhvb2tzIiwiY2hpbGROYW1lIiwiY29uZmlndXJlRGVmYXVsdExvZ2dlciIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsImNhY2hlZE1vZHVsZSIsImRlZmluaXRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwid2VicGFja19saWJfbG9nZ2luZ19ydW50aW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fIiwiX19lc01vZHVsZSIsIl9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fIiwiYW5zaV9yZWdleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiYW5zaVJlZ2V4IiwiX3JlZiRvbmx5Rmlyc3QiLCJvbmx5Rmlyc3QiLCJzdHJpcF9hbnNpX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJpZnJhbWVDb250YWluZXJFbGVtZW50IiwiY29udGFpbmVyRWxlbWVudCIsIm9uTG9hZFF1ZXVlIiwiY3JlYXRlQ29udGFpbmVyIiwiYm9yZGVyIiwiekluZGV4IiwiY29udGVudERvY3VtZW50IiwiYm94U2l6aW5nIiwiYmFja2dyb3VuZENvbG9yIiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwicGFkZGluZyIsIndoaXRlU3BhY2UiLCJvdmVyZmxvdyIsImhlYWRlckVsZW1lbnQiLCJpbm5lclRleHQiLCJjbG9zZUJ1dHRvbkVsZW1lbnQiLCJiYWNrZ3JvdW5kIiwiZm9udFdlaWdodCIsImNzc0Zsb2F0Iiwic3R5bGVGbG9hdCIsIm9uTG9hZCIsImVuc3VyZU92ZXJsYXlFeGlzdHMiLCJtZXNzYWdlcyIsImVudHJ5RWxlbWVudCIsInR5cGVFbGVtZW50IiwiZXJyb3JNZXNzYWdlIiwibWVzc2FnZVRleHROb2RlIiwiQ2xpZW50IiwiX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18iLCJyZXRyaWVzIiwiaW5pdFNvY2tldCIsImhhbmRsZXJzIiwicmV0cnlJbk1zIiwiSlNPTiIsInBhcnNlZFVSTCIsImlzSW5BZGRyQW55Iiwic29ja2V0VVJMUHJvdG9jb2wiLCJzb2NrZXRVUkxBdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInNvY2tldFVSTEhvc3RuYW1lIiwic29ja2V0VVJMUG9ydCIsInNvY2tldFVSTFBhdGhuYW1lIiwiZnJvbUN1cnJlbnRTY3JpcHQiLCJnZXRDdXJyZW50U2NyaXB0U291cmNlIiwic2NyaXB0RWxlbWVudHMiLCJzY3JpcHRFbGVtZW50c1dpdGhTcmMiLCJkZWZhdWx0TGV2ZWwiLCJyZXNvdXJjZVF1ZXJ5Iiwic2VhcmNoUGFyYW1zIiwic2NyaXB0U291cmNlIiwic2NyaXB0U291cmNlVVJMIiwiVVJMIiwiaG90RW1pdHRlciIsImlzSW5pdGlhbCIsImFwcGx5UmVsb2FkIiwicm9vdFdpbmRvdyIsImludGVydmFsSWQiLCJjbGVhckludGVydmFsIiwiYWxsb3dUb0hvdCIsImFsbG93VG9MaXZlUmVsb2FkIiwicG9zdE1lc3NhZ2UiLCJzZXRJbnRlcnZhbCIsInNlbmRNc2ciLCJXb3JrZXJHbG9iYWxTY29wZSIsImxhc3RIYXNoIiwidXBUb0RhdGUiLCJjaGVjayIsInVwZGF0ZWRNb2R1bGVzIiwiY2F0Y2giLCJmb3JtYXRFcnJvciIsInJlbmV3ZWRNb2R1bGVzIiwidW5hY2NlcHRlZE1vZHVsZXMiLCJudW1iZXJJZHMiLCJsb2dMZXZlbCIsImR1bW15Iiwic2hvdWxkTG9nIiwibG9nR3JvdXAiLCJsb2dGbiJdLCJzb3VyY2VSb290IjoiIn0=